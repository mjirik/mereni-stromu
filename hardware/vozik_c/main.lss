
main.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         000047c2  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         0000010e  00800060  000047c2  00004856  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          0000024e  0080016e  0080016e  00004964  2**0
                  ALLOC
  3 .debug_aranges 00000200  00000000  00000000  00004964  2**0
                  CONTENTS, READONLY, DEBUGGING
  4 .debug_pubnames 00000ad3  00000000  00000000  00004b64  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_info   0000383d  00000000  00000000  00005637  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_abbrev 00001449  00000000  00000000  00008e74  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_line   00002e86  00000000  00000000  0000a2bd  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_frame  000008c0  00000000  00000000  0000d144  2**2
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_str    00000d7d  00000000  00000000  0000da04  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_loc    000018e6  00000000  00000000  0000e781  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_ranges 00000160  00000000  00000000  00010067  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 cd 06 	jmp	0xd9a	; 0xd9a <__ctors_end>
       4:	0c 94 ea 06 	jmp	0xdd4	; 0xdd4 <__bad_interrupt>
       8:	0c 94 2a 1a 	jmp	0x3454	; 0x3454 <__vector_2>
       c:	0c 94 ea 06 	jmp	0xdd4	; 0xdd4 <__bad_interrupt>
      10:	0c 94 ea 06 	jmp	0xdd4	; 0xdd4 <__bad_interrupt>
      14:	0c 94 ea 06 	jmp	0xdd4	; 0xdd4 <__bad_interrupt>
      18:	0c 94 ea 06 	jmp	0xdd4	; 0xdd4 <__bad_interrupt>
      1c:	0c 94 94 07 	jmp	0xf28	; 0xf28 <__vector_7>
      20:	0c 94 ea 06 	jmp	0xdd4	; 0xdd4 <__bad_interrupt>
      24:	0c 94 ea 06 	jmp	0xdd4	; 0xdd4 <__bad_interrupt>
      28:	0c 94 ea 06 	jmp	0xdd4	; 0xdd4 <__bad_interrupt>
      2c:	0c 94 ea 06 	jmp	0xdd4	; 0xdd4 <__bad_interrupt>
      30:	0c 94 ea 06 	jmp	0xdd4	; 0xdd4 <__bad_interrupt>
      34:	0c 94 e8 09 	jmp	0x13d0	; 0x13d0 <__vector_13>
      38:	0c 94 11 0c 	jmp	0x1822	; 0x1822 <__vector_14>
      3c:	0c 94 ea 06 	jmp	0xdd4	; 0xdd4 <__bad_interrupt>
      40:	0c 94 ea 06 	jmp	0xdd4	; 0xdd4 <__bad_interrupt>
      44:	0c 94 ea 06 	jmp	0xdd4	; 0xdd4 <__bad_interrupt>
      48:	0c 94 ea 06 	jmp	0xdd4	; 0xdd4 <__bad_interrupt>
      4c:	0c 94 ea 06 	jmp	0xdd4	; 0xdd4 <__bad_interrupt>
      50:	0c 94 ea 06 	jmp	0xdd4	; 0xdd4 <__bad_interrupt>
      54:	45 0e       	add	r4, r21
      56:	eb 0c       	add	r14, r11
      58:	eb 0c       	add	r14, r11
      5a:	41 0e       	add	r4, r17
      5c:	eb 0c       	add	r14, r11
      5e:	eb 0c       	add	r14, r11
      60:	36 0e       	add	r3, r22
      62:	eb 0c       	add	r14, r11
      64:	eb 0c       	add	r14, r11
      66:	eb 0c       	add	r14, r11
      68:	22 0e       	add	r2, r18
      6a:	07 0e       	add	r0, r23
      6c:	fa 0d       	add	r31, r10
      6e:	e6 0d       	add	r30, r6
      70:	eb 0c       	add	r14, r11
      72:	eb 0c       	add	r14, r11
      74:	e2 0d       	add	r30, r2
      76:	eb 0c       	add	r14, r11
      78:	eb 0c       	add	r14, r11
      7a:	eb 0c       	add	r14, r11
      7c:	eb 0c       	add	r14, r11
      7e:	eb 0c       	add	r14, r11
      80:	eb 0c       	add	r14, r11
      82:	eb 0c       	add	r14, r11
      84:	eb 0c       	add	r14, r11
      86:	eb 0c       	add	r14, r11
      88:	eb 0c       	add	r14, r11
      8a:	eb 0c       	add	r14, r11
      8c:	eb 0c       	add	r14, r11
      8e:	eb 0c       	add	r14, r11
      90:	eb 0c       	add	r14, r11
      92:	eb 0c       	add	r14, r11
      94:	eb 0c       	add	r14, r11
      96:	eb 0c       	add	r14, r11
      98:	eb 0c       	add	r14, r11
      9a:	eb 0c       	add	r14, r11
      9c:	eb 0c       	add	r14, r11
      9e:	eb 0c       	add	r14, r11
      a0:	eb 0c       	add	r14, r11
      a2:	eb 0c       	add	r14, r11
      a4:	eb 0c       	add	r14, r11
      a6:	eb 0c       	add	r14, r11
      a8:	eb 0c       	add	r14, r11
      aa:	eb 0c       	add	r14, r11
      ac:	eb 0c       	add	r14, r11
      ae:	eb 0c       	add	r14, r11
      b0:	eb 0c       	add	r14, r11
      b2:	eb 0c       	add	r14, r11
      b4:	eb 0c       	add	r14, r11
      b6:	eb 0c       	add	r14, r11
      b8:	eb 0c       	add	r14, r11
      ba:	eb 0c       	add	r14, r11
      bc:	eb 0c       	add	r14, r11
      be:	eb 0c       	add	r14, r11
      c0:	eb 0c       	add	r14, r11
      c2:	eb 0c       	add	r14, r11
      c4:	eb 0c       	add	r14, r11
      c6:	eb 0c       	add	r14, r11
      c8:	eb 0c       	add	r14, r11
      ca:	eb 0c       	add	r14, r11
      cc:	eb 0c       	add	r14, r11
      ce:	eb 0c       	add	r14, r11
      d0:	eb 0c       	add	r14, r11
      d2:	eb 0c       	add	r14, r11
      d4:	eb 0c       	add	r14, r11
      d6:	eb 0c       	add	r14, r11
      d8:	eb 0c       	add	r14, r11
      da:	eb 0c       	add	r14, r11
      dc:	eb 0c       	add	r14, r11
      de:	eb 0c       	add	r14, r11
      e0:	eb 0c       	add	r14, r11
      e2:	eb 0c       	add	r14, r11
      e4:	eb 0c       	add	r14, r11
      e6:	eb 0c       	add	r14, r11
      e8:	eb 0c       	add	r14, r11
      ea:	eb 0c       	add	r14, r11
      ec:	eb 0c       	add	r14, r11
      ee:	eb 0c       	add	r14, r11
      f0:	eb 0c       	add	r14, r11
      f2:	eb 0c       	add	r14, r11
      f4:	eb 0c       	add	r14, r11
      f6:	eb 0c       	add	r14, r11
      f8:	eb 0c       	add	r14, r11
      fa:	eb 0c       	add	r14, r11
      fc:	eb 0c       	add	r14, r11
      fe:	eb 0c       	add	r14, r11
     100:	eb 0c       	add	r14, r11
     102:	eb 0c       	add	r14, r11
     104:	eb 0c       	add	r14, r11
     106:	eb 0c       	add	r14, r11
     108:	eb 0c       	add	r14, r11
     10a:	eb 0c       	add	r14, r11
     10c:	eb 0c       	add	r14, r11
     10e:	eb 0c       	add	r14, r11
     110:	eb 0c       	add	r14, r11
     112:	eb 0c       	add	r14, r11
     114:	eb 0c       	add	r14, r11
     116:	eb 0c       	add	r14, r11
     118:	eb 0c       	add	r14, r11
     11a:	eb 0c       	add	r14, r11
     11c:	eb 0c       	add	r14, r11
     11e:	eb 0c       	add	r14, r11
     120:	eb 0c       	add	r14, r11
     122:	eb 0c       	add	r14, r11
     124:	eb 0c       	add	r14, r11
     126:	eb 0c       	add	r14, r11
     128:	eb 0c       	add	r14, r11
     12a:	eb 0c       	add	r14, r11
     12c:	c3 0d       	add	r28, r3
     12e:	b7 0d       	add	r27, r7
     130:	ab 0d       	add	r26, r11
     132:	9f 0d       	add	r25, r15
     134:	93 0d       	add	r25, r3
     136:	87 0d       	add	r24, r7
     138:	7b 0d       	add	r23, r11
     13a:	6f 0d       	add	r22, r15
     13c:	63 0d       	add	r22, r3
     13e:	57 0d       	add	r21, r7
     140:	4b 0d       	add	r20, r11
     142:	3f 0d       	add	r19, r15
     144:	33 0d       	add	r19, r3
     146:	27 0d       	add	r18, r7
     148:	1b 0d       	add	r17, r11
     14a:	0f 0d       	add	r16, r15
     14c:	eb 0c       	add	r14, r11
     14e:	eb 0c       	add	r14, r11
     150:	eb 0c       	add	r14, r11
     152:	eb 0c       	add	r14, r11
     154:	eb 0c       	add	r14, r11
     156:	eb 0c       	add	r14, r11
     158:	eb 0c       	add	r14, r11
     15a:	eb 0c       	add	r14, r11
     15c:	eb 0c       	add	r14, r11
     15e:	eb 0c       	add	r14, r11
     160:	eb 0c       	add	r14, r11
     162:	eb 0c       	add	r14, r11
     164:	eb 0c       	add	r14, r11
     166:	eb 0c       	add	r14, r11
     168:	eb 0c       	add	r14, r11
     16a:	eb 0c       	add	r14, r11
     16c:	0c 0d       	add	r16, r12
     16e:	09 0d       	add	r16, r9
     170:	f6 0c       	add	r15, r6
     172:	eb 0c       	add	r14, r11
     174:	cf 0d       	add	r28, r15
     176:	eb 0c       	add	r14, r11
     178:	eb 0c       	add	r14, r11
     17a:	eb 0c       	add	r14, r11
     17c:	eb 0c       	add	r14, r11
     17e:	eb 0c       	add	r14, r11
     180:	eb 0c       	add	r14, r11
     182:	eb 0c       	add	r14, r11
     184:	eb 0c       	add	r14, r11
     186:	eb 0c       	add	r14, r11
     188:	eb 0c       	add	r14, r11
     18a:	eb 0c       	add	r14, r11
     18c:	e7 0c       	add	r14, r7
     18e:	0b 18       	sub	r0, r11
     190:	17 17       	cp	r17, r23
     192:	17 17       	cp	r17, r23
     194:	02 18       	sub	r0, r2
     196:	17 17       	cp	r17, r23
     198:	f9 17       	cp	r31, r25
     19a:	f0 17       	cp	r31, r16
     19c:	17 17       	cp	r17, r23
     19e:	17 17       	cp	r17, r23
     1a0:	e7 17       	cp	r30, r23
     1a2:	de 17       	cp	r29, r30
     1a4:	17 17       	cp	r17, r23
     1a6:	17 17       	cp	r17, r23
     1a8:	17 17       	cp	r17, r23
     1aa:	17 17       	cp	r17, r23
     1ac:	17 17       	cp	r17, r23
     1ae:	17 17       	cp	r17, r23
     1b0:	17 17       	cp	r17, r23
     1b2:	17 17       	cp	r17, r23
     1b4:	17 17       	cp	r17, r23
     1b6:	17 17       	cp	r17, r23
     1b8:	17 17       	cp	r17, r23
     1ba:	17 17       	cp	r17, r23
     1bc:	17 17       	cp	r17, r23
     1be:	17 17       	cp	r17, r23
     1c0:	17 17       	cp	r17, r23
     1c2:	17 17       	cp	r17, r23
     1c4:	17 17       	cp	r17, r23
     1c6:	17 17       	cp	r17, r23
     1c8:	17 17       	cp	r17, r23
     1ca:	17 17       	cp	r17, r23
     1cc:	17 17       	cp	r17, r23
     1ce:	17 17       	cp	r17, r23
     1d0:	17 17       	cp	r17, r23
     1d2:	17 17       	cp	r17, r23
     1d4:	17 17       	cp	r17, r23
     1d6:	17 17       	cp	r17, r23
     1d8:	17 17       	cp	r17, r23
     1da:	17 17       	cp	r17, r23
     1dc:	17 17       	cp	r17, r23
     1de:	17 17       	cp	r17, r23
     1e0:	17 17       	cp	r17, r23
     1e2:	17 17       	cp	r17, r23
     1e4:	17 17       	cp	r17, r23
     1e6:	17 17       	cp	r17, r23
     1e8:	17 17       	cp	r17, r23
     1ea:	17 17       	cp	r17, r23
     1ec:	17 17       	cp	r17, r23
     1ee:	17 17       	cp	r17, r23
     1f0:	17 17       	cp	r17, r23
     1f2:	17 17       	cp	r17, r23
     1f4:	17 17       	cp	r17, r23
     1f6:	17 17       	cp	r17, r23
     1f8:	17 17       	cp	r17, r23
     1fa:	17 17       	cp	r17, r23
     1fc:	17 17       	cp	r17, r23
     1fe:	17 17       	cp	r17, r23
     200:	17 17       	cp	r17, r23
     202:	17 17       	cp	r17, r23
     204:	17 17       	cp	r17, r23
     206:	17 17       	cp	r17, r23
     208:	17 17       	cp	r17, r23
     20a:	17 17       	cp	r17, r23
     20c:	17 17       	cp	r17, r23
     20e:	17 17       	cp	r17, r23
     210:	17 17       	cp	r17, r23
     212:	17 17       	cp	r17, r23
     214:	17 17       	cp	r17, r23
     216:	17 17       	cp	r17, r23
     218:	17 17       	cp	r17, r23
     21a:	17 17       	cp	r17, r23
     21c:	17 17       	cp	r17, r23
     21e:	17 17       	cp	r17, r23
     220:	17 17       	cp	r17, r23
     222:	17 17       	cp	r17, r23
     224:	17 17       	cp	r17, r23
     226:	17 17       	cp	r17, r23
     228:	17 17       	cp	r17, r23
     22a:	17 17       	cp	r17, r23
     22c:	d5 17       	cp	r29, r21
     22e:	cc 17       	cp	r28, r28
     230:	c3 17       	cp	r28, r19
     232:	ba 17       	cp	r27, r26
     234:	b1 17       	cp	r27, r17
     236:	a8 17       	cp	r26, r24
     238:	9f 17       	cp	r25, r31
     23a:	96 17       	cp	r25, r22
     23c:	8d 17       	cp	r24, r29
     23e:	84 17       	cp	r24, r20
     240:	7b 17       	cp	r23, r27
     242:	72 17       	cp	r23, r18
     244:	69 17       	cp	r22, r25
     246:	60 17       	cp	r22, r16
     248:	57 17       	cp	r21, r23
     24a:	4e 17       	cp	r20, r30
     24c:	45 17       	cp	r20, r21
     24e:	17 17       	cp	r17, r23
     250:	17 17       	cp	r17, r23
     252:	3c 17       	cp	r19, r28
     254:	33 17       	cp	r19, r19
     256:	2a 17       	cp	r18, r26
     258:	21 17       	cp	r18, r17
     25a:	17 17       	cp	r17, r23
     25c:	17 17       	cp	r17, r23
     25e:	17 17       	cp	r17, r23
     260:	17 17       	cp	r17, r23
     262:	17 17       	cp	r17, r23
     264:	17 17       	cp	r17, r23
     266:	17 17       	cp	r17, r23
     268:	17 17       	cp	r17, r23
     26a:	17 17       	cp	r17, r23
     26c:	17 17       	cp	r17, r23
     26e:	17 17       	cp	r17, r23
     270:	17 17       	cp	r17, r23
     272:	17 17       	cp	r17, r23
     274:	17 17       	cp	r17, r23
     276:	17 17       	cp	r17, r23
     278:	17 17       	cp	r17, r23
     27a:	17 17       	cp	r17, r23
     27c:	17 17       	cp	r17, r23
     27e:	17 17       	cp	r17, r23
     280:	17 17       	cp	r17, r23
     282:	17 17       	cp	r17, r23
     284:	17 17       	cp	r17, r23
     286:	17 17       	cp	r17, r23
     288:	17 17       	cp	r17, r23
     28a:	17 17       	cp	r17, r23
     28c:	17 17       	cp	r17, r23
     28e:	17 17       	cp	r17, r23
     290:	17 17       	cp	r17, r23
     292:	17 17       	cp	r17, r23
     294:	17 17       	cp	r17, r23
     296:	17 17       	cp	r17, r23
     298:	17 17       	cp	r17, r23
     29a:	17 17       	cp	r17, r23
     29c:	17 17       	cp	r17, r23
     29e:	17 17       	cp	r17, r23
     2a0:	17 17       	cp	r17, r23
     2a2:	17 17       	cp	r17, r23
     2a4:	17 17       	cp	r17, r23
     2a6:	17 17       	cp	r17, r23
     2a8:	17 17       	cp	r17, r23
     2aa:	17 17       	cp	r17, r23
     2ac:	17 17       	cp	r17, r23
     2ae:	17 17       	cp	r17, r23
     2b0:	17 17       	cp	r17, r23
     2b2:	17 17       	cp	r17, r23
     2b4:	17 17       	cp	r17, r23
     2b6:	17 17       	cp	r17, r23
     2b8:	17 17       	cp	r17, r23
     2ba:	17 17       	cp	r17, r23
     2bc:	17 17       	cp	r17, r23
     2be:	17 17       	cp	r17, r23
     2c0:	17 17       	cp	r17, r23
     2c2:	17 17       	cp	r17, r23
     2c4:	17 17       	cp	r17, r23
     2c6:	17 17       	cp	r17, r23
     2c8:	17 17       	cp	r17, r23
     2ca:	17 17       	cp	r17, r23
     2cc:	17 17       	cp	r17, r23
     2ce:	17 17       	cp	r17, r23
     2d0:	17 17       	cp	r17, r23
     2d2:	17 17       	cp	r17, r23
     2d4:	17 17       	cp	r17, r23
     2d6:	17 17       	cp	r17, r23
     2d8:	17 17       	cp	r17, r23
     2da:	17 17       	cp	r17, r23
     2dc:	17 17       	cp	r17, r23
     2de:	17 17       	cp	r17, r23
     2e0:	17 17       	cp	r17, r23
     2e2:	17 17       	cp	r17, r23
     2e4:	17 17       	cp	r17, r23
     2e6:	17 17       	cp	r17, r23
     2e8:	17 17       	cp	r17, r23
     2ea:	17 17       	cp	r17, r23
     2ec:	17 17       	cp	r17, r23
     2ee:	17 17       	cp	r17, r23
     2f0:	17 17       	cp	r17, r23
     2f2:	17 17       	cp	r17, r23
     2f4:	17 17       	cp	r17, r23
     2f6:	17 17       	cp	r17, r23
     2f8:	17 17       	cp	r17, r23
     2fa:	17 17       	cp	r17, r23
     2fc:	17 17       	cp	r17, r23
     2fe:	17 17       	cp	r17, r23
     300:	17 17       	cp	r17, r23
     302:	17 17       	cp	r17, r23
     304:	17 17       	cp	r17, r23
     306:	17 17       	cp	r17, r23
     308:	17 17       	cp	r17, r23
     30a:	17 17       	cp	r17, r23
     30c:	17 17       	cp	r17, r23
     30e:	17 17       	cp	r17, r23
     310:	17 17       	cp	r17, r23
     312:	17 17       	cp	r17, r23
     314:	17 17       	cp	r17, r23
     316:	17 17       	cp	r17, r23
     318:	17 17       	cp	r17, r23
     31a:	17 17       	cp	r17, r23
     31c:	18 17       	cp	r17, r24
     31e:	0f 17       	cp	r16, r31
     320:	df 19       	sub	r29, r15
     322:	29 1a       	sub	r2, r25
     324:	d3 19       	sub	r29, r3
     326:	cd 19       	sub	r28, r13
     328:	c7 19       	sub	r28, r7
     32a:	ca 19       	sub	r28, r10
     32c:	e8 19       	sub	r30, r8
     32e:	29 1a       	sub	r2, r25
     330:	e2 19       	sub	r30, r2
     332:	dc 19       	sub	r29, r12
     334:	d6 19       	sub	r29, r6
     336:	d0 19       	sub	r29, r0
     338:	31 19       	sub	r19, r1
     33a:	29 1a       	sub	r2, r25
     33c:	29 1a       	sub	r2, r25
     33e:	29 1a       	sub	r2, r25
     340:	29 1a       	sub	r2, r25
     342:	29 1a       	sub	r2, r25
     344:	29 1a       	sub	r2, r25
     346:	29 1a       	sub	r2, r25
     348:	34 19       	sub	r19, r4
     34a:	a0 19       	sub	r26, r0
     34c:	29 1a       	sub	r2, r25
     34e:	29 1a       	sub	r2, r25
     350:	29 1a       	sub	r2, r25
     352:	7f 19       	sub	r23, r15
     354:	61 19       	sub	r22, r1
     356:	5e 19       	sub	r21, r14
     358:	37 19       	sub	r19, r7
     35a:	a3 19       	sub	r26, r3
     35c:	29 1a       	sub	r2, r25
     35e:	29 1a       	sub	r2, r25
     360:	85 19       	sub	r24, r5
     362:	82 19       	sub	r24, r2
     364:	64 19       	sub	r22, r4
     366:	3a 19       	sub	r19, r10
     368:	a9 19       	sub	r26, r9
     36a:	a6 19       	sub	r26, r6
     36c:	29 1a       	sub	r2, r25
     36e:	29 1a       	sub	r2, r25
     370:	97 19       	sub	r25, r7
     372:	88 19       	sub	r24, r8
     374:	67 19       	sub	r22, r7
     376:	40 19       	sub	r20, r0
     378:	3d 19       	sub	r19, r13
     37a:	ac 19       	sub	r26, r12
     37c:	29 1a       	sub	r2, r25
     37e:	29 1a       	sub	r2, r25
     380:	8e 19       	sub	r24, r14
     382:	8b 19       	sub	r24, r11
     384:	6d 19       	sub	r22, r13
     386:	6a 19       	sub	r22, r10
     388:	43 19       	sub	r20, r3
     38a:	af 19       	sub	r26, r15
     38c:	29 1a       	sub	r2, r25
     38e:	29 1a       	sub	r2, r25
     390:	29 1a       	sub	r2, r25
     392:	91 19       	sub	r25, r1
     394:	70 19       	sub	r23, r0
     396:	46 19       	sub	r20, r6
     398:	b2 19       	sub	r27, r2
     39a:	b5 19       	sub	r27, r5
     39c:	29 1a       	sub	r2, r25
     39e:	29 1a       	sub	r2, r25
     3a0:	94 19       	sub	r25, r4
     3a2:	73 19       	sub	r23, r3
     3a4:	49 19       	sub	r20, r9
     3a6:	4c 19       	sub	r20, r12
     3a8:	9d 19       	sub	r25, r13
     3aa:	b8 19       	sub	r27, r8
     3ac:	29 1a       	sub	r2, r25
     3ae:	29 1a       	sub	r2, r25
     3b0:	be 19       	sub	r27, r14
     3b2:	1f 1a       	sub	r1, r31
     3b4:	76 19       	sub	r23, r6
     3b6:	79 19       	sub	r23, r9
     3b8:	4f 19       	sub	r20, r15
     3ba:	bb 19       	sub	r27, r11
     3bc:	29 1a       	sub	r2, r25
     3be:	29 1a       	sub	r2, r25
     3c0:	29 1a       	sub	r2, r25
     3c2:	7c 19       	sub	r23, r12
     3c4:	29 1a       	sub	r2, r25
     3c6:	52 19       	sub	r21, r2
     3c8:	2b 19       	sub	r18, r11
     3ca:	29 1a       	sub	r2, r25
     3cc:	29 1a       	sub	r2, r25
     3ce:	5b 19       	sub	r21, r11
     3d0:	29 1a       	sub	r2, r25
     3d2:	1c 1a       	sub	r1, r28
     3d4:	55 19       	sub	r21, r5
     3d6:	29 1a       	sub	r2, r25
     3d8:	58 19       	sub	r21, r8
     3da:	29 1a       	sub	r2, r25
     3dc:	29 1a       	sub	r2, r25
     3de:	29 1a       	sub	r2, r25
     3e0:	29 1a       	sub	r2, r25
     3e2:	29 1a       	sub	r2, r25
     3e4:	29 1a       	sub	r2, r25
     3e6:	29 1a       	sub	r2, r25
     3e8:	29 1a       	sub	r2, r25
     3ea:	2e 19       	sub	r18, r14
     3ec:	29 1a       	sub	r2, r25
     3ee:	29 1a       	sub	r2, r25
     3f0:	a0 19       	sub	r26, r0
     3f2:	29 1a       	sub	r2, r25
     3f4:	a9 19       	sub	r26, r9
     3f6:	b2 19       	sub	r27, r2
     3f8:	29 1a       	sub	r2, r25
     3fa:	29 1a       	sub	r2, r25
     3fc:	29 1a       	sub	r2, r25
     3fe:	9d 19       	sub	r25, r13
     400:	be 19       	sub	r27, r14
     402:	a3 19       	sub	r26, r3
     404:	ac 19       	sub	r26, r12
     406:	af 19       	sub	r26, r15
     408:	b5 19       	sub	r27, r5
     40a:	9a 19       	sub	r25, r10
     40c:	29 1a       	sub	r2, r25
     40e:	e5 19       	sub	r30, r5
     410:	c4 19       	sub	r28, r4
     412:	a6 19       	sub	r26, r6
     414:	bb 19       	sub	r27, r11
     416:	c1 19       	sub	r28, r1
     418:	b8 19       	sub	r27, r8
     41a:	29 1a       	sub	r2, r25
     41c:	29 1a       	sub	r2, r25
     41e:	29 1a       	sub	r2, r25
     420:	29 1a       	sub	r2, r25
     422:	29 1a       	sub	r2, r25
     424:	d9 19       	sub	r29, r9
     426:	29 1a       	sub	r2, r25
     428:	29 1a       	sub	r2, r25
     42a:	29 1a       	sub	r2, r25
     42c:	29 1a       	sub	r2, r25
     42e:	29 1a       	sub	r2, r25
     430:	29 1a       	sub	r2, r25
     432:	29 1a       	sub	r2, r25
     434:	29 1a       	sub	r2, r25
     436:	29 1a       	sub	r2, r25
     438:	29 1a       	sub	r2, r25
     43a:	29 1a       	sub	r2, r25
     43c:	29 1a       	sub	r2, r25
     43e:	29 1a       	sub	r2, r25
     440:	29 1a       	sub	r2, r25
     442:	29 1a       	sub	r2, r25
     444:	29 1a       	sub	r2, r25
     446:	29 1a       	sub	r2, r25
     448:	29 1a       	sub	r2, r25
     44a:	29 1a       	sub	r2, r25
     44c:	29 1a       	sub	r2, r25
     44e:	29 1a       	sub	r2, r25
     450:	29 1a       	sub	r2, r25
     452:	29 1a       	sub	r2, r25
     454:	29 1a       	sub	r2, r25
     456:	29 1a       	sub	r2, r25
     458:	29 1a       	sub	r2, r25
     45a:	29 1a       	sub	r2, r25
     45c:	29 1a       	sub	r2, r25
     45e:	29 1a       	sub	r2, r25
     460:	29 1a       	sub	r2, r25
     462:	29 1a       	sub	r2, r25
     464:	29 1a       	sub	r2, r25
     466:	29 1a       	sub	r2, r25
     468:	29 1a       	sub	r2, r25
     46a:	29 1a       	sub	r2, r25
     46c:	29 1a       	sub	r2, r25
     46e:	29 1a       	sub	r2, r25
     470:	29 1a       	sub	r2, r25
     472:	29 1a       	sub	r2, r25
     474:	29 1a       	sub	r2, r25
     476:	29 1a       	sub	r2, r25
     478:	29 1a       	sub	r2, r25
     47a:	29 1a       	sub	r2, r25
     47c:	29 1a       	sub	r2, r25
     47e:	29 1a       	sub	r2, r25
     480:	29 1a       	sub	r2, r25
     482:	29 1a       	sub	r2, r25
     484:	29 1a       	sub	r2, r25
     486:	29 1a       	sub	r2, r25
     488:	29 1a       	sub	r2, r25
     48a:	29 1a       	sub	r2, r25
     48c:	29 1a       	sub	r2, r25
     48e:	29 1a       	sub	r2, r25
     490:	29 1a       	sub	r2, r25
     492:	29 1a       	sub	r2, r25
     494:	29 1a       	sub	r2, r25
     496:	29 1a       	sub	r2, r25
     498:	29 1a       	sub	r2, r25
     49a:	29 1a       	sub	r2, r25
     49c:	29 1a       	sub	r2, r25
     49e:	29 1a       	sub	r2, r25
     4a0:	29 1a       	sub	r2, r25
     4a2:	29 1a       	sub	r2, r25
     4a4:	29 1a       	sub	r2, r25
     4a6:	29 1a       	sub	r2, r25
     4a8:	29 1a       	sub	r2, r25
     4aa:	29 1a       	sub	r2, r25
     4ac:	29 1a       	sub	r2, r25
     4ae:	29 1a       	sub	r2, r25
     4b0:	29 1a       	sub	r2, r25
     4b2:	29 1a       	sub	r2, r25
     4b4:	29 1a       	sub	r2, r25
     4b6:	29 1a       	sub	r2, r25
     4b8:	29 1a       	sub	r2, r25
     4ba:	29 1a       	sub	r2, r25
     4bc:	29 1a       	sub	r2, r25
     4be:	29 1a       	sub	r2, r25
     4c0:	29 1a       	sub	r2, r25
     4c2:	29 1a       	sub	r2, r25
     4c4:	29 1a       	sub	r2, r25
     4c6:	29 1a       	sub	r2, r25
     4c8:	29 1a       	sub	r2, r25
     4ca:	29 1a       	sub	r2, r25
     4cc:	29 1a       	sub	r2, r25
     4ce:	29 1a       	sub	r2, r25
     4d0:	29 1a       	sub	r2, r25
     4d2:	29 1a       	sub	r2, r25
     4d4:	29 1a       	sub	r2, r25
     4d6:	29 1a       	sub	r2, r25
     4d8:	29 1a       	sub	r2, r25
     4da:	29 1a       	sub	r2, r25
     4dc:	29 1a       	sub	r2, r25
     4de:	eb 19       	sub	r30, r11
     4e0:	29 1a       	sub	r2, r25
     4e2:	29 1a       	sub	r2, r25
     4e4:	29 1a       	sub	r2, r25
     4e6:	29 1a       	sub	r2, r25
     4e8:	29 1a       	sub	r2, r25
     4ea:	29 1a       	sub	r2, r25
     4ec:	29 1a       	sub	r2, r25
     4ee:	29 1a       	sub	r2, r25
     4f0:	29 1a       	sub	r2, r25
     4f2:	29 1a       	sub	r2, r25
     4f4:	29 1a       	sub	r2, r25
     4f6:	29 1a       	sub	r2, r25
     4f8:	29 1a       	sub	r2, r25
     4fa:	29 1a       	sub	r2, r25
     4fc:	29 1a       	sub	r2, r25
     4fe:	ed 19       	sub	r30, r13

00000500 <err98>:
     500:	45 72 72 6f 72 20 39 38 3a 20 44 6f 73 6c 6f 20     Error 98: Doslo 
     510:	6b 65 20 6b 72 c3 a1 74 6b c3 a9 6d 75 20 76 c3     ke kr..tk..mu v.
     520:	bd 70 61 64 6b 75 20 20 20 20 20 6e 61 70 c3 a1     .padku     nap..
     530:	6a 65 6e c3 ad 2e 20 44 61 74 61 20 75 6c 6f 7a     jen... Data uloz
     540:	65 6e 61 2e 20 52 65 73 65 74 2e 00                 ena. Reset..

0000054c <msg14>:
     54c:	14 6f 6b 20 20 00 00 00 00 00 00 00                 .ok  .......

00000558 <msg0A>:
     558:	0a 20 20 20 20 00 00 00 00 00 00 00                 .    .......

00000564 <err1>:
     564:	45 72 72 6f 72 20 31 3a 20 44 6f 73 6c 6f 20 6b     Error 1: Doslo k
     574:	20 63 68 79 62 65 20 76 20 6b 6f 6e 74 72 6f 6c      chybe v kontrol
     584:	6e 69 6d 0a 73 6f 75 63 74 75 20 70 72 69 20 70     nim.souctu pri p
     594:	72 69 6a 6d 75 20 7a 70 72 61 76 79 20 6e 61 20     rijmu zpravy na 
     5a4:	6b 61 74 72 75 2e 20 0a 4e 65 6d 75 73 69 20 74     katru. .Nemusi t
     5b4:	6f 20 7a 6e 61 6d 65 6e 61 74 20 7a 61 64 6e 65     o znamenat zadne
     5c4:	20 70 6f 74 69 7a 65 2e 00                           potize..

000005cd <err4>:
     5cd:	45 72 72 6f 72 20 34 3a 20 43 68 79 62 61 20 49     Error 4: Chyba I
     5dd:	52 43 0a 52 79 63 68 6c 65 20 6f 74 6f 63 65 6e     RC.Rychle otocen
     5ed:	69 20 49 52 43 20 6e 61 20 6b 61 74 72 75 00        i IRC na katru.

000005fc <err6>:
     5fc:	45 72 72 6f 72 20 36 3a 20 43 68 79 62 61 20 49     Error 6: Chyba I
     60c:	52 43 0a 52 79 63 68 6c 65 20 6f 74 6f 63 65 6e     RC.Rychle otocen
     61c:	69 20 49 52 43 20 6e 61 20 76 6f 7a 69 6b 75 00     i IRC na voziku.

0000062c <err7>:
     62c:	45 72 72 6f 72 20 37 3a 20 50 6c 6e 61 20 6f 64     Error 7: Plna od
     63c:	65 73 69 6c 61 63 69 20 66 72 6f 6e 74 61 20 6e     esilaci fronta n
     64c:	61 20 6b 61 74 72 75 2e 0a 4e 65 6d 75 73 69 20     a katru..Nemusi 
     65c:	74 6f 20 7a 6e 61 6d 65 6e 61 74 20 7a 61 64 6e     to znamenat zadn
     66c:	79 20 70 72 6f 62 6c 65 6d 2e 00                    y problem..

00000677 <err10>:
     677:	45 72 72 6f 72 20 31 30 3a 20 0a 20 44 45 42 55     Error 10: . DEBU
     687:	47 00                                               G.

00000689 <err11>:
     689:	45 72 72 6f 72 20 31 31 3a 20 0a 20 44 45 42 55     Error 11: . DEBU
     699:	47 20 32 00                                         G 2.

0000069d <err80>:
     69d:	45 72 72 6f 72 20 38 30 3a 20 43 68 79 62 61 20     Error 80: Chyba 
     6ad:	4c 43 44 0a 50 72 65 6b 72 6f 63 65 6e 69 20 72     LCD.Prekroceni r
     6bd:	6f 7a 73 61 68 75 0a 4c 43 44 20 70 6f 20 6f 64     ozsahu.LCD po od
     6cd:	72 61 64 6b 6f 76 61 6e 69 00                       radkovani.

000006d7 <err81>:
     6d7:	45 72 72 6f 72 20 38 31 3a 20 43 68 79 62 61 20     Error 81: Chyba 
     6e7:	4c 43 44 0a 54 65 78 74 20 70 72 65 73 61 68 75     LCD.Text presahu
     6f7:	6a 65 0a 6f 6b 72 61 6a 20 4c 43 44 00              je.okraj LCD.

00000704 <err82>:
     704:	45 72 72 6f 72 20 38 32 3a 20 43 68 79 62 61 20     Error 82: Chyba 
     714:	4c 43 44 0a 50 6f 63 61 74 65 6b 20 74 65 78 74     LCD.Pocatek text
     724:	75 0a 6d 69 6d 6f 20 64 69 73 70 6c 65 6a 00        u.mimo displej.

00000733 <err83>:
     733:	45 72 72 6f 72 20 38 33 3a 20 43 68 79 62 61 20     Error 83: Chyba 
     743:	49 52 43 0a 4f 70 72 61 76 61 20 6e 61 20 72 65     IRC.Oprava na re
     753:	66 65 72 65 6e 2e 0a 62 6f 64 65 20 6f 20 76 69     feren..bode o vi
     763:	63 65 20 6e 65 7a 0a 20 31 30 20 63 6d 00           ce nez. 10 cm.

00000771 <err84>:
     771:	45 72 72 6f 72 20 38 34 3a 20 0a 4e 65 6c 7a 65     Error 84: .Nelze
     781:	20 7a 61 68 61 6a 69 74 20 6d 65 72 65 6e 69 0a      zahajit mereni.
     791:	64 6f 6b 75 64 20 6e 65 6e 69 0a 75 6b 6f 6e 63     dokud neni.ukonc
     7a1:	65 6e 6f 20 70 72 65 64 63 68 6f 7a 69 2e 00        eno predchozi..

000007b0 <err85>:
     7b0:	45 72 72 6f 72 20 38 35 3a 20 43 68 79 62 61 20     Error 85: Chyba 
     7c0:	6b 6f 6e 76 65 72 7a 65 20 69 6e 74 32 73 74 72     konverze int2str
     7d0:	69 6e 67 2e 0a 50 72 65 76 61 64 65 6e 65 20 63     ing..Prevadene c
     7e0:	69 73 6c 6f 20 6a 65 20 70 72 69 6c 69 73 20 64     islo je prilis d
     7f0:	6c 6f 75 68 65 2e 0a 44 6f 63 68 61 7a 69 20 6b     louhe..Dochazi k
     800:	20 70 72 65 74 65 6b 61 6e 69 20 76 65 20 76 79      pretekani ve vy
     810:	70 69 73 75 2e 00                                   pisu..

00000816 <err86>:
     816:	45 72 72 6f 72 20 38 36 3a 20 44 6f 73 6c 6f 20     Error 86: Doslo 
     826:	6b 20 63 68 79 62 65 20 76 20 6b 6f 6e 74 72 6f     k chybe v kontro
     836:	6c 6e 69 6d 0a 73 6f 75 63 74 75 20 70 72 69 20     lnim.souctu pri 
     846:	70 72 69 6a 6d 75 20 7a 70 72 61 76 79 0a 6e 61     prijmu zpravy.na
     856:	20 76 6f 7a 69 6b 75 2e 0a 4e 65 6d 75 73 69 20      voziku..Nemusi 
     866:	74 6f 20 7a 6e 61 6d 65 6e 61 74 20 7a 61 64 6e     to znamenat zadn
     876:	65 20 70 6f 74 69 7a 65 2e 00                       e potize..

00000880 <err87>:
     880:	45 72 72 6f 72 20 38 37 3a 20 50 72 69 20 70 72     Error 87: Pri pr
     890:	69 6a 6d 75 20 7a 70 72 61 76 79 20 6e 61 0a 76     ijmu zpravy na.v
     8a0:	6f 7a 69 6b 75 20 62 79 6c 61 20 6b 6f 6d 75 6e     oziku byla komun
     8b0:	69 6b 61 63 65 20 7a 61 68 61 6a 65 6e 61 0a 6e     ikace zahajena.n
     8c0:	65 73 70 72 76 6e 79 6d 20 7a 6e 61 6b 65 6d 00     esprvnym znakem.

000008d0 <err88>:
     8d0:	45 72 72 6f 72 20 38 38 3a 20 4e 65 64 6f 73 74     Error 88: Nedost
     8e0:	61 74 65 6b 20 70 61 6d 65 74 69 00                 atek pameti.

000008ec <err89>:
     8ec:	45 72 72 6f 72 20 38 39 3a 20 0a 50 72 65 6b 72     Error 89: .Prekr
     8fc:	6f 63 65 6e 20 72 6f 7a 73 61 68 20 75 6c 6f 7a     ocen rozsah uloz
     90c:	69 74 65 6c 6e 65 20 64 65 6c 6b 79 2e 0a 4d 61     itelne delky..Ma
     91c:	78 69 6d 61 6c 6e 69 20 75 6c 6f 7a 69 74 65 6c     ximalni ulozitel
     92c:	6e 61 20 64 65 6c 6b 61 20 6a 65 20 32 35 2e 35     na delka je 25.5
     93c:	20 6d 00                                             m.

0000093f <err90>:
     93f:	45 72 72 6f 72 20 39 30 3a 20 0a 50 72 65 6b 72     Error 90: .Prekr
     94f:	6f 63 65 6e 20 72 6f 7a 73 61 68 20 75 6c 6f 7a     ocen rozsah uloz
     95f:	69 74 65 6c 6e 65 68 6f 20 70 72 75 6d 65 72 75     itelneho prumeru
     96f:	2e 0a 4d 61 78 69 6d 61 6c 6e 69 20 75 6c 6f 7a     ..Maximalni uloz
     97f:	69 74 65 6c 6e 79 20 70 72 75 6d 65 72 20 6a 65     itelny prumer je
     98f:	20 36 33 2e 35 20 63 6d 00                           63.5 cm.

00000998 <err91>:
     998:	45 72 72 6f 72 20 39 31 3a 20 0a 50 72 65 6b 72     Error 91: .Prekr
     9a8:	6f 63 65 6e 61 20 6d 61 78 69 6d 61 6c 6e 69 20     ocena maximalni 
     9b8:	64 6f 62 61 20 6f 64 65 7a 76 79 20 6e 61 20 0a     doba odezvy na .
     9c8:	7a 70 72 61 76 75 2e 00                             zpravu..

000009d0 <err92>:
     9d0:	45 72 72 6f 72 20 39 32 3a 20 0a 56 20 64 75 73     Error 92: .V dus
     9e0:	6c 65 64 6b 75 20 6f 64 6a 65 7a 64 75 20 76 6f     ledku odjezdu vo
     9f0:	7a 69 6b 75 20 6f 64 20 6b 61 74 72 75 20 0a 73     ziku od katru .s
     a00:	65 20 6e 65 70 6f 64 61 72 69 6c 6f 20 70 72 6f     e nepodarilo pro
     a10:	76 65 73 74 20 64 6f 73 74 61 74 65 6b 20 6d 65     vest dostatek me
     a20:	72 65 6e 69 2e 0a 4e 61 6d 65 72 65 6e 61 20 64     reni..Namerena d
     a30:	61 74 61 20 6d 6f 68 6f 75 20 62 79 74 20 6e 65     ata mohou byt ne
     a40:	70 72 65 73 6e 61 2e 00                             presna..

00000a48 <err93>:
     a48:	45 72 72 6f 72 20 39 33 3a 20 0a 56 20 64 75 73     Error 93: .V dus
     a58:	6c 65 64 6b 75 20 6f 64 6a 65 7a 64 75 20 76 6f     ledku odjezdu vo
     a68:	7a 69 6b 75 20 6f 64 20 6b 61 74 72 75 2c 20 0a     ziku od katru, .
     a78:	6e 65 62 79 6c 6f 20 7a 61 6a 69 73 74 65 6e 6f     nebylo zajisteno
     a88:	20 64 6f 73 74 61 74 65 6b 20 64 61 74 2e 0a 4d      dostatek dat..M
     a98:	65 72 65 6e 69 20 6a 65 20 7a 72 75 73 65 6e 6f     ereni je zruseno
     aa8:	2e 00                                               ..

00000aaa <err94>:
     aaa:	45 72 72 6f 72 20 39 34 3a 20 0a 4a 65 20 6e 75     Error 94: .Je nu
     aba:	74 6e 65 20 6e 65 6a 64 72 69 76 65 20 7a 61 64     tne nejdrive zad
     aca:	61 74 20 6a 6d 65 6e 6f 20 7a 61 6b 61 7a 6e 69     at jmeno zakazni
     ada:	6b 61 2e 00                                         ka..

00000ade <err95>:
     ade:	45 72 72 6f 72 20 39 35 3a 20 5a 61 6b 61 7a 6e     Error 95: Zakazn
     aee:	69 6b 61 20 6e 65 6c 7a 65 20 6f 64 73 74 72 61     ika nelze odstra
     afe:	6e 69 74 2e 20 0a 42 79 6c 6f 20 70 72 6f 20 6e     nit. .Bylo pro n
     b0e:	65 6a 20 6a 69 7a 20 6e 61 6d 65 72 65 6e 6f 20     ej jiz namereno 
     b1e:	6e 65 6b 6f 6c 69 6b 20 6b 6d 65 6e 75 2e 0a 50     nekolik kmenu..P
     b2e:	72 65 64 20 6f 64 73 74 72 61 6e 65 6e 69 6d 20     red odstranenim 
     b3e:	6a 65 20 6e 75 74 6e 65 20 74 61 74 6f 20 6d 65     je nutne tato me
     b4e:	72 65 6e 69 0a 73 6d 61 7a 61 74 2e 00              reni.smazat..

00000b5b <err96>:
     b5b:	45 72 72 6f 72 20 39 36 3a 20 0a 44 6f 73 6c 6f     Error 96: .Doslo
     b6b:	20 6b 20 70 72 65 70 6c 6e 65 6e 69 20 6f 64 65      k preplneni ode
     b7b:	73 69 6c 61 63 69 68 6f 20 62 75 66 66 65 72 75     silaciho bufferu
     b8b:	20 0a 73 65 72 69 6f 76 65 68 6f 20 6b 61 6e 61      .serioveho kana
     b9b:	6c 75 20 6e 61 20 6b 61 74 72 75 2e 20 4e 65 6d     lu na katru. Nem
     bab:	75 73 69 20 74 6f 20 0a 7a 6e 61 6d 65 6e 61 74     usi to .znamenat
     bbb:	20 7a 61 64 6e 65 20 70 6f 74 69 7a 65 2e 00         zadne potize..

00000bca <err99>:
     bca:	45 72 72 6f 72 20 39 39 3a 20 0a 50 6f 6b 75 73     Error 99: .Pokus
     bda:	20 6f 20 6d 65 72 65 6e 69 20 70 72 69 6c 69 73      o mereni prilis
     bea:	20 6b 72 61 74 6b 65 68 6f 20 6b 6d 65 6e 75 2e      kratkeho kmenu.
     bfa:	0a 4e 65 6a 6b 72 61 74 73 69 20 6d 65 72 69 74     .Nejkratsi merit
     c0a:	65 6c 6e 79 20 6b 6d 65 6e 20 6a 65 20 32 6d 2e     elny kmen je 2m.
	...

00000c1b <err100>:
     c1b:	45 72 72 6f 72 20 31 30 30 3a 20 0a 4e 65 73 70     Error 100: .Nesp
     c2b:	72 61 76 6e 65 20 7a 61 64 61 6e 65 20 63 69 73     ravne zadane cis
     c3b:	6c 6f 2e 00                                         lo..

00000c3f <err101>:
     c3f:	45 72 72 6f 72 20 31 30 31 3a 20 50 61 6d 65 74     Error 101: Pamet
     c4f:	20 7a 61 7a 6e 61 6d 75 20 7a 61 70 6c 6e 65 6e      zaznamu zaplnen
     c5f:	61 2e 0a 4e 65 6c 7a 65 20 75 6b 6c 61 64 61 74     a..Nelze ukladat
     c6f:	20 64 61 6c 73 69 20 7a 61 7a 6e 61 6d 79 2e 20      dalsi zaznamy. 
     c7f:	4f 64 65 73 6c 65 74 65 0a 64 61 74 61 20 6e 61     Odeslete.data na
     c8f:	20 73 65 72 76 65 72 2e 00                           server..

00000c98 <err102>:
     c98:	45 72 72 6f 72 20 31 30 32 3a 20 0a 43 68 79 62     Error 102: .Chyb
     ca8:	61 20 70 72 69 20 6b 6f 6d 75 6e 69 6b 61 63 69     a pri komunikaci
     cb8:	20 73 65 20 73 65 72 76 65 72 65 6d 2e 00            se serverem..

00000cc6 <err200>:
     cc6:	0a 20 20 20 20 20 20 20 20 20 20 20 20 20 44 61     .             Da
     cd6:	74 61 20 6f 64 65 73 6c 61 6e 61 2e 00              ta odeslana..

00000ce3 <err201>:
     ce3:	0a 50 61 6d 65 74 20 7a 61 7a 6e 61 6d 75 20 74     .Pamet zaznamu t
     cf3:	65 6d 65 72 20 7a 61 70 6c 6e 65 6e 61 2e 0a 5a     emer zaplnena..Z
     d03:	62 79 76 61 20 6d 69 73 74 6f 20 6e 61 20 6d 65     byva misto na me
     d13:	6e 65 20 6e 65 7a 20 31 30 20 7a 61 7a 6e 61 6d     ne nez 10 zaznam
     d23:	75 2e 00                                            u..

00000d26 <err97>:
     d26:	45 72 72 6f 72 20 39 37 3a 20 56 61 7a 6e 61 20     Error 97: Vazna 
     d36:	63 68 79 62 61 20 62 65 68 75 20 70 72 6f 67 72     chyba behu progr
     d46:	61 6d 75 2e 20 20 20 20 55 6b 6c 61 64 61 6e 69     amu.    Ukladani
     d56:	20 64 61 74 2e 00                                    dat..

00000d5c <err97b>:
     d5c:	45 72 72 6f 72 20 39 37 3a 20 44 61 74 61 20 75     Error 97: Data u
     d6c:	6c 6f 7a 65 6e 61 2e 20 52 65 73 65 74 2e 00        lozena. Reset..

00000d7b <s_zakz>:
     d7b:	53 65 72 76 65 72 20 6e 65 64 6f 73 61 7a 65 6e     Server nedosazen
     d8b:	20 00                                                .

00000d8d <s_delka>:
     d8d:	44 65 6c 6b 61 00                                   Delka.

00000d93 <s_prumer_v>:
     d93:	70 72 75 6d 5f 76 00                                prum_v.

00000d9a <__ctors_end>:
     d9a:	11 24       	eor	r1, r1
     d9c:	1f be       	out	0x3f, r1	; 63
     d9e:	cf e5       	ldi	r28, 0x5F	; 95
     da0:	d8 e0       	ldi	r29, 0x08	; 8
     da2:	de bf       	out	0x3e, r29	; 62
     da4:	cd bf       	out	0x3d, r28	; 61

00000da6 <__do_copy_data>:
     da6:	11 e0       	ldi	r17, 0x01	; 1
     da8:	a0 e6       	ldi	r26, 0x60	; 96
     daa:	b0 e0       	ldi	r27, 0x00	; 0
     dac:	e2 ec       	ldi	r30, 0xC2	; 194
     dae:	f7 e4       	ldi	r31, 0x47	; 71
     db0:	02 c0       	rjmp	.+4      	; 0xdb6 <.do_copy_data_start>

00000db2 <.do_copy_data_loop>:
     db2:	05 90       	lpm	r0, Z+
     db4:	0d 92       	st	X+, r0

00000db6 <.do_copy_data_start>:
     db6:	ae 36       	cpi	r26, 0x6E	; 110
     db8:	b1 07       	cpc	r27, r17
     dba:	d9 f7       	brne	.-10     	; 0xdb2 <.do_copy_data_loop>

00000dbc <__do_clear_bss>:
     dbc:	13 e0       	ldi	r17, 0x03	; 3
     dbe:	ae e6       	ldi	r26, 0x6E	; 110
     dc0:	b1 e0       	ldi	r27, 0x01	; 1
     dc2:	01 c0       	rjmp	.+2      	; 0xdc6 <.do_clear_bss_start>

00000dc4 <.do_clear_bss_loop>:
     dc4:	1d 92       	st	X+, r1

00000dc6 <.do_clear_bss_start>:
     dc6:	ac 3b       	cpi	r26, 0xBC	; 188
     dc8:	b1 07       	cpc	r27, r17
     dca:	e1 f7       	brne	.-8      	; 0xdc4 <.do_clear_bss_loop>
     dcc:	0e 94 28 08 	call	0x1050	; 0x1050 <main>
     dd0:	0c 94 df 23 	jmp	0x47be	; 0x47be <_exit>

00000dd4 <__bad_interrupt>:
     dd4:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000dd8 <ioinit>:
/// Inicializace čítače pro volání inkrementálního čidla
void ioinit (void) {
  int pocet_cyklu = 2500;

  // citac bude citat v každém cyklu, režim - Clear Timer on Compare (CTC)
  TCCR1B = (1 << CS10) | (1 << WGM12);
     dd8:	89 e0       	ldi	r24, 0x09	; 9
     dda:	8e bd       	out	0x2e, r24	; 46
  // nastaveni přerušení při porovnání
  TIMSK = (1 << OCIE1A);
     ddc:	90 e1       	ldi	r25, 0x10	; 16
     dde:	99 bf       	out	0x39, r25	; 57

  // Nastavení jak často se bude volat 
  OCR1AH = (unsigned char)(pocet_cyklu >> 8);
     de0:	8b bd       	out	0x2b, r24	; 43
  OCR1AL = (unsigned char) pocet_cyklu;
     de2:	84 ec       	ldi	r24, 0xC4	; 196
     de4:	8a bd       	out	0x2a, r24	; 42
}
     de6:	08 95       	ret

00000de8 <prazdna>:
void err102(void){
  new_error(102); // chyba při komunikaci se serverem
}

void prazdna(char* s){
}
     de8:	08 95       	ret

00000dea <get_data_from_server>:
Funkce je volána v případě, že je nastaveno získávání dat o šířce ze serveru.
Zajišťuje výzvu k odesílání pro server a čekání na odpověď.
@todo Přepsat. Chce to zajistit umlčení katru.
*/
void get_data_from_server(void){
  char * msg = (char *)mmalloc(DATASIZE);
     dea:	8a e0       	ldi	r24, 0x0A	; 10
     dec:	90 e0       	ldi	r25, 0x00	; 0
     dee:	0e 94 a4 1d 	call	0x3b48	; 0x3b48 <mmalloc>
     df2:	fc 01       	movw	r30, r24
  msg[0] = '\x46';
     df4:	86 e4       	ldi	r24, 0x46	; 70
     df6:	80 83       	st	Z, r24
  new_ack_msg(msg, 0,prazdna,err102);
     df8:	cf 01       	movw	r24, r30
     dfa:	60 e0       	ldi	r22, 0x00	; 0
     dfc:	44 ef       	ldi	r20, 0xF4	; 244
     dfe:	56 e0       	ldi	r21, 0x06	; 6
     e00:	25 e0       	ldi	r18, 0x05	; 5
     e02:	37 e0       	ldi	r19, 0x07	; 7
     e04:	0e 94 f7 0a 	call	0x15ee	; 0x15ee <new_ack_msg>
}
     e08:	08 95       	ret

00000e0a <err102>:
    msg2[1] = (unsigned char) 1;
    new_msg(msg2);
}

void err102(void){
  new_error(102); // chyba při komunikaci se serverem
     e0a:	86 e6       	ldi	r24, 0x66	; 102
     e0c:	0e 94 33 18 	call	0x3066	; 0x3066 <new_error>
}
     e10:	08 95       	ret

00000e12 <get_data_from_katr>:
}

/**
Tato funkce je volána při startu jednočipu. Jejím úkolem je získat data z katru.
*/
void get_data_from_katr(void){
     e12:	1f 93       	push	r17
    char * msg1;
    char * msg2;
    msg1 =(void*) mmalloc (DATASIZE);
     e14:	8a e0       	ldi	r24, 0x0A	; 10
     e16:	90 e0       	ldi	r25, 0x00	; 0
     e18:	0e 94 a4 1d 	call	0x3b48	; 0x3b48 <mmalloc>
     e1c:	fc 01       	movw	r30, r24

    msg1[0] = '\x09';
     e1e:	89 e0       	ldi	r24, 0x09	; 9
     e20:	80 83       	st	Z, r24
    msg1[1] = (unsigned char) 1;
     e22:	11 e0       	ldi	r17, 0x01	; 1
     e24:	11 83       	std	Z+1, r17	; 0x01
    new_msg(msg1);
     e26:	cf 01       	movw	r24, r30
     e28:	0e 94 21 0a 	call	0x1442	; 0x1442 <new_msg>


    msg2 =(void*) mmalloc (DATASIZE);
     e2c:	8a e0       	ldi	r24, 0x0A	; 10
     e2e:	90 e0       	ldi	r25, 0x00	; 0
     e30:	0e 94 a4 1d 	call	0x3b48	; 0x3b48 <mmalloc>
     e34:	fc 01       	movw	r30, r24
    
    msg2[0] = '\x16';
     e36:	86 e1       	ldi	r24, 0x16	; 22
     e38:	80 83       	st	Z, r24
    msg2[1] = (unsigned char) 1;
     e3a:	11 83       	std	Z+1, r17	; 0x01
    new_msg(msg2);
     e3c:	cf 01       	movw	r24, r30
     e3e:	0e 94 21 0a 	call	0x1442	; 0x1442 <new_msg>
}
     e42:	1f 91       	pop	r17
     e44:	08 95       	ret

00000e46 <send_start_msg>:
Tato funkce je volána při startu jednočipu. Jejím úkolem je získat data z katru.
*/
void send_start_msg(void){
    char * msg1;

    msg1 =(void*) mmalloc (DATASIZE);
     e46:	8a e0       	ldi	r24, 0x0A	; 10
     e48:	90 e0       	ldi	r25, 0x00	; 0
     e4a:	0e 94 a4 1d 	call	0x3b48	; 0x3b48 <mmalloc>
     e4e:	fc 01       	movw	r30, r24

    msg1[0] = MSGN_START;
     e50:	8a e8       	ldi	r24, 0x8A	; 138
     e52:	80 83       	st	Z, r24
    msg1[1] = (unsigned char) 1;
     e54:	81 e0       	ldi	r24, 0x01	; 1
     e56:	81 83       	std	Z+1, r24	; 0x01
    new_msg(msg1);
     e58:	cf 01       	movw	r24, r30
     e5a:	0e 94 21 0a 	call	0x1442	; 0x1442 <new_msg>

}
     e5e:	08 95       	ret

00000e60 <getstr_P>:
 * paměť pro uložení řetězce do SRAM, řetězec tam zkopíruje a vrátí ukazatel na
 * toto místo.
 * @param s_p Ukazatel do programové paměti.
 * @return Ukazatel v paměti SRAM, kam je zkopírován řetězec z \a s_p
 **/
char * getstr_P( PGM_P s_p){
     e60:	0f 93       	push	r16
     e62:	1f 93       	push	r17
     e64:	cf 93       	push	r28
     e66:	df 93       	push	r29
     e68:	8c 01       	movw	r16, r24
  char * p_pom;

  p_pom = (char *) mmalloc(strlen_P(s_p) + 1);
     e6a:	0e 94 d1 1e 	call	0x3da2	; 0x3da2 <strlen_P>
     e6e:	01 96       	adiw	r24, 0x01	; 1
     e70:	0e 94 a4 1d 	call	0x3b48	; 0x3b48 <mmalloc>
     e74:	ec 01       	movw	r28, r24
  if(p_pom == NULL){
     e76:	00 97       	sbiw	r24, 0x00	; 0
     e78:	21 f4       	brne	.+8      	; 0xe82 <getstr_P+0x22>
    new_error(88);
     e7a:	88 e5       	ldi	r24, 0x58	; 88
     e7c:	0e 94 33 18 	call	0x3066	; 0x3066 <new_error>
     e80:	03 c0       	rjmp	.+6      	; 0xe88 <getstr_P+0x28>
    return NULL;
  }
  else{
    strcpy_P(p_pom, s_p);
     e82:	b8 01       	movw	r22, r16
     e84:	0e 94 ca 1e 	call	0x3d94	; 0x3d94 <strcpy_P>
  }

  return p_pom;
}
     e88:	ce 01       	movw	r24, r28
     e8a:	df 91       	pop	r29
     e8c:	cf 91       	pop	r28
     e8e:	1f 91       	pop	r17
     e90:	0f 91       	pop	r16
     e92:	08 95       	ret

00000e94 <send_irc_values_to_PC>:
    //my_watchdog_counter = 0; //my_watchdog
  }
}


void send_irc_values_to_PC(void){
     e94:	ef 92       	push	r14
     e96:	ff 92       	push	r15
     e98:	0f 93       	push	r16
     e9a:	1f 93       	push	r17
     e9c:	cf 93       	push	r28
     e9e:	df 93       	push	r29
  static uint16_t irc2_tmp = 0;
  uint16_t irc1;
  uint16_t irc2;

  
  wtch_dbg_info();
     ea0:	80 e6       	ldi	r24, 0x60	; 96
     ea2:	90 e0       	ldi	r25, 0x00	; 0
     ea4:	90 93 fe 00 	sts	0x00FE, r25
     ea8:	80 93 fd 00 	sts	0x00FD, r24
     eac:	8e e7       	ldi	r24, 0x7E	; 126
     eae:	91 e0       	ldi	r25, 0x01	; 1
     eb0:	90 93 00 01 	sts	0x0100, r25
     eb4:	80 93 ff 00 	sts	0x00FF, r24

  irc1 = irc1_get_l();
     eb8:	0e 94 93 0e 	call	0x1d26	; 0x1d26 <irc1_get_l>
     ebc:	7c 01       	movw	r14, r24
  irc2 = irc2_get_l();
     ebe:	0e 94 4d 10 	call	0x209a	; 0x209a <irc2_get_l>
     ec2:	ec 01       	movw	r28, r24

  // došlo ke změně
  if ((irc1_tmp != irc1)||(irc2_tmp != irc2)){
     ec4:	80 91 70 01 	lds	r24, 0x0170
     ec8:	90 91 71 01 	lds	r25, 0x0171
     ecc:	8e 15       	cp	r24, r14
     ece:	9f 05       	cpc	r25, r15
     ed0:	39 f4       	brne	.+14     	; 0xee0 <send_irc_values_to_PC+0x4c>
     ed2:	80 91 6e 01 	lds	r24, 0x016E
     ed6:	90 91 6f 01 	lds	r25, 0x016F
     eda:	8c 17       	cp	r24, r28
     edc:	9d 07       	cpc	r25, r29
     ede:	89 f0       	breq	.+34     	; 0xf02 <send_irc_values_to_PC+0x6e>
    send_uint32(MSGN_IRC,(uint32_t) irc1, (uint32_t)irc2);
     ee0:	a7 01       	movw	r20, r14
     ee2:	60 e0       	ldi	r22, 0x00	; 0
     ee4:	70 e0       	ldi	r23, 0x00	; 0
     ee6:	8e 01       	movw	r16, r28
     ee8:	20 e0       	ldi	r18, 0x00	; 0
     eea:	30 e0       	ldi	r19, 0x00	; 0
     eec:	81 e6       	ldi	r24, 0x61	; 97
     eee:	0e 94 83 0a 	call	0x1506	; 0x1506 <send_uint32>

    //send_msg...
    irc1_tmp = irc1;
     ef2:	f0 92 71 01 	sts	0x0171, r15
     ef6:	e0 92 70 01 	sts	0x0170, r14
    irc2_tmp = irc2;
     efa:	d0 93 6f 01 	sts	0x016F, r29
     efe:	c0 93 6e 01 	sts	0x016E, r28
  }
   wtch_dbg_info();
     f02:	80 e6       	ldi	r24, 0x60	; 96
     f04:	90 e0       	ldi	r25, 0x00	; 0
     f06:	90 93 fe 00 	sts	0x00FE, r25
     f0a:	80 93 fd 00 	sts	0x00FD, r24
     f0e:	8b e8       	ldi	r24, 0x8B	; 139
     f10:	91 e0       	ldi	r25, 0x01	; 1
     f12:	90 93 00 01 	sts	0x0100, r25
     f16:	80 93 ff 00 	sts	0x00FF, r24
}
     f1a:	df 91       	pop	r29
     f1c:	cf 91       	pop	r28
     f1e:	1f 91       	pop	r17
     f20:	0f 91       	pop	r16
     f22:	ff 90       	pop	r15
     f24:	ef 90       	pop	r14
     f26:	08 95       	ret

00000f28 <__vector_7>:
    // a pokračujeme v programu
  }
}

/// Obsluha inkrementálního čidla je volána v přerušení čítače
SIGNAL (SIG_OUTPUT_COMPARE1A) {
     f28:	1f 92       	push	r1
     f2a:	0f 92       	push	r0
     f2c:	0f b6       	in	r0, 0x3f	; 63
     f2e:	0f 92       	push	r0
     f30:	11 24       	eor	r1, r1
     f32:	2f 93       	push	r18
     f34:	3f 93       	push	r19
     f36:	4f 93       	push	r20
     f38:	5f 93       	push	r21
     f3a:	6f 93       	push	r22
     f3c:	7f 93       	push	r23
     f3e:	8f 93       	push	r24
     f40:	9f 93       	push	r25
     f42:	af 93       	push	r26
     f44:	bf 93       	push	r27
     f46:	ef 93       	push	r30
     f48:	ff 93       	push	r31
  t_lcd++;
     f4a:	80 91 72 01 	lds	r24, 0x0172
     f4e:	90 91 73 01 	lds	r25, 0x0173
     f52:	01 96       	adiw	r24, 0x01	; 1
     f54:	90 93 73 01 	sts	0x0173, r25
     f58:	80 93 72 01 	sts	0x0172, r24
//  qqq++;


  irc1_watch();
     f5c:	0e 94 c5 0e 	call	0x1d8a	; 0x1d8a <irc1_watch>
  irc2_watch();
     f60:	0e 94 7f 10 	call	0x20fe	; 0x20fe <irc2_watch>
  wtch_main();
     f64:	0e 94 f1 1a 	call	0x35e2	; 0x35e2 <wtch_main>
  t_tictoc++;
  #endif
//wtch_reset2();
  
  
}
     f68:	ff 91       	pop	r31
     f6a:	ef 91       	pop	r30
     f6c:	bf 91       	pop	r27
     f6e:	af 91       	pop	r26
     f70:	9f 91       	pop	r25
     f72:	8f 91       	pop	r24
     f74:	7f 91       	pop	r23
     f76:	6f 91       	pop	r22
     f78:	5f 91       	pop	r21
     f7a:	4f 91       	pop	r20
     f7c:	3f 91       	pop	r19
     f7e:	2f 91       	pop	r18
     f80:	0f 90       	pop	r0
     f82:	0f be       	out	0x3f, r0	; 63
     f84:	0f 90       	pop	r0
     f86:	1f 90       	pop	r1
     f88:	18 95       	reti

00000f8a <test_shutdown>:
void test_shutdown(void){
  uint8_t time = 0;
  uint16_t i = 0;
//  char * s = __FILE__;

  wtch_dbg_info();
     f8a:	80 e6       	ldi	r24, 0x60	; 96
     f8c:	90 e0       	ldi	r25, 0x00	; 0
     f8e:	90 93 fe 00 	sts	0x00FE, r25
     f92:	80 93 fd 00 	sts	0x00FD, r24
     f96:	8c e8       	ldi	r24, 0x8C	; 140
     f98:	90 e0       	ldi	r25, 0x00	; 0
     f9a:	90 93 00 01 	sts	0x0100, r25
     f9e:	80 93 ff 00 	sts	0x00FF, r24

  if (((PIND >> 2) & (0x01)) == 0){
     fa2:	80 b3       	in	r24, 0x10	; 16
     fa4:	86 95       	lsr	r24
     fa6:	86 95       	lsr	r24
     fa8:	80 fd       	sbrc	r24, 0
     faa:	51 c0       	rjmp	.+162    	; 0x104e <test_shutdown+0xc4>
    printcxyd(1,1,'x');
     fac:	81 e0       	ldi	r24, 0x01	; 1
     fae:	90 e0       	ldi	r25, 0x00	; 0
     fb0:	61 e0       	ldi	r22, 0x01	; 1
     fb2:	70 e0       	ldi	r23, 0x00	; 0
     fb4:	48 e7       	ldi	r20, 0x78	; 120
     fb6:	0e 94 34 13 	call	0x2668	; 0x2668 <printcxyd>
    eeprom_save();
     fba:	0e 94 58 12 	call	0x24b0	; 0x24b0 <eeprom_save>
     fbe:	40 91 b4 01 	lds	r20, 0x01B4
     fc2:	50 91 b5 01 	lds	r21, 0x01B5
     fc6:	20 e0       	ldi	r18, 0x00	; 0
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
     fc8:	60 ed       	ldi	r22, 0xD0	; 208
     fca:	77 e0       	ldi	r23, 0x07	; 7
     fcc:	01 c0       	rjmp	.+2      	; 0xfd0 <test_shutdown+0x46>
     fce:	20 e0       	ldi	r18, 0x00	; 0
     fd0:	cb 01       	movw	r24, r22
     fd2:	01 97       	sbiw	r24, 0x01	; 1
     fd4:	f1 f7       	brne	.-4      	; 0xfd2 <test_shutdown+0x48>

    //Tenhle while běhá dokola. Pokud alespň na 5 ms naskočí na pinu 2 portu d
    //jednička, čekání skončí.
    while(1){
      _delay_ms(1);
      wtch_reset2();
     fd6:	14 16       	cp	r1, r20
     fd8:	15 06       	cpc	r1, r21
     fda:	14 f4       	brge	.+4      	; 0xfe0 <test_shutdown+0x56>
     fdc:	40 e0       	ldi	r20, 0x00	; 0
     fde:	50 e0       	ldi	r21, 0x00	; 0
     fe0:	a8 95       	wdr

      if (((PIND >> 2) & (0x01)) == 0)
     fe2:	82 9b       	sbis	0x10, 2	; 16
     fe4:	f4 cf       	rjmp	.-24     	; 0xfce <test_shutdown+0x44>
        time = 0;
      else
        time++;
     fe6:	2f 5f       	subi	r18, 0xFF	; 255

      if (time > 5)
     fe8:	26 30       	cpi	r18, 0x06	; 6
     fea:	90 f3       	brcs	.-28     	; 0xfd0 <test_shutdown+0x46>
     fec:	20 e0       	ldi	r18, 0x00	; 0
     fee:	30 e0       	ldi	r19, 0x00	; 0
     ff0:	60 ed       	ldi	r22, 0xD0	; 208
     ff2:	77 e0       	ldi	r23, 0x07	; 7
    }

    // počkáme vteřinku
    // to je kvůli tomu, aby napští na kondenzátoru vylezlo nad 4.5 V, což je nutné pro chod LCD
    for(i=0 ; i < 500;i++){
      wtch_reset2();
     ff4:	a8 95       	wdr
     ff6:	cb 01       	movw	r24, r22
     ff8:	01 97       	sbiw	r24, 0x01	; 1
     ffa:	f1 f7       	brne	.-4      	; 0xff8 <test_shutdown+0x6e>
        break;
    }

    // počkáme vteřinku
    // to je kvůli tomu, aby napští na kondenzátoru vylezlo nad 4.5 V, což je nutné pro chod LCD
    for(i=0 ; i < 500;i++){
     ffc:	2f 5f       	subi	r18, 0xFF	; 255
     ffe:	3f 4f       	sbci	r19, 0xFF	; 255
    1000:	81 e0       	ldi	r24, 0x01	; 1
    1002:	24 3f       	cpi	r18, 0xF4	; 244
    1004:	38 07       	cpc	r19, r24
    1006:	b1 f7       	brne	.-20     	; 0xff4 <test_shutdown+0x6a>
    1008:	50 93 b5 01 	sts	0x01B5, r21
    100c:	40 93 b4 01 	sts	0x01B4, r20
      wtch_reset2();
      _delay_ms(1);
    }
    lcd_w_inst(0x01);
    1010:	81 e0       	ldi	r24, 0x01	; 1
    1012:	0e 94 71 13 	call	0x26e2	; 0x26e2 <lcd_w_inst>
    printnt_P((void *)err98); // Výpadek napájení - reset.
    1016:	80 e0       	ldi	r24, 0x00	; 0
    1018:	95 e0       	ldi	r25, 0x05	; 5
    101a:	0e 94 1a 13 	call	0x2634	; 0x2634 <printnt_P>
    101e:	40 91 b4 01 	lds	r20, 0x01B4
    1022:	50 91 b5 01 	lds	r21, 0x01B5
    1026:	20 e0       	ldi	r18, 0x00	; 0
    1028:	30 e0       	ldi	r19, 0x00	; 0
    102a:	60 ed       	ldi	r22, 0xD0	; 208
    102c:	77 e0       	ldi	r23, 0x07	; 7

    for(i=0 ; i < 5000;i++){
       wtch_reset2();
    102e:	14 16       	cp	r1, r20
    1030:	15 06       	cpc	r1, r21
    1032:	14 f4       	brge	.+4      	; 0x1038 <test_shutdown+0xae>
    1034:	40 e0       	ldi	r20, 0x00	; 0
    1036:	50 e0       	ldi	r21, 0x00	; 0
    1038:	a8 95       	wdr
    103a:	cb 01       	movw	r24, r22
    103c:	01 97       	sbiw	r24, 0x01	; 1
    103e:	f1 f7       	brne	.-4      	; 0x103c <test_shutdown+0xb2>
      _delay_ms(1);
    }
    lcd_w_inst(0x01);
    printnt_P((void *)err98); // Výpadek napájení - reset.

    for(i=0 ; i < 5000;i++){
    1040:	2f 5f       	subi	r18, 0xFF	; 255
    1042:	3f 4f       	sbci	r19, 0xFF	; 255
    1044:	83 e1       	ldi	r24, 0x13	; 19
    1046:	28 38       	cpi	r18, 0x88	; 136
    1048:	38 07       	cpc	r19, r24
    104a:	89 f7       	brne	.-30     	; 0x102e <test_shutdown+0xa4>
    104c:	ff cf       	rjmp	.-2      	; 0x104c <test_shutdown+0xc2>
    104e:	08 95       	ret

00001050 <main>:
 * které obsluhují LCD, klávesnici, zajiš_tují měření atd.
 *
 * Část funkcí (např obsluha LCD, nebo kontrola IRC) je časově kritická. Jejich
 * volání je proto prováděno v závislosti na časocači.
 */
int main(void){
    1050:	0f 93       	push	r16
    1052:	1f 93       	push	r17
    1054:	cf 93       	push	r28
    1056:	df 93       	push	r29
    1058:	80 e0       	ldi	r24, 0x00	; 0
    105a:	90 e0       	ldi	r25, 0x00	; 0
    105c:	20 ed       	ldi	r18, 0xD0	; 208
    105e:	37 e0       	ldi	r19, 0x07	; 7
    1060:	f9 01       	movw	r30, r18
    1062:	31 97       	sbiw	r30, 0x01	; 1
    1064:	f1 f7       	brne	.-4      	; 0x1062 <main+0x12>
  //char c = 0;
  int i;


  for(i=0 ; i <200;i++){
    1066:	01 96       	adiw	r24, 0x01	; 1
    1068:	88 3c       	cpi	r24, 0xC8	; 200
    106a:	91 05       	cpc	r25, r1
    106c:	c9 f7       	brne	.-14     	; 0x1060 <main+0x10>
/// Inicializace čítače pro volání inkrementálního čidla
void ioinit (void) {
  int pocet_cyklu = 2500;

  // citac bude citat v každém cyklu, režim - Clear Timer on Compare (CTC)
  TCCR1B = (1 << CS10) | (1 << WGM12);
    106e:	99 e0       	ldi	r25, 0x09	; 9
    1070:	9e bd       	out	0x2e, r25	; 46
  // nastaveni přerušení při porovnání
  TIMSK = (1 << OCIE1A);
    1072:	80 e1       	ldi	r24, 0x10	; 16
    1074:	89 bf       	out	0x39, r24	; 57

  // Nastavení jak často se bude volat 
  OCR1AH = (unsigned char)(pocet_cyklu >> 8);
    1076:	9b bd       	out	0x2b, r25	; 43
  OCR1AL = (unsigned char) pocet_cyklu;
    1078:	84 ec       	ldi	r24, 0xC4	; 196
    107a:	8a bd       	out	0x2a, r24	; 42
  }

  // ioinit prehodit lcd_control, zapnout cas na zacatku
  ioinit();

  DDRC = 128; //testy
    107c:	80 e8       	ldi	r24, 0x80	; 128
    107e:	84 bb       	out	0x14, r24	; 20
  PORTC = 0;
    1080:	15 ba       	out	0x15, r1	; 21
  PORTD = _BV(7);
    1082:	82 bb       	out	0x12, r24	; 18
  
  irc1_init();
    1084:	0e 94 77 0e 	call	0x1cee	; 0x1cee <irc1_init>
  irc2_init();
    1088:	0e 94 2d 10 	call	0x205a	; 0x205a <irc2_init>
  lcd_init();
    108c:	0e 94 89 13 	call	0x2712	; 0x2712 <lcd_init>
  // pozor - možná užitečné
  //eeprom_load();

  //gui_init();

  keyboard_init();
    1090:	0e 94 b6 18 	call	0x316c	; 0x316c <keyboard_init>

  buttons_init();
    1094:	0e 94 7a 1a 	call	0x34f4	; 0x34f4 <buttons_init>
  USART_Init(51);
    1098:	83 e3       	ldi	r24, 0x33	; 51
    109a:	90 e0       	ldi	r25, 0x00	; 0
    109c:	0e 94 c2 08 	call	0x1184	; 0x1184 <USART_Init>

  

  //
  //get_data_from_katr();
  printnt("Start");
    10a0:	87 e6       	ldi	r24, 0x67	; 103
    10a2:	90 e0       	ldi	r25, 0x00	; 0
    10a4:	0e 94 28 13 	call	0x2650	; 0x2650 <printnt>
    10a8:	80 e0       	ldi	r24, 0x00	; 0
    10aa:	90 e0       	ldi	r25, 0x00	; 0
    10ac:	20 ed       	ldi	r18, 0xD0	; 208
    10ae:	37 e0       	ldi	r19, 0x07	; 7
    10b0:	f9 01       	movw	r30, r18
    10b2:	31 97       	sbiw	r30, 0x01	; 1
    10b4:	f1 f7       	brne	.-4      	; 0x10b2 <main+0x62>

  for(i=0 ; i <1000;i++){
    10b6:	01 96       	adiw	r24, 0x01	; 1
    10b8:	43 e0       	ldi	r20, 0x03	; 3
    10ba:	88 3e       	cpi	r24, 0xE8	; 232
    10bc:	94 07       	cpc	r25, r20
    10be:	c1 f7       	brne	.-16     	; 0x10b0 <main+0x60>
    _delay_ms(1);
  }

  wtch_init();
    10c0:	0e 94 e3 1a 	call	0x35c6	; 0x35c6 <wtch_init>
  wtch_dbg_info();
    10c4:	80 e6       	ldi	r24, 0x60	; 96
    10c6:	90 e0       	ldi	r25, 0x00	; 0
    10c8:	90 93 fe 00 	sts	0x00FE, r25
    10cc:	80 93 fd 00 	sts	0x00FD, r24
    10d0:	87 e1       	ldi	r24, 0x17	; 23
    10d2:	91 e0       	ldi	r25, 0x01	; 1
    10d4:	90 93 00 01 	sts	0x0100, r25
    10d8:	80 93 ff 00 	sts	0x00FF, r24
  sei();
    10dc:	78 94       	sei
  
  printxyd(1,5, "Cekani na spojeni...");
    10de:	81 e0       	ldi	r24, 0x01	; 1
    10e0:	90 e0       	ldi	r25, 0x00	; 0
    10e2:	65 e0       	ldi	r22, 0x05	; 5
    10e4:	70 e0       	ldi	r23, 0x00	; 0
    10e6:	4d e6       	ldi	r20, 0x6D	; 109
    10e8:	50 e0       	ldi	r21, 0x00	; 0
    10ea:	0e 94 85 15 	call	0x2b0a	; 0x2b0a <printxyd>
  send_start_msg();
    10ee:	0e 94 23 07 	call	0xe46	; 0xe46 <send_start_msg>
  while(1){
//    char st[2]=" ";
    //static char prekreslit = 1;
    static char cc = 0;

    wtch_dbg_info();
    10f2:	00 e6       	ldi	r16, 0x60	; 96
    10f4:	10 e0       	ldi	r17, 0x00	; 0
    10f6:	c2 e2       	ldi	r28, 0x22	; 34
    10f8:	d1 e0       	ldi	r29, 0x01	; 1
    10fa:	10 93 fe 00 	sts	0x00FE, r17
    10fe:	00 93 fd 00 	sts	0x00FD, r16
    1102:	d0 93 00 01 	sts	0x0100, r29
    1106:	c0 93 ff 00 	sts	0x00FF, r28
    
    si_print_run(cc);
    110a:	80 91 b6 01 	lds	r24, 0x01B6
    110e:	86 ff       	sbrs	r24, 6
    1110:	08 c0       	rjmp	.+16     	; 0x1122 <main+0xd2>
    1112:	80 e0       	ldi	r24, 0x00	; 0
    1114:	90 e0       	ldi	r25, 0x00	; 0
    1116:	60 e0       	ldi	r22, 0x00	; 0
    1118:	70 e0       	ldi	r23, 0x00	; 0
    111a:	40 91 74 01 	lds	r20, 0x0174
    111e:	0e 94 34 13 	call	0x2668	; 0x2668 <printcxyd>
    
    cc++;
    1122:	80 91 74 01 	lds	r24, 0x0174
    1126:	8f 5f       	subi	r24, 0xFF	; 255
    1128:	80 93 74 01 	sts	0x0174, r24

      //a = t_lcd;
 //     counter1++;


  if (t_lcd > T_LCD_MAX){
    112c:	80 91 72 01 	lds	r24, 0x0172
    1130:	90 91 73 01 	lds	r25, 0x0173
    1134:	02 97       	sbiw	r24, 0x02	; 2
    1136:	40 f0       	brcs	.+16     	; 0x1148 <main+0xf8>
    msg_time_pp();
    1138:	0e 94 d8 08 	call	0x11b0	; 0x11b0 <msg_time_pp>
        //printcxyd(2,2,cc);
        lcd_control();
    113c:	0e 94 18 14 	call	0x2830	; 0x2830 <lcd_control>
        //printxyd(1,0,__FILE__);
        //printnt(st);
        t_lcd = 0;
    1140:	10 92 73 01 	sts	0x0173, r1
    1144:	10 92 72 01 	sts	0x0172, r1
      }
      
      keyboard_recv_watchdog();
    1148:	0e 94 bf 18 	call	0x317e	; 0x317e <keyboard_recv_watchdog>
          prekreslit = 1;
        }*/



        send_irc_values_to_PC();
    114c:	0e 94 4a 07 	call	0xe94	; 0xe94 <send_irc_values_to_PC>

        //sprintf(str_buf,"%i",qqq);
        //printxyd(3,15,str_buf);
        //qqq=0;

    buttons();
    1150:	0e 94 81 1a 	call	0x3502	; 0x3502 <buttons>
    
    //measure();
    test_shutdown();
    1154:	0e 94 c5 07 	call	0xf8a	; 0xf8a <test_shutdown>
    //err_control();
    sysinfo();
    1158:	0e 94 9f 1b 	call	0x373e	; 0x373e <sysinfo>
    serial_read_buffer();
    115c:	0e 94 7e 0c 	call	0x18fc	; 0x18fc <serial_read_buffer>
    wtch_reset2();
    1160:	80 91 b4 01 	lds	r24, 0x01B4
    1164:	90 91 b5 01 	lds	r25, 0x01B5
    1168:	18 16       	cp	r1, r24
    116a:	19 06       	cpc	r1, r25
    116c:	14 f4       	brge	.+4      	; 0x1172 <main+0x122>
    116e:	80 e0       	ldi	r24, 0x00	; 0
    1170:	90 e0       	ldi	r25, 0x00	; 0
    1172:	90 93 b5 01 	sts	0x01B5, r25
    1176:	80 93 b4 01 	sts	0x01B4, r24
    117a:	a8 95       	wdr
    117c:	be cf       	rjmp	.-132    	; 0x10fa <main+0xaa>

0000117e <get_recv_buffer>:
static void into_buffer(unsigned char c);
//static void read_port(void);

char* get_recv_buffer(void){
  return usart_recv_buff;
}
    117e:	84 e0       	ldi	r24, 0x04	; 4
    1180:	93 e0       	ldi	r25, 0x03	; 3
    1182:	08 95       	ret

00001184 <USART_Init>:
 * Inicializace usartu
 */
void USART_Init( unsigned int baud ){
  int i = 0;
  /* Set baud rate */
  UBRRH = (unsigned char)(baud>>8);
    1184:	90 bd       	out	0x20, r25	; 32
  UBRRL = (unsigned char)baud;
    1186:	89 b9       	out	0x09, r24	; 9
  /* Enable Receiver and Transmitter */
  /* Data,RX interrupt enable*/
  UCSRB = (1<<RXEN)|(1<<TXEN)|(1<<RXCIE); // |(1<<UDRIE)
    1188:	88 e9       	ldi	r24, 0x98	; 152
    118a:	8a b9       	out	0x0a, r24	; 10
  /* Set frame format: 8data, 2stop bit */
  UCSRC = (1<<URSEL)|(1<<USBS)|(3<<UCSZ0);
    118c:	8e e8       	ldi	r24, 0x8E	; 142
    118e:	80 bd       	out	0x20, r24	; 32
    1190:	e4 e0       	ldi	r30, 0x04	; 4
    1192:	f3 e0       	ldi	r31, 0x03	; 3

  // Clear usart recive buffer
  for (i = 0; i < LenOfRecvBuff; i++){
    usart_recv_buff[i] = 0;
    1194:	11 92       	st	Z+, r1
  UCSRB = (1<<RXEN)|(1<<TXEN)|(1<<RXCIE); // |(1<<UDRIE)
  /* Set frame format: 8data, 2stop bit */
  UCSRC = (1<<URSEL)|(1<<USBS)|(3<<UCSZ0);

  // Clear usart recive buffer
  for (i = 0; i < LenOfRecvBuff; i++){
    1196:	83 e0       	ldi	r24, 0x03	; 3
    1198:	e6 31       	cpi	r30, 0x16	; 22
    119a:	f8 07       	cpc	r31, r24
    119c:	d9 f7       	brne	.-10     	; 0x1194 <USART_Init+0x10>
    119e:	e3 ee       	ldi	r30, 0xE3	; 227
    11a0:	f1 e0       	ldi	r31, 0x01	; 1
    usart_recv_buff[i] = 0;
  }

  // Clear usart transmitt buffer
  for (i = 0; i < LenOfTransBuff; i++){
    usart_trans_buff[i] = 0;
    11a2:	11 92       	st	Z+, r1
  for (i = 0; i < LenOfRecvBuff; i++){
    usart_recv_buff[i] = 0;
  }

  // Clear usart transmitt buffer
  for (i = 0; i < LenOfTransBuff; i++){
    11a4:	81 e0       	ldi	r24, 0x01	; 1
    11a6:	e5 3f       	cpi	r30, 0xF5	; 245
    11a8:	f8 07       	cpc	r31, r24
    11aa:	d9 f7       	brne	.-10     	; 0x11a2 <USART_Init+0x1e>
    usart_trans_buff_2[i] = 0;
  }
  */

//  UDR = 0;
  DDRD = DDRD | (1 << 4); // přepínání sériových linek
    11ac:	8c 9a       	sbi	0x11, 4	; 17


}
    11ae:	08 95       	ret

000011b0 <msg_time_pp>:



/// funkce inkrementuje počítadlo od poslední doručené zprávy
void msg_time_pp(void){
    11b0:	ef 92       	push	r14
    11b2:	ff 92       	push	r15
    11b4:	0f 93       	push	r16
    11b6:	1f 93       	push	r17
  if (msg_time < (100e4))
    11b8:	e0 90 92 00 	lds	r14, 0x0092
    11bc:	f0 90 93 00 	lds	r15, 0x0093
    11c0:	00 91 94 00 	lds	r16, 0x0094
    11c4:	10 91 95 00 	lds	r17, 0x0095
    11c8:	c8 01       	movw	r24, r16
    11ca:	b7 01       	movw	r22, r14
    11cc:	0e 94 7b 22 	call	0x44f6	; 0x44f6 <__floatunsisf>
    11d0:	20 e0       	ldi	r18, 0x00	; 0
    11d2:	34 e2       	ldi	r19, 0x24	; 36
    11d4:	44 e7       	ldi	r20, 0x74	; 116
    11d6:	59 e4       	ldi	r21, 0x49	; 73
    11d8:	0e 94 de 21 	call	0x43bc	; 0x43bc <__cmpsf2>
    11dc:	88 23       	and	r24, r24
    11de:	6c f4       	brge	.+26     	; 0x11fa <msg_time_pp+0x4a>
  msg_time++;
    11e0:	08 94       	sec
    11e2:	e1 1c       	adc	r14, r1
    11e4:	f1 1c       	adc	r15, r1
    11e6:	01 1d       	adc	r16, r1
    11e8:	11 1d       	adc	r17, r1
    11ea:	e0 92 92 00 	sts	0x0092, r14
    11ee:	f0 92 93 00 	sts	0x0093, r15
    11f2:	00 93 94 00 	sts	0x0094, r16
    11f6:	10 93 95 00 	sts	0x0095, r17
}
    11fa:	1f 91       	pop	r17
    11fc:	0f 91       	pop	r16
    11fe:	ff 90       	pop	r15
    1200:	ef 90       	pop	r14
    1202:	08 95       	ret

00001204 <msg_time_0>:

/// Funkce nuluje počítadlo
void msg_time_0(void){
  msg_time = 0;
    1204:	10 92 92 00 	sts	0x0092, r1
    1208:	10 92 93 00 	sts	0x0093, r1
    120c:	10 92 94 00 	sts	0x0094, r1
    1210:	10 92 95 00 	sts	0x0095, r1
}
    1214:	08 95       	ret

00001216 <get_msg_time>:

/// funkce vrací hodnotu počítadla
uint32_t get_msg_time(void){
    1216:	60 91 92 00 	lds	r22, 0x0092
    121a:	70 91 93 00 	lds	r23, 0x0093
  return (msg_time);
}
    121e:	80 91 94 00 	lds	r24, 0x0094
    1222:	90 91 95 00 	lds	r25, 0x0095
    1226:	08 95       	ret

00001228 <test_message>:

/// Funkce tesuje spravnost zpravy
/// @return 
/// Pokud je zprava v poradku vrati 1,
/// pokud je ve zprave chyba vrati funkce 0.
int test_message(char *msg){
    1228:	cf 93       	push	r28
    122a:	df 93       	push	r29
    122c:	ec 01       	movw	r28, r24
  int i=0;

  if (msg[0] != 255){
    122e:	88 81       	ld	r24, Y
    1230:	8f 3f       	cpi	r24, 0xFF	; 255
    1232:	e9 f4       	brne	.+58     	; 0x126e <test_message+0x46>
    1234:	de 01       	movw	r26, r28
    1236:	40 e0       	ldi	r20, 0x00	; 0
    1238:	50 e0       	ldi	r21, 0x00	; 0
    a = msg[i+2];
    b = msg[i+3];
    c = 2 + DATASIZE + 1 + (i/2);
    d = msg[c];
    //printf("%i ^ %i = %i, compare with buffer[%i] = %i\n",a,b,a^b,c,d);
    if ((a^b) != d){
    123a:	13 96       	adiw	r26, 0x03	; 3
    123c:	2c 91       	ld	r18, X
    123e:	13 97       	sbiw	r26, 0x03	; 3
    1240:	12 96       	adiw	r26, 0x02	; 2
    1242:	8c 91       	ld	r24, X
    1244:	12 97       	sbiw	r26, 0x02	; 2
    1246:	28 27       	eor	r18, r24
    1248:	ca 01       	movw	r24, r20
    124a:	95 95       	asr	r25
    124c:	87 95       	ror	r24
    124e:	83 5f       	subi	r24, 0xF3	; 243
    1250:	fe 01       	movw	r30, r28
    1252:	e8 0f       	add	r30, r24
    1254:	f1 1d       	adc	r31, r1
    1256:	80 81       	ld	r24, Z
    1258:	28 17       	cp	r18, r24
    125a:	49 f4       	brne	.+18     	; 0x126e <test_message+0x46>

  if (msg[0] != 255){
    return 0;
  }
//  printf("zacatek ok!\n");
  for(i=0;i < DATASIZE;i=i+2){
    125c:	4e 5f       	subi	r20, 0xFE	; 254
    125e:	5f 4f       	sbci	r21, 0xFF	; 255
    1260:	12 96       	adiw	r26, 0x02	; 2
    1262:	4a 30       	cpi	r20, 0x0A	; 10
    1264:	51 05       	cpc	r21, r1
    1266:	49 f7       	brne	.-46     	; 0x123a <test_message+0x12>
    1268:	21 e0       	ldi	r18, 0x01	; 1
    126a:	30 e0       	ldi	r19, 0x00	; 0
    126c:	02 c0       	rjmp	.+4      	; 0x1272 <test_message+0x4a>
    126e:	20 e0       	ldi	r18, 0x00	; 0
    1270:	30 e0       	ldi	r19, 0x00	; 0
	//printf("fuckoff");
      return 0;
    }
  }
  return 1;
}
    1272:	c9 01       	movw	r24, r18
    1274:	df 91       	pop	r29
    1276:	cf 91       	pop	r28
    1278:	08 95       	ret

0000127a <msg_ack_fcn>:
 * Funkce je volána při příjmu potvrzovací zprávy. Zavolá funkci,
 * která má být volána po potvrzení.
*/
void msg_ack_fcn(char * msg){
  //static int i = 0;
  if (p_ack_fcn != NULL){
    127a:	e0 91 7a 01 	lds	r30, 0x017A
    127e:	f0 91 7b 01 	lds	r31, 0x017B
    1282:	30 97       	sbiw	r30, 0x00	; 0
    1284:	69 f0       	breq	.+26     	; 0x12a0 <msg_ack_fcn+0x26>
    void (*p_fcn_tmp)(char*s);
    p_fcn_tmp = p_ack_fcn;
    p_ack_fcn = NULL;
    1286:	10 92 7b 01 	sts	0x017B, r1
    128a:	10 92 7a 01 	sts	0x017A, r1
    p_nack_fcn = NULL; // tohle musí být před voláním té funkce, protože v ní je
    128e:	10 92 80 01 	sts	0x0180, r1
    1292:	10 92 7f 01 	sts	0x017F, r1
                //znovu zahájeno vysílání zprávy a tady by se to zase zastavilo.
    p_fcn_tmp(msg);
    1296:	09 95       	icall
    msg_ack_timer = 0;
    1298:	10 92 7d 01 	sts	0x017D, r1
    129c:	10 92 7c 01 	sts	0x017C, r1
    12a0:	08 95       	ret

000012a2 <msg_nack_fcn>:
/**
 * Funkce uzavírá komunikaci při neúspěšném pokusu o odeslání zprávy s
 * odpovědí.
 */
void msg_nack_fcn(void){
  if (p_nack_fcn != NULL){
    12a2:	e0 91 7f 01 	lds	r30, 0x017F
    12a6:	f0 91 80 01 	lds	r31, 0x0180
    12aa:	30 97       	sbiw	r30, 0x00	; 0
    12ac:	09 f0       	breq	.+2      	; 0x12b0 <msg_nack_fcn+0xe>
    p_nack_fcn();
    12ae:	09 95       	icall
  }
  //new_error(91);
  msg_ack_timer = 0;
    12b0:	10 92 7d 01 	sts	0x017D, r1
    12b4:	10 92 7c 01 	sts	0x017C, r1
  p_ack_fcn = NULL;
    12b8:	10 92 7b 01 	sts	0x017B, r1
    12bc:	10 92 7a 01 	sts	0x017A, r1
  p_nack_fcn = NULL;
    12c0:	10 92 80 01 	sts	0x0180, r1
    12c4:	10 92 7f 01 	sts	0x017F, r1
}
    12c8:	08 95       	ret

000012ca <usart_get_recv_buff>:
    }
  }
}
    
/// Funkce vrací příslušný znak z přijímacího bufferu sériového kanálu.
char usart_get_recv_buff(int i){
    12ca:	fc 01       	movw	r30, r24
    12cc:	ec 5f       	subi	r30, 0xFC	; 252
    12ce:	fc 4f       	sbci	r31, 0xFC	; 252
  return usart_recv_buff[i];
}
    12d0:	80 81       	ld	r24, Z
    12d2:	08 95       	ret

000012d4 <recive_uint32>:
/// Funkce získá ze zprávy dvě čísla uint32_t
/// @param number1 ukazatel na číslo, kam se má vrátit první číslo
/// @param number2 ukazatel na číslo, kam se má vrátit druhé číslo, pokud
//     je NULL, neprovádí se nic
/// @param msg zpráva z níž mají být čísla získána
void recive_uint32(char * msg, uint32_t * number1, uint32_t * number2){
    12d4:	cf 93       	push	r28
    12d6:	df 93       	push	r29
  uint32_t * uint32;


  uint32 = (uint32_t *) (msg);
    12d8:	fc 01       	movw	r30, r24
  *number1 = *uint32;
    12da:	80 81       	ld	r24, Z
    12dc:	91 81       	ldd	r25, Z+1	; 0x01
    12de:	a2 81       	ldd	r26, Z+2	; 0x02
    12e0:	b3 81       	ldd	r27, Z+3	; 0x03
    12e2:	eb 01       	movw	r28, r22
    12e4:	88 83       	st	Y, r24
    12e6:	99 83       	std	Y+1, r25	; 0x01
    12e8:	aa 83       	std	Y+2, r26	; 0x02
    12ea:	bb 83       	std	Y+3, r27	; 0x03

  uint32 = (uint32_t *) (msg+4);
  *number2 = *uint32;
    12ec:	84 81       	ldd	r24, Z+4	; 0x04
    12ee:	95 81       	ldd	r25, Z+5	; 0x05
    12f0:	a6 81       	ldd	r26, Z+6	; 0x06
    12f2:	b7 81       	ldd	r27, Z+7	; 0x07
    12f4:	fa 01       	movw	r30, r20
    12f6:	80 83       	st	Z, r24
    12f8:	91 83       	std	Z+1, r25	; 0x01
    12fa:	a2 83       	std	Z+2, r26	; 0x02
    12fc:	b3 83       	std	Z+3, r27	; 0x03

}
    12fe:	df 91       	pop	r29
    1300:	cf 91       	pop	r28
    1302:	08 95       	ret

00001304 <inc_lower_buffer_oldest>:
 * přerušení, novému testování a následně dvojitému zvýšení čítače. Toto je nyní
 * ošetřeno.
 */
void inc_lower_buffer_oldest(void) {
  static char instance_counter = 0;
  instance_counter++;
    1304:	40 91 82 01 	lds	r20, 0x0182
    1308:	4f 5f       	subi	r20, 0xFF	; 255
    130a:	40 93 82 01 	sts	0x0182, r20


  // Nastavení hodnoty ukazatele na 2. nejstarší přijatý byte
  //if (lower_buffer_oldest < (SIZE_OF_LOWER_BUFFER - 1)) {

  if (lower_buffer_oldest < (SIZE_OF_LOWER_BUFFER - instance_counter)) {
    130e:	20 91 77 01 	lds	r18, 0x0177
    1312:	30 91 78 01 	lds	r19, 0x0178
    1316:	8a ef       	ldi	r24, 0xFA	; 250
    1318:	90 e0       	ldi	r25, 0x00	; 0
    131a:	84 1b       	sub	r24, r20
    131c:	91 09       	sbc	r25, r1
    131e:	28 17       	cp	r18, r24
    1320:	39 07       	cpc	r19, r25
    1322:	1c f4       	brge	.+6      	; 0x132a <inc_lower_buffer_oldest+0x26>
    // problém je pokud dojde k přerušení právě ZDE
    lower_buffer_oldest++;
    1324:	2f 5f       	subi	r18, 0xFF	; 255
    1326:	3f 4f       	sbci	r19, 0xFF	; 255
    1328:	02 c0       	rjmp	.+4      	; 0x132e <inc_lower_buffer_oldest+0x2a>
  } else {
    // pokud jsme na konci paměti bufferu, jdeme na začátek
    //lower_buffer_oldest = 0;
    lower_buffer_oldest = lower_buffer_oldest - (SIZE_OF_LOWER_BUFFER - 1);
    132a:	29 5f       	subi	r18, 0xF9	; 249
    132c:	30 40       	sbci	r19, 0x00	; 0
    132e:	30 93 78 01 	sts	0x0178, r19
    1332:	20 93 77 01 	sts	0x0177, r18


  // toto je jen informační error, situace je ošetřena v kódu výše
  // k chybě dojde jen při naplnění bufferu, bufferu na konci a současném volání
  //funkce z programu i přerušení
  if (instance_counter > 1) {
    1336:	42 30       	cpi	r20, 0x02	; 2
    1338:	18 f0       	brcs	.+6      	; 0x1340 <inc_lower_buffer_oldest+0x3c>
    new_error(ERRN_RECIVE_END_OF_BUFFER_BUG);
    133a:	89 e6       	ldi	r24, 0x69	; 105
    133c:	0e 94 33 18 	call	0x3066	; 0x3066 <new_error>
  }

  instance_counter--;
    1340:	80 91 82 01 	lds	r24, 0x0182
    1344:	81 50       	subi	r24, 0x01	; 1
    1346:	80 93 82 01 	sts	0x0182, r24
}
    134a:	08 95       	ret

0000134c <getc_lb>:

/**
 * Funkce načítá z lower_buffer
 * @return vrací nejstarí byte z bufferu, pokud je buffer prázdný, vrací -1
 */
int getc_lb(void) {
    134c:	cf 93       	push	r28
    134e:	df 93       	push	r29
  int out;
  
  // test, zda je prázdný buffer
  if (lower_buffer_oldest == lower_buffer_newest) {
    1350:	e0 91 77 01 	lds	r30, 0x0177
    1354:	f0 91 78 01 	lds	r31, 0x0178
    1358:	80 91 75 01 	lds	r24, 0x0175
    135c:	90 91 76 01 	lds	r25, 0x0176
    1360:	e8 17       	cp	r30, r24
    1362:	f9 07       	cpc	r31, r25
    1364:	19 f4       	brne	.+6      	; 0x136c <getc_lb+0x20>
    1366:	cf ef       	ldi	r28, 0xFF	; 255
    1368:	df ef       	ldi	r29, 0xFF	; 255
    136a:	07 c0       	rjmp	.+14     	; 0x137a <getc_lb+0x2e>

    out = -1;
  } else {
    // neprázdný buffer

    out = (int) lower_buffer[(int) lower_buffer_oldest];
    136c:	e1 50       	subi	r30, 0x01	; 1
    136e:	fe 4f       	sbci	r31, 0xFE	; 254
    1370:	80 81       	ld	r24, Z
    1372:	c8 2f       	mov	r28, r24
    1374:	d0 e0       	ldi	r29, 0x00	; 0

    inc_lower_buffer_oldest();
    1376:	0e 94 82 09 	call	0x1304	; 0x1304 <inc_lower_buffer_oldest>

  }

  
  return out;
}
    137a:	ce 01       	movw	r24, r28
    137c:	df 91       	pop	r29
    137e:	cf 91       	pop	r28
    1380:	08 95       	ret

00001382 <into_lower_buffer>:
 * jeho naplnění, je vyhlášen error a je zapomenut nejstarší byte.
 * 
 */
void into_lower_buffer(char recived_byte) {

  lower_buffer[(int)lower_buffer_newest] = recived_byte;
    1382:	20 91 75 01 	lds	r18, 0x0175
    1386:	30 91 76 01 	lds	r19, 0x0176
    138a:	f9 01       	movw	r30, r18
    138c:	e1 50       	subi	r30, 0x01	; 1
    138e:	fe 4f       	sbci	r31, 0xFE	; 254
    1390:	80 83       	st	Z, r24

  // Nastavení hodnoty ukazatele za nejnovější přijatý buffer.
  if (lower_buffer_newest < (SIZE_OF_LOWER_BUFFER-1)) {
    1392:	29 3f       	cpi	r18, 0xF9	; 249
    1394:	31 05       	cpc	r19, r1
    1396:	3c f4       	brge	.+14     	; 0x13a6 <into_lower_buffer+0x24>
    lower_buffer_newest++;
    1398:	2f 5f       	subi	r18, 0xFF	; 255
    139a:	3f 4f       	sbci	r19, 0xFF	; 255
    139c:	30 93 76 01 	sts	0x0176, r19
    13a0:	20 93 75 01 	sts	0x0175, r18
    13a4:	04 c0       	rjmp	.+8      	; 0x13ae <into_lower_buffer+0x2c>
  } else {
    // pokud jsme na konci paměti bufferu, jdeme na začátek
    lower_buffer_newest = 0;
    13a6:	10 92 76 01 	sts	0x0176, r1
    13aa:	10 92 75 01 	sts	0x0175, r1
  }

  // Došlo-li k dostižení ukazatele na nejstarší byte, je zásobník přeplněn.
  if (lower_buffer_newest == lower_buffer_oldest){
    13ae:	20 91 75 01 	lds	r18, 0x0175
    13b2:	30 91 76 01 	lds	r19, 0x0176
    13b6:	80 91 77 01 	lds	r24, 0x0177
    13ba:	90 91 78 01 	lds	r25, 0x0178
    13be:	28 17       	cp	r18, r24
    13c0:	39 07       	cpc	r19, r25
    13c2:	29 f4       	brne	.+10     	; 0x13ce <into_lower_buffer+0x4c>
    // zásobník přeplněn -> dojde k zapomenutí nejstaršího byte


    inc_lower_buffer_oldest();
    13c4:	0e 94 82 09 	call	0x1304	; 0x1304 <inc_lower_buffer_oldest>


    
    new_error(ERRN_RECIVE_BUFFER_FULL);
    13c8:	88 e6       	ldi	r24, 0x68	; 104
    13ca:	0e 94 33 18 	call	0x3066	; 0x3066 <new_error>
    13ce:	08 95       	ret

000013d0 <__vector_13>:
  

}

/// Tahle část se spouští vždy když přijmeme nějaký byte po sériovém kanále.
SIGNAL(SIG_UART_RECV){
    13d0:	1f 92       	push	r1
    13d2:	0f 92       	push	r0
    13d4:	0f b6       	in	r0, 0x3f	; 63
    13d6:	0f 92       	push	r0
    13d8:	11 24       	eor	r1, r1
    13da:	2f 93       	push	r18
    13dc:	3f 93       	push	r19
    13de:	4f 93       	push	r20
    13e0:	5f 93       	push	r21
    13e2:	6f 93       	push	r22
    13e4:	7f 93       	push	r23
    13e6:	8f 93       	push	r24
    13e8:	9f 93       	push	r25
    13ea:	af 93       	push	r26
    13ec:	bf 93       	push	r27
    13ee:	ef 93       	push	r30
    13f0:	ff 93       	push	r31

  if (kolikrat_spusteno > 1){
    new_error(ERRN_RECIVER_OVERLOADED);
  }
  else{*/
    into_lower_buffer(UDR);
    13f2:	8c b1       	in	r24, 0x0c	; 12
    13f4:	0e 94 c1 09 	call	0x1382	; 0x1382 <into_lower_buffer>
  /*
  }
  kolikrat_spusteno--;
  */
  
}
    13f8:	ff 91       	pop	r31
    13fa:	ef 91       	pop	r30
    13fc:	bf 91       	pop	r27
    13fe:	af 91       	pop	r26
    1400:	9f 91       	pop	r25
    1402:	8f 91       	pop	r24
    1404:	7f 91       	pop	r23
    1406:	6f 91       	pop	r22
    1408:	5f 91       	pop	r21
    140a:	4f 91       	pop	r20
    140c:	3f 91       	pop	r19
    140e:	2f 91       	pop	r18
    1410:	0f 90       	pop	r0
    1412:	0f be       	out	0x3f, r0	; 63
    1414:	0f 90       	pop	r0
    1416:	1f 90       	pop	r1
    1418:	18 95       	reti

0000141a <process_recived_msg>:
  }
  
}

/// V těle této funkce je řešeno zpracování přijaté zprávy.
void process_recived_msg(){
    141a:	20 e0       	ldi	r18, 0x00	; 0
    141c:	30 e0       	ldi	r19, 0x00	; 0
  int i = 0;
  
  //zkopirovani zpravy a tim uvoneni prijimaciho bufferu
  for (i = 0; i < LenOfMsg; i++){
    recived_msg[i] = usart_recv_buff[i + 1];
    141e:	2f 5f       	subi	r18, 0xFF	; 255
    1420:	3f 4f       	sbci	r19, 0xFF	; 255
    1422:	f9 01       	movw	r30, r18
    1424:	e8 50       	subi	r30, 0x08	; 8
    1426:	fd 4f       	sbci	r31, 0xFD	; 253
    1428:	d9 01       	movw	r26, r18
    142a:	ac 5f       	subi	r26, 0xFC	; 252
    142c:	bc 4f       	sbci	r27, 0xFC	; 252
    142e:	8c 91       	ld	r24, X
    1430:	80 83       	st	Z, r24
/// V těle této funkce je řešeno zpracování přijaté zprávy.
void process_recived_msg(){
  int i = 0;
  
  //zkopirovani zpravy a tim uvoneni prijimaciho bufferu
  for (i = 0; i < LenOfMsg; i++){
    1432:	2b 30       	cpi	r18, 0x0B	; 11
    1434:	31 05       	cpc	r19, r1
    1436:	99 f7       	brne	.-26     	; 0x141e <process_recived_msg+0x4>
    recived_msg[i] = usart_recv_buff[i + 1];
  }
  recv_msg(recived_msg);
    1438:	89 ef       	ldi	r24, 0xF9	; 249
    143a:	92 e0       	ldi	r25, 0x02	; 2
    143c:	0e 94 c8 0c 	call	0x1990	; 0x1990 <recv_msg>
}
    1440:	08 95       	ret

00001442 <new_msg>:


/// Vstupem do teto funkce je ukazatel na zpravu
/// pokud se ukazatel uz v seznamu nenachazi, tak je zarazen na konec seznamu.
/// Prostor musí být správně naalokovaný. Po odeslání zprávy je paměť uvolněna.
void new_msg (char *msg){
    1442:	0f 93       	push	r16
    1444:	1f 93       	push	r17
    1446:	cf 93       	push	r28
    1448:	df 93       	push	r29
    144a:	8c 01       	movw	r16, r24
   wtch_dbg_info();
    144c:	82 e8       	ldi	r24, 0x82	; 130
    144e:	90 e0       	ldi	r25, 0x00	; 0
    1450:	90 93 fe 00 	sts	0x00FE, r25
    1454:	80 93 fd 00 	sts	0x00FD, r24
    1458:	8a e0       	ldi	r24, 0x0A	; 10
    145a:	92 e0       	ldi	r25, 0x02	; 2
    145c:	90 93 00 01 	sts	0x0100, r25
    1460:	80 93 ff 00 	sts	0x00FF, r24
  //if (prepinani == 0){
  if (1){

  // pokud zadna zprava v seznamu neni, tak ji strc na nulty misto
  // a nastartuj citac a zapni preruseni od datovaho bufferu.
    if (msg_buffer_counter == -1){
    1464:	40 91 8e 00 	lds	r20, 0x008E
    1468:	50 91 8f 00 	lds	r21, 0x008F
    146c:	8f ef       	ldi	r24, 0xFF	; 255
    146e:	4f 3f       	cpi	r20, 0xFF	; 255
    1470:	58 07       	cpc	r21, r24
    1472:	51 f4       	brne	.+20     	; 0x1488 <new_msg+0x46>
      
      msg_buffer_counter = 0;
    1474:	10 92 8f 00 	sts	0x008F, r1
    1478:	10 92 8e 00 	sts	0x008E, r1

      msg_buffer[msg_buffer_counter] = msg;
    147c:	10 93 f6 01 	sts	0x01F6, r17
    1480:	00 93 f5 01 	sts	0x01F5, r16
/*      if (msg != NULL){
        char mystr[40];
        sprintf(mystr, "msg = %x %x %x %x", (unsigned int)msg[0],(unsigned int)msg[1],(unsigned int)msg[2],(unsigned int)msg[3]);
        printnt(mystr);
      }*/
      UCSRB = UCSRB | (1 << UDRIE);
    1484:	55 9a       	sbi	0x0a, 5	; 10
    1486:	3a c0       	rjmp	.+116    	; 0x14fc <new_msg+0xba>
      int i = 0;

      // testujeme, zda uz zprava s tímto kódem neni v seznamu
      // pokud je, nadradíme starší tou novější
      for (i = 0; i < LenOfMsgBuffer; i++) {
        if (msg_buffer[i][0] == msg[0]) {
    1488:	f8 01       	movw	r30, r16
    148a:	90 81       	ld	r25, Z
    148c:	e5 ef       	ldi	r30, 0xF5	; 245
    148e:	f1 e0       	ldi	r31, 0x01	; 1
    1490:	c0 e0       	ldi	r28, 0x00	; 0
    1492:	d0 e0       	ldi	r29, 0x00	; 0
    1494:	a0 81       	ld	r26, Z
    1496:	b1 81       	ldd	r27, Z+1	; 0x01
    1498:	8c 91       	ld	r24, X
    149a:	89 17       	cp	r24, r25
    149c:	51 f4       	brne	.+20     	; 0x14b2 <new_msg+0x70>
          mfree((void *) msg_buffer[i]);
    149e:	cd 01       	movw	r24, r26
    14a0:	0e 94 98 1d 	call	0x3b30	; 0x3b30 <mfree>
          msg_buffer[i] = msg;
    14a4:	cc 0f       	add	r28, r28
    14a6:	dd 1f       	adc	r29, r29
    14a8:	cb 50       	subi	r28, 0x0B	; 11
    14aa:	de 4f       	sbci	r29, 0xFE	; 254
    14ac:	19 83       	std	Y+1, r17	; 0x01
    14ae:	08 83       	st	Y, r16
    14b0:	25 c0       	rjmp	.+74     	; 0x14fc <new_msg+0xba>
    else{
      int i = 0;

      // testujeme, zda uz zprava s tímto kódem neni v seznamu
      // pokud je, nadradíme starší tou novější
      for (i = 0; i < LenOfMsgBuffer; i++) {
    14b2:	21 96       	adiw	r28, 0x01	; 1
    14b4:	32 96       	adiw	r30, 0x02	; 2
    14b6:	c5 30       	cpi	r28, 0x05	; 5
    14b8:	d1 05       	cpc	r29, r1
    14ba:	61 f7       	brne	.-40     	; 0x1494 <new_msg+0x52>
          return;
        }
      }
      
      // nastavime pocitadlo na prvek za aktualnim prvkem
      if (msg_buffer_counter != (LenOfMsgBuffer - 1))
    14bc:	44 30       	cpi	r20, 0x04	; 4
    14be:	51 05       	cpc	r21, r1
    14c0:	71 f0       	breq	.+28     	; 0x14de <new_msg+0x9c>
        i = msg_buffer_counter + 1;
    14c2:	9a 01       	movw	r18, r20
    14c4:	0f c0       	rjmp	.+30     	; 0x14e4 <new_msg+0xa2>
      else
        i = 0;
    
      while(i != msg_buffer_counter){
        // kdyz najdeme ukazatel NULL, tak vyskocime z cyklu
        if (msg_buffer[i] == NULL)
    14c6:	f9 01       	movw	r30, r18
    14c8:	ee 0f       	add	r30, r30
    14ca:	ff 1f       	adc	r31, r31
    14cc:	eb 50       	subi	r30, 0x0B	; 11
    14ce:	fe 4f       	sbci	r31, 0xFE	; 254
    14d0:	80 81       	ld	r24, Z
    14d2:	91 81       	ldd	r25, Z+1	; 0x01
    14d4:	89 2b       	or	r24, r25
    14d6:	61 f0       	breq	.+24     	; 0x14f0 <new_msg+0xae>
          break;

        // jesli nejsme na konci, inkrementujem, jinak na nulu.
        if (i != (LenOfMsgBuffer - 1)) 
    14d8:	24 30       	cpi	r18, 0x04	; 4
    14da:	31 05       	cpc	r19, r1
    14dc:	19 f4       	brne	.+6      	; 0x14e4 <new_msg+0xa2>
    14de:	20 e0       	ldi	r18, 0x00	; 0
    14e0:	30 e0       	ldi	r19, 0x00	; 0
    14e2:	02 c0       	rjmp	.+4      	; 0x14e8 <new_msg+0xa6>
          i++;
    14e4:	2f 5f       	subi	r18, 0xFF	; 255
    14e6:	3f 4f       	sbci	r19, 0xFF	; 255
      if (msg_buffer_counter != (LenOfMsgBuffer - 1))
        i = msg_buffer_counter + 1;
      else
        i = 0;
    
      while(i != msg_buffer_counter){
    14e8:	24 17       	cp	r18, r20
    14ea:	35 07       	cpc	r19, r21
    14ec:	61 f7       	brne	.-40     	; 0x14c6 <new_msg+0x84>
    14ee:	03 c0       	rjmp	.+6      	; 0x14f6 <new_msg+0xb4>
        else 
          i = 0;
      }
      
      if (i != msg_buffer_counter){
        msg_buffer[i] = msg;
    14f0:	11 83       	std	Z+1, r17	; 0x01
    14f2:	00 83       	st	Z, r16
    14f4:	03 c0       	rjmp	.+6      	; 0x14fc <new_msg+0xba>
      }
      else{
        new_error(96);
    14f6:	80 e6       	ldi	r24, 0x60	; 96
    14f8:	0e 94 33 18 	call	0x3066	; 0x3066 <new_error>
        //psat error preplneni zasobniku zprav
      }
    
    }
  }
}
    14fc:	df 91       	pop	r29
    14fe:	cf 91       	pop	r28
    1500:	1f 91       	pop	r17
    1502:	0f 91       	pop	r16
    1504:	08 95       	ret

00001506 <send_uint32>:


/**
 * Funkce odešle jedno až dvě čísla uint16 po sériové lince
 */
void send_uint32(char msgn, uint32_t number1, uint32_t number2){
    1506:	7f 92       	push	r7
    1508:	8f 92       	push	r8
    150a:	9f 92       	push	r9
    150c:	af 92       	push	r10
    150e:	bf 92       	push	r11
    1510:	cf 92       	push	r12
    1512:	df 92       	push	r13
    1514:	ef 92       	push	r14
    1516:	ff 92       	push	r15
    1518:	0f 93       	push	r16
    151a:	1f 93       	push	r17
    151c:	78 2e       	mov	r7, r24
    151e:	6a 01       	movw	r12, r20
    1520:	7b 01       	movw	r14, r22
    1522:	48 01       	movw	r8, r16
    1524:	59 01       	movw	r10, r18

  char * msg;

  uint32_t * uint32;

   wtch_dbg_info();
    1526:	82 e8       	ldi	r24, 0x82	; 130
    1528:	90 e0       	ldi	r25, 0x00	; 0
    152a:	90 93 fe 00 	sts	0x00FE, r25
    152e:	80 93 fd 00 	sts	0x00FD, r24
    1532:	84 e3       	ldi	r24, 0x34	; 52
    1534:	93 e0       	ldi	r25, 0x03	; 3
    1536:	90 93 00 01 	sts	0x0100, r25
    153a:	80 93 ff 00 	sts	0x00FF, r24
//  unsigned char num;

  // alokace místa pro novou zprávu, nastavení vlajky zprávy
  msg =(void*) mmalloc (DATASIZE);
    153e:	8a e0       	ldi	r24, 0x0A	; 10
    1540:	90 e0       	ldi	r25, 0x00	; 0
    1542:	0e 94 a4 1d 	call	0x3b48	; 0x3b48 <mmalloc>
    1546:	fc 01       	movw	r30, r24
  msg[0] = msgn;
    1548:	70 82       	st	Z, r7


  // zde se vytvoří ukazatel na první datový byte zprávy, řekne se že je to
  // uint32 a přiřadí se do něj hodnota
  uint32 = ((uint32_t *)&(msg[1]));
  *uint32 = number1;
    154a:	c1 82       	std	Z+1, r12	; 0x01
    154c:	d2 82       	std	Z+2, r13	; 0x02
    154e:	e3 82       	std	Z+3, r14	; 0x03
    1550:	f4 82       	std	Z+4, r15	; 0x04

  uint32 = ((uint32_t *)&(msg[5]));
  *uint32 = number2;
    1552:	85 82       	std	Z+5, r8	; 0x05
    1554:	96 82       	std	Z+6, r9	; 0x06
    1556:	a7 82       	std	Z+7, r10	; 0x07
    1558:	b0 86       	std	Z+8, r11	; 0x08
    msg[7] = number2 % 256;
    number2 = number2 / 256;
    msg[8] = number2 % 256;
*/

  new_msg(msg);
    155a:	0e 94 21 0a 	call	0x1442	; 0x1442 <new_msg>
  
}
    155e:	1f 91       	pop	r17
    1560:	0f 91       	pop	r16
    1562:	ff 90       	pop	r15
    1564:	ef 90       	pop	r14
    1566:	df 90       	pop	r13
    1568:	cf 90       	pop	r12
    156a:	bf 90       	pop	r11
    156c:	af 90       	pop	r10
    156e:	9f 90       	pop	r9
    1570:	8f 90       	pop	r8
    1572:	7f 90       	pop	r7
    1574:	08 95       	ret

00001576 <serial_msg_ack_timer>:
/// Funkce zobsluhuje čítač doby čekání na odezvu zprávy a
/// čítač počtu pokusů o odeslání. Na odpověď na každou potvrzovanou zprávu se čeká
/// MAX_MSG_ACK_DELAY cyklů. Po uplynutí této doby je zpráva zopakována. Po
/// MAX_MSG_ACK_REPEATS - tém opakování je vytvořen error.
void serial_msg_ack_timer(void){
  if (p_ack_fcn != NULL){
    1576:	80 91 7a 01 	lds	r24, 0x017A
    157a:	90 91 7b 01 	lds	r25, 0x017B
    157e:	89 2b       	or	r24, r25
    1580:	a9 f1       	breq	.+106    	; 0x15ec <serial_msg_ack_timer+0x76>
    msg_ack_timer++;
    1582:	80 91 7c 01 	lds	r24, 0x017C
    1586:	90 91 7d 01 	lds	r25, 0x017D
    158a:	01 96       	adiw	r24, 0x01	; 1
    158c:	90 93 7d 01 	sts	0x017D, r25
    1590:	80 93 7c 01 	sts	0x017C, r24
    if (msg_ack_timer > MAX_MSG_ACK_DELAY){
    1594:	89 58       	subi	r24, 0x89	; 137
    1596:	93 41       	sbci	r25, 0x13	; 19
    1598:	48 f1       	brcs	.+82     	; 0x15ec <serial_msg_ack_timer+0x76>
      if (msg_ack_repeats > 0){
    159a:	80 91 7e 01 	lds	r24, 0x017E
    159e:	88 23       	and	r24, r24
    15a0:	19 f1       	breq	.+70     	; 0x15e8 <serial_msg_ack_timer+0x72>
        char * opakovana_zprava;
        int i = 0;
        
        opakovana_zprava = (char *) mmalloc(LenOfMsg);
    15a2:	8b e0       	ldi	r24, 0x0B	; 11
    15a4:	90 e0       	ldi	r25, 0x00	; 0
    15a6:	0e 94 a4 1d 	call	0x3b48	; 0x3b48 <mmalloc>
    15aa:	ac 01       	movw	r20, r24
    15ac:	68 2f       	mov	r22, r24
    15ae:	95 2f       	mov	r25, r21
    15b0:	20 e0       	ldi	r18, 0x00	; 0
    15b2:	30 e0       	ldi	r19, 0x00	; 0
        for (i = 0; i < LenOfMsg; i++){
          opakovana_zprava[i] = last_msg_ack[i];
    15b4:	fa 01       	movw	r30, r20
    15b6:	e2 0f       	add	r30, r18
    15b8:	f3 1f       	adc	r31, r19
    15ba:	d9 01       	movw	r26, r18
    15bc:	ad 57       	subi	r26, 0x7D	; 125
    15be:	be 4f       	sbci	r27, 0xFE	; 254
    15c0:	8c 91       	ld	r24, X
    15c2:	80 83       	st	Z, r24
      if (msg_ack_repeats > 0){
        char * opakovana_zprava;
        int i = 0;
        
        opakovana_zprava = (char *) mmalloc(LenOfMsg);
        for (i = 0; i < LenOfMsg; i++){
    15c4:	2f 5f       	subi	r18, 0xFF	; 255
    15c6:	3f 4f       	sbci	r19, 0xFF	; 255
    15c8:	2b 30       	cpi	r18, 0x0B	; 11
    15ca:	31 05       	cpc	r19, r1
    15cc:	99 f7       	brne	.-26     	; 0x15b4 <serial_msg_ack_timer+0x3e>
          opakovana_zprava[i] = last_msg_ack[i];
        }
        
        new_msg(opakovana_zprava);
    15ce:	86 2f       	mov	r24, r22
    15d0:	0e 94 21 0a 	call	0x1442	; 0x1442 <new_msg>
        msg_ack_repeats--;
    15d4:	80 91 7e 01 	lds	r24, 0x017E
    15d8:	81 50       	subi	r24, 0x01	; 1
    15da:	80 93 7e 01 	sts	0x017E, r24
        msg_ack_timer = 0;
    15de:	10 92 7d 01 	sts	0x017D, r1
    15e2:	10 92 7c 01 	sts	0x017C, r1
    15e6:	08 95       	ret
      }
      else{
        msg_nack_fcn();
    15e8:	0e 94 51 09 	call	0x12a2	; 0x12a2 <msg_nack_fcn>
    15ec:	08 95       	ret

000015ee <new_ack_msg>:
 * dochází k uvolnění paměti po řetězci msg, při dalším odesílání se
 * však odesílají data opět z ukazatele msg, která jsou však již
 * uvolněná. 
 * 
 * */
void new_ack_msg(char * msg, unsigned char repeats, void (*p_fcn)(char*s),void (*p_fcn_nresponse)(void)){
    15ee:	df 92       	push	r13
    15f0:	ef 92       	push	r14
    15f2:	ff 92       	push	r15
    15f4:	0f 93       	push	r16
    15f6:	1f 93       	push	r17
    15f8:	cf 93       	push	r28
    15fa:	df 93       	push	r29
    15fc:	ec 01       	movw	r28, r24
    15fe:	d6 2e       	mov	r13, r22
    1600:	8a 01       	movw	r16, r20
    1602:	79 01       	movw	r14, r18
  int i = 0;

  assert(msg != NULL);
    1604:	00 97       	sbiw	r24, 0x00	; 0
    1606:	31 f4       	brne	.+12     	; 0x1614 <new_ack_msg+0x26>
    1608:	82 e8       	ldi	r24, 0x82	; 130
    160a:	90 e0       	ldi	r25, 0x00	; 0
    160c:	63 ec       	ldi	r22, 0xC3	; 195
    160e:	72 e0       	ldi	r23, 0x02	; 2
    1610:	0e 94 a3 16 	call	0x2d46	; 0x2d46 <err_assert>
  assert(repeats > 0);
    1614:	dd 20       	and	r13, r13
    1616:	31 f4       	brne	.+12     	; 0x1624 <new_ack_msg+0x36>
    1618:	82 e8       	ldi	r24, 0x82	; 130
    161a:	90 e0       	ldi	r25, 0x00	; 0
    161c:	64 ec       	ldi	r22, 0xC4	; 196
    161e:	72 e0       	ldi	r23, 0x02	; 2
    1620:	0e 94 a3 16 	call	0x2d46	; 0x2d46 <err_assert>
    1624:	20 e0       	ldi	r18, 0x00	; 0
    1626:	30 e0       	ldi	r19, 0x00	; 0
  for(i =0; i < LenOfMsg; i++){
    last_msg_ack[i] = msg[i];
    1628:	f9 01       	movw	r30, r18
    162a:	ed 57       	subi	r30, 0x7D	; 125
    162c:	fe 4f       	sbci	r31, 0xFE	; 254
    162e:	de 01       	movw	r26, r28
    1630:	a2 0f       	add	r26, r18
    1632:	b3 1f       	adc	r27, r19
    1634:	8c 91       	ld	r24, X
    1636:	80 83       	st	Z, r24
void new_ack_msg(char * msg, unsigned char repeats, void (*p_fcn)(char*s),void (*p_fcn_nresponse)(void)){
  int i = 0;

  assert(msg != NULL);
  assert(repeats > 0);
  for(i =0; i < LenOfMsg; i++){
    1638:	2f 5f       	subi	r18, 0xFF	; 255
    163a:	3f 4f       	sbci	r19, 0xFF	; 255
    163c:	2b 30       	cpi	r18, 0x0B	; 11
    163e:	31 05       	cpc	r19, r1
    1640:	99 f7       	brne	.-26     	; 0x1628 <new_ack_msg+0x3a>
    last_msg_ack[i] = msg[i];
  }
  msg_ack_timer = 0;
    1642:	10 92 7d 01 	sts	0x017D, r1
    1646:	10 92 7c 01 	sts	0x017C, r1
  msg_ack_repeats = repeats;
    164a:	d0 92 7e 01 	sts	0x017E, r13
  p_ack_fcn = p_fcn;
    164e:	10 93 7b 01 	sts	0x017B, r17
    1652:	00 93 7a 01 	sts	0x017A, r16
  p_nack_fcn = p_fcn_nresponse;
    1656:	f0 92 80 01 	sts	0x0180, r15
    165a:	e0 92 7f 01 	sts	0x017F, r14
  assert(p_ack_fcn != NULL);
    165e:	01 2b       	or	r16, r17
    1660:	31 f4       	brne	.+12     	; 0x166e <new_ack_msg+0x80>
    1662:	82 e8       	ldi	r24, 0x82	; 130
    1664:	90 e0       	ldi	r25, 0x00	; 0
    1666:	6c ec       	ldi	r22, 0xCC	; 204
    1668:	72 e0       	ldi	r23, 0x02	; 2
    166a:	0e 94 a3 16 	call	0x2d46	; 0x2d46 <err_assert>
  assert(p_nack_fcn != NULL);
    166e:	80 91 7f 01 	lds	r24, 0x017F
    1672:	90 91 80 01 	lds	r25, 0x0180
    1676:	89 2b       	or	r24, r25
    1678:	31 f4       	brne	.+12     	; 0x1686 <new_ack_msg+0x98>
    167a:	82 e8       	ldi	r24, 0x82	; 130
    167c:	90 e0       	ldi	r25, 0x00	; 0
    167e:	6d ec       	ldi	r22, 0xCD	; 205
    1680:	72 e0       	ldi	r23, 0x02	; 2
    1682:	0e 94 a3 16 	call	0x2d46	; 0x2d46 <err_assert>
  new_msg(msg);
    1686:	ce 01       	movw	r24, r28
    1688:	0e 94 21 0a 	call	0x1442	; 0x1442 <new_msg>
/*  */
}
    168c:	df 91       	pop	r29
    168e:	cf 91       	pop	r28
    1690:	1f 91       	pop	r17
    1692:	0f 91       	pop	r16
    1694:	ff 90       	pop	r15
    1696:	ef 90       	pop	r14
    1698:	df 90       	pop	r13
    169a:	08 95       	ret

0000169c <new_msg_P>:
 * Funkce naalokuje paměť pro uložení řetězce do SRAM, řetězec tam zkopíruje
 * a zprávu odešle
 * @param s_p Ukazatel do programové paměti.
 * @return Ukazatel v paměti SRAM, kam je zkopírován řetězec z \a s_p
 **/
void new_msg_P( PGM_P s_p){
    169c:	0f 93       	push	r16
    169e:	1f 93       	push	r17
    16a0:	cf 93       	push	r28
    16a2:	df 93       	push	r29
    16a4:	8c 01       	movw	r16, r24
  char * p_pom;

  p_pom = (char *) mmalloc(LenOfMsg);
    16a6:	8b e0       	ldi	r24, 0x0B	; 11
    16a8:	90 e0       	ldi	r25, 0x00	; 0
    16aa:	0e 94 a4 1d 	call	0x3b48	; 0x3b48 <mmalloc>
    16ae:	ec 01       	movw	r28, r24
  if(p_pom == NULL){
    16b0:	00 97       	sbiw	r24, 0x00	; 0
    16b2:	21 f4       	brne	.+8      	; 0x16bc <new_msg_P+0x20>
    new_error(88); //Došla paměť
    16b4:	88 e5       	ldi	r24, 0x58	; 88
    16b6:	0e 94 33 18 	call	0x3066	; 0x3066 <new_error>
    16ba:	08 c0       	rjmp	.+16     	; 0x16cc <new_msg_P+0x30>
    return ;
  }
  else{
    memcpy_P(p_pom, s_p,LenOfMsg);
    16bc:	b8 01       	movw	r22, r16
    16be:	4b e0       	ldi	r20, 0x0B	; 11
    16c0:	50 e0       	ldi	r21, 0x00	; 0
    16c2:	0e 94 c1 1e 	call	0x3d82	; 0x3d82 <memcpy_P>
    new_msg(p_pom);
    16c6:	ce 01       	movw	r24, r28
    16c8:	0e 94 21 0a 	call	0x1442	; 0x1442 <new_msg>
  }

  return;
}
    16cc:	df 91       	pop	r29
    16ce:	cf 91       	pop	r28
    16d0:	1f 91       	pop	r17
    16d2:	0f 91       	pop	r16
    16d4:	08 95       	ret

000016d6 <to_transmitt_buffer>:

/// Tato funkce obaluje zpravu kodem pouzivanym pro prenos po seriovem kanale.
/// Zde je provedeno uvolnění paměti zprávy. Je tak učiněno po nakopírování
/// zprávy do odesílacího bufferu.

void to_transmitt_buffer(char *msg) {
    16d6:	cf 93       	push	r28
    16d8:	df 93       	push	r29
    16da:	ac 01       	movw	r20, r24
  int i = 0;

  wtch_dbg_info();
    16dc:	82 e8       	ldi	r24, 0x82	; 130
    16de:	90 e0       	ldi	r25, 0x00	; 0
    16e0:	90 93 fe 00 	sts	0x00FE, r25
    16e4:	80 93 fd 00 	sts	0x00FD, r24
    16e8:	88 ed       	ldi	r24, 0xD8	; 216
    16ea:	91 e0       	ldi	r25, 0x01	; 1
    16ec:	90 93 00 01 	sts	0x0100, r25
    16f0:	80 93 ff 00 	sts	0x00FF, r24
  usart_trans_buff[0] = 255;
    16f4:	8f ef       	ldi	r24, 0xFF	; 255
    16f6:	80 93 e3 01 	sts	0x01E3, r24
    16fa:	ea 01       	movw	r28, r20
    16fc:	e4 ee       	ldi	r30, 0xE4	; 228
    16fe:	f1 e0       	ldi	r31, 0x01	; 1
    1700:	da 01       	movw	r26, r20

  for (i = 0; i < LenOfMsg; i++) {
    usart_trans_buff[i + 1] = msg[i];
    1702:	8d 91       	ld	r24, X+
    1704:	81 93       	st	Z+, r24
  int i = 0;

  wtch_dbg_info();
  usart_trans_buff[0] = 255;

  for (i = 0; i < LenOfMsg; i++) {
    1706:	81 e0       	ldi	r24, 0x01	; 1
    1708:	ef 3e       	cpi	r30, 0xEF	; 239
    170a:	f8 07       	cpc	r31, r24
    170c:	d1 f7       	brne	.-12     	; 0x1702 <to_transmitt_buffer+0x2c>
    usart_trans_buff[i + 1] = msg[i];
  }
  usart_trans_buff[LenOfMsg + 1] = usart_trans_buff[0] ^ msg[0];
    170e:	da 01       	movw	r26, r20
    1710:	8c 91       	ld	r24, X
    1712:	90 91 e3 01 	lds	r25, 0x01E3
    1716:	89 27       	eor	r24, r25
    1718:	80 83       	st	Z, r24
    171a:	20 e0       	ldi	r18, 0x00	; 0
    171c:	30 e0       	ldi	r19, 0x00	; 0

  for (i = 0; i < DATASIZE; i = i + 2) {
    usart_trans_buff[DATASIZE + 3 + (i / 2)] = msg[i + 1]^msg[i + 2];
    171e:	f9 01       	movw	r30, r18
    1720:	f5 95       	asr	r31
    1722:	e7 95       	ror	r30
    1724:	ed 51       	subi	r30, 0x1D	; 29
    1726:	fe 4f       	sbci	r31, 0xFE	; 254
    1728:	8a 81       	ldd	r24, Y+2	; 0x02
    172a:	99 81       	ldd	r25, Y+1	; 0x01
    172c:	89 27       	eor	r24, r25
    172e:	85 87       	std	Z+13, r24	; 0x0d
  for (i = 0; i < LenOfMsg; i++) {
    usart_trans_buff[i + 1] = msg[i];
  }
  usart_trans_buff[LenOfMsg + 1] = usart_trans_buff[0] ^ msg[0];

  for (i = 0; i < DATASIZE; i = i + 2) {
    1730:	2e 5f       	subi	r18, 0xFE	; 254
    1732:	3f 4f       	sbci	r19, 0xFF	; 255
    1734:	22 96       	adiw	r28, 0x02	; 2
    1736:	2a 30       	cpi	r18, 0x0A	; 10
    1738:	31 05       	cpc	r19, r1
    173a:	89 f7       	brne	.-30     	; 0x171e <to_transmitt_buffer+0x48>
    usart_trans_buff[DATASIZE + 3 + (i / 2)] = msg[i + 1]^msg[i + 2];
  }

  mfree((void *) msg);
    173c:	ca 01       	movw	r24, r20
    173e:	0e 94 98 1d 	call	0x3b30	; 0x3b30 <mfree>

  msg = NULL;

}
    1742:	df 91       	pop	r29
    1744:	cf 91       	pop	r28
    1746:	08 95       	ret

00001748 <send_msg>:
}

/// Funkce po svem zavolani projde seznam zprav. Jestli je nejaka zprava k
/// odeslani, zkopiruje ji do odesilaciho bufferu a nastavi usart_trans_count=0;
/// Tim se zahaji odesilani.
void send_msg (void){
    1748:	cf 93       	push	r28
    174a:	df 93       	push	r29
  wtch_dbg_info();
    174c:	c2 e8       	ldi	r28, 0x82	; 130
    174e:	d0 e0       	ldi	r29, 0x00	; 0
    1750:	d0 93 fe 00 	sts	0x00FE, r29
    1754:	c0 93 fd 00 	sts	0x00FD, r28
    1758:	83 e5       	ldi	r24, 0x53	; 83
    175a:	92 e0       	ldi	r25, 0x02	; 2
    175c:	90 93 00 01 	sts	0x0100, r25
    1760:	80 93 ff 00 	sts	0x00FF, r24
  if (msg_buffer_counter != -1){
    1764:	e0 91 8e 00 	lds	r30, 0x008E
    1768:	f0 91 8f 00 	lds	r31, 0x008F
    176c:	8f ef       	ldi	r24, 0xFF	; 255
    176e:	ef 3f       	cpi	r30, 0xFF	; 255
    1770:	f8 07       	cpc	r31, r24
    1772:	09 f4       	brne	.+2      	; 0x1776 <send_msg+0x2e>
    1774:	53 c0       	rjmp	.+166    	; 0x181c <send_msg+0xd4>
    char *poiter_to_msg;

    wtch_dbg_info();
    // zkopirujeme obsah do bufferu
    poiter_to_msg = msg_buffer[msg_buffer_counter];
    1776:	ee 0f       	add	r30, r30
    1778:	ff 1f       	adc	r31, r31
    177a:	eb 50       	subi	r30, 0x0B	; 11
    177c:	fe 4f       	sbci	r31, 0xFE	; 254
    177e:	80 81       	ld	r24, Z
    1780:	91 81       	ldd	r25, Z+1	; 0x01
    wtch_dbg_info();
    1782:	2a e5       	ldi	r18, 0x5A	; 90
    1784:	32 e0       	ldi	r19, 0x02	; 2
    1786:	30 93 00 01 	sts	0x0100, r19
    178a:	20 93 ff 00 	sts	0x00FF, r18
    to_transmitt_buffer(poiter_to_msg);
    178e:	0e 94 6b 0b 	call	0x16d6	; 0x16d6 <to_transmitt_buffer>
    for (i = 0; i < LenOfTransBuff; i++){
      usart_trans_buff[i] = poiter_to_msg[i];
    }
    */
    // 
    msg_buffer[msg_buffer_counter] = NULL;
    1792:	20 91 8e 00 	lds	r18, 0x008E
    1796:	30 91 8f 00 	lds	r19, 0x008F
    179a:	f9 01       	movw	r30, r18
    179c:	ee 0f       	add	r30, r30
    179e:	ff 1f       	adc	r31, r31
    17a0:	eb 50       	subi	r30, 0x0B	; 11
    17a2:	fe 4f       	sbci	r31, 0xFE	; 254
    17a4:	11 82       	std	Z+1, r1	; 0x01
    17a6:	10 82       	st	Z, r1

    // zahajime odesilani
    usart_trans_count = 0;
    17a8:	10 92 8d 00 	sts	0x008D, r1
    17ac:	10 92 8c 00 	sts	0x008C, r1

    wtch_dbg_info();
    17b0:	d0 93 fe 00 	sts	0x00FE, r29
    17b4:	c0 93 fd 00 	sts	0x00FD, r28
    17b8:	89 e6       	ldi	r24, 0x69	; 105
    17ba:	92 e0       	ldi	r25, 0x02	; 2
    17bc:	90 93 00 01 	sts	0x0100, r25
    17c0:	80 93 ff 00 	sts	0x00FF, r24
    // Pokusime se nalezt dalsi zpravu
    if (msg_buffer_counter == (LenOfMsgBuffer - 1)){
    17c4:	24 30       	cpi	r18, 0x04	; 4
    17c6:	31 05       	cpc	r19, r1
    17c8:	29 f4       	brne	.+10     	; 0x17d4 <send_msg+0x8c>
      msg_buffer_counter = 0;
    17ca:	10 92 8f 00 	sts	0x008F, r1
    17ce:	10 92 8e 00 	sts	0x008E, r1
    17d2:	06 c0       	rjmp	.+12     	; 0x17e0 <send_msg+0x98>
    }
    else{
      msg_buffer_counter++;
    17d4:	2f 5f       	subi	r18, 0xFF	; 255
    17d6:	3f 4f       	sbci	r19, 0xFF	; 255
    17d8:	30 93 8f 00 	sts	0x008F, r19
    17dc:	20 93 8e 00 	sts	0x008E, r18
    }

    // Pokud zprava neexistuje, nastavime pocitadlo na -1;
    if (msg_buffer[msg_buffer_counter] == NULL){
    17e0:	e0 91 8e 00 	lds	r30, 0x008E
    17e4:	f0 91 8f 00 	lds	r31, 0x008F
    17e8:	ee 0f       	add	r30, r30
    17ea:	ff 1f       	adc	r31, r31
    17ec:	eb 50       	subi	r30, 0x0B	; 11
    17ee:	fe 4f       	sbci	r31, 0xFE	; 254
    17f0:	80 81       	ld	r24, Z
    17f2:	91 81       	ldd	r25, Z+1	; 0x01
    17f4:	89 2b       	or	r24, r25
    17f6:	91 f4       	brne	.+36     	; 0x181c <send_msg+0xd4>
      wtch_dbg_info();
    17f8:	82 e8       	ldi	r24, 0x82	; 130
    17fa:	90 e0       	ldi	r25, 0x00	; 0
    17fc:	90 93 fe 00 	sts	0x00FE, r25
    1800:	80 93 fd 00 	sts	0x00FD, r24
    1804:	84 e7       	ldi	r24, 0x74	; 116
    1806:	92 e0       	ldi	r25, 0x02	; 2
    1808:	90 93 00 01 	sts	0x0100, r25
    180c:	80 93 ff 00 	sts	0x00FF, r24
      msg_buffer_counter = -1; 
    1810:	8f ef       	ldi	r24, 0xFF	; 255
    1812:	9f ef       	ldi	r25, 0xFF	; 255
    1814:	90 93 8f 00 	sts	0x008F, r25
    1818:	80 93 8e 00 	sts	0x008E, r24
      }
      */
    }
  }
  
}
    181c:	df 91       	pop	r29
    181e:	cf 91       	pop	r28
    1820:	08 95       	ret

00001822 <__vector_14>:

/// Tohle se spouští když je prázdný odesílací buffer.
/// Když je zapotřebí vysílat, stačí, když nastaví usart_trans_count = 0 .
/// Odesílá to po bytech věci z usart_trans_bufferu az do konce
/// na konci je malé odmlčení, kvůli lepší synchronizaci
SIGNAL(SIG_UART_DATA) {
    1822:	1f 92       	push	r1
    1824:	0f 92       	push	r0
    1826:	0f b6       	in	r0, 0x3f	; 63
    1828:	0f 92       	push	r0
    182a:	11 24       	eor	r1, r1
    182c:	2f 93       	push	r18
    182e:	3f 93       	push	r19
    1830:	4f 93       	push	r20
    1832:	5f 93       	push	r21
    1834:	6f 93       	push	r22
    1836:	7f 93       	push	r23
    1838:	8f 93       	push	r24
    183a:	9f 93       	push	r25
    183c:	af 93       	push	r26
    183e:	bf 93       	push	r27
    1840:	ef 93       	push	r30
    1842:	ff 93       	push	r31
  wtch_dbg_info();
    1844:	82 e8       	ldi	r24, 0x82	; 130
    1846:	90 e0       	ldi	r25, 0x00	; 0
    1848:	90 93 fe 00 	sts	0x00FE, r25
    184c:	80 93 fd 00 	sts	0x00FD, r24
    1850:	8b e9       	ldi	r24, 0x9B	; 155
    1852:	91 e0       	ldi	r25, 0x01	; 1
    1854:	90 93 00 01 	sts	0x0100, r25
    1858:	80 93 ff 00 	sts	0x00FF, r24
  // Pokud neni co odesilat, tak se mrnkni jestli neco nema send_msg
  if (usart_trans_count == -1) {
    185c:	80 91 8c 00 	lds	r24, 0x008C
    1860:	90 91 8d 00 	lds	r25, 0x008D
    1864:	8f 5f       	subi	r24, 0xFF	; 255
    1866:	9f 4f       	sbci	r25, 0xFF	; 255
    1868:	11 f4       	brne	.+4      	; 0x186e <__vector_14+0x4c>

    send_msg();
    186a:	0e 94 a4 0b 	call	0x1748	; 0x1748 <send_msg>

  }

  // pokud je neco v bufferu, tak makej
  if (usart_trans_count != -1) {
    186e:	20 91 8c 00 	lds	r18, 0x008C
    1872:	30 91 8d 00 	lds	r19, 0x008D
    1876:	8f ef       	ldi	r24, 0xFF	; 255
    1878:	2f 3f       	cpi	r18, 0xFF	; 255
    187a:	38 07       	cpc	r19, r24
    187c:	69 f1       	breq	.+90     	; 0x18d8 <__vector_14+0xb6>

    if (usart_trans_count != LenOfTransBuff) { // zde je odesílán byte po bytu
    187e:	22 31       	cpi	r18, 0x12	; 18
    1880:	31 05       	cpc	r19, r1
    1882:	59 f0       	breq	.+22     	; 0x189a <__vector_14+0x78>

      UDR = usart_trans_buff[usart_trans_count];
    1884:	f9 01       	movw	r30, r18
    1886:	ed 51       	subi	r30, 0x1D	; 29
    1888:	fe 4f       	sbci	r31, 0xFE	; 254
    188a:	80 81       	ld	r24, Z
    188c:	8c b9       	out	0x0c, r24	; 12

      usart_trans_count++;
    188e:	2f 5f       	subi	r18, 0xFF	; 255
    1890:	3f 4f       	sbci	r19, 0xFF	; 255
    1892:	30 93 8d 00 	sts	0x008D, r19
    1896:	20 93 8c 00 	sts	0x008C, r18

    // teď se po každým odeslání udělá pauza
    // dela se to tak, že se vždycky sníží counter a když je nula, tak se vše
    // nastaví a ukončí
    //*
    if (usart_trans_count == LenOfTransBuff) {
    189a:	80 91 8c 00 	lds	r24, 0x008C
    189e:	90 91 8d 00 	lds	r25, 0x008D
    18a2:	42 97       	sbiw	r24, 0x12	; 18
    18a4:	d1 f4       	brne	.+52     	; 0x18da <__vector_14+0xb8>

      if (after_trans_delay_counter != 0) {
    18a6:	80 91 90 00 	lds	r24, 0x0090
    18aa:	90 91 91 00 	lds	r25, 0x0091
    18ae:	00 97       	sbiw	r24, 0x00	; 0
    18b0:	31 f0       	breq	.+12     	; 0x18be <__vector_14+0x9c>
        after_trans_delay_counter--;
    18b2:	01 97       	sbiw	r24, 0x01	; 1
    18b4:	90 93 91 00 	sts	0x0091, r25
    18b8:	80 93 90 00 	sts	0x0090, r24
    18bc:	0e c0       	rjmp	.+28     	; 0x18da <__vector_14+0xb8>


      } else {
        after_trans_delay_counter = Delay;
    18be:	84 ef       	ldi	r24, 0xF4	; 244
    18c0:	91 e0       	ldi	r25, 0x01	; 1
    18c2:	90 93 91 00 	sts	0x0091, r25
    18c6:	80 93 90 00 	sts	0x0090, r24
        usart_trans_count = -1;
    18ca:	8f ef       	ldi	r24, 0xFF	; 255
    18cc:	9f ef       	ldi	r25, 0xFF	; 255
    18ce:	90 93 8d 00 	sts	0x008D, r25
    18d2:	80 93 8c 00 	sts	0x008C, r24
    18d6:	01 c0       	rjmp	.+2      	; 0x18da <__vector_14+0xb8>
    }
    //*/

  } else {

    UCSRB = UCSRB & (~(1 << UDRIE));
    18d8:	55 98       	cbi	0x0a, 5	; 10
  }

}
    18da:	ff 91       	pop	r31
    18dc:	ef 91       	pop	r30
    18de:	bf 91       	pop	r27
    18e0:	af 91       	pop	r26
    18e2:	9f 91       	pop	r25
    18e4:	8f 91       	pop	r24
    18e6:	7f 91       	pop	r23
    18e8:	6f 91       	pop	r22
    18ea:	5f 91       	pop	r21
    18ec:	4f 91       	pop	r20
    18ee:	3f 91       	pop	r19
    18f0:	2f 91       	pop	r18
    18f2:	0f 90       	pop	r0
    18f4:	0f be       	out	0x3f, r0	; 63
    18f6:	0f 90       	pop	r0
    18f8:	1f 90       	pop	r1
    18fa:	18 95       	reti

000018fc <serial_read_buffer>:
  return out;
}

/// Nová implementace přijímní zpráv
/// Není naimplementována chyba z chybně přijatéo prvního znaku.
void serial_read_buffer(void) {
    18fc:	cf 93       	push	r28
    18fe:	df 93       	push	r29
  static unsigned char byte_counter = 0;
  int c;

  wtch_dbg_info();
    1900:	82 e8       	ldi	r24, 0x82	; 130
    1902:	90 e0       	ldi	r25, 0x00	; 0
    1904:	90 93 fe 00 	sts	0x00FE, r25
    1908:	80 93 fd 00 	sts	0x00FD, r24
    190c:	85 e6       	ldi	r24, 0x65	; 101
    190e:	91 e0       	ldi	r25, 0x01	; 1
    1910:	90 93 00 01 	sts	0x0100, r25
    1914:	80 93 ff 00 	sts	0x00FF, r24
    1918:	27 c0       	rjmp	.+78     	; 0x1968 <serial_read_buffer+0x6c>
  //  unsigned char c;
  //  unsigned char typ=0;

  // načtení z lower_buffer
  while ((c = getc_lb()) != -1) {
    191a:	c4 e0       	ldi	r28, 0x04	; 4
    191c:	d3 e0       	ldi	r29, 0x03	; 3
 * Funkce je založená na stejné implementaci jako na serveru.
 */
void into_buffer(unsigned char c){
  int i = 0;
  for (i = 0;i < LenOfRecvBuff - 1;i++){
    usart_recv_buff[i]=usart_recv_buff[i+1];
    191e:	89 81       	ldd	r24, Y+1	; 0x01
    1920:	89 93       	st	Y+, r24
 * Funkce vkládá data do bufferu.
 * Funkce je založená na stejné implementaci jako na serveru.
 */
void into_buffer(unsigned char c){
  int i = 0;
  for (i = 0;i < LenOfRecvBuff - 1;i++){
    1922:	83 e0       	ldi	r24, 0x03	; 3
    1924:	c5 31       	cpi	r28, 0x15	; 21
    1926:	d8 07       	cpc	r29, r24
    1928:	d1 f7       	brne	.-12     	; 0x191e <serial_read_buffer+0x22>
    usart_recv_buff[i]=usart_recv_buff[i+1];
  }
  usart_recv_buff[i]=c;
    192a:	28 83       	st	Y, r18
  // načtení z lower_buffer
  while ((c = getc_lb()) != -1) {
    into_buffer((char) c);

    // obsah bufferu se tiskne jen pokud je to povoleno
    si_print_recv_buffer();
    192c:	0e 94 eb 1b 	call	0x37d6	; 0x37d6 <si_print_recv_buffer>
    byte_counter++;
    1930:	80 91 81 01 	lds	r24, 0x0181
    1934:	8f 5f       	subi	r24, 0xFF	; 255
    1936:	80 93 81 01 	sts	0x0181, r24

    if ((byte_counter >= LenOfRecvBuff) && (test_message(usart_recv_buff) == 1)) {
    193a:	82 31       	cpi	r24, 0x12	; 18
    193c:	50 f0       	brcs	.+20     	; 0x1952 <serial_read_buffer+0x56>
    193e:	ce 01       	movw	r24, r28
    1940:	41 97       	sbiw	r24, 0x11	; 17
    1942:	0e 94 14 09 	call	0x1228	; 0x1228 <test_message>
    1946:	01 97       	sbiw	r24, 0x01	; 1
    1948:	21 f4       	brne	.+8      	; 0x1952 <serial_read_buffer+0x56>
      process_recived_msg();
    194a:	0e 94 0d 0a 	call	0x141a	; 0x141a <process_recived_msg>
      //reset_buffer(); // reset naplní nulami a pak je možné, že dorazí jen jeden znak 255 a ostatní nuly
      byte_counter = 0;
    194e:	10 92 81 01 	sts	0x0181, r1
      //    zpracuj_zpravu();
      //dorazilo
    }
    if ((usart_recv_buff[0] == 255) && (byte_counter > LenOfRecvBuff)) {
    1952:	80 91 04 03 	lds	r24, 0x0304
    1956:	8f 3f       	cpi	r24, 0xFF	; 255
    1958:	39 f4       	brne	.+14     	; 0x1968 <serial_read_buffer+0x6c>
    195a:	80 91 81 01 	lds	r24, 0x0181
    195e:	83 31       	cpi	r24, 0x13	; 19
    1960:	18 f0       	brcs	.+6      	; 0x1968 <serial_read_buffer+0x6c>
      //si_print_recv_buffer();
      // chyba prenosu - neshoda v kontrolnim souctu
      new_error(86);
    1962:	86 e5       	ldi	r24, 0x56	; 86
    1964:	0e 94 33 18 	call	0x3066	; 0x3066 <new_error>
  wtch_dbg_info();
  //  unsigned char c;
  //  unsigned char typ=0;

  // načtení z lower_buffer
  while ((c = getc_lb()) != -1) {
    1968:	0e 94 a6 09 	call	0x134c	; 0x134c <getc_lb>
    196c:	9c 01       	movw	r18, r24
    196e:	8f ef       	ldi	r24, 0xFF	; 255
    1970:	2f 3f       	cpi	r18, 0xFF	; 255
    1972:	38 07       	cpc	r19, r24
    1974:	91 f6       	brne	.-92     	; 0x191a <serial_read_buffer+0x1e>
      new_error(86);
    }
  }
  

}
    1976:	df 91       	pop	r29
    1978:	cf 91       	pop	r28
    197a:	08 95       	ret

0000197c <msg_14>:

/** 
 * Funkce odešle zprávu s příslušným kódem.
 */
void msg_14 (void){
  new_msg_P(msg14);
    197c:	8c e4       	ldi	r24, 0x4C	; 76
    197e:	95 e0       	ldi	r25, 0x05	; 5
    1980:	0e 94 4e 0b 	call	0x169c	; 0x169c <new_msg_P>
}
    1984:	08 95       	ret

00001986 <msg_0A>:

/** 
 * Funkce odešle zprávu s příslušným kódem.
 */
void msg_0A (void){
  new_msg_P(msg0A);
    1986:	88 e5       	ldi	r24, 0x58	; 88
    1988:	95 e0       	ldi	r25, 0x05	; 5
    198a:	0e 94 4e 0b 	call	0x169c	; 0x169c <new_msg_P>
}
    198e:	08 95       	ret

00001990 <recv_msg>:


/**
 * Funkce je spouštěna po přijetí zprávy. Rozhoduje o tom, co bude po přijetí učiněno.
 */
void recv_msg(char * recived_msg){
    1990:	0f 93       	push	r16
    1992:	1f 93       	push	r17
    1994:	df 93       	push	r29
    1996:	cf 93       	push	r28
    1998:	cd b7       	in	r28, 0x3d	; 61
    199a:	de b7       	in	r29, 0x3e	; 62
    199c:	28 97       	sbiw	r28, 0x08	; 8
    199e:	0f b6       	in	r0, 0x3f	; 63
    19a0:	f8 94       	cli
    19a2:	de bf       	out	0x3e, r29	; 62
    19a4:	0f be       	out	0x3f, r0	; 63
    19a6:	cd bf       	out	0x3d, r28	; 61
    19a8:	8c 01       	movw	r16, r24
  msg_time_0();
    19aa:	0e 94 02 09 	call	0x1204	; 0x1204 <msg_time_0>
  switch (recived_msg[0]){
    19ae:	f8 01       	movw	r30, r16
    19b0:	80 81       	ld	r24, Z
    19b2:	90 e0       	ldi	r25, 0x00	; 0
    19b4:	fc 01       	movw	r30, r24
    19b6:	34 97       	sbiw	r30, 0x04	; 4
    19b8:	ed 39       	cpi	r30, 0x9D	; 157
    19ba:	f1 05       	cpc	r31, r1
    19bc:	60 f4       	brcc	.+24     	; 0x19d6 <recv_msg+0x46>
    19be:	e6 5d       	subi	r30, 0xD6	; 214
    19c0:	ff 4f       	sbci	r31, 0xFF	; 255
    19c2:	ee 0f       	add	r30, r30
    19c4:	ff 1f       	adc	r31, r31
    19c6:	05 90       	lpm	r0, Z+
    19c8:	f4 91       	lpm	r31, Z+
    19ca:	e0 2d       	mov	r30, r0
    19cc:	09 94       	ijmp
      recive_uint32(recived_msg+1, &k2, &q2);
      io_irc2_options((uint16_t) k2, q2);
    }
    break;
    case MSGN_SYSINFO:
      si_set_flag(recived_msg[1]);
    19ce:	f8 01       	movw	r30, r16
    19d0:	81 81       	ldd	r24, Z+1	; 0x01
    19d2:	0e 94 6c 1b 	call	0x36d8	; 0x36d8 <si_set_flag>
      break;
    default:
    break;
    
  }
}
    19d6:	28 96       	adiw	r28, 0x08	; 8
    19d8:	0f b6       	in	r0, 0x3f	; 63
    19da:	f8 94       	cli
    19dc:	de bf       	out	0x3e, r29	; 62
    19de:	0f be       	out	0x3f, r0	; 63
    19e0:	cd bf       	out	0x3d, r28	; 61
    19e2:	cf 91       	pop	r28
    19e4:	df 91       	pop	r29
    19e6:	1f 91       	pop	r17
    19e8:	0f 91       	pop	r16
    19ea:	08 95       	ret

    case MSGN_IRC1_OPTIONS:
    {
      uint32_t k1;
      uint32_t q1;
      recive_uint32(recived_msg+1, &k1, &q1);
    19ec:	c8 01       	movw	r24, r16
    19ee:	01 96       	adiw	r24, 0x01	; 1
    19f0:	be 01       	movw	r22, r28
    19f2:	6b 5f       	subi	r22, 0xFB	; 251
    19f4:	7f 4f       	sbci	r23, 0xFF	; 255
    19f6:	ae 01       	movw	r20, r28
    19f8:	4f 5f       	subi	r20, 0xFF	; 255
    19fa:	5f 4f       	sbci	r21, 0xFF	; 255
    19fc:	0e 94 6a 09 	call	0x12d4	; 0x12d4 <recive_uint32>
      io_irc1_options((uint16_t) k1, q1);
    1a00:	49 81       	ldd	r20, Y+1	; 0x01
    1a02:	5a 81       	ldd	r21, Y+2	; 0x02
    1a04:	6b 81       	ldd	r22, Y+3	; 0x03
    1a06:	7c 81       	ldd	r23, Y+4	; 0x04
    1a08:	8d 81       	ldd	r24, Y+5	; 0x05
    1a0a:	9e 81       	ldd	r25, Y+6	; 0x06
    1a0c:	0e 94 b8 1c 	call	0x3970	; 0x3970 <io_irc1_options>
    1a10:	e2 cf       	rjmp	.-60     	; 0x19d6 <recv_msg+0x46>

    case MSGN_MSR_LED_ON:
      io_msr_led_on();
      break;
    case MSGN_MSR_LED_OFF:
      io_msr_led_off();
    1a12:	0e 94 a5 1c 	call	0x394a	; 0x394a <io_msr_led_off>
    1a16:	df cf       	rjmp	.-66     	; 0x19d6 <recv_msg+0x46>
      printnxyd(3, 3 * LCD_NBYTES, recived_msg+1, LCD_NBYTES);
      break;


    case MSGN_MSR_LED_ON:
      io_msr_led_on();
    1a18:	0e 94 a3 1c 	call	0x3946	; 0x3946 <io_msr_led_on>
    1a1c:	dc cf       	rjmp	.-72     	; 0x19d6 <recv_msg+0x46>
      break;
    case MSGN_LCD14:
      printnxyd(3, 2 * LCD_NBYTES, recived_msg+1, LCD_NBYTES);
      break;
    case MSGN_LCD15:
      printnxyd(3, 3 * LCD_NBYTES, recived_msg+1, LCD_NBYTES);
    1a1e:	0f 5f       	subi	r16, 0xFF	; 255
    1a20:	1f 4f       	sbci	r17, 0xFF	; 255
    1a22:	83 e0       	ldi	r24, 0x03	; 3
    1a24:	90 e0       	ldi	r25, 0x00	; 0
    1a26:	6e e1       	ldi	r22, 0x1E	; 30
    1a28:	70 e0       	ldi	r23, 0x00	; 0
    1a2a:	a8 01       	movw	r20, r16
    1a2c:	2a e0       	ldi	r18, 0x0A	; 10
    1a2e:	30 e0       	ldi	r19, 0x00	; 0
    1a30:	0e 94 4a 13 	call	0x2694	; 0x2694 <printnxyd>
    1a34:	d0 cf       	rjmp	.-96     	; 0x19d6 <recv_msg+0x46>
      break;
    case MSGN_LCD13:
      printnxyd(3, 1 * LCD_NBYTES, recived_msg+1, LCD_NBYTES);
      break;
    case MSGN_LCD14:
      printnxyd(3, 2 * LCD_NBYTES, recived_msg+1, LCD_NBYTES);
    1a36:	0f 5f       	subi	r16, 0xFF	; 255
    1a38:	1f 4f       	sbci	r17, 0xFF	; 255
    1a3a:	83 e0       	ldi	r24, 0x03	; 3
    1a3c:	90 e0       	ldi	r25, 0x00	; 0
    1a3e:	64 e1       	ldi	r22, 0x14	; 20
    1a40:	70 e0       	ldi	r23, 0x00	; 0
    1a42:	a8 01       	movw	r20, r16
    1a44:	2a e0       	ldi	r18, 0x0A	; 10
    1a46:	30 e0       	ldi	r19, 0x00	; 0
    1a48:	0e 94 4a 13 	call	0x2694	; 0x2694 <printnxyd>
    1a4c:	c4 cf       	rjmp	.-120    	; 0x19d6 <recv_msg+0x46>
      break;
    case MSGN_LCD12:
      printnxyd(3, 0 * LCD_NBYTES, recived_msg+1, LCD_NBYTES);
      break;
    case MSGN_LCD13:
      printnxyd(3, 1 * LCD_NBYTES, recived_msg+1, LCD_NBYTES);
    1a4e:	0f 5f       	subi	r16, 0xFF	; 255
    1a50:	1f 4f       	sbci	r17, 0xFF	; 255
    1a52:	83 e0       	ldi	r24, 0x03	; 3
    1a54:	90 e0       	ldi	r25, 0x00	; 0
    1a56:	6a e0       	ldi	r22, 0x0A	; 10
    1a58:	70 e0       	ldi	r23, 0x00	; 0
    1a5a:	a8 01       	movw	r20, r16
    1a5c:	2a e0       	ldi	r18, 0x0A	; 10
    1a5e:	30 e0       	ldi	r19, 0x00	; 0
    1a60:	0e 94 4a 13 	call	0x2694	; 0x2694 <printnxyd>
    1a64:	b8 cf       	rjmp	.-144    	; 0x19d6 <recv_msg+0x46>
      break;
    case MSGN_LCD11:
      printnxyd(2, 3 * LCD_NBYTES, recived_msg+1, LCD_NBYTES);
      break;
    case MSGN_LCD12:
      printnxyd(3, 0 * LCD_NBYTES, recived_msg+1, LCD_NBYTES);
    1a66:	0f 5f       	subi	r16, 0xFF	; 255
    1a68:	1f 4f       	sbci	r17, 0xFF	; 255
    1a6a:	83 e0       	ldi	r24, 0x03	; 3
    1a6c:	90 e0       	ldi	r25, 0x00	; 0
    1a6e:	60 e0       	ldi	r22, 0x00	; 0
    1a70:	70 e0       	ldi	r23, 0x00	; 0
    1a72:	a8 01       	movw	r20, r16
    1a74:	2a e0       	ldi	r18, 0x0A	; 10
    1a76:	30 e0       	ldi	r19, 0x00	; 0
    1a78:	0e 94 4a 13 	call	0x2694	; 0x2694 <printnxyd>
    1a7c:	ac cf       	rjmp	.-168    	; 0x19d6 <recv_msg+0x46>
      break;
    case MSGN_LCD10:
      printnxyd(2, 2 * LCD_NBYTES, recived_msg+1, LCD_NBYTES);
      break;
    case MSGN_LCD11:
      printnxyd(2, 3 * LCD_NBYTES, recived_msg+1, LCD_NBYTES);
    1a7e:	0f 5f       	subi	r16, 0xFF	; 255
    1a80:	1f 4f       	sbci	r17, 0xFF	; 255
    1a82:	82 e0       	ldi	r24, 0x02	; 2
    1a84:	90 e0       	ldi	r25, 0x00	; 0
    1a86:	6e e1       	ldi	r22, 0x1E	; 30
    1a88:	70 e0       	ldi	r23, 0x00	; 0
    1a8a:	a8 01       	movw	r20, r16
    1a8c:	2a e0       	ldi	r18, 0x0A	; 10
    1a8e:	30 e0       	ldi	r19, 0x00	; 0
    1a90:	0e 94 4a 13 	call	0x2694	; 0x2694 <printnxyd>
    1a94:	a0 cf       	rjmp	.-192    	; 0x19d6 <recv_msg+0x46>
      break;
    case MSGN_LCD09:
      printnxyd(2, 1 * LCD_NBYTES, recived_msg+1, LCD_NBYTES);
      break;
    case MSGN_LCD10:
      printnxyd(2, 2 * LCD_NBYTES, recived_msg+1, LCD_NBYTES);
    1a96:	0f 5f       	subi	r16, 0xFF	; 255
    1a98:	1f 4f       	sbci	r17, 0xFF	; 255
    1a9a:	82 e0       	ldi	r24, 0x02	; 2
    1a9c:	90 e0       	ldi	r25, 0x00	; 0
    1a9e:	64 e1       	ldi	r22, 0x14	; 20
    1aa0:	70 e0       	ldi	r23, 0x00	; 0
    1aa2:	a8 01       	movw	r20, r16
    1aa4:	2a e0       	ldi	r18, 0x0A	; 10
    1aa6:	30 e0       	ldi	r19, 0x00	; 0
    1aa8:	0e 94 4a 13 	call	0x2694	; 0x2694 <printnxyd>
    1aac:	94 cf       	rjmp	.-216    	; 0x19d6 <recv_msg+0x46>
      break;
    case MSGN_LCD08:
      printnxyd(2, 0 * LCD_NBYTES, recived_msg+1, LCD_NBYTES);
      break;
    case MSGN_LCD09:
      printnxyd(2, 1 * LCD_NBYTES, recived_msg+1, LCD_NBYTES);
    1aae:	0f 5f       	subi	r16, 0xFF	; 255
    1ab0:	1f 4f       	sbci	r17, 0xFF	; 255
    1ab2:	82 e0       	ldi	r24, 0x02	; 2
    1ab4:	90 e0       	ldi	r25, 0x00	; 0
    1ab6:	6a e0       	ldi	r22, 0x0A	; 10
    1ab8:	70 e0       	ldi	r23, 0x00	; 0
    1aba:	a8 01       	movw	r20, r16
    1abc:	2a e0       	ldi	r18, 0x0A	; 10
    1abe:	30 e0       	ldi	r19, 0x00	; 0
    1ac0:	0e 94 4a 13 	call	0x2694	; 0x2694 <printnxyd>
    1ac4:	88 cf       	rjmp	.-240    	; 0x19d6 <recv_msg+0x46>
      break;
    case MSGN_LCD07:
      printnxyd(1, 3 * LCD_NBYTES, recived_msg+1, LCD_NBYTES);
      break;
    case MSGN_LCD08:
      printnxyd(2, 0 * LCD_NBYTES, recived_msg+1, LCD_NBYTES);
    1ac6:	0f 5f       	subi	r16, 0xFF	; 255
    1ac8:	1f 4f       	sbci	r17, 0xFF	; 255
    1aca:	82 e0       	ldi	r24, 0x02	; 2
    1acc:	90 e0       	ldi	r25, 0x00	; 0
    1ace:	60 e0       	ldi	r22, 0x00	; 0
    1ad0:	70 e0       	ldi	r23, 0x00	; 0
    1ad2:	a8 01       	movw	r20, r16
    1ad4:	2a e0       	ldi	r18, 0x0A	; 10
    1ad6:	30 e0       	ldi	r19, 0x00	; 0
    1ad8:	0e 94 4a 13 	call	0x2694	; 0x2694 <printnxyd>
    1adc:	7c cf       	rjmp	.-264    	; 0x19d6 <recv_msg+0x46>
      break;
    case MSGN_LCD06:
      printnxyd(1, 2 * LCD_NBYTES, recived_msg+1, LCD_NBYTES);
      break;
    case MSGN_LCD07:
      printnxyd(1, 3 * LCD_NBYTES, recived_msg+1, LCD_NBYTES);
    1ade:	0f 5f       	subi	r16, 0xFF	; 255
    1ae0:	1f 4f       	sbci	r17, 0xFF	; 255
    1ae2:	81 e0       	ldi	r24, 0x01	; 1
    1ae4:	90 e0       	ldi	r25, 0x00	; 0
    1ae6:	6e e1       	ldi	r22, 0x1E	; 30
    1ae8:	70 e0       	ldi	r23, 0x00	; 0
    1aea:	a8 01       	movw	r20, r16
    1aec:	2a e0       	ldi	r18, 0x0A	; 10
    1aee:	30 e0       	ldi	r19, 0x00	; 0
    1af0:	0e 94 4a 13 	call	0x2694	; 0x2694 <printnxyd>
    1af4:	70 cf       	rjmp	.-288    	; 0x19d6 <recv_msg+0x46>
      break;
    case MSGN_LCD05:
      printnxyd(1, 1 * LCD_NBYTES, recived_msg+1, LCD_NBYTES);
      break;
    case MSGN_LCD06:
      printnxyd(1, 2 * LCD_NBYTES, recived_msg+1, LCD_NBYTES);
    1af6:	0f 5f       	subi	r16, 0xFF	; 255
    1af8:	1f 4f       	sbci	r17, 0xFF	; 255
    1afa:	81 e0       	ldi	r24, 0x01	; 1
    1afc:	90 e0       	ldi	r25, 0x00	; 0
    1afe:	64 e1       	ldi	r22, 0x14	; 20
    1b00:	70 e0       	ldi	r23, 0x00	; 0
    1b02:	a8 01       	movw	r20, r16
    1b04:	2a e0       	ldi	r18, 0x0A	; 10
    1b06:	30 e0       	ldi	r19, 0x00	; 0
    1b08:	0e 94 4a 13 	call	0x2694	; 0x2694 <printnxyd>
    1b0c:	64 cf       	rjmp	.-312    	; 0x19d6 <recv_msg+0x46>
      break;
    case MSGN_LCD04:
      printnxyd(1, 0 * LCD_NBYTES, recived_msg+1, LCD_NBYTES);
      break;
    case MSGN_LCD05:
      printnxyd(1, 1 * LCD_NBYTES, recived_msg+1, LCD_NBYTES);
    1b0e:	0f 5f       	subi	r16, 0xFF	; 255
    1b10:	1f 4f       	sbci	r17, 0xFF	; 255
    1b12:	81 e0       	ldi	r24, 0x01	; 1
    1b14:	90 e0       	ldi	r25, 0x00	; 0
    1b16:	6a e0       	ldi	r22, 0x0A	; 10
    1b18:	70 e0       	ldi	r23, 0x00	; 0
    1b1a:	a8 01       	movw	r20, r16
    1b1c:	2a e0       	ldi	r18, 0x0A	; 10
    1b1e:	30 e0       	ldi	r19, 0x00	; 0
    1b20:	0e 94 4a 13 	call	0x2694	; 0x2694 <printnxyd>
    1b24:	58 cf       	rjmp	.-336    	; 0x19d6 <recv_msg+0x46>
      break;
    case MSGN_LCD03:
      printnxyd(0, 3 * LCD_NBYTES, recived_msg+1, LCD_NBYTES);
      break;
    case MSGN_LCD04:
      printnxyd(1, 0 * LCD_NBYTES, recived_msg+1, LCD_NBYTES);
    1b26:	0f 5f       	subi	r16, 0xFF	; 255
    1b28:	1f 4f       	sbci	r17, 0xFF	; 255
    1b2a:	81 e0       	ldi	r24, 0x01	; 1
    1b2c:	90 e0       	ldi	r25, 0x00	; 0
    1b2e:	60 e0       	ldi	r22, 0x00	; 0
    1b30:	70 e0       	ldi	r23, 0x00	; 0
    1b32:	a8 01       	movw	r20, r16
    1b34:	2a e0       	ldi	r18, 0x0A	; 10
    1b36:	30 e0       	ldi	r19, 0x00	; 0
    1b38:	0e 94 4a 13 	call	0x2694	; 0x2694 <printnxyd>
    1b3c:	4c cf       	rjmp	.-360    	; 0x19d6 <recv_msg+0x46>
      break;
    case MSGN_LCD02:
      printnxyd(0, 2 * LCD_NBYTES, recived_msg+1, LCD_NBYTES);
      break;
    case MSGN_LCD03:
      printnxyd(0, 3 * LCD_NBYTES, recived_msg+1, LCD_NBYTES);
    1b3e:	0f 5f       	subi	r16, 0xFF	; 255
    1b40:	1f 4f       	sbci	r17, 0xFF	; 255
    1b42:	80 e0       	ldi	r24, 0x00	; 0
    1b44:	90 e0       	ldi	r25, 0x00	; 0
    1b46:	6e e1       	ldi	r22, 0x1E	; 30
    1b48:	70 e0       	ldi	r23, 0x00	; 0
    1b4a:	a8 01       	movw	r20, r16
    1b4c:	2a e0       	ldi	r18, 0x0A	; 10
    1b4e:	30 e0       	ldi	r19, 0x00	; 0
    1b50:	0e 94 4a 13 	call	0x2694	; 0x2694 <printnxyd>
    1b54:	40 cf       	rjmp	.-384    	; 0x19d6 <recv_msg+0x46>
      break;
    case MSGN_LCD01:
      printnxyd(0, 1 * LCD_NBYTES, recived_msg+1, LCD_NBYTES);
      break;
    case MSGN_LCD02:
      printnxyd(0, 2 * LCD_NBYTES, recived_msg+1, LCD_NBYTES);
    1b56:	0f 5f       	subi	r16, 0xFF	; 255
    1b58:	1f 4f       	sbci	r17, 0xFF	; 255
    1b5a:	80 e0       	ldi	r24, 0x00	; 0
    1b5c:	90 e0       	ldi	r25, 0x00	; 0
    1b5e:	64 e1       	ldi	r22, 0x14	; 20
    1b60:	70 e0       	ldi	r23, 0x00	; 0
    1b62:	a8 01       	movw	r20, r16
    1b64:	2a e0       	ldi	r18, 0x0A	; 10
    1b66:	30 e0       	ldi	r19, 0x00	; 0
    1b68:	0e 94 4a 13 	call	0x2694	; 0x2694 <printnxyd>
    1b6c:	34 cf       	rjmp	.-408    	; 0x19d6 <recv_msg+0x46>
    // ta +1 u recived_msd je proto, že první byte je identifikátor zprávy
    case MSGN_LCD00:
      printnxyd(0, 0 * LCD_NBYTES, recived_msg+1, LCD_NBYTES);
      break;
    case MSGN_LCD01:
      printnxyd(0, 1 * LCD_NBYTES, recived_msg+1, LCD_NBYTES);
    1b6e:	0f 5f       	subi	r16, 0xFF	; 255
    1b70:	1f 4f       	sbci	r17, 0xFF	; 255
    1b72:	80 e0       	ldi	r24, 0x00	; 0
    1b74:	90 e0       	ldi	r25, 0x00	; 0
    1b76:	6a e0       	ldi	r22, 0x0A	; 10
    1b78:	70 e0       	ldi	r23, 0x00	; 0
    1b7a:	a8 01       	movw	r20, r16
    1b7c:	2a e0       	ldi	r18, 0x0A	; 10
    1b7e:	30 e0       	ldi	r19, 0x00	; 0
    1b80:	0e 94 4a 13 	call	0x2694	; 0x2694 <printnxyd>
    1b84:	28 cf       	rjmp	.-432    	; 0x19d6 <recv_msg+0x46>
    break;

    // příjem toho co se má zobrazit na LCD,
    // ta +1 u recived_msd je proto, že první byte je identifikátor zprávy
    case MSGN_LCD00:
      printnxyd(0, 0 * LCD_NBYTES, recived_msg+1, LCD_NBYTES);
    1b86:	0f 5f       	subi	r16, 0xFF	; 255
    1b88:	1f 4f       	sbci	r17, 0xFF	; 255
    1b8a:	80 e0       	ldi	r24, 0x00	; 0
    1b8c:	90 e0       	ldi	r25, 0x00	; 0
    1b8e:	60 e0       	ldi	r22, 0x00	; 0
    1b90:	70 e0       	ldi	r23, 0x00	; 0
    1b92:	a8 01       	movw	r20, r16
    1b94:	2a e0       	ldi	r18, 0x0A	; 10
    1b96:	30 e0       	ldi	r19, 0x00	; 0
    1b98:	0e 94 4a 13 	call	0x2694	; 0x2694 <printnxyd>
    1b9c:	1c cf       	rjmp	.-456    	; 0x19d6 <recv_msg+0x46>
    break;
    case MSGN_IRC2_OPTIONS:
    {
      uint32_t k2;
      uint32_t q2;
      recive_uint32(recived_msg+1, &k2, &q2);
    1b9e:	c8 01       	movw	r24, r16
    1ba0:	01 96       	adiw	r24, 0x01	; 1
    1ba2:	be 01       	movw	r22, r28
    1ba4:	6f 5f       	subi	r22, 0xFF	; 255
    1ba6:	7f 4f       	sbci	r23, 0xFF	; 255
    1ba8:	ae 01       	movw	r20, r28
    1baa:	4b 5f       	subi	r20, 0xFB	; 251
    1bac:	5f 4f       	sbci	r21, 0xFF	; 255
    1bae:	0e 94 6a 09 	call	0x12d4	; 0x12d4 <recive_uint32>
      io_irc2_options((uint16_t) k2, q2);
    1bb2:	4d 81       	ldd	r20, Y+5	; 0x05
    1bb4:	5e 81       	ldd	r21, Y+6	; 0x06
    1bb6:	6f 81       	ldd	r22, Y+7	; 0x07
    1bb8:	78 85       	ldd	r23, Y+8	; 0x08
    1bba:	89 81       	ldd	r24, Y+1	; 0x01
    1bbc:	9a 81       	ldd	r25, Y+2	; 0x02
    1bbe:	0e 94 a7 1c 	call	0x394e	; 0x394e <io_irc2_options>
    1bc2:	09 cf       	rjmp	.-494    	; 0x19d6 <recv_msg+0x46>
    new_msg(msg);
    new_msg_P(msg14);
    break;
  }
  case '\x14':
    msg_ack_fcn(recived_msg);
    1bc4:	c8 01       	movw	r24, r16
    1bc6:	0e 94 3d 09 	call	0x127a	; 0x127a <msg_ack_fcn>
    1bca:	05 cf       	rjmp	.-502    	; 0x19d6 <recv_msg+0x46>
    new_msg_P(msg14);
    break;
  }
  case '\x11':{
    char * msg;
    msg = (char*)mmalloc(LenOfMsg);
    1bcc:	8b e0       	ldi	r24, 0x0B	; 11
    1bce:	90 e0       	ldi	r25, 0x00	; 0
    1bd0:	0e 94 a4 1d 	call	0x3b48	; 0x3b48 <mmalloc>
    1bd4:	ac 01       	movw	r20, r24
    memcpy(msg,recived_msg,LenOfMsg);
    1bd6:	dc 01       	movw	r26, r24
    1bd8:	f8 01       	movw	r30, r16
    1bda:	8b e0       	ldi	r24, 0x0B	; 11
    1bdc:	01 90       	ld	r0, Z+
    1bde:	0d 92       	st	X+, r0
    1be0:	81 50       	subi	r24, 0x01	; 1
    1be2:	e1 f7       	brne	.-8      	; 0x1bdc <recv_msg+0x24c>
    new_msg(msg);
    1be4:	ca 01       	movw	r24, r20
    1be6:	0e 94 21 0a 	call	0x1442	; 0x1442 <new_msg>
    new_msg_P(msg14);
    1bea:	8c e4       	ldi	r24, 0x4C	; 76
    1bec:	95 e0       	ldi	r25, 0x05	; 5
    1bee:	0e 94 4e 0b 	call	0x169c	; 0x169c <new_msg_P>
    1bf2:	f1 ce       	rjmp	.-542    	; 0x19d6 <recv_msg+0x46>
    eeprom_w32((void *)ee_irc_set_on_value,(uint32_t) get_irc1_set_on_value());
    new_msg_P(msg14);
    break;
  case '\x10':{
    char * msg;
    msg = (char*)mmalloc(LenOfMsg);
    1bf4:	8b e0       	ldi	r24, 0x0B	; 11
    1bf6:	90 e0       	ldi	r25, 0x00	; 0
    1bf8:	0e 94 a4 1d 	call	0x3b48	; 0x3b48 <mmalloc>
    1bfc:	ac 01       	movw	r20, r24
    memcpy(msg,recived_msg,LenOfMsg);
    1bfe:	dc 01       	movw	r26, r24
    1c00:	f8 01       	movw	r30, r16
    1c02:	8b e0       	ldi	r24, 0x0B	; 11
    1c04:	01 90       	ld	r0, Z+
    1c06:	0d 92       	st	X+, r0
    1c08:	81 50       	subi	r24, 0x01	; 1
    1c0a:	e1 f7       	brne	.-8      	; 0x1c04 <recv_msg+0x274>
    1c0c:	eb cf       	rjmp	.-42     	; 0x1be4 <recv_msg+0x254>
    eeprom_w16((void *)ee_irc_k, (uint16_t)irc1_get_k());
    new_msg_P(msg14);
    break;
    
  case '\x0F':
    set_irc1_set_on_value_mm((uint32_t)((uint32_t)(recived_msg[1] * 256) + recived_msg[2]));
    1c0e:	f8 01       	movw	r30, r16
    1c10:	71 81       	ldd	r23, Z+1	; 0x01
    1c12:	60 e0       	ldi	r22, 0x00	; 0
    1c14:	88 27       	eor	r24, r24
    1c16:	77 fd       	sbrc	r23, 7
    1c18:	80 95       	com	r24
    1c1a:	98 2f       	mov	r25, r24
    1c1c:	22 81       	ldd	r18, Z+2	; 0x02
    1c1e:	62 0f       	add	r22, r18
    1c20:	71 1d       	adc	r23, r1
    1c22:	81 1d       	adc	r24, r1
    1c24:	91 1d       	adc	r25, r1
    1c26:	0e 94 b5 0f 	call	0x1f6a	; 0x1f6a <set_irc1_set_on_value_mm>
    eeprom_w32((void *)ee_irc_set_on_value,(uint32_t) get_irc1_set_on_value());
    1c2a:	0e 94 49 0e 	call	0x1c92	; 0x1c92 <get_irc1_set_on_value>
    1c2e:	ab 01       	movw	r20, r22
    1c30:	bc 01       	movw	r22, r24
    1c32:	86 e0       	ldi	r24, 0x06	; 6
    1c34:	90 e0       	ldi	r25, 0x00	; 0
    1c36:	0e 94 22 12 	call	0x2444	; 0x2444 <eeprom_w32>
    new_msg_P(msg14);
    1c3a:	8c e4       	ldi	r24, 0x4C	; 76
    1c3c:	95 e0       	ldi	r25, 0x05	; 5
    1c3e:	0e 94 4e 0b 	call	0x169c	; 0x169c <new_msg_P>
    1c42:	c9 ce       	rjmp	.-622    	; 0x19d6 <recv_msg+0x46>
  }
    break;
    
  case '\x0E':
    //nastavení přenásobovací konstanty
    set_irc1_k_mm((uint16_t)((uint16_t)(recived_msg[1] * 256) + recived_msg[2]));
    1c44:	f8 01       	movw	r30, r16
    1c46:	91 81       	ldd	r25, Z+1	; 0x01
    1c48:	80 e0       	ldi	r24, 0x00	; 0
    1c4a:	22 81       	ldd	r18, Z+2	; 0x02
    1c4c:	82 0f       	add	r24, r18
    1c4e:	91 1d       	adc	r25, r1
    1c50:	0e 94 e8 0f 	call	0x1fd0	; 0x1fd0 <set_irc1_k_mm>
    
    //uložení do eeprom
    eeprom_w16((void *)ee_irc_k, (uint16_t)irc1_get_k());
    1c54:	0e 94 69 0e 	call	0x1cd2	; 0x1cd2 <irc1_get_k>
    1c58:	bc 01       	movw	r22, r24
    1c5a:	84 e0       	ldi	r24, 0x04	; 4
    1c5c:	90 e0       	ldi	r25, 0x00	; 0
    1c5e:	0e 94 43 12 	call	0x2486	; 0x2486 <eeprom_w16>
    new_msg_P(msg14);
    1c62:	8c e4       	ldi	r24, 0x4C	; 76
    1c64:	95 e0       	ldi	r25, 0x05	; 5
    1c66:	0e 94 4e 0b 	call	0x169c	; 0x169c <new_msg_P>
    1c6a:	b5 ce       	rjmp	.-662    	; 0x19d6 <recv_msg+0x46>
  case '\x07':
    new_error(7);
    break;

  case '\x0A':{
    eeprom_save();
    1c6c:	0e 94 58 12 	call	0x24b0	; 0x24b0 <eeprom_save>
    
    new_msg_P(msg0A); 	/* přepošle zprávu na katr */
    1c70:	88 e5       	ldi	r24, 0x58	; 88
    1c72:	95 e0       	ldi	r25, 0x05	; 5
    1c74:	0e 94 4e 0b 	call	0x169c	; 0x169c <new_msg_P>
    new_msg_P(msg14);
    1c78:	8c e4       	ldi	r24, 0x4C	; 76
    1c7a:	95 e0       	ldi	r25, 0x05	; 5
    1c7c:	0e 94 4e 0b 	call	0x169c	; 0x169c <new_msg_P>
    1c80:	aa ce       	rjmp	.-684    	; 0x19d6 <recv_msg+0x46>
   
  case '\x04':
    new_error(4);
    break;
  case '\x07':
    new_error(7);
    1c82:	87 e0       	ldi	r24, 0x07	; 7
    1c84:	0e 94 33 18 	call	0x3066	; 0x3066 <new_error>
    1c88:	a6 ce       	rjmp	.-692    	; 0x19d6 <recv_msg+0x46>
void recv_msg(char * recived_msg){
  msg_time_0();
  switch (recived_msg[0]){
   
  case '\x04':
    new_error(4);
    1c8a:	84 e0       	ldi	r24, 0x04	; 4
    1c8c:	0e 94 33 18 	call	0x3066	; 0x3066 <new_error>
    1c90:	a2 ce       	rjmp	.-700    	; 0x19d6 <recv_msg+0x46>

00001c92 <get_irc1_set_on_value>:
//void irc_watch(void);
//void irc_send_msg(void);
//void set_irc_k_mm(uint16_t i);
//void set_irc_set_on_value_mm(int32_t q);

int32_t get_irc1_set_on_value(){
    1c92:	60 91 98 00 	lds	r22, 0x0098
    1c96:	70 91 99 00 	lds	r23, 0x0099
  return irc_set_on_value;
}
    1c9a:	80 91 9a 00 	lds	r24, 0x009A
    1c9e:	90 91 9b 00 	lds	r25, 0x009B
    1ca2:	08 95       	ret

00001ca4 <set_irc1_counter>:
//void set_irc_set_on_value(int32_t a){
//  irc_set_on_value = a;
//}

void set_irc1_counter (int32_t a){
  irc_counter = a;
    1ca4:	60 93 95 01 	sts	0x0195, r22
    1ca8:	70 93 96 01 	sts	0x0196, r23
    1cac:	80 93 97 01 	sts	0x0197, r24
    1cb0:	90 93 98 01 	sts	0x0198, r25
}
    1cb4:	08 95       	ret

00001cb6 <get_irc1_counter>:

int32_t get_irc1_counter(void){
    1cb6:	60 91 95 01 	lds	r22, 0x0195
    1cba:	70 91 96 01 	lds	r23, 0x0196
  return irc_counter;
}
    1cbe:	80 91 97 01 	lds	r24, 0x0197
    1cc2:	90 91 98 01 	lds	r25, 0x0198
    1cc6:	08 95       	ret

00001cc8 <set_irc1_k>:

void set_irc1_k(uint16_t a){
  irc_k = a;
    1cc8:	90 93 97 00 	sts	0x0097, r25
    1ccc:	80 93 96 00 	sts	0x0096, r24
}
    1cd0:	08 95       	ret

00001cd2 <irc1_get_k>:
  eeprom_w16((void *)ee_irc_k,irc_k);
}

uint16_t irc1_get_k(void){
  return irc_k;
}
    1cd2:	80 91 96 00 	lds	r24, 0x0096
    1cd6:	90 91 97 00 	lds	r25, 0x0097
    1cda:	08 95       	ret

00001cdc <set_irc1_set_on_value>:
  irc_set_on_value = (int32_t)(q * (1000.0 /(irc_k)));
  eeprom_w32((void *)ee_irc_k,irc_set_on_value);
}

void set_irc1_set_on_value(int32_t a ){
  irc_set_on_value = a;
    1cdc:	60 93 98 00 	sts	0x0098, r22
    1ce0:	70 93 99 00 	sts	0x0099, r23
    1ce4:	80 93 9a 00 	sts	0x009A, r24
    1ce8:	90 93 9b 00 	sts	0x009B, r25
}
    1cec:	08 95       	ret

00001cee <irc1_init>:
  // nastavení výstupu na jedničky

  // předchozí implementace - funkční
  //PORTD = PORTD | (1 << 5) | (1 << 6) | (1 << 7);

  A_PORT = A_PORT | (1 << A_BIT);
    1cee:	95 9a       	sbi	0x12, 5	; 18
  B_PORT = B_PORT | (1 << B_BIT);
    1cf0:	96 9a       	sbi	0x12, 6	; 18
  SP_PORT = SP_PORT | (1 << SP_BIT);
    1cf2:	97 9a       	sbi	0x12, 7	; 18
  // předchozí implementace - funkční
  //prev_state = ((PIND) >> 5) & 0x07;

  
  prev_state = 0x00;
  prev_state = prev_state | (((A_PIN >> A_BIT) & 0x01) << 0);
    1cf4:	80 b3       	in	r24, 0x10	; 16
  prev_state = prev_state | (((B_PIN >> B_BIT) & 0x01) << 1);
    1cf6:	20 b3       	in	r18, 0x10	; 16
  prev_state = prev_state | (((SP_PIN >> SP_BIT) & 0x01) << 2);
    1cf8:	90 b3       	in	r25, 0x10	; 16
    1cfa:	99 1f       	adc	r25, r25
    1cfc:	99 27       	eor	r25, r25
    1cfe:	99 1f       	adc	r25, r25
    1d00:	99 0f       	add	r25, r25
    1d02:	99 0f       	add	r25, r25
    1d04:	82 95       	swap	r24
    1d06:	86 95       	lsr	r24
    1d08:	81 70       	andi	r24, 0x01	; 1
    1d0a:	98 2b       	or	r25, r24
    1d0c:	22 95       	swap	r18
    1d0e:	26 95       	lsr	r18
    1d10:	26 95       	lsr	r18
    1d12:	23 70       	andi	r18, 0x03	; 3
    1d14:	30 e0       	ldi	r19, 0x00	; 0
    1d16:	21 70       	andi	r18, 0x01	; 1
    1d18:	30 70       	andi	r19, 0x00	; 0
    1d1a:	22 0f       	add	r18, r18
    1d1c:	33 1f       	adc	r19, r19
    1d1e:	92 2b       	or	r25, r18
    1d20:	90 93 9a 01 	sts	0x019A, r25
   
}
    1d24:	08 95       	ret

00001d26 <irc1_get_l>:
}




uint16_t irc1_get_l(void){
    1d26:	ef 92       	push	r14
    1d28:	ff 92       	push	r15
    1d2a:	0f 93       	push	r16
    1d2c:	1f 93       	push	r17
    1d2e:	60 91 95 01 	lds	r22, 0x0195
    1d32:	70 91 96 01 	lds	r23, 0x0196
    1d36:	80 91 97 01 	lds	r24, 0x0197
    1d3a:	90 91 98 01 	lds	r25, 0x0198
    1d3e:	97 ff       	sbrs	r25, 7
    1d40:	04 c0       	rjmp	.+8      	; 0x1d4a <irc1_get_l+0x24>
    1d42:	60 e0       	ldi	r22, 0x00	; 0
    1d44:	70 e0       	ldi	r23, 0x00	; 0
    1d46:	80 e0       	ldi	r24, 0x00	; 0
    1d48:	90 e0       	ldi	r25, 0x00	; 0
    1d4a:	0e 94 7d 22 	call	0x44fa	; 0x44fa <__floatsisf>
    1d4e:	27 e1       	ldi	r18, 0x17	; 23
    1d50:	37 eb       	ldi	r19, 0xB7	; 183
    1d52:	41 ed       	ldi	r20, 0xD1	; 209
    1d54:	58 e3       	ldi	r21, 0x38	; 56
    1d56:	0e 94 31 23 	call	0x4662	; 0x4662 <__mulsf3>
    1d5a:	7b 01       	movw	r14, r22
    1d5c:	8c 01       	movw	r16, r24
    1d5e:	60 91 96 00 	lds	r22, 0x0096
    1d62:	70 91 97 00 	lds	r23, 0x0097
    1d66:	80 e0       	ldi	r24, 0x00	; 0
    1d68:	90 e0       	ldi	r25, 0x00	; 0
    1d6a:	0e 94 7b 22 	call	0x44f6	; 0x44f6 <__floatunsisf>
    1d6e:	9b 01       	movw	r18, r22
    1d70:	ac 01       	movw	r20, r24
    1d72:	c8 01       	movw	r24, r16
    1d74:	b7 01       	movw	r22, r14
    1d76:	0e 94 31 23 	call	0x4662	; 0x4662 <__mulsf3>
    1d7a:	0e 94 4f 22 	call	0x449e	; 0x449e <__fixunssfsi>
  //out = (uint16_t) (count * (0.0001 * irc_k));

  out = count * 0.0001 * irc_k;
  return out;

}
    1d7e:	cb 01       	movw	r24, r22
    1d80:	1f 91       	pop	r17
    1d82:	0f 91       	pop	r16
    1d84:	ff 90       	pop	r15
    1d86:	ef 90       	pop	r14
    1d88:	08 95       	ret

00001d8a <irc1_watch>:
/// funkce zavolana, je zkontrolovano, zda nedoslo okd minuleho zavolani ke
/// zmene na vstupech irc. Pokud ano, jsou provedeny prislusne korky - zvyseni
/// nebo snizeni citace irc a pripadne odeslani namerene hodnoty. Namerena
/// hodnota je dana jako hodnota irc cidla krat
/// konstanta (obvykle mensi nez jedna). 
void irc1_watch(void){
    1d8a:	9f 92       	push	r9
    1d8c:	af 92       	push	r10
    1d8e:	bf 92       	push	r11
    1d90:	cf 92       	push	r12
    1d92:	df 92       	push	r13
    1d94:	ef 92       	push	r14
    1d96:	ff 92       	push	r15
    1d98:	0f 93       	push	r16
    1d9a:	1f 93       	push	r17
  //printcxyd(0,0,'0'+ stav);


  // tohle funguje vždy, ale pro některé konkrétní případy by byla možná rychlejší implementace
  stav = 0x00;
  stav = stav | (((A_PIN >> A_BIT) & 0x01) << 0);
    1d9c:	80 b3       	in	r24, 0x10	; 16
  stav = stav | (((B_PIN >> B_BIT) & 0x01) << 1);
    1d9e:	20 b3       	in	r18, 0x10	; 16
  stav = stav | (((SP_PIN >> SP_BIT) & 0x01) << 2);
    1da0:	90 b2       	in	r9, 0x10	; 16
    1da2:	99 1c       	adc	r9, r9
    1da4:	99 24       	eor	r9, r9
    1da6:	99 1c       	adc	r9, r9
    1da8:	99 0c       	add	r9, r9
    1daa:	99 0c       	add	r9, r9
    1dac:	82 95       	swap	r24
    1dae:	86 95       	lsr	r24
    1db0:	81 70       	andi	r24, 0x01	; 1
    1db2:	98 2a       	or	r9, r24
    1db4:	22 95       	swap	r18
    1db6:	26 95       	lsr	r18
    1db8:	26 95       	lsr	r18
    1dba:	23 70       	andi	r18, 0x03	; 3
    1dbc:	30 e0       	ldi	r19, 0x00	; 0
    1dbe:	21 70       	andi	r18, 0x01	; 1
    1dc0:	30 70       	andi	r19, 0x00	; 0
    1dc2:	22 0f       	add	r18, r18
    1dc4:	33 1f       	adc	r19, r19
    1dc6:	92 2a       	or	r9, r18

  si_print_dbgirc1(stav);
    1dc8:	80 91 b6 01 	lds	r24, 0x01B6
    1dcc:	82 95       	swap	r24
    1dce:	8f 70       	andi	r24, 0x0F	; 15
    1dd0:	80 ff       	sbrs	r24, 0
    1dd2:	08 c0       	rjmp	.+16     	; 0x1de4 <irc1_watch+0x5a>
    1dd4:	49 2d       	mov	r20, r9
    1dd6:	40 5d       	subi	r20, 0xD0	; 208
    1dd8:	80 e0       	ldi	r24, 0x00	; 0
    1dda:	90 e0       	ldi	r25, 0x00	; 0
    1ddc:	61 e0       	ldi	r22, 0x01	; 1
    1dde:	70 e0       	ldi	r23, 0x00	; 0
    1de0:	0e 94 34 13 	call	0x2668	; 0x2668 <printcxyd>
  //printcxyd(0,1,'0'+ stavt);

  zmena_stavu = stav ^ prev_state;
    1de4:	10 91 9a 01 	lds	r17, 0x019A
    1de8:	19 25       	eor	r17, r9
  ruzne = (((stav >> 0) ^ (stav >> 1)) & 0x01);
    1dea:	29 2d       	mov	r18, r9
    1dec:	26 95       	lsr	r18
    1dee:	29 25       	eor	r18, r9
    1df0:	21 70       	andi	r18, 0x01	; 1

  // zde se resi pricitani a odecitani pri zmenach vstupu A a B Jestlize dojde
  // ke zmene nektereho vstupu, pak se porovna zda jsou oba bity stejne, ci ne
  // a podle toho se citac bud inkrementuje nebo dekrementuje.
  // Rovnez je zde resen erroru pri soucasne zmene obou vstupu.
  switch ((zmena_stavu >> 0) & 0x03){
    1df2:	81 2f       	mov	r24, r17
    1df4:	90 e0       	ldi	r25, 0x00	; 0
    1df6:	83 70       	andi	r24, 0x03	; 3
    1df8:	90 70       	andi	r25, 0x00	; 0
    1dfa:	82 30       	cpi	r24, 0x02	; 2
    1dfc:	91 05       	cpc	r25, r1
    1dfe:	81 f0       	breq	.+32     	; 0x1e20 <irc1_watch+0x96>
    1e00:	83 30       	cpi	r24, 0x03	; 3
    1e02:	91 05       	cpc	r25, r1
    1e04:	a1 f1       	breq	.+104    	; 0x1e6e <irc1_watch+0xe4>
    1e06:	01 97       	sbiw	r24, 0x01	; 1
    1e08:	a9 f5       	brne	.+106    	; 0x1e74 <irc1_watch+0xea>
    1e0a:	80 91 95 01 	lds	r24, 0x0195
    1e0e:	90 91 96 01 	lds	r25, 0x0196
    1e12:	a0 91 97 01 	lds	r26, 0x0197
    1e16:	b0 91 98 01 	lds	r27, 0x0198
    case 1 : 
      // zmenaA
      if (ruzne == 0){
    1e1a:	22 23       	and	r18, r18
    1e1c:	59 f4       	brne	.+22     	; 0x1e34 <irc1_watch+0xaa>
    1e1e:	18 c0       	rjmp	.+48     	; 0x1e50 <irc1_watch+0xc6>
    1e20:	80 91 95 01 	lds	r24, 0x0195
    1e24:	90 91 96 01 	lds	r25, 0x0196
    1e28:	a0 91 97 01 	lds	r26, 0x0197
    1e2c:	b0 91 98 01 	lds	r27, 0x0198
        //irc_send_msg();
      }
      break;
    case 2 :
      // zmenaB
      if (ruzne == 0){
    1e30:	22 23       	and	r18, r18
    1e32:	71 f4       	brne	.+28     	; 0x1e50 <irc1_watch+0xc6>
        irc_counter--;
    1e34:	01 97       	sbiw	r24, 0x01	; 1
    1e36:	a1 09       	sbc	r26, r1
    1e38:	b1 09       	sbc	r27, r1
    1e3a:	80 93 95 01 	sts	0x0195, r24
    1e3e:	90 93 96 01 	sts	0x0196, r25
    1e42:	a0 93 97 01 	sts	0x0197, r26
    1e46:	b0 93 98 01 	sts	0x0198, r27
        last_oper_with_irc_counter = 0;
    1e4a:	10 92 99 01 	sts	0x0199, r1
    1e4e:	12 c0       	rjmp	.+36     	; 0x1e74 <irc1_watch+0xea>
        //irc_send_msg();
      }
      else{
        irc_counter++;
    1e50:	01 96       	adiw	r24, 0x01	; 1
    1e52:	a1 1d       	adc	r26, r1
    1e54:	b1 1d       	adc	r27, r1
    1e56:	80 93 95 01 	sts	0x0195, r24
    1e5a:	90 93 96 01 	sts	0x0196, r25
    1e5e:	a0 93 97 01 	sts	0x0197, r26
    1e62:	b0 93 98 01 	sts	0x0198, r27
        last_oper_with_irc_counter = 1;
    1e66:	81 e0       	ldi	r24, 0x01	; 1
    1e68:	80 93 99 01 	sts	0x0199, r24
    1e6c:	03 c0       	rjmp	.+6      	; 0x1e74 <irc1_watch+0xea>
      break;
    case 3 :
      // oba
      // error
      //printcxyd(2,15,'e');
      new_error(6);
    1e6e:	86 e0       	ldi	r24, 0x06	; 6
    1e70:	0e 94 33 18 	call	0x3066	; 0x3066 <new_error>
  // zde je reseno nastavovani irc citace
  // pokud se objevi jednicka na pinc.6 a pohybujeme se nahoru (nula je tam
  // pri obraceni vstupu)
  // 
  
  if ((((zmena_stavu >> 2) & 0x01 ) == 1) && (last_oper_with_irc_counter == 1) && (((stav >> 2 ) & 1) == 0)){
    1e74:	81 2f       	mov	r24, r17
    1e76:	86 95       	lsr	r24
    1e78:	86 95       	lsr	r24
    1e7a:	80 ff       	sbrs	r24, 0
    1e7c:	6a c0       	rjmp	.+212    	; 0x1f52 <irc1_watch+0x1c8>
    1e7e:	80 91 99 01 	lds	r24, 0x0199
    1e82:	81 30       	cpi	r24, 0x01	; 1
    1e84:	09 f0       	breq	.+2      	; 0x1e88 <irc1_watch+0xfe>
    1e86:	65 c0       	rjmp	.+202    	; 0x1f52 <irc1_watch+0x1c8>
    1e88:	89 2d       	mov	r24, r9
    1e8a:	86 95       	lsr	r24
    1e8c:	86 95       	lsr	r24
    1e8e:	80 fd       	sbrc	r24, 0
    1e90:	60 c0       	rjmp	.+192    	; 0x1f52 <irc1_watch+0x1c8>
    int dif = 0;

    dif = irc_set_on_value - irc_counter;
    1e92:	a0 90 98 00 	lds	r10, 0x0098
    1e96:	b0 90 99 00 	lds	r11, 0x0099
    1e9a:	c0 90 9a 00 	lds	r12, 0x009A
    1e9e:	d0 90 9b 00 	lds	r13, 0x009B
    1ea2:	e0 90 95 01 	lds	r14, 0x0195
    1ea6:	f0 90 96 01 	lds	r15, 0x0196
    1eaa:	00 91 97 01 	lds	r16, 0x0197
    1eae:	10 91 98 01 	lds	r17, 0x0198
//    irc_dif_msg[2] = 0;
//    irc_dif_msg[3] = 0;
//    irc_dif_msg[4] = 0;

    // odeslání informace o prvním nasetování
    if (irc1_wait4set > 0){
    1eb2:	80 91 9c 00 	lds	r24, 0x009C
    1eb6:	88 23       	and	r24, r24
    1eb8:	61 f0       	breq	.+24     	; 0x1ed2 <irc1_watch+0x148>
      char * msg ;
      irc1_wait4set = 0;
    1eba:	10 92 9c 00 	sts	0x009C, r1
      msg =(void*) mmalloc (DATASIZE);
    1ebe:	8a e0       	ldi	r24, 0x0A	; 10
    1ec0:	90 e0       	ldi	r25, 0x00	; 0
    1ec2:	0e 94 a4 1d 	call	0x3b48	; 0x3b48 <mmalloc>
    1ec6:	fc 01       	movw	r30, r24

      msg[0] = MSGN_IRC1_SETCOMPLETED;
    1ec8:	86 e9       	ldi	r24, 0x96	; 150
    1eca:	80 83       	st	Z, r24
      new_msg(msg);
    1ecc:	cf 01       	movw	r24, r30
    1ece:	0e 94 21 0a 	call	0x1442	; 0x1442 <new_msg>
    }

    irc_counter = irc_set_on_value;
    1ed2:	80 91 98 00 	lds	r24, 0x0098
    1ed6:	90 91 99 00 	lds	r25, 0x0099
    1eda:	a0 91 9a 00 	lds	r26, 0x009A
    1ede:	b0 91 9b 00 	lds	r27, 0x009B
    1ee2:	80 93 95 01 	sts	0x0195, r24
    1ee6:	90 93 96 01 	sts	0x0196, r25
    1eea:	a0 93 97 01 	sts	0x0197, r26
    1eee:	b0 93 98 01 	sts	0x0198, r27
  // 
  
  if ((((zmena_stavu >> 2) & 0x01 ) == 1) && (last_oper_with_irc_counter == 1) && (((stav >> 2 ) & 1) == 0)){
    int dif = 0;

    dif = irc_set_on_value - irc_counter;
    1ef2:	95 01       	movw	r18, r10
    1ef4:	2e 19       	sub	r18, r14
    1ef6:	3f 09       	sbc	r19, r15
    irc_counter = irc_set_on_value;


    //irc_send_msg();
    // tady by šlo tršku nahnat
    if ((dif * 0.0001 * irc_k) > 10){
    1ef8:	37 ff       	sbrs	r19, 7
    1efa:	03 c0       	rjmp	.+6      	; 0x1f02 <irc1_watch+0x178>
    1efc:	30 95       	com	r19
    1efe:	21 95       	neg	r18
    1f00:	3f 4f       	sbci	r19, 0xFF	; 255
    1f02:	b9 01       	movw	r22, r18
    1f04:	88 27       	eor	r24, r24
    1f06:	77 fd       	sbrc	r23, 7
    1f08:	80 95       	com	r24
    1f0a:	98 2f       	mov	r25, r24
    1f0c:	0e 94 7d 22 	call	0x44fa	; 0x44fa <__floatsisf>
    1f10:	27 e1       	ldi	r18, 0x17	; 23
    1f12:	37 eb       	ldi	r19, 0xB7	; 183
    1f14:	41 ed       	ldi	r20, 0xD1	; 209
    1f16:	58 e3       	ldi	r21, 0x38	; 56
    1f18:	0e 94 31 23 	call	0x4662	; 0x4662 <__mulsf3>
    1f1c:	7b 01       	movw	r14, r22
    1f1e:	8c 01       	movw	r16, r24
    1f20:	60 91 96 00 	lds	r22, 0x0096
    1f24:	70 91 97 00 	lds	r23, 0x0097
    1f28:	80 e0       	ldi	r24, 0x00	; 0
    1f2a:	90 e0       	ldi	r25, 0x00	; 0
    1f2c:	0e 94 7b 22 	call	0x44f6	; 0x44f6 <__floatunsisf>
    1f30:	9b 01       	movw	r18, r22
    1f32:	ac 01       	movw	r20, r24
    1f34:	c8 01       	movw	r24, r16
    1f36:	b7 01       	movw	r22, r14
    1f38:	0e 94 31 23 	call	0x4662	; 0x4662 <__mulsf3>
    1f3c:	20 e0       	ldi	r18, 0x00	; 0
    1f3e:	30 e0       	ldi	r19, 0x00	; 0
    1f40:	40 e2       	ldi	r20, 0x20	; 32
    1f42:	51 e4       	ldi	r21, 0x41	; 65
    1f44:	0e 94 2d 23 	call	0x465a	; 0x465a <__gesf2>
    1f48:	18 16       	cp	r1, r24
    1f4a:	1c f4       	brge	.+6      	; 0x1f52 <irc1_watch+0x1c8>
      new_error(83);
    1f4c:	83 e5       	ldi	r24, 0x53	; 83
    1f4e:	0e 94 33 18 	call	0x3066	; 0x3066 <new_error>
    
  }
  

    
  prev_state = stav;
    1f52:	90 92 9a 01 	sts	0x019A, r9
  
}
    1f56:	1f 91       	pop	r17
    1f58:	0f 91       	pop	r16
    1f5a:	ff 90       	pop	r15
    1f5c:	ef 90       	pop	r14
    1f5e:	df 90       	pop	r13
    1f60:	cf 90       	pop	r12
    1f62:	bf 90       	pop	r11
    1f64:	af 90       	pop	r10
    1f66:	9f 90       	pop	r9
    1f68:	08 95       	ret

00001f6a <set_irc1_set_on_value_mm>:
}

/// Nastavení hodnoty.
/// Vstupem je vzdálenost nastavovacíhoo bodu od počátku v centimetrech vynásobená deseti.
/// tj 65 cm je 650
void set_irc1_set_on_value_mm(int32_t q){
    1f6a:	ef 92       	push	r14
    1f6c:	ff 92       	push	r15
    1f6e:	0f 93       	push	r16
    1f70:	1f 93       	push	r17
  // je tu jen 1000 místo 10000. Je to protože ta vstupní hodnota je přenásobená deseti, tak je
  // třeba jí vydělit
  irc_set_on_value = (int32_t)(q * (1000.0 /(irc_k)));
    1f72:	0e 94 7d 22 	call	0x44fa	; 0x44fa <__floatsisf>
    1f76:	7b 01       	movw	r14, r22
    1f78:	8c 01       	movw	r16, r24
    1f7a:	60 91 96 00 	lds	r22, 0x0096
    1f7e:	70 91 97 00 	lds	r23, 0x0097
    1f82:	80 e0       	ldi	r24, 0x00	; 0
    1f84:	90 e0       	ldi	r25, 0x00	; 0
    1f86:	0e 94 7b 22 	call	0x44f6	; 0x44f6 <__floatunsisf>
    1f8a:	9b 01       	movw	r18, r22
    1f8c:	ac 01       	movw	r20, r24
    1f8e:	60 e0       	ldi	r22, 0x00	; 0
    1f90:	70 e0       	ldi	r23, 0x00	; 0
    1f92:	8a e7       	ldi	r24, 0x7A	; 122
    1f94:	94 e4       	ldi	r25, 0x44	; 68
    1f96:	0e 94 e2 21 	call	0x43c4	; 0x43c4 <__divsf3>
    1f9a:	9b 01       	movw	r18, r22
    1f9c:	ac 01       	movw	r20, r24
    1f9e:	c8 01       	movw	r24, r16
    1fa0:	b7 01       	movw	r22, r14
    1fa2:	0e 94 31 23 	call	0x4662	; 0x4662 <__mulsf3>
    1fa6:	0e 94 4a 22 	call	0x4494	; 0x4494 <__fixsfsi>
    1faa:	ab 01       	movw	r20, r22
    1fac:	bc 01       	movw	r22, r24
    1fae:	40 93 98 00 	sts	0x0098, r20
    1fb2:	50 93 99 00 	sts	0x0099, r21
    1fb6:	60 93 9a 00 	sts	0x009A, r22
    1fba:	70 93 9b 00 	sts	0x009B, r23
  eeprom_w32((void *)ee_irc_k,irc_set_on_value);
    1fbe:	84 e0       	ldi	r24, 0x04	; 4
    1fc0:	90 e0       	ldi	r25, 0x00	; 0
    1fc2:	0e 94 22 12 	call	0x2444	; 0x2444 <eeprom_w32>
}
    1fc6:	1f 91       	pop	r17
    1fc8:	0f 91       	pop	r16
    1fca:	ff 90       	pop	r15
    1fcc:	ef 90       	pop	r14
    1fce:	08 95       	ret

00001fd0 <set_irc1_k_mm>:
/// Vstupem je číslo, které odpodvídá kolik milimetrů je na jednu otáčku.
void set_irc1_k_mm (uint16_t i) {

  //10000/480 = 125/6, 120 pulzů * 4 hrany  = 480
  // irc_k = (i * 125) / (60); // 125/60 = 25/12 
  irc_k = (i * 25) / (12);
    1fd0:	29 e1       	ldi	r18, 0x19	; 25
    1fd2:	30 e0       	ldi	r19, 0x00	; 0
    1fd4:	ac 01       	movw	r20, r24
    1fd6:	42 9f       	mul	r20, r18
    1fd8:	c0 01       	movw	r24, r0
    1fda:	43 9f       	mul	r20, r19
    1fdc:	90 0d       	add	r25, r0
    1fde:	52 9f       	mul	r21, r18
    1fe0:	90 0d       	add	r25, r0
    1fe2:	11 24       	eor	r1, r1
    1fe4:	6c e0       	ldi	r22, 0x0C	; 12
    1fe6:	70 e0       	ldi	r23, 0x00	; 0
    1fe8:	0e 94 94 23 	call	0x4728	; 0x4728 <__udivmodhi4>
    1fec:	60 93 96 00 	sts	0x0096, r22
    1ff0:	70 93 97 00 	sts	0x0097, r23
  eeprom_w16((void *)ee_irc_k,irc_k);
    1ff4:	84 e0       	ldi	r24, 0x04	; 4
    1ff6:	90 e0       	ldi	r25, 0x00	; 0
    1ff8:	0e 94 43 12 	call	0x2486	; 0x2486 <eeprom_w16>
}
    1ffc:	08 95       	ret

00001ffe <get_irc2_set_on_value>:
//void irc_watch(void);
//void irc_send_msg(void);
//void set_irc_k_mm(uint16_t i);
//void set_irc_set_on_value_mm(int32_t q);

int32_t get_irc2_set_on_value(){
    1ffe:	60 91 9f 00 	lds	r22, 0x009F
    2002:	70 91 a0 00 	lds	r23, 0x00A0
  return irc_set_on_value;
}
    2006:	80 91 a1 00 	lds	r24, 0x00A1
    200a:	90 91 a2 00 	lds	r25, 0x00A2
    200e:	08 95       	ret

00002010 <set_irc2_counter>:
//void set_irc_set_on_value(int32_t a){
//  irc_set_on_value = a;
//}

void set_irc2_counter (int32_t a){
  irc_counter = a;
    2010:	60 93 9b 01 	sts	0x019B, r22
    2014:	70 93 9c 01 	sts	0x019C, r23
    2018:	80 93 9d 01 	sts	0x019D, r24
    201c:	90 93 9e 01 	sts	0x019E, r25
}
    2020:	08 95       	ret

00002022 <get_irc2_counter>:

int32_t get_irc2_counter(void){
    2022:	60 91 9b 01 	lds	r22, 0x019B
    2026:	70 91 9c 01 	lds	r23, 0x019C
  return irc_counter;
}
    202a:	80 91 9d 01 	lds	r24, 0x019D
    202e:	90 91 9e 01 	lds	r25, 0x019E
    2032:	08 95       	ret

00002034 <set_irc2_k>:

void set_irc2_k(uint16_t a){
  irc_k = a;
    2034:	90 93 9e 00 	sts	0x009E, r25
    2038:	80 93 9d 00 	sts	0x009D, r24
}
    203c:	08 95       	ret

0000203e <irc2_get_k>:
  eeprom_w16((void *)ee_irc_k,irc_k);
}

uint16_t irc2_get_k(void){
  return irc_k;
}
    203e:	80 91 9d 00 	lds	r24, 0x009D
    2042:	90 91 9e 00 	lds	r25, 0x009E
    2046:	08 95       	ret

00002048 <set_irc2_set_on_value>:
  irc_set_on_value = (int32_t)(q * (1000.0 /(irc_k)));
  eeprom_w32((void *)ee_irc_k,irc_set_on_value);
}

void set_irc2_set_on_value(int32_t a ){
  irc_set_on_value = a;
    2048:	60 93 9f 00 	sts	0x009F, r22
    204c:	70 93 a0 00 	sts	0x00A0, r23
    2050:	80 93 a1 00 	sts	0x00A1, r24
    2054:	90 93 a2 00 	sts	0x00A2, r25
}
    2058:	08 95       	ret

0000205a <irc2_init>:
  // nastavení výstupu na jedničky

  // předchozí implementace - funkční
  //PORTD = PORTD | (1 << 5) | (1 << 6) | (1 << 7);

  A_PORT = A_PORT | (1 << A_BIT);
    205a:	c3 9a       	sbi	0x18, 3	; 24
  B_PORT = B_PORT | (1 << B_BIT);
    205c:	c4 9a       	sbi	0x18, 4	; 24
  SP_PORT = SP_PORT | (1 << SP_BIT);
    205e:	95 9a       	sbi	0x12, 5	; 18
  // předchozí implementace - funkční
  //prev_state = ((PIND) >> 5) & 0x07;


  prev_state = 0x00;
  prev_state = prev_state | (((A_PIN >> A_BIT) & 0x01) << 0);
    2060:	46 b3       	in	r20, 0x16	; 22
  prev_state = prev_state | (((B_PIN >> B_BIT) & 0x01) << 1);
    2062:	26 b3       	in	r18, 0x16	; 22
  prev_state = prev_state | (((SP_PIN >> SP_BIT) & 0x01) << 2);
    2064:	86 b3       	in	r24, 0x16	; 22
    2066:	22 95       	swap	r18
    2068:	2f 70       	andi	r18, 0x0F	; 15
    206a:	30 e0       	ldi	r19, 0x00	; 0
    206c:	21 70       	andi	r18, 0x01	; 1
    206e:	30 70       	andi	r19, 0x00	; 0
    2070:	22 0f       	add	r18, r18
    2072:	33 1f       	adc	r19, r19
    2074:	82 95       	swap	r24
    2076:	86 95       	lsr	r24
    2078:	87 70       	andi	r24, 0x07	; 7
    207a:	90 e0       	ldi	r25, 0x00	; 0
    207c:	81 70       	andi	r24, 0x01	; 1
    207e:	90 70       	andi	r25, 0x00	; 0
    2080:	88 0f       	add	r24, r24
    2082:	99 1f       	adc	r25, r25
    2084:	88 0f       	add	r24, r24
    2086:	99 1f       	adc	r25, r25
    2088:	28 2b       	or	r18, r24
    208a:	46 95       	lsr	r20
    208c:	46 95       	lsr	r20
    208e:	46 95       	lsr	r20
    2090:	41 70       	andi	r20, 0x01	; 1
    2092:	24 2b       	or	r18, r20
    2094:	20 93 a0 01 	sts	0x01A0, r18

}
    2098:	08 95       	ret

0000209a <irc2_get_l>:
}




uint16_t irc2_get_l(void){
    209a:	ef 92       	push	r14
    209c:	ff 92       	push	r15
    209e:	0f 93       	push	r16
    20a0:	1f 93       	push	r17
    20a2:	60 91 9b 01 	lds	r22, 0x019B
    20a6:	70 91 9c 01 	lds	r23, 0x019C
    20aa:	80 91 9d 01 	lds	r24, 0x019D
    20ae:	90 91 9e 01 	lds	r25, 0x019E
    20b2:	97 ff       	sbrs	r25, 7
    20b4:	04 c0       	rjmp	.+8      	; 0x20be <irc2_get_l+0x24>
    20b6:	60 e0       	ldi	r22, 0x00	; 0
    20b8:	70 e0       	ldi	r23, 0x00	; 0
    20ba:	80 e0       	ldi	r24, 0x00	; 0
    20bc:	90 e0       	ldi	r25, 0x00	; 0
    20be:	0e 94 7d 22 	call	0x44fa	; 0x44fa <__floatsisf>
    20c2:	27 e1       	ldi	r18, 0x17	; 23
    20c4:	37 eb       	ldi	r19, 0xB7	; 183
    20c6:	41 ed       	ldi	r20, 0xD1	; 209
    20c8:	58 e3       	ldi	r21, 0x38	; 56
    20ca:	0e 94 31 23 	call	0x4662	; 0x4662 <__mulsf3>
    20ce:	7b 01       	movw	r14, r22
    20d0:	8c 01       	movw	r16, r24
    20d2:	60 91 9d 00 	lds	r22, 0x009D
    20d6:	70 91 9e 00 	lds	r23, 0x009E
    20da:	80 e0       	ldi	r24, 0x00	; 0
    20dc:	90 e0       	ldi	r25, 0x00	; 0
    20de:	0e 94 7b 22 	call	0x44f6	; 0x44f6 <__floatunsisf>
    20e2:	9b 01       	movw	r18, r22
    20e4:	ac 01       	movw	r20, r24
    20e6:	c8 01       	movw	r24, r16
    20e8:	b7 01       	movw	r22, r14
    20ea:	0e 94 31 23 	call	0x4662	; 0x4662 <__mulsf3>
    20ee:	0e 94 4f 22 	call	0x449e	; 0x449e <__fixunssfsi>
  //out = (uint16_t) (count * (0.0001 * irc_k));

  out = count * 0.0001 * irc_k;
  return out;

}
    20f2:	cb 01       	movw	r24, r22
    20f4:	1f 91       	pop	r17
    20f6:	0f 91       	pop	r16
    20f8:	ff 90       	pop	r15
    20fa:	ef 90       	pop	r14
    20fc:	08 95       	ret

000020fe <irc2_watch>:
/// funkce zavolana, je zkontrolovano, zda nedoslo okd minuleho zavolani ke
/// zmene na vstupech irc. Pokud ano, jsou provedeny prislusne korky - zvyseni
/// nebo snizeni citace irc a pripadne odeslani namerene hodnoty. Namerena
/// hodnota je dana jako hodnota irc cidla krat
/// konstanta (obvykle mensi nez jedna).
void irc2_watch(void){
    20fe:	9f 92       	push	r9
    2100:	af 92       	push	r10
    2102:	bf 92       	push	r11
    2104:	cf 92       	push	r12
    2106:	df 92       	push	r13
    2108:	ef 92       	push	r14
    210a:	ff 92       	push	r15
    210c:	0f 93       	push	r16
    210e:	1f 93       	push	r17
  //předchozí implementace - funkční
  //stavt = ((PIND) >> 5) & 0x07;
  

  stav = 0x00;
  stav = stav | (((A_PIN >> A_BIT) & 0x01) << 0);
    2110:	46 b3       	in	r20, 0x16	; 22
  stav = stav | (((B_PIN >> B_BIT) & 0x01) << 1);
    2112:	26 b3       	in	r18, 0x16	; 22
  stav = stav | (((SP_PIN >> SP_BIT) & 0x01) << 2);
    2114:	86 b3       	in	r24, 0x16	; 22
    2116:	22 95       	swap	r18
    2118:	2f 70       	andi	r18, 0x0F	; 15
    211a:	30 e0       	ldi	r19, 0x00	; 0
    211c:	21 70       	andi	r18, 0x01	; 1
    211e:	30 70       	andi	r19, 0x00	; 0
    2120:	22 0f       	add	r18, r18
    2122:	33 1f       	adc	r19, r19
    2124:	82 95       	swap	r24
    2126:	86 95       	lsr	r24
    2128:	87 70       	andi	r24, 0x07	; 7
    212a:	90 e0       	ldi	r25, 0x00	; 0
    212c:	81 70       	andi	r24, 0x01	; 1
    212e:	90 70       	andi	r25, 0x00	; 0
    2130:	88 0f       	add	r24, r24
    2132:	99 1f       	adc	r25, r25
    2134:	88 0f       	add	r24, r24
    2136:	99 1f       	adc	r25, r25
    2138:	92 2e       	mov	r9, r18
    213a:	98 2a       	or	r9, r24
    213c:	46 95       	lsr	r20
    213e:	46 95       	lsr	r20
    2140:	46 95       	lsr	r20
    2142:	41 70       	andi	r20, 0x01	; 1
    2144:	94 2a       	or	r9, r20


  si_print_dbgirc2(stav);
    2146:	80 91 b6 01 	lds	r24, 0x01B6
    214a:	82 95       	swap	r24
    214c:	8f 70       	andi	r24, 0x0F	; 15
    214e:	80 ff       	sbrs	r24, 0
    2150:	08 c0       	rjmp	.+16     	; 0x2162 <irc2_watch+0x64>
    2152:	49 2d       	mov	r20, r9
    2154:	40 5d       	subi	r20, 0xD0	; 208
    2156:	80 e0       	ldi	r24, 0x00	; 0
    2158:	90 e0       	ldi	r25, 0x00	; 0
    215a:	62 e0       	ldi	r22, 0x02	; 2
    215c:	70 e0       	ldi	r23, 0x00	; 0
    215e:	0e 94 34 13 	call	0x2668	; 0x2668 <printcxyd>
  //printcxyd(0,0,'0'+ stav);
  //printcxyd(0,1,'0'+ stavt);

  zmena_stavu = stav ^ prev_state;
    2162:	10 91 a0 01 	lds	r17, 0x01A0
    2166:	19 25       	eor	r17, r9
  ruzne = (((stav >> 0) ^ (stav >> 1)) & 0x01);
    2168:	29 2d       	mov	r18, r9
    216a:	26 95       	lsr	r18
    216c:	29 25       	eor	r18, r9
    216e:	21 70       	andi	r18, 0x01	; 1

  // zde se resi pricitani a odecitani pri zmenach vstupu A a B Jestlize dojde
  // ke zmene nektereho vstupu, pak se porovna zda jsou oba bity stejne, ci ne
  // a podle toho se citac bud inkrementuje nebo dekrementuje.
  // Rovnez je zde resen erroru pri soucasne zmene obou vstupu.
  switch ((zmena_stavu >> 0) & 0x03){
    2170:	81 2f       	mov	r24, r17
    2172:	90 e0       	ldi	r25, 0x00	; 0
    2174:	83 70       	andi	r24, 0x03	; 3
    2176:	90 70       	andi	r25, 0x00	; 0
    2178:	82 30       	cpi	r24, 0x02	; 2
    217a:	91 05       	cpc	r25, r1
    217c:	81 f0       	breq	.+32     	; 0x219e <irc2_watch+0xa0>
    217e:	83 30       	cpi	r24, 0x03	; 3
    2180:	91 05       	cpc	r25, r1
    2182:	a1 f1       	breq	.+104    	; 0x21ec <irc2_watch+0xee>
    2184:	01 97       	sbiw	r24, 0x01	; 1
    2186:	a9 f5       	brne	.+106    	; 0x21f2 <irc2_watch+0xf4>
    2188:	80 91 9b 01 	lds	r24, 0x019B
    218c:	90 91 9c 01 	lds	r25, 0x019C
    2190:	a0 91 9d 01 	lds	r26, 0x019D
    2194:	b0 91 9e 01 	lds	r27, 0x019E
    case 1 :
      // zmenaA
      if (ruzne == 0){
    2198:	22 23       	and	r18, r18
    219a:	59 f4       	brne	.+22     	; 0x21b2 <irc2_watch+0xb4>
    219c:	18 c0       	rjmp	.+48     	; 0x21ce <irc2_watch+0xd0>
    219e:	80 91 9b 01 	lds	r24, 0x019B
    21a2:	90 91 9c 01 	lds	r25, 0x019C
    21a6:	a0 91 9d 01 	lds	r26, 0x019D
    21aa:	b0 91 9e 01 	lds	r27, 0x019E
        //irc_send_msg();
      }
      break;
    case 2 :
      // zmenaB
      if (ruzne == 0){
    21ae:	22 23       	and	r18, r18
    21b0:	71 f4       	brne	.+28     	; 0x21ce <irc2_watch+0xd0>
        irc_counter--;
    21b2:	01 97       	sbiw	r24, 0x01	; 1
    21b4:	a1 09       	sbc	r26, r1
    21b6:	b1 09       	sbc	r27, r1
    21b8:	80 93 9b 01 	sts	0x019B, r24
    21bc:	90 93 9c 01 	sts	0x019C, r25
    21c0:	a0 93 9d 01 	sts	0x019D, r26
    21c4:	b0 93 9e 01 	sts	0x019E, r27
        last_oper_with_irc_counter = 0;
    21c8:	10 92 9f 01 	sts	0x019F, r1
    21cc:	12 c0       	rjmp	.+36     	; 0x21f2 <irc2_watch+0xf4>
        //irc_send_msg();
      }
      else{
        irc_counter++;
    21ce:	01 96       	adiw	r24, 0x01	; 1
    21d0:	a1 1d       	adc	r26, r1
    21d2:	b1 1d       	adc	r27, r1
    21d4:	80 93 9b 01 	sts	0x019B, r24
    21d8:	90 93 9c 01 	sts	0x019C, r25
    21dc:	a0 93 9d 01 	sts	0x019D, r26
    21e0:	b0 93 9e 01 	sts	0x019E, r27
        last_oper_with_irc_counter = 1;
    21e4:	81 e0       	ldi	r24, 0x01	; 1
    21e6:	80 93 9f 01 	sts	0x019F, r24
    21ea:	03 c0       	rjmp	.+6      	; 0x21f2 <irc2_watch+0xf4>
      }
      break;
    case 3 :
      // oba
      // error
      new_error(6);
    21ec:	86 e0       	ldi	r24, 0x06	; 6
    21ee:	0e 94 33 18 	call	0x3066	; 0x3066 <new_error>
  // zde je reseno nastavovani irc citace
  // pokud se objevi jednicka na pinc.6 a pohybujeme se nahoru (nula je tam
  // pri obraceni vstupu)
  //

  if ((((zmena_stavu >> 2) & 0x01 ) == 1) && (last_oper_with_irc_counter == 1) && (((stav >> 2 ) & 1) == 0)){
    21f2:	81 2f       	mov	r24, r17
    21f4:	86 95       	lsr	r24
    21f6:	86 95       	lsr	r24
    21f8:	80 ff       	sbrs	r24, 0
    21fa:	6a c0       	rjmp	.+212    	; 0x22d0 <irc2_watch+0x1d2>
    21fc:	80 91 9f 01 	lds	r24, 0x019F
    2200:	81 30       	cpi	r24, 0x01	; 1
    2202:	09 f0       	breq	.+2      	; 0x2206 <irc2_watch+0x108>
    2204:	65 c0       	rjmp	.+202    	; 0x22d0 <irc2_watch+0x1d2>
    2206:	89 2d       	mov	r24, r9
    2208:	86 95       	lsr	r24
    220a:	86 95       	lsr	r24
    220c:	80 fd       	sbrc	r24, 0
    220e:	60 c0       	rjmp	.+192    	; 0x22d0 <irc2_watch+0x1d2>
    int dif = 0;

    dif = irc_set_on_value - irc_counter;
    2210:	a0 90 9f 00 	lds	r10, 0x009F
    2214:	b0 90 a0 00 	lds	r11, 0x00A0
    2218:	c0 90 a1 00 	lds	r12, 0x00A1
    221c:	d0 90 a2 00 	lds	r13, 0x00A2
    2220:	e0 90 9b 01 	lds	r14, 0x019B
    2224:	f0 90 9c 01 	lds	r15, 0x019C
    2228:	00 91 9d 01 	lds	r16, 0x019D
    222c:	10 91 9e 01 	lds	r17, 0x019E
//    irc_dif_msg[2] = 0;
//    irc_dif_msg[3] = 0;
//    irc_dif_msg[4] = 0;

    // odeslání informace o prvním nasetování
    if (irc2_wait4set > 0){
    2230:	80 91 a3 00 	lds	r24, 0x00A3
    2234:	88 23       	and	r24, r24
    2236:	61 f0       	breq	.+24     	; 0x2250 <irc2_watch+0x152>
      char * msg ;
      irc2_wait4set =0;
    2238:	10 92 a3 00 	sts	0x00A3, r1
      msg =(void*) mmalloc (DATASIZE);
    223c:	8a e0       	ldi	r24, 0x0A	; 10
    223e:	90 e0       	ldi	r25, 0x00	; 0
    2240:	0e 94 a4 1d 	call	0x3b48	; 0x3b48 <mmalloc>
    2244:	fc 01       	movw	r30, r24

      msg[0] = MSGN_IRC2_SETCOMPLETED;
    2246:	87 e9       	ldi	r24, 0x97	; 151
    2248:	80 83       	st	Z, r24
      new_msg(msg);
    224a:	cf 01       	movw	r24, r30
    224c:	0e 94 21 0a 	call	0x1442	; 0x1442 <new_msg>
    }

    irc_counter = irc_set_on_value;
    2250:	80 91 9f 00 	lds	r24, 0x009F
    2254:	90 91 a0 00 	lds	r25, 0x00A0
    2258:	a0 91 a1 00 	lds	r26, 0x00A1
    225c:	b0 91 a2 00 	lds	r27, 0x00A2
    2260:	80 93 9b 01 	sts	0x019B, r24
    2264:	90 93 9c 01 	sts	0x019C, r25
    2268:	a0 93 9d 01 	sts	0x019D, r26
    226c:	b0 93 9e 01 	sts	0x019E, r27
  //

  if ((((zmena_stavu >> 2) & 0x01 ) == 1) && (last_oper_with_irc_counter == 1) && (((stav >> 2 ) & 1) == 0)){
    int dif = 0;

    dif = irc_set_on_value - irc_counter;
    2270:	95 01       	movw	r18, r10
    2272:	2e 19       	sub	r18, r14
    2274:	3f 09       	sbc	r19, r15
    irc_counter = irc_set_on_value;


    //irc_send_msg();
    // tady by šlo tršku nahnat
    if ((dif * 0.0001 * irc_k) > 10){
    2276:	37 ff       	sbrs	r19, 7
    2278:	03 c0       	rjmp	.+6      	; 0x2280 <irc2_watch+0x182>
    227a:	30 95       	com	r19
    227c:	21 95       	neg	r18
    227e:	3f 4f       	sbci	r19, 0xFF	; 255
    2280:	b9 01       	movw	r22, r18
    2282:	88 27       	eor	r24, r24
    2284:	77 fd       	sbrc	r23, 7
    2286:	80 95       	com	r24
    2288:	98 2f       	mov	r25, r24
    228a:	0e 94 7d 22 	call	0x44fa	; 0x44fa <__floatsisf>
    228e:	27 e1       	ldi	r18, 0x17	; 23
    2290:	37 eb       	ldi	r19, 0xB7	; 183
    2292:	41 ed       	ldi	r20, 0xD1	; 209
    2294:	58 e3       	ldi	r21, 0x38	; 56
    2296:	0e 94 31 23 	call	0x4662	; 0x4662 <__mulsf3>
    229a:	7b 01       	movw	r14, r22
    229c:	8c 01       	movw	r16, r24
    229e:	60 91 9d 00 	lds	r22, 0x009D
    22a2:	70 91 9e 00 	lds	r23, 0x009E
    22a6:	80 e0       	ldi	r24, 0x00	; 0
    22a8:	90 e0       	ldi	r25, 0x00	; 0
    22aa:	0e 94 7b 22 	call	0x44f6	; 0x44f6 <__floatunsisf>
    22ae:	9b 01       	movw	r18, r22
    22b0:	ac 01       	movw	r20, r24
    22b2:	c8 01       	movw	r24, r16
    22b4:	b7 01       	movw	r22, r14
    22b6:	0e 94 31 23 	call	0x4662	; 0x4662 <__mulsf3>
    22ba:	20 e0       	ldi	r18, 0x00	; 0
    22bc:	30 e0       	ldi	r19, 0x00	; 0
    22be:	40 e2       	ldi	r20, 0x20	; 32
    22c0:	51 e4       	ldi	r21, 0x41	; 65
    22c2:	0e 94 2d 23 	call	0x465a	; 0x465a <__gesf2>
    22c6:	18 16       	cp	r1, r24
    22c8:	1c f4       	brge	.+6      	; 0x22d0 <irc2_watch+0x1d2>
      new_error(83);
    22ca:	83 e5       	ldi	r24, 0x53	; 83
    22cc:	0e 94 33 18 	call	0x3066	; 0x3066 <new_error>

  }



  prev_state = stav;
    22d0:	90 92 a0 01 	sts	0x01A0, r9

}
    22d4:	1f 91       	pop	r17
    22d6:	0f 91       	pop	r16
    22d8:	ff 90       	pop	r15
    22da:	ef 90       	pop	r14
    22dc:	df 90       	pop	r13
    22de:	cf 90       	pop	r12
    22e0:	bf 90       	pop	r11
    22e2:	af 90       	pop	r10
    22e4:	9f 90       	pop	r9
    22e6:	08 95       	ret

000022e8 <set_irc2_set_on_value_mm>:
}

/// Nastavení hodnoty.
/// Vstupem je vzdálenost nastavovacíhoo bodu od počátku v centimetrech vynásobená deseti.
/// tj 65 cm je 650
void set_irc2_set_on_value_mm(int32_t q){
    22e8:	ef 92       	push	r14
    22ea:	ff 92       	push	r15
    22ec:	0f 93       	push	r16
    22ee:	1f 93       	push	r17
  // je tu jen 1000 místo 10000. Je to protože ta vstupní hodnota je přenásobená deseti, tak je
  // třeba jí vydělit
  irc_set_on_value = (int32_t)(q * (1000.0 /(irc_k)));
    22f0:	0e 94 7d 22 	call	0x44fa	; 0x44fa <__floatsisf>
    22f4:	7b 01       	movw	r14, r22
    22f6:	8c 01       	movw	r16, r24
    22f8:	60 91 9d 00 	lds	r22, 0x009D
    22fc:	70 91 9e 00 	lds	r23, 0x009E
    2300:	80 e0       	ldi	r24, 0x00	; 0
    2302:	90 e0       	ldi	r25, 0x00	; 0
    2304:	0e 94 7b 22 	call	0x44f6	; 0x44f6 <__floatunsisf>
    2308:	9b 01       	movw	r18, r22
    230a:	ac 01       	movw	r20, r24
    230c:	60 e0       	ldi	r22, 0x00	; 0
    230e:	70 e0       	ldi	r23, 0x00	; 0
    2310:	8a e7       	ldi	r24, 0x7A	; 122
    2312:	94 e4       	ldi	r25, 0x44	; 68
    2314:	0e 94 e2 21 	call	0x43c4	; 0x43c4 <__divsf3>
    2318:	9b 01       	movw	r18, r22
    231a:	ac 01       	movw	r20, r24
    231c:	c8 01       	movw	r24, r16
    231e:	b7 01       	movw	r22, r14
    2320:	0e 94 31 23 	call	0x4662	; 0x4662 <__mulsf3>
    2324:	0e 94 4a 22 	call	0x4494	; 0x4494 <__fixsfsi>
    2328:	ab 01       	movw	r20, r22
    232a:	bc 01       	movw	r22, r24
    232c:	40 93 9f 00 	sts	0x009F, r20
    2330:	50 93 a0 00 	sts	0x00A0, r21
    2334:	60 93 a1 00 	sts	0x00A1, r22
    2338:	70 93 a2 00 	sts	0x00A2, r23
  eeprom_w32((void *)ee_irc_k,irc_set_on_value);
    233c:	84 e0       	ldi	r24, 0x04	; 4
    233e:	90 e0       	ldi	r25, 0x00	; 0
    2340:	0e 94 22 12 	call	0x2444	; 0x2444 <eeprom_w32>
}
    2344:	1f 91       	pop	r17
    2346:	0f 91       	pop	r16
    2348:	ff 90       	pop	r15
    234a:	ef 90       	pop	r14
    234c:	08 95       	ret

0000234e <set_irc2_k_mm>:
/// Vstupem je číslo, které odpodvídá kolik milimetrů je na jednu otáčku.
void set_irc2_k_mm (uint16_t i) {

  //10000/480 = 125/6, 120 pulzů * 4 hrany  = 480
  // irc_k = (i * 125) / (60); // 125/60 = 25/12
  irc_k = (i * 25) / (12);
    234e:	29 e1       	ldi	r18, 0x19	; 25
    2350:	30 e0       	ldi	r19, 0x00	; 0
    2352:	ac 01       	movw	r20, r24
    2354:	42 9f       	mul	r20, r18
    2356:	c0 01       	movw	r24, r0
    2358:	43 9f       	mul	r20, r19
    235a:	90 0d       	add	r25, r0
    235c:	52 9f       	mul	r21, r18
    235e:	90 0d       	add	r25, r0
    2360:	11 24       	eor	r1, r1
    2362:	6c e0       	ldi	r22, 0x0C	; 12
    2364:	70 e0       	ldi	r23, 0x00	; 0
    2366:	0e 94 94 23 	call	0x4728	; 0x4728 <__udivmodhi4>
    236a:	60 93 9d 00 	sts	0x009D, r22
    236e:	70 93 9e 00 	sts	0x009E, r23
  eeprom_w16((void *)ee_irc_k,irc_k);
    2372:	84 e0       	ldi	r24, 0x04	; 4
    2374:	90 e0       	ldi	r25, 0x00	; 0
    2376:	0e 94 43 12 	call	0x2486	; 0x2486 <eeprom_w16>
}
    237a:	08 95       	ret

0000237c <eeprom_read_byte>:

/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    237c:	9c 01       	movw	r18, r24
    do {} while (!eeprom_is_ready ());
    237e:	e1 99       	sbic	0x1c, 1	; 28
    2380:	fe cf       	rjmp	.-4      	; 0x237e <eeprom_read_byte+0x2>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    2382:	3f bb       	out	0x1f, r19	; 31
    2384:	2e bb       	out	0x1e, r18	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    2386:	e0 9a       	sbi	0x1c, 0	; 28
    2388:	8d b3       	in	r24, 0x1d	; 29
        : "i" (_SFR_IO_ADDR(EECR)),
          "i" (EERE),
          "i" (_SFR_IO_ADDR(EEDR))
    );
    return __result;
}
    238a:	08 95       	ret

0000238c <eeprom_write_byte>:

/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    238c:	9c 01       	movw	r18, r24
    do {} while (!eeprom_is_ready ());
    238e:	e1 99       	sbic	0x1c, 1	; 28
    2390:	fe cf       	rjmp	.-4      	; 0x238e <eeprom_write_byte+0x2>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    2392:	3f bb       	out	0x1f, r19	; 31
    2394:	2e bb       	out	0x1e, r18	; 30
#endif
    EEDR = __value;
    2396:	6d bb       	out	0x1d, r22	; 29

    __asm__ __volatile__ (
    2398:	0f b6       	in	r0, 0x3f	; 63
    239a:	f8 94       	cli
    239c:	e2 9a       	sbi	0x1c, 2	; 28
    239e:	e1 9a       	sbi	0x1c, 1	; 28
    23a0:	0f be       	out	0x3f, r0	; 63
          [__sreg]  "i" (_SFR_IO_ADDR(SREG)),
          [__eemwe] "i" (EEMWE),
          [__eewe]  "i" (EEWE)
        : "r0"
    );
}
    23a2:	08 95       	ret

000023a4 <eeprom_w8>:
  wtch_enable2();
  wtch_reset2();
}

//8 bit
void eeprom_w8(void *uiAddress, uint8_t c){
    23a4:	9c 01       	movw	r18, r24
  //cekame dokud neni volno
  wtch_reset2();
    23a6:	80 91 b4 01 	lds	r24, 0x01B4
    23aa:	90 91 b5 01 	lds	r25, 0x01B5
    23ae:	18 16       	cp	r1, r24
    23b0:	19 06       	cpc	r1, r25
    23b2:	14 f4       	brge	.+4      	; 0x23b8 <eeprom_w8+0x14>
    23b4:	80 e0       	ldi	r24, 0x00	; 0
    23b6:	90 e0       	ldi	r25, 0x00	; 0
    23b8:	90 93 b5 01 	sts	0x01B5, r25
    23bc:	80 93 b4 01 	sts	0x01B4, r24
    23c0:	a8 95       	wdr
  eeprom_busy_wait();
    23c2:	e1 99       	sbic	0x1c, 1	; 28
    23c4:	fe cf       	rjmp	.-4      	; 0x23c2 <eeprom_w8+0x1e>
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    23c6:	e1 99       	sbic	0x1c, 1	; 28
    23c8:	fe cf       	rjmp	.-4      	; 0x23c6 <eeprom_w8+0x22>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    23ca:	3f bb       	out	0x1f, r19	; 31
    23cc:	2e bb       	out	0x1e, r18	; 30
#endif
    EEDR = __value;
    23ce:	6d bb       	out	0x1d, r22	; 29

    __asm__ __volatile__ (
    23d0:	0f b6       	in	r0, 0x3f	; 63
    23d2:	f8 94       	cli
    23d4:	e2 9a       	sbi	0x1c, 2	; 28
    23d6:	e1 9a       	sbi	0x1c, 1	; 28
    23d8:	0f be       	out	0x3f, r0	; 63
  eeprom_write_byte(uiAddress, c);
  
}
    23da:	08 95       	ret

000023dc <eeprom_r8>:

char eeprom_r8(void *uiAddress){
    23dc:	9c 01       	movw	r18, r24
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    23de:	e1 99       	sbic	0x1c, 1	; 28
    23e0:	fe cf       	rjmp	.-4      	; 0x23de <eeprom_r8+0x2>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    23e2:	3f bb       	out	0x1f, r19	; 31
    23e4:	2e bb       	out	0x1e, r18	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    23e6:	e0 9a       	sbi	0x1c, 0	; 28
    23e8:	8d b3       	in	r24, 0x1d	; 29
  return eeprom_read_byte(uiAddress);
}
    23ea:	08 95       	ret

000023ec <eeprom_r32>:
  //cekame dokud neni volno
  eeprom_busy_wait();
  eeprom_write_block( (void *)&data, uiAddress, 4);
}

uint32_t eeprom_r32(void *uiAddress){
    23ec:	df 93       	push	r29
    23ee:	cf 93       	push	r28
    23f0:	00 d0       	rcall	.+0      	; 0x23f2 <eeprom_r32+0x6>
    23f2:	00 d0       	rcall	.+0      	; 0x23f4 <eeprom_r32+0x8>
    23f4:	cd b7       	in	r28, 0x3d	; 61
    23f6:	de b7       	in	r29, 0x3e	; 62
    23f8:	bc 01       	movw	r22, r24
  wtch_reset2();
    23fa:	80 91 b4 01 	lds	r24, 0x01B4
    23fe:	90 91 b5 01 	lds	r25, 0x01B5
    2402:	18 16       	cp	r1, r24
    2404:	19 06       	cpc	r1, r25
    2406:	14 f4       	brge	.+4      	; 0x240c <eeprom_r32+0x20>
    2408:	80 e0       	ldi	r24, 0x00	; 0
    240a:	90 e0       	ldi	r25, 0x00	; 0
    240c:	90 93 b5 01 	sts	0x01B5, r25
    2410:	80 93 b4 01 	sts	0x01B4, r24
    2414:	a8 95       	wdr
  uint32_t out = 0;
    2416:	19 82       	std	Y+1, r1	; 0x01
    2418:	1a 82       	std	Y+2, r1	; 0x02
    241a:	1b 82       	std	Y+3, r1	; 0x03
    241c:	1c 82       	std	Y+4, r1	; 0x04
 */
static __inline__ void
eeprom_read_block (void *__dst, const void *__src, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eerd_block (__dst, __src, __n, eeprom_read_byte);
    241e:	ce 01       	movw	r24, r28
    2420:	01 96       	adiw	r24, 0x01	; 1
    2422:	44 e0       	ldi	r20, 0x04	; 4
    2424:	50 e0       	ldi	r21, 0x00	; 0
    2426:	2e eb       	ldi	r18, 0xBE	; 190
    2428:	31 e1       	ldi	r19, 0x11	; 17
    242a:	0e 94 da 1e 	call	0x3db4	; 0x3db4 <__eerd_block>
    242e:	69 81       	ldd	r22, Y+1	; 0x01
    2430:	7a 81       	ldd	r23, Y+2	; 0x02
  eeprom_read_block( (void *)&out, uiAddress, 4);
  
  return out;
}
    2432:	8b 81       	ldd	r24, Y+3	; 0x03
    2434:	9c 81       	ldd	r25, Y+4	; 0x04
    2436:	0f 90       	pop	r0
    2438:	0f 90       	pop	r0
    243a:	0f 90       	pop	r0
    243c:	0f 90       	pop	r0
    243e:	cf 91       	pop	r28
    2440:	df 91       	pop	r29
    2442:	08 95       	ret

00002444 <eeprom_w32>:
uint16_t eeprom_r16(void *uiAddress){
  return eeprom_read_word(uiAddress);
}

//32bit
void eeprom_w32(void *uiAddress, uint32_t data){
    2444:	df 93       	push	r29
    2446:	cf 93       	push	r28
    2448:	00 d0       	rcall	.+0      	; 0x244a <eeprom_w32+0x6>
    244a:	00 d0       	rcall	.+0      	; 0x244c <eeprom_w32+0x8>
    244c:	cd b7       	in	r28, 0x3d	; 61
    244e:	de b7       	in	r29, 0x3e	; 62
    2450:	49 83       	std	Y+1, r20	; 0x01
    2452:	5a 83       	std	Y+2, r21	; 0x02
    2454:	6b 83       	std	Y+3, r22	; 0x03
    2456:	7c 83       	std	Y+4, r23	; 0x04
  //cekame dokud neni volno
  eeprom_busy_wait();
    2458:	e1 99       	sbic	0x1c, 1	; 28
    245a:	fe cf       	rjmp	.-4      	; 0x2458 <eeprom_w32+0x14>
 */
static __inline__ void
eeprom_write_block (const void *__src, void *__dst, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eewr_block (__dst, __src, __n, eeprom_write_byte);
    245c:	be 01       	movw	r22, r28
    245e:	6f 5f       	subi	r22, 0xFF	; 255
    2460:	7f 4f       	sbci	r23, 0xFF	; 255
    2462:	44 e0       	ldi	r20, 0x04	; 4
    2464:	50 e0       	ldi	r21, 0x00	; 0
    2466:	26 ec       	ldi	r18, 0xC6	; 198
    2468:	31 e1       	ldi	r19, 0x11	; 17
    246a:	0e 94 0c 1f 	call	0x3e18	; 0x3e18 <__eewr_block>
  eeprom_write_block( (void *)&data, uiAddress, 4);
}
    246e:	0f 90       	pop	r0
    2470:	0f 90       	pop	r0
    2472:	0f 90       	pop	r0
    2474:	0f 90       	pop	r0
    2476:	cf 91       	pop	r28
    2478:	df 91       	pop	r29
    247a:	08 95       	ret

0000247c <eeprom_r16>:
    Read one 16-bit word (little endian) from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint16_t eeprom_read_word (const uint16_t *__p)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    return __eerd_word (__p, eeprom_read_byte);
    247c:	6e eb       	ldi	r22, 0xBE	; 190
    247e:	71 e1       	ldi	r23, 0x11	; 17
    2480:	0e 94 f6 1e 	call	0x3dec	; 0x3dec <__eerd_word>
  
}

uint16_t eeprom_r16(void *uiAddress){
  return eeprom_read_word(uiAddress);
}
    2484:	08 95       	ret

00002486 <eeprom_w16>:
}

//16bit
void eeprom_w16(void *uiAddress, uint16_t word){
  //cekame dokud neni volno
  wtch_reset2();
    2486:	20 91 b4 01 	lds	r18, 0x01B4
    248a:	30 91 b5 01 	lds	r19, 0x01B5
    248e:	12 16       	cp	r1, r18
    2490:	13 06       	cpc	r1, r19
    2492:	14 f4       	brge	.+4      	; 0x2498 <eeprom_w16+0x12>
    2494:	20 e0       	ldi	r18, 0x00	; 0
    2496:	30 e0       	ldi	r19, 0x00	; 0
    2498:	30 93 b5 01 	sts	0x01B5, r19
    249c:	20 93 b4 01 	sts	0x01B4, r18
    24a0:	a8 95       	wdr
  eeprom_busy_wait();
    24a2:	e1 99       	sbic	0x1c, 1	; 28
    24a4:	fe cf       	rjmp	.-4      	; 0x24a2 <eeprom_w16+0x1c>
    Write a word \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_word (uint16_t *__p, uint16_t __value)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eewr_word (__p, __value, eeprom_write_byte);
    24a6:	46 ec       	ldi	r20, 0xC6	; 198
    24a8:	51 e1       	ldi	r21, 0x11	; 17
    24aa:	0e 94 28 1f 	call	0x3e50	; 0x3e50 <__eewr_word>
  eeprom_write_word(uiAddress, word);
  
}
    24ae:	08 95       	ret

000024b0 <eeprom_save>:
}

void eeprom_save(void){
//  void * p_eeprom;
  
  wtch_reset2();
    24b0:	a8 95       	wdr
  wtch_disable2();
    24b2:	8f ef       	ldi	r24, 0xFF	; 255
    24b4:	9f ef       	ldi	r25, 0xFF	; 255
    24b6:	90 93 b5 01 	sts	0x01B5, r25
    24ba:	80 93 b4 01 	sts	0x01B4, r24
    24be:	88 e1       	ldi	r24, 0x18	; 24
    24c0:	0f b6       	in	r0, 0x3f	; 63
    24c2:	f8 94       	cli
    24c4:	81 bd       	out	0x21, r24	; 33
    24c6:	11 bc       	out	0x21, r1	; 33
    24c8:	0f be       	out	0x3f, r0	; 63
  eeprom_w32((void *)ee_irc_counter, get_irc1_counter());
    24ca:	0e 94 5b 0e 	call	0x1cb6	; 0x1cb6 <get_irc1_counter>
    24ce:	ab 01       	movw	r20, r22
    24d0:	bc 01       	movw	r22, r24
    24d2:	80 e0       	ldi	r24, 0x00	; 0
    24d4:	90 e0       	ldi	r25, 0x00	; 0
    24d6:	0e 94 22 12 	call	0x2444	; 0x2444 <eeprom_w32>
}

//8 bit
void eeprom_w8(void *uiAddress, uint8_t c){
  //cekame dokud neni volno
  wtch_reset2();
    24da:	a8 95       	wdr
  eeprom_busy_wait();
    24dc:	e1 99       	sbic	0x1c, 1	; 28
    24de:	fe cf       	rjmp	.-4      	; 0x24dc <eeprom_save+0x2c>
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    24e0:	e1 99       	sbic	0x1c, 1	; 28
    24e2:	fe cf       	rjmp	.-4      	; 0x24e0 <eeprom_save+0x30>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    24e4:	8b e0       	ldi	r24, 0x0B	; 11
    24e6:	90 e0       	ldi	r25, 0x00	; 0
    24e8:	9f bb       	out	0x1f, r25	; 31
    24ea:	8e bb       	out	0x1e, r24	; 30
#endif
    EEDR = __value;
    24ec:	8f e3       	ldi	r24, 0x3F	; 63
    24ee:	8d bb       	out	0x1d, r24	; 29

    __asm__ __volatile__ (
    24f0:	0f b6       	in	r0, 0x3f	; 63
    24f2:	f8 94       	cli
    24f4:	e2 9a       	sbi	0x1c, 2	; 28
    24f6:	e1 9a       	sbi	0x1c, 1	; 28
    24f8:	0f be       	out	0x3f, r0	; 63
  //lst_write_eeprom((void *) ee_lst);

  //p_eeprom = dat_zak_write_eeprom((void *)ee_lst);
  //p_eeprom = dat_write_eeprom((void *)ee_data);

  wtch_enable2();
    24fa:	2f e0       	ldi	r18, 0x0F	; 15
    24fc:	88 e1       	ldi	r24, 0x18	; 24
    24fe:	90 e0       	ldi	r25, 0x00	; 0
    2500:	0f b6       	in	r0, 0x3f	; 63
    2502:	f8 94       	cli
    2504:	a8 95       	wdr
    2506:	81 bd       	out	0x21, r24	; 33
    2508:	0f be       	out	0x3f, r0	; 63
    250a:	21 bd       	out	0x21, r18	; 33
  wtch_reset2();
    250c:	10 92 b5 01 	sts	0x01B5, r1
    2510:	10 92 b4 01 	sts	0x01B4, r1
    2514:	a8 95       	wdr
}
    2516:	08 95       	ret

00002518 <eeprom_load>:

//kods
void eeprom_load(void){
  char flag; // ukazuje, zda došlo k uložení dat
//  void * p_eeprom;
  set_irc1_counter ( (int32_t)eeprom_r32((void *)ee_irc_counter) );
    2518:	80 e0       	ldi	r24, 0x00	; 0
    251a:	90 e0       	ldi	r25, 0x00	; 0
    251c:	0e 94 f6 11 	call	0x23ec	; 0x23ec <eeprom_r32>
    2520:	0e 94 52 0e 	call	0x1ca4	; 0x1ca4 <set_irc1_counter>
    Read one 16-bit word (little endian) from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint16_t eeprom_read_word (const uint16_t *__p)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    return __eerd_word (__p, eeprom_read_byte);
    2524:	84 e0       	ldi	r24, 0x04	; 4
    2526:	90 e0       	ldi	r25, 0x00	; 0
    2528:	6e eb       	ldi	r22, 0xBE	; 190
    252a:	71 e1       	ldi	r23, 0x11	; 17
    252c:	0e 94 f6 1e 	call	0x3dec	; 0x3dec <__eerd_word>
  set_irc1_k ( (uint16_t)eeprom_r16((void *)ee_irc_k) );
    2530:	0e 94 64 0e 	call	0x1cc8	; 0x1cc8 <set_irc1_k>
  set_irc1_set_on_value ( (int32_t)eeprom_r32((void *)ee_irc_set_on_value) );
    2534:	86 e0       	ldi	r24, 0x06	; 6
    2536:	90 e0       	ldi	r25, 0x00	; 0
    2538:	0e 94 f6 11 	call	0x23ec	; 0x23ec <eeprom_r32>
    253c:	0e 94 6e 0e 	call	0x1cdc	; 0x1cdc <set_irc1_set_on_value>
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    2540:	e1 99       	sbic	0x1c, 1	; 28
    2542:	fe cf       	rjmp	.-4      	; 0x2540 <eeprom_load+0x28>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    2544:	8b e0       	ldi	r24, 0x0B	; 11
    2546:	90 e0       	ldi	r25, 0x00	; 0
    2548:	9f bb       	out	0x1f, r25	; 31
    254a:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    254c:	e0 9a       	sbi	0x1c, 0	; 28
    254e:	8d b3       	in	r24, 0x1d	; 29
  //width_src = (unsigned char) eeprom_r8((void *)ee_width_src);
  //width_src = width_src < 3?width_src:1;
  
  flag = eeprom_r8((void *)ee_flag);
  if (flag == 63){
    2550:	8f 33       	cpi	r24, 0x3F	; 63
    2552:	51 f0       	breq	.+20     	; 0x2568 <eeprom_load+0x50>
    //p_eeprom = dat_zak_read_eeprom((void *)ee_lst);
    //p_eeprom = dat_read_eeprom((void *)ee_data);

  }
  else{
    set_irc1_k_mm(DEFAULT_irc_k);
    2554:	80 e5       	ldi	r24, 0x50	; 80
    2556:	91 e0       	ldi	r25, 0x01	; 1
    2558:	0e 94 e8 0f 	call	0x1fd0	; 0x1fd0 <set_irc1_k_mm>
    set_irc1_set_on_value_mm(DEFAULT_irc_set_on_value);
    255c:	6c ec       	ldi	r22, 0xCC	; 204
    255e:	70 e1       	ldi	r23, 0x10	; 16
    2560:	80 e0       	ldi	r24, 0x00	; 0
    2562:	90 e0       	ldi	r25, 0x00	; 0
    2564:	0e 94 b5 0f 	call	0x1f6a	; 0x1f6a <set_irc1_set_on_value_mm>
    2568:	08 95       	ret

0000256a <lcd_new_frame>:
int lcd_ctrl_y = LCD_Y_MAX ;

/// @returns
/// Funkce vrátí 1 pokud se při dalším zavolání lcd_control začne vykreslovat nový frame
/// jinak vrátí nula
char lcd_new_frame(void){
    256a:	20 e0       	ldi	r18, 0x00	; 0
    256c:	80 91 a9 00 	lds	r24, 0x00A9
    2570:	90 91 aa 00 	lds	r25, 0x00AA
    2574:	04 97       	sbiw	r24, 0x04	; 4
    2576:	09 f4       	brne	.+2      	; 0x257a <lcd_new_frame+0x10>
    2578:	21 e0       	ldi	r18, 0x01	; 1
  if (lcd_ctrl_y == LCD_Y_MAX)
    return 1;
  else
    return 0;
}
    257a:	82 2f       	mov	r24, r18
    257c:	08 95       	ret

0000257e <d10>:


/// Jen taková zdržovací funkce pro odlazování
void d10(void){
    257e:	80 e0       	ldi	r24, 0x00	; 0
    2580:	90 e0       	ldi	r25, 0x00	; 0
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    2582:	32 e0       	ldi	r19, 0x02	; 2
    2584:	23 2f       	mov	r18, r19
    2586:	2a 95       	dec	r18
    2588:	f1 f7       	brne	.-4      	; 0x2586 <d10+0x8>
  int i;//250
  for (i=0; i< 250; i++){
    258a:	01 96       	adiw	r24, 0x01	; 1
    258c:	8a 3f       	cpi	r24, 0xFA	; 250
    258e:	91 05       	cpc	r25, r1
    2590:	c9 f7       	brne	.-14     	; 0x2584 <d10+0x6>
    _delay_us(1);
  }
}
    2592:	08 95       	ret

00002594 <clear_dscreen>:

/// Vymaže default screen.
void clear_dscreen(void){
    2594:	e8 e1       	ldi	r30, 0x18	; 24
    2596:	f3 e0       	ldi	r31, 0x03	; 3
void clear_screen(char (*screen)[LCD_X_MAX]){
  int i,j;

  for (i=0; i < LCD_X_MAX; i++){
    for (j = 0; j < LCD_Y_MAX; j++){
      screen[j][i] = ' ';
    2598:	80 e2       	ldi	r24, 0x20	; 32
    259a:	80 83       	st	Z, r24
    259c:	80 a7       	std	Z+40, r24	; 0x28
    259e:	e0 5b       	subi	r30, 0xB0	; 176
    25a0:	ff 4f       	sbci	r31, 0xFF	; 255
    25a2:	80 83       	st	Z, r24
    25a4:	b8 96       	adiw	r30, 0x28	; 40
    25a6:	80 83       	st	Z, r24
    25a8:	e7 57       	subi	r30, 0x77	; 119
    25aa:	f0 40       	sbci	r31, 0x00	; 0

// Vymaže obsah lcd_data
void clear_screen(char (*screen)[LCD_X_MAX]){
  int i,j;

  for (i=0; i < LCD_X_MAX; i++){
    25ac:	93 e0       	ldi	r25, 0x03	; 3
    25ae:	e0 34       	cpi	r30, 0x40	; 64
    25b0:	f9 07       	cpc	r31, r25
    25b2:	99 f7       	brne	.-26     	; 0x259a <clear_dscreen+0x6>
}

/// Vymaže default screen.
void clear_dscreen(void){
  clear_screen(default_screen);
}
    25b4:	08 95       	ret

000025b6 <clear_screen>:


// Vymaže obsah lcd_data
void clear_screen(char (*screen)[LCD_X_MAX]){
    25b6:	fc 01       	movw	r30, r24
  int i,j;

  for (i=0; i < LCD_X_MAX; i++){
    for (j = 0; j < LCD_Y_MAX; j++){
      screen[j][i] = ' ';
    25b8:	80 e2       	ldi	r24, 0x20	; 32

// Vymaže obsah lcd_data
void clear_screen(char (*screen)[LCD_X_MAX]){
  int i,j;

  for (i=0; i < LCD_X_MAX; i++){
    25ba:	9f 01       	movw	r18, r30
    25bc:	28 5d       	subi	r18, 0xD8	; 216
    25be:	3f 4f       	sbci	r19, 0xFF	; 255
    for (j = 0; j < LCD_Y_MAX; j++){
      screen[j][i] = ' ';
    25c0:	80 83       	st	Z, r24
    25c2:	80 a7       	std	Z+40, r24	; 0x28
    25c4:	e0 5b       	subi	r30, 0xB0	; 176
    25c6:	ff 4f       	sbci	r31, 0xFF	; 255
    25c8:	80 83       	st	Z, r24
    25ca:	b8 96       	adiw	r30, 0x28	; 40
    25cc:	80 83       	st	Z, r24
    25ce:	e7 57       	subi	r30, 0x77	; 119
    25d0:	f0 40       	sbci	r31, 0x00	; 0

// Vymaže obsah lcd_data
void clear_screen(char (*screen)[LCD_X_MAX]){
  int i,j;

  for (i=0; i < LCD_X_MAX; i++){
    25d2:	e2 17       	cp	r30, r18
    25d4:	f3 07       	cpc	r31, r19
    25d6:	a1 f7       	brne	.-24     	; 0x25c0 <clear_screen+0xa>
    for (j = 0; j < LCD_Y_MAX; j++){
      screen[j][i] = ' ';
    }
  }
}
    25d8:	08 95       	ret

000025da <printc>:

/**
 * Funkce vytiskne znak na místo kurzoru. Funkce není prováděna ve "vlákně".
 */
void printc(char c){
    25da:	20 e0       	ldi	r18, 0x00	; 0
    25dc:	30 e0       	ldi	r19, 0x00	; 0
    25de:	42 e0       	ldi	r20, 0x02	; 2
    25e0:	94 2f       	mov	r25, r20
    25e2:	9a 95       	dec	r25
    25e4:	f1 f7       	brne	.-4      	; 0x25e2 <printc+0x8>


/// Jen taková zdržovací funkce pro odlazování
void d10(void){
  int i;//250
  for (i=0; i< 250; i++){
    25e6:	2f 5f       	subi	r18, 0xFF	; 255
    25e8:	3f 4f       	sbci	r19, 0xFF	; 255
    25ea:	2a 3f       	cpi	r18, 0xFA	; 250
    25ec:	31 05       	cpc	r19, r1
    25ee:	c1 f7       	brne	.-16     	; 0x25e0 <printc+0x6>
/**
 * Funkce vytiskne znak na místo kurzoru. Funkce není prováděna ve "vlákně".
 */
void printc(char c){
  d10();
  PORTA = c;
    25f0:	8b bb       	out	0x1b, r24	; 27
  PORTB = ((PORTB & 0xf8) | (5 & 0x07));
    25f2:	88 b3       	in	r24, 0x18	; 24
    25f4:	88 7f       	andi	r24, 0xF8	; 248
    25f6:	85 60       	ori	r24, 0x05	; 5
    25f8:	88 bb       	out	0x18, r24	; 24
    25fa:	80 e0       	ldi	r24, 0x00	; 0
    25fc:	90 e0       	ldi	r25, 0x00	; 0
    25fe:	32 e0       	ldi	r19, 0x02	; 2
    2600:	23 2f       	mov	r18, r19
    2602:	2a 95       	dec	r18
    2604:	f1 f7       	brne	.-4      	; 0x2602 <printc+0x28>


/// Jen taková zdržovací funkce pro odlazování
void d10(void){
  int i;//250
  for (i=0; i< 250; i++){
    2606:	01 96       	adiw	r24, 0x01	; 1
    2608:	8a 3f       	cpi	r24, 0xFA	; 250
    260a:	91 05       	cpc	r25, r1
    260c:	c9 f7       	brne	.-14     	; 0x2600 <printc+0x26>
void printc(char c){
  d10();
  PORTA = c;
  PORTB = ((PORTB & 0xf8) | (5 & 0x07));
  d10();
  PORTB = ((PORTB & 0xf8) | (1 & 0x07));
    260e:	88 b3       	in	r24, 0x18	; 24
    2610:	88 7f       	andi	r24, 0xF8	; 248
    2612:	81 60       	ori	r24, 0x01	; 1
    2614:	88 bb       	out	0x18, r24	; 24
    2616:	80 e0       	ldi	r24, 0x00	; 0
    2618:	90 e0       	ldi	r25, 0x00	; 0
    261a:	32 e0       	ldi	r19, 0x02	; 2
    261c:	23 2f       	mov	r18, r19
    261e:	2a 95       	dec	r18
    2620:	f1 f7       	brne	.-4      	; 0x261e <printc+0x44>


/// Jen taková zdržovací funkce pro odlazování
void d10(void){
  int i;//250
  for (i=0; i< 250; i++){
    2622:	01 96       	adiw	r24, 0x01	; 1
    2624:	8a 3f       	cpi	r24, 0xFA	; 250
    2626:	91 05       	cpc	r25, r1
    2628:	c9 f7       	brne	.-14     	; 0x261c <printc+0x42>
  PORTA = c;
  PORTB = ((PORTB & 0xf8) | (5 & 0x07));
  d10();
  PORTB = ((PORTB & 0xf8) | (1 & 0x07));
  d10();
  PORTB = ((PORTB & 0xf8) | (5 & 0x07));
    262a:	88 b3       	in	r24, 0x18	; 24
    262c:	88 7f       	andi	r24, 0xF8	; 248
    262e:	85 60       	ori	r24, 0x05	; 5
    2630:	88 bb       	out	0x18, r24	; 24
}
    2632:	08 95       	ret

00002634 <printnt_P>:

/**
 * Funkce vypíše na současnou pozici kurzoru text z programové paměti.
 * Funkce není napsána do "vlákna".
 */
void printnt_P(char * s){
    2634:	cf 93       	push	r28
    2636:	df 93       	push	r29
    2638:	ec 01       	movw	r28, r24
    263a:	02 c0       	rjmp	.+4      	; 0x2640 <printnt_P+0xc>
  int i=0;
  char c;
  while ((c = pgm_read_byte_near(s+i)) != '\0'){
    printc(c);
    263c:	0e 94 ed 12 	call	0x25da	; 0x25da <printc>
 * Funkce není napsána do "vlákna".
 */
void printnt_P(char * s){
  int i=0;
  char c;
  while ((c = pgm_read_byte_near(s+i)) != '\0'){
    2640:	fe 01       	movw	r30, r28
    2642:	84 91       	lpm	r24, Z+
    2644:	21 96       	adiw	r28, 0x01	; 1
    2646:	88 23       	and	r24, r24
    2648:	c9 f7       	brne	.-14     	; 0x263c <printnt_P+0x8>
    printc(c);
    i++;
  }
}
    264a:	df 91       	pop	r29
    264c:	cf 91       	pop	r28
    264e:	08 95       	ret

00002650 <printnt>:

void printnt(char *s){
    2650:	cf 93       	push	r28
    2652:	df 93       	push	r29
    2654:	ec 01       	movw	r28, r24
    2656:	02 c0       	rjmp	.+4      	; 0x265c <printnt+0xc>
  int i=0;
  char c;
  while ((c = s[i]) != '\0'){
    printc(c);
    2658:	0e 94 ed 12 	call	0x25da	; 0x25da <printc>
}

void printnt(char *s){
  int i=0;
  char c;
  while ((c = s[i]) != '\0'){
    265c:	89 91       	ld	r24, Y+
    265e:	88 23       	and	r24, r24
    2660:	d9 f7       	brne	.-10     	; 0x2658 <printnt+0x8>
    printc(c);
    i++;
  }
}
    2662:	df 91       	pop	r29
    2664:	cf 91       	pop	r28
    2666:	08 95       	ret

00002668 <printcxyd>:
void print(char * s){
  printxy(default_screen,0,0,s);
}

/// Vytiskne znak do defaultscreenu na souřadnici x,y.
void printcxyd(int y, int x, char c){
    2668:	9c 01       	movw	r18, r24
  if ((x < LCD_X_MAX)&&(y < LCD_Y_MAX)){
    266a:	68 32       	cpi	r22, 0x28	; 40
    266c:	71 05       	cpc	r23, r1
    266e:	8c f4       	brge	.+34     	; 0x2692 <printcxyd+0x2a>
    2670:	84 30       	cpi	r24, 0x04	; 4
    2672:	91 05       	cpc	r25, r1
    2674:	74 f4       	brge	.+28     	; 0x2692 <printcxyd+0x2a>
    default_screen[y][x] = c;
    2676:	88 e2       	ldi	r24, 0x28	; 40
    2678:	90 e0       	ldi	r25, 0x00	; 0
    267a:	28 9f       	mul	r18, r24
    267c:	f0 01       	movw	r30, r0
    267e:	29 9f       	mul	r18, r25
    2680:	f0 0d       	add	r31, r0
    2682:	38 9f       	mul	r19, r24
    2684:	f0 0d       	add	r31, r0
    2686:	11 24       	eor	r1, r1
    2688:	e6 0f       	add	r30, r22
    268a:	f7 1f       	adc	r31, r23
    268c:	e8 5e       	subi	r30, 0xE8	; 232
    268e:	fc 4f       	sbci	r31, 0xFC	; 252
    2690:	40 83       	st	Z, r20
    2692:	08 95       	ret

00002694 <printnxyd>:
  }
}

/// Vytiskne n znaků do defaultscreenu na souřadnici x,y.
void printnxyd(int y, int x, char * s, int n){
    2694:	fc 01       	movw	r30, r24
  // mínus jedna je tam proto, že 30+10 = 40, ale posledni index je 39
  if ((x < LCD_X_MAX)&&(y < LCD_Y_MAX)&&((x+n-1) < LCD_X_MAX)){
    2696:	68 32       	cpi	r22, 0x28	; 40
    2698:	71 05       	cpc	r23, r1
    269a:	14 f5       	brge	.+68     	; 0x26e0 <printnxyd+0x4c>
    269c:	84 30       	cpi	r24, 0x04	; 4
    269e:	91 05       	cpc	r25, r1
    26a0:	fc f4       	brge	.+62     	; 0x26e0 <printnxyd+0x4c>
    26a2:	c9 01       	movw	r24, r18
    26a4:	86 0f       	add	r24, r22
    26a6:	97 1f       	adc	r25, r23
    26a8:	89 97       	sbiw	r24, 0x29	; 41
    26aa:	d4 f4       	brge	.+52     	; 0x26e0 <printnxyd+0x4c>
    26ac:	88 e2       	ldi	r24, 0x28	; 40
    26ae:	90 e0       	ldi	r25, 0x00	; 0
    26b0:	e8 9f       	mul	r30, r24
    26b2:	d0 01       	movw	r26, r0
    26b4:	e9 9f       	mul	r30, r25
    26b6:	b0 0d       	add	r27, r0
    26b8:	f8 9f       	mul	r31, r24
    26ba:	b0 0d       	add	r27, r0
    26bc:	11 24       	eor	r1, r1
    26be:	a6 0f       	add	r26, r22
    26c0:	b7 1f       	adc	r27, r23
    26c2:	a8 5e       	subi	r26, 0xE8	; 232
    26c4:	bc 4f       	sbci	r27, 0xFC	; 252
    26c6:	60 e0       	ldi	r22, 0x00	; 0
    26c8:	70 e0       	ldi	r23, 0x00	; 0
    26ca:	07 c0       	rjmp	.+14     	; 0x26da <printnxyd+0x46>
    int i;
    for(i = 0; i < n; i++){
      default_screen[y][x+i] = s[i];
    26cc:	fa 01       	movw	r30, r20
    26ce:	e6 0f       	add	r30, r22
    26d0:	f7 1f       	adc	r31, r23
    26d2:	80 81       	ld	r24, Z
    26d4:	8d 93       	st	X+, r24
/// Vytiskne n znaků do defaultscreenu na souřadnici x,y.
void printnxyd(int y, int x, char * s, int n){
  // mínus jedna je tam proto, že 30+10 = 40, ale posledni index je 39
  if ((x < LCD_X_MAX)&&(y < LCD_Y_MAX)&&((x+n-1) < LCD_X_MAX)){
    int i;
    for(i = 0; i < n; i++){
    26d6:	6f 5f       	subi	r22, 0xFF	; 255
    26d8:	7f 4f       	sbci	r23, 0xFF	; 255
    26da:	62 17       	cp	r22, r18
    26dc:	73 07       	cpc	r23, r19
    26de:	b4 f3       	brlt	.-20     	; 0x26cc <printnxyd+0x38>
    26e0:	08 95       	ret

000026e2 <lcd_w_inst>:


/// Zapiš instrukci.
void lcd_w_inst(char c){
#ifdef DVA_E
  PORTA = c;
    26e2:	8b bb       	out	0x1b, r24	; 27
  PORTB = ((PORTB & 0xf8) | (6 & 0x07));
    26e4:	88 b3       	in	r24, 0x18	; 24
    26e6:	88 7f       	andi	r24, 0xF8	; 248
    26e8:	86 60       	ori	r24, 0x06	; 6
    26ea:	88 bb       	out	0x18, r24	; 24
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    26ec:	20 e2       	ldi	r18, 0x20	; 32
    26ee:	3e e4       	ldi	r19, 0x4E	; 78
    26f0:	c9 01       	movw	r24, r18
    26f2:	01 97       	sbiw	r24, 0x01	; 1
    26f4:	f1 f7       	brne	.-4      	; 0x26f2 <lcd_w_inst+0x10>
   _delay_ms(10);
  PORTB = ((PORTB & 0xf8) | (0 & 0x07));
    26f6:	88 b3       	in	r24, 0x18	; 24
    26f8:	88 7f       	andi	r24, 0xF8	; 248
    26fa:	88 bb       	out	0x18, r24	; 24
    26fc:	c9 01       	movw	r24, r18
    26fe:	01 97       	sbiw	r24, 0x01	; 1
    2700:	f1 f7       	brne	.-4      	; 0x26fe <lcd_w_inst+0x1c>
   _delay_ms(10);
  PORTB = ((PORTB & 0xf8) | (6 & 0x07));
    2702:	88 b3       	in	r24, 0x18	; 24
    2704:	88 7f       	andi	r24, 0xF8	; 248
    2706:	86 60       	ori	r24, 0x06	; 6
    2708:	88 bb       	out	0x18, r24	; 24
    270a:	c9 01       	movw	r24, r18
    270c:	01 97       	sbiw	r24, 0x01	; 1
    270e:	f1 f7       	brne	.-4      	; 0x270c <lcd_w_inst+0x2a>
  PORTB = ((PORTB & 0xf8) | (0 & 0x07));
   _delay_ms(10);
  PORTB = ((PORTB & 0xf8) | (4 & 0x07));
   _delay_ms(10);
#endif
}
    2710:	08 95       	ret

00002712 <lcd_init>:

void lcd_init(void){
  p_akt_screen = default_screen;
    2712:	48 e1       	ldi	r20, 0x18	; 24
    2714:	53 e0       	ldi	r21, 0x03	; 3
    2716:	50 93 17 03 	sts	0x0317, r21
    271a:	40 93 16 03 	sts	0x0316, r20

  int i;
  //cekej 15ms od náběhu Vcc nad 4,5V
  DDRB = (DDRB & 0xf8)|(7 & 0x07);
    271e:	87 b3       	in	r24, 0x17	; 23
    2720:	87 60       	ori	r24, 0x07	; 7
    2722:	87 bb       	out	0x17, r24	; 23
  DDRA = 255;
    2724:	8f ef       	ldi	r24, 0xFF	; 255
    2726:	8a bb       	out	0x1a, r24	; 26
    2728:	20 e2       	ldi	r18, 0x20	; 32
    272a:	3e e4       	ldi	r19, 0x4E	; 78
    272c:	c9 01       	movw	r24, r18
    272e:	01 97       	sbiw	r24, 0x01	; 1
    2730:	f1 f7       	brne	.-4      	; 0x272e <lcd_init+0x1c>
    2732:	c9 01       	movw	r24, r18
    2734:	01 97       	sbiw	r24, 0x01	; 1
    2736:	f1 f7       	brne	.-4      	; 0x2734 <lcd_init+0x22>
    2738:	c9 01       	movw	r24, r18
    273a:	01 97       	sbiw	r24, 0x01	; 1
    273c:	f1 f7       	brne	.-4      	; 0x273a <lcd_init+0x28>

  for (i = 0; i < 3; i++){
    _delay_ms(10);
  }
  PORTB = ((PORTB & 0xf8) | (0 & 0x07));
    273e:	88 b3       	in	r24, 0x18	; 24
    2740:	88 7f       	andi	r24, 0xF8	; 248
    2742:	88 bb       	out	0x18, r24	; 24
    2744:	c9 01       	movw	r24, r18
    2746:	01 97       	sbiw	r24, 0x01	; 1
    2748:	f1 f7       	brne	.-4      	; 0x2746 <lcd_init+0x34>
  _delay_ms(10);
  PORTB = ((PORTB & 0xf8) | (4 & 0x07));
    274a:	88 b3       	in	r24, 0x18	; 24
    274c:	88 7f       	andi	r24, 0xF8	; 248
    274e:	84 60       	ori	r24, 0x04	; 4
    2750:	88 bb       	out	0x18, r24	; 24
    2752:	c9 01       	movw	r24, r18
    2754:	01 97       	sbiw	r24, 0x01	; 1
    2756:	f1 f7       	brne	.-4      	; 0x2754 <lcd_init+0x42>


/// Zapiš instrukci.
void lcd_w_inst(char c){
#ifdef DVA_E
  PORTA = c;
    2758:	88 e3       	ldi	r24, 0x38	; 56
    275a:	8b bb       	out	0x1b, r24	; 27
  PORTB = ((PORTB & 0xf8) | (6 & 0x07));
    275c:	88 b3       	in	r24, 0x18	; 24
    275e:	88 7f       	andi	r24, 0xF8	; 248
    2760:	86 60       	ori	r24, 0x06	; 6
    2762:	88 bb       	out	0x18, r24	; 24
    2764:	c9 01       	movw	r24, r18
    2766:	01 97       	sbiw	r24, 0x01	; 1
    2768:	f1 f7       	brne	.-4      	; 0x2766 <lcd_init+0x54>
   _delay_ms(10);
  PORTB = ((PORTB & 0xf8) | (0 & 0x07));
    276a:	88 b3       	in	r24, 0x18	; 24
    276c:	88 7f       	andi	r24, 0xF8	; 248
    276e:	88 bb       	out	0x18, r24	; 24
    2770:	c9 01       	movw	r24, r18
    2772:	01 97       	sbiw	r24, 0x01	; 1
    2774:	f1 f7       	brne	.-4      	; 0x2772 <lcd_init+0x60>
   _delay_ms(10);
  PORTB = ((PORTB & 0xf8) | (6 & 0x07));
    2776:	88 b3       	in	r24, 0x18	; 24
    2778:	88 7f       	andi	r24, 0xF8	; 248
    277a:	86 60       	ori	r24, 0x06	; 6
    277c:	88 bb       	out	0x18, r24	; 24
    277e:	c9 01       	movw	r24, r18
    2780:	01 97       	sbiw	r24, 0x01	; 1
    2782:	f1 f7       	brne	.-4      	; 0x2780 <lcd_init+0x6e>


/// Zapiš instrukci.
void lcd_w_inst(char c){
#ifdef DVA_E
  PORTA = c;
    2784:	8c e0       	ldi	r24, 0x0C	; 12
    2786:	8b bb       	out	0x1b, r24	; 27
  PORTB = ((PORTB & 0xf8) | (6 & 0x07));
    2788:	88 b3       	in	r24, 0x18	; 24
    278a:	88 7f       	andi	r24, 0xF8	; 248
    278c:	86 60       	ori	r24, 0x06	; 6
    278e:	88 bb       	out	0x18, r24	; 24
    2790:	c9 01       	movw	r24, r18
    2792:	01 97       	sbiw	r24, 0x01	; 1
    2794:	f1 f7       	brne	.-4      	; 0x2792 <lcd_init+0x80>
   _delay_ms(10);
  PORTB = ((PORTB & 0xf8) | (0 & 0x07));
    2796:	88 b3       	in	r24, 0x18	; 24
    2798:	88 7f       	andi	r24, 0xF8	; 248
    279a:	88 bb       	out	0x18, r24	; 24
    279c:	c9 01       	movw	r24, r18
    279e:	01 97       	sbiw	r24, 0x01	; 1
    27a0:	f1 f7       	brne	.-4      	; 0x279e <lcd_init+0x8c>
   _delay_ms(10);
  PORTB = ((PORTB & 0xf8) | (6 & 0x07));
    27a2:	88 b3       	in	r24, 0x18	; 24
    27a4:	88 7f       	andi	r24, 0xF8	; 248
    27a6:	86 60       	ori	r24, 0x06	; 6
    27a8:	88 bb       	out	0x18, r24	; 24
    27aa:	c9 01       	movw	r24, r18
    27ac:	01 97       	sbiw	r24, 0x01	; 1
    27ae:	f1 f7       	brne	.-4      	; 0x27ac <lcd_init+0x9a>


/// Zapiš instrukci.
void lcd_w_inst(char c){
#ifdef DVA_E
  PORTA = c;
    27b0:	86 e0       	ldi	r24, 0x06	; 6
    27b2:	8b bb       	out	0x1b, r24	; 27
  PORTB = ((PORTB & 0xf8) | (6 & 0x07));
    27b4:	88 b3       	in	r24, 0x18	; 24
    27b6:	88 7f       	andi	r24, 0xF8	; 248
    27b8:	86 60       	ori	r24, 0x06	; 6
    27ba:	88 bb       	out	0x18, r24	; 24
    27bc:	c9 01       	movw	r24, r18
    27be:	01 97       	sbiw	r24, 0x01	; 1
    27c0:	f1 f7       	brne	.-4      	; 0x27be <lcd_init+0xac>
   _delay_ms(10);
  PORTB = ((PORTB & 0xf8) | (0 & 0x07));
    27c2:	88 b3       	in	r24, 0x18	; 24
    27c4:	88 7f       	andi	r24, 0xF8	; 248
    27c6:	88 bb       	out	0x18, r24	; 24
    27c8:	c9 01       	movw	r24, r18
    27ca:	01 97       	sbiw	r24, 0x01	; 1
    27cc:	f1 f7       	brne	.-4      	; 0x27ca <lcd_init+0xb8>
   _delay_ms(10);
  PORTB = ((PORTB & 0xf8) | (6 & 0x07));
    27ce:	88 b3       	in	r24, 0x18	; 24
    27d0:	88 7f       	andi	r24, 0xF8	; 248
    27d2:	86 60       	ori	r24, 0x06	; 6
    27d4:	88 bb       	out	0x18, r24	; 24
    27d6:	c9 01       	movw	r24, r18
    27d8:	01 97       	sbiw	r24, 0x01	; 1
    27da:	f1 f7       	brne	.-4      	; 0x27d8 <lcd_init+0xc6>


/// Zapiš instrukci.
void lcd_w_inst(char c){
#ifdef DVA_E
  PORTA = c;
    27dc:	81 e0       	ldi	r24, 0x01	; 1
    27de:	8b bb       	out	0x1b, r24	; 27
  PORTB = ((PORTB & 0xf8) | (6 & 0x07));
    27e0:	88 b3       	in	r24, 0x18	; 24
    27e2:	88 7f       	andi	r24, 0xF8	; 248
    27e4:	86 60       	ori	r24, 0x06	; 6
    27e6:	88 bb       	out	0x18, r24	; 24
    27e8:	c9 01       	movw	r24, r18
    27ea:	01 97       	sbiw	r24, 0x01	; 1
    27ec:	f1 f7       	brne	.-4      	; 0x27ea <lcd_init+0xd8>
   _delay_ms(10);
  PORTB = ((PORTB & 0xf8) | (0 & 0x07));
    27ee:	88 b3       	in	r24, 0x18	; 24
    27f0:	88 7f       	andi	r24, 0xF8	; 248
    27f2:	88 bb       	out	0x18, r24	; 24
    27f4:	c9 01       	movw	r24, r18
    27f6:	01 97       	sbiw	r24, 0x01	; 1
    27f8:	f1 f7       	brne	.-4      	; 0x27f6 <lcd_init+0xe4>
   _delay_ms(10);
  PORTB = ((PORTB & 0xf8) | (6 & 0x07));
    27fa:	88 b3       	in	r24, 0x18	; 24
    27fc:	88 7f       	andi	r24, 0xF8	; 248
    27fe:	86 60       	ori	r24, 0x06	; 6
    2800:	88 bb       	out	0x18, r24	; 24
    2802:	c9 01       	movw	r24, r18
    2804:	01 97       	sbiw	r24, 0x01	; 1
    2806:	f1 f7       	brne	.-4      	; 0x2804 <lcd_init+0xf2>
  lcd_w_inst(0x38);
  lcd_w_inst(0x0c); //0x0e; //-kurzor zapnutý  //0x0c //vypne kurzor
  lcd_w_inst(0x06);
  lcd_w_inst(0x01); //vymaže display a posune kurzor na začátek.

  PORTB = ((PORTB & 0xf8) | (5 & 0x07)); //připrraví na odesílání dat
    2808:	88 b3       	in	r24, 0x18	; 24
    280a:	88 7f       	andi	r24, 0xF8	; 248
    280c:	85 60       	ori	r24, 0x05	; 5
    280e:	88 bb       	out	0x18, r24	; 24
    2810:	fa 01       	movw	r30, r20
void clear_screen(char (*screen)[LCD_X_MAX]){
  int i,j;

  for (i=0; i < LCD_X_MAX; i++){
    for (j = 0; j < LCD_Y_MAX; j++){
      screen[j][i] = ' ';
    2812:	80 e2       	ldi	r24, 0x20	; 32
    2814:	80 83       	st	Z, r24
    2816:	80 a7       	std	Z+40, r24	; 0x28
    2818:	e0 5b       	subi	r30, 0xB0	; 176
    281a:	ff 4f       	sbci	r31, 0xFF	; 255
    281c:	80 83       	st	Z, r24
    281e:	b8 96       	adiw	r30, 0x28	; 40
    2820:	80 83       	st	Z, r24
    2822:	e7 57       	subi	r30, 0x77	; 119
    2824:	f0 40       	sbci	r31, 0x00	; 0

// Vymaže obsah lcd_data
void clear_screen(char (*screen)[LCD_X_MAX]){
  int i,j;

  for (i=0; i < LCD_X_MAX; i++){
    2826:	93 e0       	ldi	r25, 0x03	; 3
    2828:	e0 34       	cpi	r30, 0x40	; 64
    282a:	f9 07       	cpc	r31, r25
    282c:	99 f7       	brne	.-26     	; 0x2814 <lcd_init+0x102>

*/
 // printxy(default_screen,0,10,int2string("  ",0));
  //lcd_print();

}
    282e:	08 95       	ret

00002830 <lcd_control>:
void lcd_control(void){
  //wtch_dbg_info();
  // Jde to po řádku a vypisuje to znak po znaku, na konci řádku 
  // to skočí na další. na posledním řádku to přidá k počítadlu
  // ještě jedničku a pak zafunguje první if. Ten nastaví displej na začátek.
  if (lcd_ctrl_y == (LCD_Y_MAX -1 + 1 )){
    2830:	40 91 a9 00 	lds	r20, 0x00A9
    2834:	50 91 aa 00 	lds	r21, 0x00AA
    2838:	20 91 a1 01 	lds	r18, 0x01A1
    283c:	30 91 a2 01 	lds	r19, 0x01A2
    2840:	44 30       	cpi	r20, 0x04	; 4
    2842:	51 05       	cpc	r21, r1
    2844:	19 f5       	brne	.+70     	; 0x288c <lcd_control+0x5c>
  
    switch (lcd_ctrl_count){
    2846:	21 30       	cpi	r18, 0x01	; 1
    2848:	31 05       	cpc	r19, r1
    284a:	61 f0       	breq	.+24     	; 0x2864 <lcd_control+0x34>
    284c:	22 30       	cpi	r18, 0x02	; 2
    284e:	31 05       	cpc	r19, r1
    2850:	69 f0       	breq	.+26     	; 0x286c <lcd_control+0x3c>
    2852:	21 15       	cp	r18, r1
    2854:	31 05       	cpc	r19, r1
    2856:	71 f4       	brne	.+28     	; 0x2874 <lcd_control+0x44>
        PORTB = ((PORTB & 0xf8) | (5 & 0x07));
        break;
#else
      case 0:  // pripravime na vynulovani a nastaveni na zacatek 
        //TODO mozna by stacilo presunuti na zacatek
        PORTA = 2;
    2858:	82 e0       	ldi	r24, 0x02	; 2
    285a:	8b bb       	out	0x1b, r24	; 27
        PORTB = ((PORTB & 0xf8) | (6 & 0x07));
    285c:	88 b3       	in	r24, 0x18	; 24
    285e:	88 7f       	andi	r24, 0xF8	; 248
    2860:	86 60       	ori	r24, 0x06	; 6
    2862:	02 c0       	rjmp	.+4      	; 0x2868 <lcd_control+0x38>
        break;
      case 1:  //zapisem
        PORTB = ((PORTB & 0xf8) | (0 & 0x07));
    2864:	88 b3       	in	r24, 0x18	; 24
    2866:	88 7f       	andi	r24, 0xF8	; 248
    2868:	88 bb       	out	0x18, r24	; 24
    286a:	45 c0       	rjmp	.+138    	; 0x28f6 <lcd_control+0xc6>
        break;
      case 2:  //zase nahodime ecko a připravíme na zápis dat
        PORTB = ((PORTB & 0xf8) | (7 & 0x07));
    286c:	88 b3       	in	r24, 0x18	; 24
    286e:	87 60       	ori	r24, 0x07	; 7
    2870:	88 bb       	out	0x18, r24	; 24
    2872:	03 c0       	rjmp	.+6      	; 0x287a <lcd_control+0x4a>
        break;
#endif
    }
    if (lcd_ctrl_count != 2)
    2874:	22 30       	cpi	r18, 0x02	; 2
    2876:	31 05       	cpc	r19, r1
    2878:	f1 f5       	brne	.+124    	; 0x28f6 <lcd_control+0xc6>
      lcd_ctrl_count++;
    else{
      lcd_ctrl_count = 0;
    287a:	10 92 a2 01 	sts	0x01A2, r1
    287e:	10 92 a1 01 	sts	0x01A1, r1
      lcd_ctrl_x = 0;
    2882:	10 92 a4 01 	sts	0x01A4, r1
    2886:	10 92 a3 01 	sts	0x01A3, r1
    288a:	5b c0       	rjmp	.+182    	; 0x2942 <lcd_control+0x112>
      lcd_ctrl_y = 0;
    }
  }
  else{
    switch (lcd_ctrl_count){
    288c:	21 30       	cpi	r18, 0x01	; 1
    288e:	31 05       	cpc	r19, r1
    2890:	f9 f0       	breq	.+62     	; 0x28d0 <lcd_control+0xa0>
    2892:	22 30       	cpi	r18, 0x02	; 2
    2894:	31 05       	cpc	r19, r1
    2896:	49 f1       	breq	.+82     	; 0x28ea <lcd_control+0xba>
    2898:	21 15       	cp	r18, r1
    289a:	31 05       	cpc	r19, r1
    289c:	49 f5       	brne	.+82     	; 0x28f0 <lcd_control+0xc0>
          lcd_ctrl_y_prohod = 2;
        PORTA = p_akt_screen[lcd_ctrl_y_prohod][lcd_ctrl_x];
        PORTB = ((PORTB & 0xf8) | (5 & 0x07));
        }
#else
        PORTA = p_akt_screen[lcd_ctrl_y][lcd_ctrl_x];
    289e:	88 e2       	ldi	r24, 0x28	; 40
    28a0:	90 e0       	ldi	r25, 0x00	; 0
    28a2:	bc 01       	movw	r22, r24
    28a4:	46 9f       	mul	r20, r22
    28a6:	c0 01       	movw	r24, r0
    28a8:	47 9f       	mul	r20, r23
    28aa:	90 0d       	add	r25, r0
    28ac:	56 9f       	mul	r21, r22
    28ae:	90 0d       	add	r25, r0
    28b0:	11 24       	eor	r1, r1
    28b2:	e0 91 16 03 	lds	r30, 0x0316
    28b6:	f0 91 17 03 	lds	r31, 0x0317
    28ba:	e8 0f       	add	r30, r24
    28bc:	f9 1f       	adc	r31, r25
    28be:	80 91 a3 01 	lds	r24, 0x01A3
    28c2:	90 91 a4 01 	lds	r25, 0x01A4
    28c6:	e8 0f       	add	r30, r24
    28c8:	f9 1f       	adc	r31, r25
    28ca:	80 81       	ld	r24, Z
    28cc:	8b bb       	out	0x1b, r24	; 27
    28ce:	0d c0       	rjmp	.+26     	; 0x28ea <lcd_control+0xba>
        break;
      case 1:  //zapisem
#ifndef DVA_E
        PORTB = ((PORTB & 0xf8) | (1 & 0x07));
#else
        if (lcd_ctrl_y < 2)
    28d0:	42 30       	cpi	r20, 0x02	; 2
    28d2:	51 05       	cpc	r21, r1
    28d4:	2c f4       	brge	.+10     	; 0x28e0 <lcd_control+0xb0>
          PORTB = ((PORTB & 0xf8) | (3 & 0x07));
    28d6:	88 b3       	in	r24, 0x18	; 24
    28d8:	88 7f       	andi	r24, 0xF8	; 248
    28da:	83 60       	ori	r24, 0x03	; 3
    28dc:	88 bb       	out	0x18, r24	; 24
    28de:	12 c0       	rjmp	.+36     	; 0x2904 <lcd_control+0xd4>
        else
          PORTB = ((PORTB & 0xf8) | (5 & 0x07));
    28e0:	88 b3       	in	r24, 0x18	; 24
    28e2:	88 7f       	andi	r24, 0xF8	; 248
    28e4:	85 60       	ori	r24, 0x05	; 5
    28e6:	88 bb       	out	0x18, r24	; 24
    28e8:	03 c0       	rjmp	.+6      	; 0x28f0 <lcd_control+0xc0>
        break;
      case 2:  //zase nahodime ecko a připravíme na zápis dat
#ifndef DVA_E
        PORTB = ((PORTB & 0xf8) | (5 & 0x07));
#else
        PORTB = ((PORTB & 0xf8) | (7 & 0x07));
    28ea:	88 b3       	in	r24, 0x18	; 24
    28ec:	87 60       	ori	r24, 0x07	; 7
    28ee:	bc cf       	rjmp	.-136    	; 0x2868 <lcd_control+0x38>
#endif
        break;
    }

    if (lcd_ctrl_count != 1)
    28f0:	21 30       	cpi	r18, 0x01	; 1
    28f2:	31 05       	cpc	r19, r1
    28f4:	39 f0       	breq	.+14     	; 0x2904 <lcd_control+0xd4>
      lcd_ctrl_count++;
    28f6:	2f 5f       	subi	r18, 0xFF	; 255
    28f8:	3f 4f       	sbci	r19, 0xFF	; 255
    28fa:	30 93 a2 01 	sts	0x01A2, r19
    28fe:	20 93 a1 01 	sts	0x01A1, r18
    2902:	08 95       	ret
    else{
      // Tady se řeší správné čítání. Při dosažení mezních hodnot pole dojde k nastavení souřadnic na další řádek...
      // sem se to dostane vždy po dokončení zápisu znaku (instrukce).
      lcd_ctrl_count = 0;
    2904:	10 92 a2 01 	sts	0x01A2, r1
    2908:	10 92 a1 01 	sts	0x01A1, r1
      if (lcd_ctrl_x < (LCD_X_MAX - 1)){
    290c:	80 91 a3 01 	lds	r24, 0x01A3
    2910:	90 91 a4 01 	lds	r25, 0x01A4
    2914:	87 32       	cpi	r24, 0x27	; 39
    2916:	91 05       	cpc	r25, r1
    2918:	34 f4       	brge	.+12     	; 0x2926 <lcd_control+0xf6>
        //pokud jsme nedosáhli koncce řádku, zvyšujeme jeho souřadnici
        lcd_ctrl_x++;
    291a:	01 96       	adiw	r24, 0x01	; 1
    291c:	90 93 a4 01 	sts	0x01A4, r25
    2920:	80 93 a3 01 	sts	0x01A3, r24
    2924:	08 95       	ret
      }
      else{
        // když jsme na konci řádku, nastavíme souřadnici na nulu a zvýšíme počítadlo řádků.
        lcd_ctrl_x = 0;
    2926:	10 92 a4 01 	sts	0x01A4, r1
    292a:	10 92 a3 01 	sts	0x01A3, r1

        if(lcd_ctrl_y < (LCD_Y_MAX -1 + 1)){
    292e:	44 30       	cpi	r20, 0x04	; 4
    2930:	51 05       	cpc	r21, r1
    2932:	3c f4       	brge	.+14     	; 0x2942 <lcd_control+0x112>
          lcd_ctrl_y++;
    2934:	4f 5f       	subi	r20, 0xFF	; 255
    2936:	5f 4f       	sbci	r21, 0xFF	; 255
    2938:	50 93 aa 00 	sts	0x00AA, r21
    293c:	40 93 a9 00 	sts	0x00A9, r20
    2940:	08 95       	ret
        }
        else{
          //pokud jsme se dostali na poslední řádek displaye + 1 , je něco divně
          // tenhle případ by totiž měla chytit první podmínka. Místo posleního řádku + 1 se zpracovává instrukce pro 
          // nastavení displeje na nulu.
          lcd_ctrl_y = 0;
    2942:	10 92 aa 00 	sts	0x00AA, r1
    2946:	10 92 a9 00 	sts	0x00A9, r1
    294a:	08 95       	ret

0000294c <printxyd_P>:
    new_error(82);
  }
}

/// Funkce vloží na danou pozici řetězec @a s
void printxyd_P(int y,int x,void * s){
    294c:	af 92       	push	r10
    294e:	bf 92       	push	r11
    2950:	cf 92       	push	r12
    2952:	df 92       	push	r13
    2954:	ef 92       	push	r14
    2956:	ff 92       	push	r15
    2958:	1f 93       	push	r17
    295a:	cf 93       	push	r28
    295c:	df 93       	push	r29
    295e:	dc 01       	movw	r26, r24
    2960:	eb 01       	movw	r28, r22
    2962:	7a 01       	movw	r14, r20
  int n = 0;
  int n_x = 0;
  char c;

  if ((x < LCD_X_MAX)&&(y < LCD_Y_MAX)){
    2964:	68 32       	cpi	r22, 0x28	; 40
    2966:	71 05       	cpc	r23, r1
    2968:	0c f0       	brlt	.+2      	; 0x296c <printxyd_P+0x20>
    296a:	50 c0       	rjmp	.+160    	; 0x2a0c <printxyd_P+0xc0>
    296c:	84 30       	cpi	r24, 0x04	; 4
    296e:	91 05       	cpc	r25, r1
    2970:	0c f0       	brlt	.+2      	; 0x2974 <printxyd_P+0x28>
    2972:	4c c0       	rjmp	.+152    	; 0x2a0c <printxyd_P+0xc0>
    //Kopíruj do pole lcd
    c = pgm_read_byte_near(s);
    2974:	fa 01       	movw	r30, r20
    2976:	14 91       	lpm	r17, Z+
    2978:	40 e0       	ldi	r20, 0x00	; 0
    297a:	50 e0       	ldi	r21, 0x00	; 0
        n_x = 0;
        n++;
        c = pgm_read_byte_near(s+n);
        if (y >= LCD_Y_MAX){
          new_error(80);
          break;
    297c:	88 e2       	ldi	r24, 0x28	; 40
    297e:	c8 2e       	mov	r12, r24
    2980:	d1 2c       	mov	r13, r1
    2982:	1f c0       	rjmp	.+62     	; 0x29c2 <printxyd_P+0x76>
  if ((x < LCD_X_MAX)&&(y < LCD_Y_MAX)){
    //Kopíruj do pole lcd
    c = pgm_read_byte_near(s);
    while ((c != '\0') && ( (x + n_x) < LCD_X_MAX)){
      //screen[y][x+n_x]=c;
      default_screen[y][x+n_x] = c;
    2984:	f5 01       	movw	r30, r10
    2986:	11 93       	st	Z+, r17
    2988:	5f 01       	movw	r10, r30

      n++;
    298a:	4f 5f       	subi	r20, 0xFF	; 255
    298c:	5f 4f       	sbci	r21, 0xFF	; 255
      n_x++;
      c = pgm_read_byte_near(s+n);
    298e:	fb 01       	movw	r30, r22
    2990:	84 91       	lpm	r24, Z+
    2992:	6f 5f       	subi	r22, 0xFF	; 255
    2994:	7f 4f       	sbci	r23, 0xFF	; 255
      if(c == '\n'){
    2996:	8a 30       	cpi	r24, 0x0A	; 10
    2998:	21 f0       	breq	.+8      	; 0x29a2 <printxyd_P+0x56>
    while ((c != '\0') && ( (x + n_x) < LCD_X_MAX)){
      //screen[y][x+n_x]=c;
      default_screen[y][x+n_x] = c;

      n++;
      n_x++;
    299a:	2f 5f       	subi	r18, 0xFF	; 255
    299c:	3f 4f       	sbci	r19, 0xFF	; 255
    299e:	18 2f       	mov	r17, r24
    29a0:	26 c0       	rjmp	.+76     	; 0x29ee <printxyd_P+0xa2>
      c = pgm_read_byte_near(s+n);
      if(c == '\n'){
        y++;
    29a2:	11 96       	adiw	r26, 0x01	; 1
        n_x = 0;
        n++;
    29a4:	4f 5f       	subi	r20, 0xFF	; 255
    29a6:	5f 4f       	sbci	r21, 0xFF	; 255
        c = pgm_read_byte_near(s+n);
    29a8:	f7 01       	movw	r30, r14
    29aa:	e4 0f       	add	r30, r20
    29ac:	f5 1f       	adc	r31, r21
    29ae:	14 91       	lpm	r17, Z+
        if (y >= LCD_Y_MAX){
    29b0:	a4 30       	cpi	r26, 0x04	; 4
    29b2:	b1 05       	cpc	r27, r1
    29b4:	34 f0       	brlt	.+12     	; 0x29c2 <printxyd_P+0x76>
          new_error(80);
    29b6:	80 e5       	ldi	r24, 0x50	; 80
    29b8:	0e 94 33 18 	call	0x3066	; 0x3066 <new_error>
    29bc:	20 e0       	ldi	r18, 0x00	; 0
    29be:	30 e0       	ldi	r19, 0x00	; 0
    29c0:	1e c0       	rjmp	.+60     	; 0x29fe <printxyd_P+0xb2>
          break;
    29c2:	ac 9d       	mul	r26, r12
    29c4:	50 01       	movw	r10, r0
    29c6:	ad 9d       	mul	r26, r13
    29c8:	b0 0c       	add	r11, r0
    29ca:	bc 9d       	mul	r27, r12
    29cc:	b0 0c       	add	r11, r0
    29ce:	11 24       	eor	r1, r1
    29d0:	ac 0e       	add	r10, r28
    29d2:	bd 1e       	adc	r11, r29
    29d4:	88 e1       	ldi	r24, 0x18	; 24
    29d6:	93 e0       	ldi	r25, 0x03	; 3
    29d8:	a8 0e       	add	r10, r24
    29da:	b9 1e       	adc	r11, r25
    29dc:	4f 5f       	subi	r20, 0xFF	; 255
    29de:	5f 4f       	sbci	r21, 0xFF	; 255
    29e0:	b7 01       	movw	r22, r14
    29e2:	64 0f       	add	r22, r20
    29e4:	75 1f       	adc	r23, r21
    29e6:	41 50       	subi	r20, 0x01	; 1
    29e8:	50 40       	sbci	r21, 0x00	; 0
    29ea:	20 e0       	ldi	r18, 0x00	; 0
    29ec:	30 e0       	ldi	r19, 0x00	; 0
  char c;

  if ((x < LCD_X_MAX)&&(y < LCD_Y_MAX)){
    //Kopíruj do pole lcd
    c = pgm_read_byte_near(s);
    while ((c != '\0') && ( (x + n_x) < LCD_X_MAX)){
    29ee:	11 23       	and	r17, r17
    29f0:	31 f0       	breq	.+12     	; 0x29fe <printxyd_P+0xb2>
    29f2:	c9 01       	movw	r24, r18
    29f4:	8c 0f       	add	r24, r28
    29f6:	9d 1f       	adc	r25, r29
    29f8:	88 97       	sbiw	r24, 0x28	; 40
    29fa:	0c f4       	brge	.+2      	; 0x29fe <printxyd_P+0xb2>
    29fc:	c3 cf       	rjmp	.-122    	; 0x2984 <printxyd_P+0x38>
          break;
        }
        
      }
    }
    if ((x+n_x) > LCD_X_MAX){
    29fe:	2c 0f       	add	r18, r28
    2a00:	3d 1f       	adc	r19, r29
    2a02:	29 32       	cpi	r18, 0x29	; 41
    2a04:	31 05       	cpc	r19, r1
    2a06:	2c f0       	brlt	.+10     	; 0x2a12 <printxyd_P+0xc6>
      new_error(81);
    2a08:	81 e5       	ldi	r24, 0x51	; 81
    2a0a:	01 c0       	rjmp	.+2      	; 0x2a0e <printxyd_P+0xc2>
    }
  }
  else{
    new_error(82);
    2a0c:	82 e5       	ldi	r24, 0x52	; 82
    2a0e:	0e 94 33 18 	call	0x3066	; 0x3066 <new_error>
  }
}
    2a12:	df 91       	pop	r29
    2a14:	cf 91       	pop	r28
    2a16:	1f 91       	pop	r17
    2a18:	ff 90       	pop	r15
    2a1a:	ef 90       	pop	r14
    2a1c:	df 90       	pop	r13
    2a1e:	cf 90       	pop	r12
    2a20:	bf 90       	pop	r11
    2a22:	af 90       	pop	r10
    2a24:	08 95       	ret

00002a26 <printxy>:
void printxyd(int y, int x, char * s){
  printxy(default_screen, y, x, s);
}

/// Funkce vloží na danou pozici řetězec @a s
void printxy(char (*screen)[LCD_X_MAX],int y,int x,char * s){
    2a26:	af 92       	push	r10
    2a28:	bf 92       	push	r11
    2a2a:	cf 92       	push	r12
    2a2c:	df 92       	push	r13
    2a2e:	ef 92       	push	r14
    2a30:	ff 92       	push	r15
    2a32:	0f 93       	push	r16
    2a34:	1f 93       	push	r17
    2a36:	cf 93       	push	r28
    2a38:	df 93       	push	r29
    2a3a:	dc 01       	movw	r26, r24
    2a3c:	8b 01       	movw	r16, r22
    2a3e:	7a 01       	movw	r14, r20
    2a40:	e9 01       	movw	r28, r18
  int n = 0;
  int n_x = 0;
  char c;
  if (s == NULL){
    2a42:	21 15       	cp	r18, r1
    2a44:	31 05       	cpc	r19, r1
    2a46:	11 f4       	brne	.+4      	; 0x2a4c <printxy+0x26>
    2a48:	c4 ea       	ldi	r28, 0xA4	; 164
    2a4a:	d0 e0       	ldi	r29, 0x00	; 0
    s = "NULL";
  }

  if ((x < LCD_X_MAX)&&(y < LCD_Y_MAX)){
    2a4c:	88 e2       	ldi	r24, 0x28	; 40
    2a4e:	e8 16       	cp	r14, r24
    2a50:	f1 04       	cpc	r15, r1
    2a52:	0c f0       	brlt	.+2      	; 0x2a56 <printxy+0x30>
    2a54:	4c c0       	rjmp	.+152    	; 0x2aee <printxy+0xc8>
    2a56:	04 30       	cpi	r16, 0x04	; 4
    2a58:	11 05       	cpc	r17, r1
    2a5a:	0c f0       	brlt	.+2      	; 0x2a5e <printxy+0x38>
    2a5c:	48 c0       	rjmp	.+144    	; 0x2aee <printxy+0xc8>
    //Kopíruj do pole lcd
    c = s[0];
    2a5e:	e8 81       	ld	r30, Y
    2a60:	88 e2       	ldi	r24, 0x28	; 40
    2a62:	90 e0       	ldi	r25, 0x00	; 0
    2a64:	08 9f       	mul	r16, r24
    2a66:	b0 01       	movw	r22, r0
    2a68:	09 9f       	mul	r16, r25
    2a6a:	70 0d       	add	r23, r0
    2a6c:	18 9f       	mul	r17, r24
    2a6e:	70 0d       	add	r23, r0
    2a70:	11 24       	eor	r1, r1
    2a72:	6a 0f       	add	r22, r26
    2a74:	7b 1f       	adc	r23, r27
    2a76:	40 e0       	ldi	r20, 0x00	; 0
    2a78:	50 e0       	ldi	r21, 0x00	; 0
    2a7a:	23 c0       	rjmp	.+70     	; 0x2ac2 <printxy+0x9c>
    while ((c != '\0') && ( (x + n_x) < LCD_X_MAX)){
      screen[y][x+n_x]=c;
    2a7c:	d6 01       	movw	r26, r12
    2a7e:	ed 93       	st	X+, r30
    2a80:	6d 01       	movw	r12, r26
      //default_screen[y][x+n_x] = c;

      n++;
    2a82:	4f 5f       	subi	r20, 0xFF	; 255
    2a84:	5f 4f       	sbci	r21, 0xFF	; 255
      n_x++;
      c = s[n];
    2a86:	d5 01       	movw	r26, r10
    2a88:	11 96       	adiw	r26, 0x01	; 1
    2a8a:	ec 91       	ld	r30, X
    2a8c:	08 94       	sec
    2a8e:	a1 1c       	adc	r10, r1
    2a90:	b1 1c       	adc	r11, r1
      if(c == '\n'){
    2a92:	ea 30       	cpi	r30, 0x0A	; 10
    2a94:	19 f0       	breq	.+6      	; 0x2a9c <printxy+0x76>
    while ((c != '\0') && ( (x + n_x) < LCD_X_MAX)){
      screen[y][x+n_x]=c;
      //default_screen[y][x+n_x] = c;

      n++;
      n_x++;
    2a96:	2f 5f       	subi	r18, 0xFF	; 255
    2a98:	3f 4f       	sbci	r19, 0xFF	; 255
    2a9a:	1b c0       	rjmp	.+54     	; 0x2ad2 <printxy+0xac>
      c = s[n];
      if(c == '\n'){
        y++;
    2a9c:	0f 5f       	subi	r16, 0xFF	; 255
    2a9e:	1f 4f       	sbci	r17, 0xFF	; 255
        n_x = 0;
        n++;
    2aa0:	4f 5f       	subi	r20, 0xFF	; 255
    2aa2:	5f 4f       	sbci	r21, 0xFF	; 255
        c = s[n];
    2aa4:	fe 01       	movw	r30, r28
    2aa6:	e4 0f       	add	r30, r20
    2aa8:	f5 1f       	adc	r31, r21
    2aaa:	e0 81       	ld	r30, Z
    2aac:	68 5d       	subi	r22, 0xD8	; 216
    2aae:	7f 4f       	sbci	r23, 0xFF	; 255
        if (y >= LCD_Y_MAX){
    2ab0:	04 30       	cpi	r16, 0x04	; 4
    2ab2:	11 05       	cpc	r17, r1
    2ab4:	34 f0       	brlt	.+12     	; 0x2ac2 <printxy+0x9c>
          new_error(80);
    2ab6:	80 e5       	ldi	r24, 0x50	; 80
    2ab8:	0e 94 33 18 	call	0x3066	; 0x3066 <new_error>
    2abc:	20 e0       	ldi	r18, 0x00	; 0
    2abe:	30 e0       	ldi	r19, 0x00	; 0
    2ac0:	0f c0       	rjmp	.+30     	; 0x2ae0 <printxy+0xba>
          break;
    2ac2:	6b 01       	movw	r12, r22
    2ac4:	ce 0c       	add	r12, r14
    2ac6:	df 1c       	adc	r13, r15
    2ac8:	5e 01       	movw	r10, r28
    2aca:	a4 0e       	add	r10, r20
    2acc:	b5 1e       	adc	r11, r21
    2ace:	20 e0       	ldi	r18, 0x00	; 0
    2ad0:	30 e0       	ldi	r19, 0x00	; 0
  }

  if ((x < LCD_X_MAX)&&(y < LCD_Y_MAX)){
    //Kopíruj do pole lcd
    c = s[0];
    while ((c != '\0') && ( (x + n_x) < LCD_X_MAX)){
    2ad2:	ee 23       	and	r30, r30
    2ad4:	29 f0       	breq	.+10     	; 0x2ae0 <printxy+0xba>
    2ad6:	c9 01       	movw	r24, r18
    2ad8:	8e 0d       	add	r24, r14
    2ada:	9f 1d       	adc	r25, r15
    2adc:	88 97       	sbiw	r24, 0x28	; 40
    2ade:	74 f2       	brlt	.-100    	; 0x2a7c <printxy+0x56>
          break;
        }
        
      }
    }
    if ((x+n_x) > LCD_X_MAX){
    2ae0:	2e 0d       	add	r18, r14
    2ae2:	3f 1d       	adc	r19, r15
    2ae4:	29 32       	cpi	r18, 0x29	; 41
    2ae6:	31 05       	cpc	r19, r1
    2ae8:	2c f0       	brlt	.+10     	; 0x2af4 <printxy+0xce>
      new_error(81);
    2aea:	81 e5       	ldi	r24, 0x51	; 81
    2aec:	01 c0       	rjmp	.+2      	; 0x2af0 <printxy+0xca>
    }
  }
  else{
    new_error(82);
    2aee:	82 e5       	ldi	r24, 0x52	; 82
    2af0:	0e 94 33 18 	call	0x3066	; 0x3066 <new_error>
  }
}
    2af4:	df 91       	pop	r29
    2af6:	cf 91       	pop	r28
    2af8:	1f 91       	pop	r17
    2afa:	0f 91       	pop	r16
    2afc:	ff 90       	pop	r15
    2afe:	ef 90       	pop	r14
    2b00:	df 90       	pop	r13
    2b02:	cf 90       	pop	r12
    2b04:	bf 90       	pop	r11
    2b06:	af 90       	pop	r10
    2b08:	08 95       	ret

00002b0a <printxyd>:
    }
  }
}

/// Tiskne do default_screenu
void printxyd(int y, int x, char * s){
    2b0a:	fc 01       	movw	r30, r24
    2b0c:	db 01       	movw	r26, r22
    2b0e:	9a 01       	movw	r18, r20
  printxy(default_screen, y, x, s);
    2b10:	88 e1       	ldi	r24, 0x18	; 24
    2b12:	93 e0       	ldi	r25, 0x03	; 3
    2b14:	bf 01       	movw	r22, r30
    2b16:	ad 01       	movw	r20, r26
    2b18:	0e 94 13 15 	call	0x2a26	; 0x2a26 <printxy>
}
    2b1c:	08 95       	ret

00002b1e <print>:
    printc(c);
    i++;
  }
}
///vytiskne text do default_screenu.
void print(char * s){
    2b1e:	9c 01       	movw	r18, r24
  printxy(default_screen,0,0,s);
    2b20:	88 e1       	ldi	r24, 0x18	; 24
    2b22:	93 e0       	ldi	r25, 0x03	; 3
    2b24:	60 e0       	ldi	r22, 0x00	; 0
    2b26:	70 e0       	ldi	r23, 0x00	; 0
    2b28:	40 e0       	ldi	r20, 0x00	; 0
    2b2a:	50 e0       	ldi	r21, 0x00	; 0
    2b2c:	0e 94 13 15 	call	0x2a26	; 0x2a26 <printxy>
}
    2b30:	08 95       	ret

00002b32 <mezery>:

/**
 * Funkce vyplní daný řetězec mezerami. Počet mezer je určen argumentem len. Za mezery je umístěn
 * znak '\0'.
 */
char * mezery(char *s,char len){
    2b32:	ac 01       	movw	r20, r24
  int i;
  for (i = 0; i < len; i++){
    2b34:	a6 2f       	mov	r26, r22
    2b36:	b0 e0       	ldi	r27, 0x00	; 0
    2b38:	10 97       	sbiw	r26, 0x00	; 0
    2b3a:	61 f0       	breq	.+24     	; 0x2b54 <mezery+0x22>
    2b3c:	20 e0       	ldi	r18, 0x00	; 0
    2b3e:	30 e0       	ldi	r19, 0x00	; 0
    s[i] = ' ';
    2b40:	80 e2       	ldi	r24, 0x20	; 32
    2b42:	fa 01       	movw	r30, r20
    2b44:	e2 0f       	add	r30, r18
    2b46:	f3 1f       	adc	r31, r19
    2b48:	80 83       	st	Z, r24
 * Funkce vyplní daný řetězec mezerami. Počet mezer je určen argumentem len. Za mezery je umístěn
 * znak '\0'.
 */
char * mezery(char *s,char len){
  int i;
  for (i = 0; i < len; i++){
    2b4a:	2f 5f       	subi	r18, 0xFF	; 255
    2b4c:	3f 4f       	sbci	r19, 0xFF	; 255
    2b4e:	2a 17       	cp	r18, r26
    2b50:	3b 07       	cpc	r19, r27
    2b52:	bc f3       	brlt	.-18     	; 0x2b42 <mezery+0x10>
    s[i] = ' ';
  }
  s[(int)len]='\0';
    2b54:	a4 0f       	add	r26, r20
    2b56:	b5 1f       	adc	r27, r21
    2b58:	1c 92       	st	X, r1
  return s;
}
    2b5a:	ca 01       	movw	r24, r20
    2b5c:	08 95       	ret

00002b5e <strlen>:


/// Funkce vrací délku řetězce.
int strlen(char * s){
  int i = 0;
  while (s[i] != '\0'){
    2b5e:	dc 01       	movw	r26, r24
    2b60:	8c 91       	ld	r24, X
    2b62:	88 23       	and	r24, r24
    2b64:	61 f0       	breq	.+24     	; 0x2b7e <strlen+0x20>
    2b66:	20 e0       	ldi	r18, 0x00	; 0
    2b68:	30 e0       	ldi	r19, 0x00	; 0
    i++;
    2b6a:	2f 5f       	subi	r18, 0xFF	; 255
    2b6c:	3f 4f       	sbci	r19, 0xFF	; 255


/// Funkce vrací délku řetězce.
int strlen(char * s){
  int i = 0;
  while (s[i] != '\0'){
    2b6e:	fd 01       	movw	r30, r26
    2b70:	e2 0f       	add	r30, r18
    2b72:	f3 1f       	adc	r31, r19
    2b74:	80 81       	ld	r24, Z
    2b76:	88 23       	and	r24, r24
    2b78:	c1 f7       	brne	.-16     	; 0x2b6a <strlen+0xc>
    i++;
  }
  return i;
}
    2b7a:	c9 01       	movw	r24, r18
    2b7c:	08 95       	ret


/// Funkce vrací délku řetězce.
int strlen(char * s){
  int i = 0;
  while (s[i] != '\0'){
    2b7e:	20 e0       	ldi	r18, 0x00	; 0
    2b80:	30 e0       	ldi	r19, 0x00	; 0
    2b82:	fb cf       	rjmp	.-10     	; 0x2b7a <strlen+0x1c>

00002b84 <int2strn>:
}

/**
 * Funkce převádí číslo na řetězec
 */
char * int2strn(char * s, int len, uint16_t cislo){
    2b84:	2f 92       	push	r2
    2b86:	3f 92       	push	r3
    2b88:	4f 92       	push	r4
    2b8a:	5f 92       	push	r5
    2b8c:	6f 92       	push	r6
    2b8e:	7f 92       	push	r7
    2b90:	8f 92       	push	r8
    2b92:	9f 92       	push	r9
    2b94:	bf 92       	push	r11
    2b96:	cf 92       	push	r12
    2b98:	df 92       	push	r13
    2b9a:	ef 92       	push	r14
    2b9c:	ff 92       	push	r15
    2b9e:	0f 93       	push	r16
    2ba0:	1f 93       	push	r17
    2ba2:	df 93       	push	r29
    2ba4:	cf 93       	push	r28
    2ba6:	cd b7       	in	r28, 0x3d	; 61
    2ba8:	de b7       	in	r29, 0x3e	; 62
    2baa:	2a 97       	sbiw	r28, 0x0a	; 10
    2bac:	0f b6       	in	r0, 0x3f	; 63
    2bae:	f8 94       	cli
    2bb0:	de bf       	out	0x3e, r29	; 62
    2bb2:	0f be       	out	0x3f, r0	; 63
    2bb4:	cd bf       	out	0x3d, r28	; 61
    2bb6:	2c 01       	movw	r4, r24
    2bb8:	3b 01       	movw	r6, r22
    2bba:	b4 2e       	mov	r11, r20
    2bbc:	45 2f       	mov	r20, r21
//  char s[6]= "     \0";
  //uint16_t zaklad;
  int nenula = 0;
  int i;
  uint16_t zaklady [5] = {1,10,100,1000,10000};
    2bbe:	1e 01       	movw	r2, r28
    2bc0:	08 94       	sec
    2bc2:	21 1c       	adc	r2, r1
    2bc4:	31 1c       	adc	r3, r1
    2bc6:	d1 01       	movw	r26, r2
    2bc8:	eb ea       	ldi	r30, 0xAB	; 171
    2bca:	f0 e0       	ldi	r31, 0x00	; 0
    2bcc:	8a e0       	ldi	r24, 0x0A	; 10
    2bce:	01 90       	ld	r0, Z+
    2bd0:	0d 92       	st	X+, r0
    2bd2:	81 50       	subi	r24, 0x01	; 1
    2bd4:	e1 f7       	brne	.-8      	; 0x2bce <int2strn+0x4a>
  
  s[len] = '\0';
    2bd6:	f2 01       	movw	r30, r4
    2bd8:	e6 0d       	add	r30, r6
    2bda:	f7 1d       	adc	r31, r7
    2bdc:	10 82       	st	Z, r1
    2bde:	88 24       	eor	r8, r8
    2be0:	99 24       	eor	r9, r9
    2be2:	d2 01       	movw	r26, r4
    2be4:	8c 91       	ld	r24, X
    2be6:	80 33       	cpi	r24, 0x30	; 48
    2be8:	09 f4       	brne	.+2      	; 0x2bec <int2strn+0x68>
    2bea:	90 c0       	rjmp	.+288    	; 0x2d0c <int2strn+0x188>
/*
  for (int i=0; i < (len - 1);i++){
    zaklad = zaklad * 10;
  }
*/
  if (len < 5){
    2bec:	b5 e0       	ldi	r27, 0x05	; 5
    2bee:	6b 16       	cp	r6, r27
    2bf0:	71 04       	cpc	r7, r1
    2bf2:	0c f4       	brge	.+2      	; 0x2bf6 <int2strn+0x72>
    2bf4:	7c c0       	rjmp	.+248    	; 0x2cee <int2strn+0x16a>
    2bf6:	e4 e0       	ldi	r30, 0x04	; 4
    2bf8:	ce 2e       	mov	r12, r30
    2bfa:	d1 2c       	mov	r13, r1
    i = 4;
  }
  
  //zaklad = zaklady[i];

  if ((cislo/zaklady[i]) >= 10){ //tohle testuje jestli neni číslo na víc míst než je možný zobrazit
    2bfc:	f6 01       	movw	r30, r12
    2bfe:	ee 0f       	add	r30, r30
    2c00:	ff 1f       	adc	r31, r31
    2c02:	e2 0d       	add	r30, r2
    2c04:	f3 1d       	adc	r31, r3
    2c06:	20 81       	ld	r18, Z
    2c08:	31 81       	ldd	r19, Z+1	; 0x01
    2c0a:	8b 2d       	mov	r24, r11
    2c0c:	94 2f       	mov	r25, r20
    2c0e:	b9 01       	movw	r22, r18
    2c10:	0e 94 94 23 	call	0x4728	; 0x4728 <__udivmodhi4>
    2c14:	6a 30       	cpi	r22, 0x0A	; 10
    2c16:	71 05       	cpc	r23, r1
    2c18:	98 f4       	brcc	.+38     	; 0x2c40 <int2strn+0xbc>
    //new_error(85);
  }
  else{
    if (i < 4)
    2c1a:	e4 e0       	ldi	r30, 0x04	; 4
    2c1c:	ce 16       	cp	r12, r30
    2c1e:	d1 04       	cpc	r13, r1
    2c20:	09 f4       	brne	.+2      	; 0x2c24 <int2strn+0xa0>
    2c22:	6a c0       	rjmp	.+212    	; 0x2cf8 <int2strn+0x174>
      cislo = cislo % (zaklady[i+1] );
    2c24:	f6 01       	movw	r30, r12
    2c26:	31 96       	adiw	r30, 0x01	; 1
    2c28:	ee 0f       	add	r30, r30
    2c2a:	ff 1f       	adc	r31, r31
    2c2c:	e2 0d       	add	r30, r2
    2c2e:	f3 1d       	adc	r31, r3
    2c30:	60 81       	ld	r22, Z
    2c32:	71 81       	ldd	r23, Z+1	; 0x01
    2c34:	8b 2d       	mov	r24, r11
    2c36:	94 2f       	mov	r25, r20
    2c38:	0e 94 94 23 	call	0x4728	; 0x4728 <__udivmodhi4>
    2c3c:	b8 2e       	mov	r11, r24
    2c3e:	49 2f       	mov	r20, r25
    else
      cislo = cislo % (zaklady[4]);
  }
  while (i >= 0){ //zaklad >= 1){//i < len){
    2c40:	d7 fc       	sbrc	r13, 7
    2c42:	3c c0       	rjmp	.+120    	; 0x2cbc <int2strn+0x138>
  }
  else{
    if (i < 4)
      cislo = cislo % (zaklady[i+1] );
    else
      cislo = cislo % (zaklady[4]);
    2c44:	86 01       	movw	r16, r12
    2c46:	01 50       	subi	r16, 0x01	; 1
    2c48:	10 40       	sbci	r17, 0x00	; 0
    2c4a:	78 01       	movw	r14, r16
    2c4c:	ee 0c       	add	r14, r14
    2c4e:	ff 1c       	adc	r15, r15
    2c50:	e2 0c       	add	r14, r2
    2c52:	f3 1c       	adc	r15, r3
    2c54:	f3 01       	movw	r30, r6
    2c56:	ec 19       	sub	r30, r12
    2c58:	fd 09       	sbc	r31, r13
    2c5a:	31 97       	sbiw	r30, 0x01	; 1
    2c5c:	e4 0d       	add	r30, r4
    2c5e:	f5 1d       	adc	r31, r5
  }
  while (i >= 0){ //zaklad >= 1){//i < len){
    int mezi;
    mezi = (cislo / zaklady[i]);
    if ((mezi == 0)&&(nenula == 0)&&(zaklady[i] > 1)){
      s[len - i - 1] = ' '; 
    2c60:	90 e2       	ldi	r25, 0x20	; 32
    2c62:	d9 2e       	mov	r13, r25
    2c64:	1a c0       	rjmp	.+52     	; 0x2c9a <int2strn+0x116>
      cislo = cislo % (zaklady[4]);
  }
  while (i >= 0){ //zaklad >= 1){//i < len){
    int mezi;
    mezi = (cislo / zaklady[i]);
    if ((mezi == 0)&&(nenula == 0)&&(zaklady[i] > 1)){
    2c66:	81 14       	cp	r8, r1
    2c68:	91 04       	cpc	r9, r1
    2c6a:	01 f5       	brne	.+64     	; 0x2cac <int2strn+0x128>
    2c6c:	22 30       	cpi	r18, 0x02	; 2
    2c6e:	31 05       	cpc	r19, r1
    2c70:	e8 f0       	brcs	.+58     	; 0x2cac <int2strn+0x128>
      s[len - i - 1] = ' '; 
    2c72:	d0 82       	st	Z, r13
        nenula = 1;
      }
    }
    cislo = cislo - ((cislo/zaklady[i]) * zaklady[i]);
    //cislo = cislo % zaklady[i];
    i--;
    2c74:	31 96       	adiw	r30, 0x01	; 1
    if (i < 4)
      cislo = cislo % (zaklady[i+1] );
    else
      cislo = cislo % (zaklady[4]);
  }
  while (i >= 0){ //zaklad >= 1){//i < len){
    2c76:	17 fd       	sbrc	r17, 7
    2c78:	21 c0       	rjmp	.+66     	; 0x2cbc <int2strn+0x138>
      s[len - i - 1] = 48 + mezi;
      if (nenula == 0){
        nenula = 1;
      }
    }
    cislo = cislo - ((cislo/zaklady[i]) * zaklady[i]);
    2c7a:	8b 2d       	mov	r24, r11
    2c7c:	94 2f       	mov	r25, r20
    2c7e:	b9 01       	movw	r22, r18
    2c80:	0e 94 94 23 	call	0x4728	; 0x4728 <__udivmodhi4>
    2c84:	b8 2e       	mov	r11, r24
    2c86:	49 2f       	mov	r20, r25
    2c88:	d7 01       	movw	r26, r14
    2c8a:	2d 91       	ld	r18, X+
    2c8c:	3c 91       	ld	r19, X
    2c8e:	8e ef       	ldi	r24, 0xFE	; 254
    2c90:	9f ef       	ldi	r25, 0xFF	; 255
    2c92:	e8 0e       	add	r14, r24
    2c94:	f9 1e       	adc	r15, r25
    2c96:	01 50       	subi	r16, 0x01	; 1
    2c98:	10 40       	sbci	r17, 0x00	; 0
    else
      cislo = cislo % (zaklady[4]);
  }
  while (i >= 0){ //zaklad >= 1){//i < len){
    int mezi;
    mezi = (cislo / zaklady[i]);
    2c9a:	8b 2d       	mov	r24, r11
    2c9c:	94 2f       	mov	r25, r20
    2c9e:	b9 01       	movw	r22, r18
    2ca0:	0e 94 94 23 	call	0x4728	; 0x4728 <__udivmodhi4>
    2ca4:	cb 01       	movw	r24, r22
    if ((mezi == 0)&&(nenula == 0)&&(zaklady[i] > 1)){
    2ca6:	61 15       	cp	r22, r1
    2ca8:	71 05       	cpc	r23, r1
    2caa:	e9 f2       	breq	.-70     	; 0x2c66 <int2strn+0xe2>
      s[len - i - 1] = ' '; 
    }
    else{
      s[len - i - 1] = 48 + mezi;
    2cac:	80 5d       	subi	r24, 0xD0	; 208
    2cae:	80 83       	st	Z, r24
    2cb0:	81 e0       	ldi	r24, 0x01	; 1
    2cb2:	88 2e       	mov	r8, r24
    2cb4:	91 2c       	mov	r9, r1
        nenula = 1;
      }
    }
    cislo = cislo - ((cislo/zaklady[i]) * zaklady[i]);
    //cislo = cislo % zaklady[i];
    i--;
    2cb6:	31 96       	adiw	r30, 0x01	; 1
    if (i < 4)
      cislo = cislo % (zaklady[i+1] );
    else
      cislo = cislo % (zaklady[4]);
  }
  while (i >= 0){ //zaklad >= 1){//i < len){
    2cb8:	17 ff       	sbrs	r17, 7
    2cba:	df cf       	rjmp	.-66     	; 0x2c7a <int2strn+0xf6>
    //cislo = cislo % zaklady[i];
    i--;
  }
  
  return s;
}
    2cbc:	c2 01       	movw	r24, r4
    2cbe:	2a 96       	adiw	r28, 0x0a	; 10
    2cc0:	0f b6       	in	r0, 0x3f	; 63
    2cc2:	f8 94       	cli
    2cc4:	de bf       	out	0x3e, r29	; 62
    2cc6:	0f be       	out	0x3f, r0	; 63
    2cc8:	cd bf       	out	0x3d, r28	; 61
    2cca:	cf 91       	pop	r28
    2ccc:	df 91       	pop	r29
    2cce:	1f 91       	pop	r17
    2cd0:	0f 91       	pop	r16
    2cd2:	ff 90       	pop	r15
    2cd4:	ef 90       	pop	r14
    2cd6:	df 90       	pop	r13
    2cd8:	cf 90       	pop	r12
    2cda:	bf 90       	pop	r11
    2cdc:	9f 90       	pop	r9
    2cde:	8f 90       	pop	r8
    2ce0:	7f 90       	pop	r7
    2ce2:	6f 90       	pop	r6
    2ce4:	5f 90       	pop	r5
    2ce6:	4f 90       	pop	r4
    2ce8:	3f 90       	pop	r3
    2cea:	2f 90       	pop	r2
    2cec:	08 95       	ret
  for (int i=0; i < (len - 1);i++){
    zaklad = zaklad * 10;
  }
*/
  if (len < 5){
    i = len - 1;
    2cee:	63 01       	movw	r12, r6
    2cf0:	08 94       	sec
    2cf2:	c1 08       	sbc	r12, r1
    2cf4:	d1 08       	sbc	r13, r1
    2cf6:	82 cf       	rjmp	.-252    	; 0x2bfc <int2strn+0x78>
  }
  else{
    if (i < 4)
      cislo = cislo % (zaklady[i+1] );
    else
      cislo = cislo % (zaklady[4]);
    2cf8:	29 85       	ldd	r18, Y+9	; 0x09
    2cfa:	3a 85       	ldd	r19, Y+10	; 0x0a
    2cfc:	8b 2d       	mov	r24, r11
    2cfe:	94 2f       	mov	r25, r20
    2d00:	b9 01       	movw	r22, r18
    2d02:	0e 94 94 23 	call	0x4728	; 0x4728 <__udivmodhi4>
    2d06:	b8 2e       	mov	r11, r24
    2d08:	49 2f       	mov	r20, r25
    2d0a:	9c cf       	rjmp	.-200    	; 0x2c44 <int2strn+0xc0>
  //uint16_t zaklad;
  int nenula = 0;
  int i;
  uint16_t zaklady [5] = {1,10,100,1000,10000};
  
  s[len] = '\0';
    2d0c:	f1 e0       	ldi	r31, 0x01	; 1
    2d0e:	8f 2e       	mov	r8, r31
    2d10:	91 2c       	mov	r9, r1
    2d12:	6c cf       	rjmp	.-296    	; 0x2bec <int2strn+0x68>

00002d14 <int2str>:
 * Funkce převádí číslo na řetězec. Vstupem je řetězec. Změří se jeho délka a na takovou délku se převede 
 * číslo. Pokud je řetězec příliš krátký, dojde k vypsání chybové zprávy. Zarovnává se vpravo.
 * Pokud je první znak vstupního řetězce roven '0', vypisují se i počáteční nuly
 * např 0056
 */
char * int2str(char *s, uint16_t cislo){
    2d14:	dc 01       	movw	r26, r24
    2d16:	ab 01       	movw	r20, r22


/// Funkce vrací délku řetězce.
int strlen(char * s){
  int i = 0;
  while (s[i] != '\0'){
    2d18:	8c 91       	ld	r24, X
    2d1a:	88 23       	and	r24, r24
    2d1c:	71 f0       	breq	.+28     	; 0x2d3a <int2str+0x26>
    2d1e:	60 e0       	ldi	r22, 0x00	; 0
    2d20:	70 e0       	ldi	r23, 0x00	; 0
    i++;
    2d22:	6f 5f       	subi	r22, 0xFF	; 255
    2d24:	7f 4f       	sbci	r23, 0xFF	; 255


/// Funkce vrací délku řetězce.
int strlen(char * s){
  int i = 0;
  while (s[i] != '\0'){
    2d26:	fd 01       	movw	r30, r26
    2d28:	e6 0f       	add	r30, r22
    2d2a:	f7 1f       	adc	r31, r23
    2d2c:	80 81       	ld	r24, Z
    2d2e:	88 23       	and	r24, r24
    2d30:	c1 f7       	brne	.-16     	; 0x2d22 <int2str+0xe>
 * Pokud je první znak vstupního řetězce roven '0', vypisují se i počáteční nuly
 * např 0056
 */
char * int2str(char *s, uint16_t cislo){
  
  return int2strn(s,strlen(s), cislo);
    2d32:	cd 01       	movw	r24, r26
    2d34:	0e 94 c2 15 	call	0x2b84	; 0x2b84 <int2strn>
}
    2d38:	08 95       	ret


/// Funkce vrací délku řetězce.
int strlen(char * s){
  int i = 0;
  while (s[i] != '\0'){
    2d3a:	60 e0       	ldi	r22, 0x00	; 0
    2d3c:	70 e0       	ldi	r23, 0x00	; 0
    2d3e:	f9 cf       	rjmp	.-14     	; 0x2d32 <int2str+0x1e>

00002d40 <err_control>:
  /*
  if (new_err == 1){
    scr_ch(ERR_SCR);
    new_err = 0;
  }*/
}
    2d40:	08 95       	ret

00002d42 <err_scr_open>:

void err_scr_open(void){
//   prev_scr = akt_scr;
}
    2d42:	08 95       	ret

00002d44 <error_scr_control>:
    default:
      break;
    }
  }
  */
}
    2d44:	08 95       	ret

00002d46 <err_assert>:
/**
 * Funkce je volána v případě že makro assert() nalezlo nějakou chybu.
 * Funkce vyvtoří řeťězec, v němˇž je popsáno jméno funkce, jméno
 * souboru a řádek, z něhož je makro spouštěno.
 */
void err_assert(char * soubor, int radek){
    2d46:	cf 92       	push	r12
    2d48:	df 92       	push	r13
    2d4a:	ef 92       	push	r14
    2d4c:	ff 92       	push	r15
    2d4e:	0f 93       	push	r16
    2d50:	1f 93       	push	r17
    2d52:	d8 2e       	mov	r13, r24
    2d54:	c9 2e       	mov	r12, r25
    2d56:	8b 01       	movw	r16, r22
  char * str = (char *)mmalloc(strlen(soubor) + 20 + 4 + 3);
    2d58:	a8 2f       	mov	r26, r24
    2d5a:	b9 2f       	mov	r27, r25
    2d5c:	fd 01       	movw	r30, r26
    2d5e:	01 90       	ld	r0, Z+
    2d60:	00 20       	and	r0, r0
    2d62:	e9 f7       	brne	.-6      	; 0x2d5e <err_assert+0x18>
    2d64:	ea 1b       	sub	r30, r26
    2d66:	fb 0b       	sbc	r31, r27
    2d68:	cf 01       	movw	r24, r30
    2d6a:	4a 96       	adiw	r24, 0x1a	; 26
    2d6c:	0e 94 a4 1d 	call	0x3b48	; 0x3b48 <mmalloc>
    2d70:	f8 2e       	mov	r15, r24
    2d72:	e9 2e       	mov	r14, r25
  
  sprintf(str,"Error 150: assert()\n%s\n%i",soubor,radek);
    2d74:	8d b7       	in	r24, 0x3d	; 61
    2d76:	9e b7       	in	r25, 0x3e	; 62
    2d78:	08 97       	sbiw	r24, 0x08	; 8
    2d7a:	0f b6       	in	r0, 0x3f	; 63
    2d7c:	f8 94       	cli
    2d7e:	9e bf       	out	0x3e, r25	; 62
    2d80:	0f be       	out	0x3f, r0	; 63
    2d82:	8d bf       	out	0x3d, r24	; 61
    2d84:	ed b7       	in	r30, 0x3d	; 61
    2d86:	fe b7       	in	r31, 0x3e	; 62
    2d88:	31 96       	adiw	r30, 0x01	; 1
    2d8a:	ad b7       	in	r26, 0x3d	; 61
    2d8c:	be b7       	in	r27, 0x3e	; 62
    2d8e:	11 96       	adiw	r26, 0x01	; 1
    2d90:	fc 92       	st	X, r15
    2d92:	e1 82       	std	Z+1, r14	; 0x01
    2d94:	85 eb       	ldi	r24, 0xB5	; 181
    2d96:	90 e0       	ldi	r25, 0x00	; 0
    2d98:	93 83       	std	Z+3, r25	; 0x03
    2d9a:	82 83       	std	Z+2, r24	; 0x02
    2d9c:	d4 82       	std	Z+4, r13	; 0x04
    2d9e:	c5 82       	std	Z+5, r12	; 0x05
    2da0:	17 83       	std	Z+7, r17	; 0x07
    2da2:	06 83       	std	Z+6, r16	; 0x06
    2da4:	0e 94 3d 1f 	call	0x3e7a	; 0x3e7a <sprintf>
  new_str_error(150,str);
    2da8:	8d b7       	in	r24, 0x3d	; 61
    2daa:	9e b7       	in	r25, 0x3e	; 62
    2dac:	08 96       	adiw	r24, 0x08	; 8
    2dae:	0f b6       	in	r0, 0x3f	; 63
    2db0:	f8 94       	cli
    2db2:	9e bf       	out	0x3e, r25	; 62
    2db4:	0f be       	out	0x3f, r0	; 63
    2db6:	8d bf       	out	0x3d, r24	; 61
    2db8:	86 e9       	ldi	r24, 0x96	; 150
    2dba:	6f 2d       	mov	r22, r15
    2dbc:	7e 2d       	mov	r23, r14
    2dbe:	0e 94 e8 16 	call	0x2dd0	; 0x2dd0 <new_str_error>
}
    2dc2:	1f 91       	pop	r17
    2dc4:	0f 91       	pop	r16
    2dc6:	ff 90       	pop	r15
    2dc8:	ef 90       	pop	r14
    2dca:	df 90       	pop	r13
    2dcc:	cf 90       	pop	r12
    2dce:	08 95       	ret

00002dd0 <new_str_error>:


/**
 * Funkce vytvoří nový error. Jeho text je zadán v parametru s.
 */
void new_str_error(uint8_t err_num, char * s){
    2dd0:	1f 93       	push	r17
    2dd2:	cf 93       	push	r28
    2dd4:	df 93       	push	r29
    2dd6:	18 2f       	mov	r17, r24
    2dd8:	eb 01       	movw	r28, r22
  assert(err_num >= 150);
    2dda:	86 39       	cpi	r24, 0x96	; 150
    2ddc:	30 f4       	brcc	.+12     	; 0x2dea <new_str_error+0x1a>
    2dde:	8f ec       	ldi	r24, 0xCF	; 207
    2de0:	90 e0       	ldi	r25, 0x00	; 0
    2de2:	6a e8       	ldi	r22, 0x8A	; 138
    2de4:	70 e0       	ldi	r23, 0x00	; 0
    2de6:	0e 94 a3 16 	call	0x2d46	; 0x2d46 <err_assert>
  last_err = err_num;
    2dea:	10 93 d7 00 	sts	0x00D7, r17
  err_str = s;
    2dee:	d0 93 a6 01 	sts	0x01A6, r29
    2df2:	c0 93 a5 01 	sts	0x01A5, r28
  //scr_ch(ERR_SCR);

}
    2df6:	df 91       	pop	r29
    2df8:	cf 91       	pop	r28
    2dfa:	1f 91       	pop	r17
    2dfc:	08 95       	ret

00002dfe <print_err>:

void print_err(void){
  
  //error_scr_draw();
  switch(last_err){
    2dfe:	80 91 d7 00 	lds	r24, 0x00D7
    2e02:	90 e0       	ldi	r25, 0x00	; 0
    2e04:	fc 01       	movw	r30, r24
    2e06:	31 97       	sbiw	r30, 0x01	; 1
    2e08:	e9 3c       	cpi	r30, 0xC9	; 201
    2e0a:	f1 05       	cpc	r31, r1
    2e0c:	80 f4       	brcc	.+32     	; 0x2e2e <print_err+0x30>
    2e0e:	e9 53       	subi	r30, 0x39	; 57
    2e10:	ff 4f       	sbci	r31, 0xFF	; 255
    2e12:	ee 0f       	add	r30, r30
    2e14:	ff 1f       	adc	r31, r31
    2e16:	05 90       	lpm	r0, Z+
    2e18:	f4 91       	lpm	r31, Z+
    2e1a:	e0 2d       	mov	r30, r0
    2e1c:	09 94       	ijmp
      break;
    case 200:
      printxyd_P(0,0,(void *)err200);
      break;
    case 201:
      printxyd_P(0,0,(void *)err201);
    2e1e:	80 e0       	ldi	r24, 0x00	; 0
    2e20:	90 e0       	ldi	r25, 0x00	; 0
    2e22:	60 e0       	ldi	r22, 0x00	; 0
    2e24:	70 e0       	ldi	r23, 0x00	; 0
    2e26:	43 ee       	ldi	r20, 0xE3	; 227
    2e28:	5c e0       	ldi	r21, 0x0C	; 12
    2e2a:	0e 94 a6 14 	call	0x294c	; 0x294c <printxyd_P>
    2e2e:	08 95       	ret
      break;
    case 102:
      printxyd_P(0,0,(void *)err102);
      break;
    case 200:
      printxyd_P(0,0,(void *)err200);
    2e30:	80 e0       	ldi	r24, 0x00	; 0
    2e32:	90 e0       	ldi	r25, 0x00	; 0
    2e34:	60 e0       	ldi	r22, 0x00	; 0
    2e36:	70 e0       	ldi	r23, 0x00	; 0
    2e38:	46 ec       	ldi	r20, 0xC6	; 198
    2e3a:	5c e0       	ldi	r21, 0x0C	; 12
    2e3c:	0e 94 a6 14 	call	0x294c	; 0x294c <printxyd_P>
    2e40:	08 95       	ret
      break;
    case 101:
      printxyd_P(0,0,(void *)err101);
      break;
    case 102:
      printxyd_P(0,0,(void *)err102);
    2e42:	80 e0       	ldi	r24, 0x00	; 0
    2e44:	90 e0       	ldi	r25, 0x00	; 0
    2e46:	60 e0       	ldi	r22, 0x00	; 0
    2e48:	70 e0       	ldi	r23, 0x00	; 0
    2e4a:	48 e9       	ldi	r20, 0x98	; 152
    2e4c:	5c e0       	ldi	r21, 0x0C	; 12
    2e4e:	0e 94 a6 14 	call	0x294c	; 0x294c <printxyd_P>
    2e52:	08 95       	ret
      break;
    case 100:
      printxyd_P(0,0,(void *)err100);
      break;
    case 101:
      printxyd_P(0,0,(void *)err101);
    2e54:	80 e0       	ldi	r24, 0x00	; 0
    2e56:	90 e0       	ldi	r25, 0x00	; 0
    2e58:	60 e0       	ldi	r22, 0x00	; 0
    2e5a:	70 e0       	ldi	r23, 0x00	; 0
    2e5c:	4f e3       	ldi	r20, 0x3F	; 63
    2e5e:	5c e0       	ldi	r21, 0x0C	; 12
    2e60:	0e 94 a6 14 	call	0x294c	; 0x294c <printxyd_P>
    2e64:	08 95       	ret
      break;
    case 99:
      printxyd_P(0,0,(void *)err99);
      break;
    case 100:
      printxyd_P(0,0,(void *)err100);
    2e66:	80 e0       	ldi	r24, 0x00	; 0
    2e68:	90 e0       	ldi	r25, 0x00	; 0
    2e6a:	60 e0       	ldi	r22, 0x00	; 0
    2e6c:	70 e0       	ldi	r23, 0x00	; 0
    2e6e:	4b e1       	ldi	r20, 0x1B	; 27
    2e70:	5c e0       	ldi	r21, 0x0C	; 12
    2e72:	0e 94 a6 14 	call	0x294c	; 0x294c <printxyd_P>
    2e76:	08 95       	ret
      break;
    case 96:
      printxyd_P(0,0,(void *)err96);
      break;
    case 99:
      printxyd_P(0,0,(void *)err99);
    2e78:	80 e0       	ldi	r24, 0x00	; 0
    2e7a:	90 e0       	ldi	r25, 0x00	; 0
    2e7c:	60 e0       	ldi	r22, 0x00	; 0
    2e7e:	70 e0       	ldi	r23, 0x00	; 0
    2e80:	4a ec       	ldi	r20, 0xCA	; 202
    2e82:	5b e0       	ldi	r21, 0x0B	; 11
    2e84:	0e 94 a6 14 	call	0x294c	; 0x294c <printxyd_P>
    2e88:	08 95       	ret
      break;
    case 95:
      printxyd_P(0,0,(void *)err95);
      break;
    case 96:
      printxyd_P(0,0,(void *)err96);
    2e8a:	80 e0       	ldi	r24, 0x00	; 0
    2e8c:	90 e0       	ldi	r25, 0x00	; 0
    2e8e:	60 e0       	ldi	r22, 0x00	; 0
    2e90:	70 e0       	ldi	r23, 0x00	; 0
    2e92:	4b e5       	ldi	r20, 0x5B	; 91
    2e94:	5b e0       	ldi	r21, 0x0B	; 11
    2e96:	0e 94 a6 14 	call	0x294c	; 0x294c <printxyd_P>
    2e9a:	08 95       	ret
      break;
    case 94:
      printxyd_P(0,0,(void *)err94);
      break;
    case 95:
      printxyd_P(0,0,(void *)err95);
    2e9c:	80 e0       	ldi	r24, 0x00	; 0
    2e9e:	90 e0       	ldi	r25, 0x00	; 0
    2ea0:	60 e0       	ldi	r22, 0x00	; 0
    2ea2:	70 e0       	ldi	r23, 0x00	; 0
    2ea4:	4e ed       	ldi	r20, 0xDE	; 222
    2ea6:	5a e0       	ldi	r21, 0x0A	; 10
    2ea8:	0e 94 a6 14 	call	0x294c	; 0x294c <printxyd_P>
    2eac:	08 95       	ret
      break;
    case 93:
      printxyd_P(0,0,(void *)err93);
      break;
    case 94:
      printxyd_P(0,0,(void *)err94);
    2eae:	80 e0       	ldi	r24, 0x00	; 0
    2eb0:	90 e0       	ldi	r25, 0x00	; 0
    2eb2:	60 e0       	ldi	r22, 0x00	; 0
    2eb4:	70 e0       	ldi	r23, 0x00	; 0
    2eb6:	4a ea       	ldi	r20, 0xAA	; 170
    2eb8:	5a e0       	ldi	r21, 0x0A	; 10
    2eba:	0e 94 a6 14 	call	0x294c	; 0x294c <printxyd_P>
    2ebe:	08 95       	ret
      break;
    case 92:
      printxyd_P(0,0,(void *)err92);
      break;
    case 93:
      printxyd_P(0,0,(void *)err93);
    2ec0:	80 e0       	ldi	r24, 0x00	; 0
    2ec2:	90 e0       	ldi	r25, 0x00	; 0
    2ec4:	60 e0       	ldi	r22, 0x00	; 0
    2ec6:	70 e0       	ldi	r23, 0x00	; 0
    2ec8:	48 e4       	ldi	r20, 0x48	; 72
    2eca:	5a e0       	ldi	r21, 0x0A	; 10
    2ecc:	0e 94 a6 14 	call	0x294c	; 0x294c <printxyd_P>
    2ed0:	08 95       	ret
      break;
    case 91:
      printxyd_P(0,0,(void *)err91);
      break;
    case 92:
      printxyd_P(0,0,(void *)err92);
    2ed2:	80 e0       	ldi	r24, 0x00	; 0
    2ed4:	90 e0       	ldi	r25, 0x00	; 0
    2ed6:	60 e0       	ldi	r22, 0x00	; 0
    2ed8:	70 e0       	ldi	r23, 0x00	; 0
    2eda:	40 ed       	ldi	r20, 0xD0	; 208
    2edc:	59 e0       	ldi	r21, 0x09	; 9
    2ede:	0e 94 a6 14 	call	0x294c	; 0x294c <printxyd_P>
    2ee2:	08 95       	ret
      break;
    case 90:
      printxyd_P(0,0,(void *)err90);
      break;
    case 91:
      printxyd_P(0,0,(void *)err91);
    2ee4:	80 e0       	ldi	r24, 0x00	; 0
    2ee6:	90 e0       	ldi	r25, 0x00	; 0
    2ee8:	60 e0       	ldi	r22, 0x00	; 0
    2eea:	70 e0       	ldi	r23, 0x00	; 0
    2eec:	48 e9       	ldi	r20, 0x98	; 152
    2eee:	59 e0       	ldi	r21, 0x09	; 9
    2ef0:	0e 94 a6 14 	call	0x294c	; 0x294c <printxyd_P>
    2ef4:	08 95       	ret
      break;
    case 89:
      printxyd_P(0,0,(void *)err89);
      break;
    case 90:
      printxyd_P(0,0,(void *)err90);
    2ef6:	80 e0       	ldi	r24, 0x00	; 0
    2ef8:	90 e0       	ldi	r25, 0x00	; 0
    2efa:	60 e0       	ldi	r22, 0x00	; 0
    2efc:	70 e0       	ldi	r23, 0x00	; 0
    2efe:	4f e3       	ldi	r20, 0x3F	; 63
    2f00:	59 e0       	ldi	r21, 0x09	; 9
    2f02:	0e 94 a6 14 	call	0x294c	; 0x294c <printxyd_P>
    2f06:	08 95       	ret
      break;
    case 88:
      printxyd_P(0,0,(void *)err88);
      break;
    case 89:
      printxyd_P(0,0,(void *)err89);
    2f08:	80 e0       	ldi	r24, 0x00	; 0
    2f0a:	90 e0       	ldi	r25, 0x00	; 0
    2f0c:	60 e0       	ldi	r22, 0x00	; 0
    2f0e:	70 e0       	ldi	r23, 0x00	; 0
    2f10:	4c ee       	ldi	r20, 0xEC	; 236
    2f12:	58 e0       	ldi	r21, 0x08	; 8
    2f14:	0e 94 a6 14 	call	0x294c	; 0x294c <printxyd_P>
    2f18:	08 95       	ret
      break;
    case 87:
      printxyd_P(0,0,(void *)err87);
      break;
    case 88:
      printxyd_P(0,0,(void *)err88);
    2f1a:	80 e0       	ldi	r24, 0x00	; 0
    2f1c:	90 e0       	ldi	r25, 0x00	; 0
    2f1e:	60 e0       	ldi	r22, 0x00	; 0
    2f20:	70 e0       	ldi	r23, 0x00	; 0
    2f22:	40 ed       	ldi	r20, 0xD0	; 208
    2f24:	58 e0       	ldi	r21, 0x08	; 8
    2f26:	0e 94 a6 14 	call	0x294c	; 0x294c <printxyd_P>
    2f2a:	08 95       	ret
      break;
    case 86:
      printxyd_P(0,0,(void *)err86);
      break;
    case 87:
      printxyd_P(0,0,(void *)err87);
    2f2c:	80 e0       	ldi	r24, 0x00	; 0
    2f2e:	90 e0       	ldi	r25, 0x00	; 0
    2f30:	60 e0       	ldi	r22, 0x00	; 0
    2f32:	70 e0       	ldi	r23, 0x00	; 0
    2f34:	40 e8       	ldi	r20, 0x80	; 128
    2f36:	58 e0       	ldi	r21, 0x08	; 8
    2f38:	0e 94 a6 14 	call	0x294c	; 0x294c <printxyd_P>
    2f3c:	08 95       	ret
      break;
    case 85:
      printxyd_P(0,0,(void *)err85);
      break;
    case 86:
      printxyd_P(0,0,(void *)err86);
    2f3e:	80 e0       	ldi	r24, 0x00	; 0
    2f40:	90 e0       	ldi	r25, 0x00	; 0
    2f42:	60 e0       	ldi	r22, 0x00	; 0
    2f44:	70 e0       	ldi	r23, 0x00	; 0
    2f46:	46 e1       	ldi	r20, 0x16	; 22
    2f48:	58 e0       	ldi	r21, 0x08	; 8
    2f4a:	0e 94 a6 14 	call	0x294c	; 0x294c <printxyd_P>
    2f4e:	08 95       	ret
      break;
    case 84: // measure.c
      printxyd_P(0,0,(void *)err84);
      break;
    case 85:
      printxyd_P(0,0,(void *)err85);
    2f50:	80 e0       	ldi	r24, 0x00	; 0
    2f52:	90 e0       	ldi	r25, 0x00	; 0
    2f54:	60 e0       	ldi	r22, 0x00	; 0
    2f56:	70 e0       	ldi	r23, 0x00	; 0
    2f58:	40 eb       	ldi	r20, 0xB0	; 176
    2f5a:	57 e0       	ldi	r21, 0x07	; 7
    2f5c:	0e 94 a6 14 	call	0x294c	; 0x294c <printxyd_P>
    2f60:	08 95       	ret
      break;
    case 83: // irc.c
      printxyd_P(0,0,(void *)err83);
      break;
    case 84: // measure.c
      printxyd_P(0,0,(void *)err84);
    2f62:	80 e0       	ldi	r24, 0x00	; 0
    2f64:	90 e0       	ldi	r25, 0x00	; 0
    2f66:	60 e0       	ldi	r22, 0x00	; 0
    2f68:	70 e0       	ldi	r23, 0x00	; 0
    2f6a:	41 e7       	ldi	r20, 0x71	; 113
    2f6c:	57 e0       	ldi	r21, 0x07	; 7
    2f6e:	0e 94 a6 14 	call	0x294c	; 0x294c <printxyd_P>
    2f72:	08 95       	ret
      break;
    case 82: // lcd.c
      printxyd_P(0,0,(void *)err82);
      break;
    case 83: // irc.c
      printxyd_P(0,0,(void *)err83);
    2f74:	80 e0       	ldi	r24, 0x00	; 0
    2f76:	90 e0       	ldi	r25, 0x00	; 0
    2f78:	60 e0       	ldi	r22, 0x00	; 0
    2f7a:	70 e0       	ldi	r23, 0x00	; 0
    2f7c:	43 e3       	ldi	r20, 0x33	; 51
    2f7e:	57 e0       	ldi	r21, 0x07	; 7
    2f80:	0e 94 a6 14 	call	0x294c	; 0x294c <printxyd_P>
    2f84:	08 95       	ret
      break;
    case 81: // lcd.c
      printxyd_P(0,0,(void *)err81);
      break;
    case 82: // lcd.c
      printxyd_P(0,0,(void *)err82);
    2f86:	80 e0       	ldi	r24, 0x00	; 0
    2f88:	90 e0       	ldi	r25, 0x00	; 0
    2f8a:	60 e0       	ldi	r22, 0x00	; 0
    2f8c:	70 e0       	ldi	r23, 0x00	; 0
    2f8e:	44 e0       	ldi	r20, 0x04	; 4
    2f90:	57 e0       	ldi	r21, 0x07	; 7
    2f92:	0e 94 a6 14 	call	0x294c	; 0x294c <printxyd_P>
    2f96:	08 95       	ret
      break;
    case 80: // lcd.c chyba LCD - překročení rozsahu displeje po odřádkování
      printxyd_P(0,0,(void *)err80);
      break;
    case 81: // lcd.c
      printxyd_P(0,0,(void *)err81);
    2f98:	80 e0       	ldi	r24, 0x00	; 0
    2f9a:	90 e0       	ldi	r25, 0x00	; 0
    2f9c:	60 e0       	ldi	r22, 0x00	; 0
    2f9e:	70 e0       	ldi	r23, 0x00	; 0
    2fa0:	47 ed       	ldi	r20, 0xD7	; 215
    2fa2:	56 e0       	ldi	r21, 0x06	; 6
    2fa4:	0e 94 a6 14 	call	0x294c	; 0x294c <printxyd_P>
    2fa8:	08 95       	ret
      break;
    case 11:
      printxyd_P(0,0,(void *)err11);
      break;
    case 80: // lcd.c chyba LCD - překročení rozsahu displeje po odřádkování
      printxyd_P(0,0,(void *)err80);
    2faa:	80 e0       	ldi	r24, 0x00	; 0
    2fac:	90 e0       	ldi	r25, 0x00	; 0
    2fae:	60 e0       	ldi	r22, 0x00	; 0
    2fb0:	70 e0       	ldi	r23, 0x00	; 0
    2fb2:	4d e9       	ldi	r20, 0x9D	; 157
    2fb4:	56 e0       	ldi	r21, 0x06	; 6
    2fb6:	0e 94 a6 14 	call	0x294c	; 0x294c <printxyd_P>
    2fba:	08 95       	ret
      break;
    case 10:
      printxyd_P(0,0,(void *)err10);
      break;
    case 11:
      printxyd_P(0,0,(void *)err11);
    2fbc:	80 e0       	ldi	r24, 0x00	; 0
    2fbe:	90 e0       	ldi	r25, 0x00	; 0
    2fc0:	60 e0       	ldi	r22, 0x00	; 0
    2fc2:	70 e0       	ldi	r23, 0x00	; 0
    2fc4:	49 e8       	ldi	r20, 0x89	; 137
    2fc6:	56 e0       	ldi	r21, 0x06	; 6
    2fc8:	0e 94 a6 14 	call	0x294c	; 0x294c <printxyd_P>
    2fcc:	08 95       	ret
      break;
    case 7:
      printxyd_P(0,0,(void *)err7);
      break;
    case 10:
      printxyd_P(0,0,(void *)err10);
    2fce:	80 e0       	ldi	r24, 0x00	; 0
    2fd0:	90 e0       	ldi	r25, 0x00	; 0
    2fd2:	60 e0       	ldi	r22, 0x00	; 0
    2fd4:	70 e0       	ldi	r23, 0x00	; 0
    2fd6:	47 e7       	ldi	r20, 0x77	; 119
    2fd8:	56 e0       	ldi	r21, 0x06	; 6
    2fda:	0e 94 a6 14 	call	0x294c	; 0x294c <printxyd_P>
    2fde:	08 95       	ret
      break;
    case 6:
      printxyd_P(0,0,(void *)err6);
      break;
    case 7:
      printxyd_P(0,0,(void *)err7);
    2fe0:	80 e0       	ldi	r24, 0x00	; 0
    2fe2:	90 e0       	ldi	r25, 0x00	; 0
    2fe4:	60 e0       	ldi	r22, 0x00	; 0
    2fe6:	70 e0       	ldi	r23, 0x00	; 0
    2fe8:	4c e2       	ldi	r20, 0x2C	; 44
    2fea:	56 e0       	ldi	r21, 0x06	; 6
    2fec:	0e 94 a6 14 	call	0x294c	; 0x294c <printxyd_P>
    2ff0:	08 95       	ret
      break;
    case 4:
      printxyd_P(0,0,(void *)err4);
      break;
    case 6:
      printxyd_P(0,0,(void *)err6);
    2ff2:	80 e0       	ldi	r24, 0x00	; 0
    2ff4:	90 e0       	ldi	r25, 0x00	; 0
    2ff6:	60 e0       	ldi	r22, 0x00	; 0
    2ff8:	70 e0       	ldi	r23, 0x00	; 0
    2ffa:	4c ef       	ldi	r20, 0xFC	; 252
    2ffc:	55 e0       	ldi	r21, 0x05	; 5
    2ffe:	0e 94 a6 14 	call	0x294c	; 0x294c <printxyd_P>
    3002:	08 95       	ret
  switch(last_err){
    case 1: 
      printxyd_P(0,0,(void *)err1);
      break;
    case 4:
      printxyd_P(0,0,(void *)err4);
    3004:	80 e0       	ldi	r24, 0x00	; 0
    3006:	90 e0       	ldi	r25, 0x00	; 0
    3008:	60 e0       	ldi	r22, 0x00	; 0
    300a:	70 e0       	ldi	r23, 0x00	; 0
    300c:	4d ec       	ldi	r20, 0xCD	; 205
    300e:	55 e0       	ldi	r21, 0x05	; 5
    3010:	0e 94 a6 14 	call	0x294c	; 0x294c <printxyd_P>
    3014:	08 95       	ret
void print_err(void){
  
  //error_scr_draw();
  switch(last_err){
    case 1: 
      printxyd_P(0,0,(void *)err1);
    3016:	80 e0       	ldi	r24, 0x00	; 0
    3018:	90 e0       	ldi	r25, 0x00	; 0
    301a:	60 e0       	ldi	r22, 0x00	; 0
    301c:	70 e0       	ldi	r23, 0x00	; 0
    301e:	44 e6       	ldi	r20, 0x64	; 100
    3020:	55 e0       	ldi	r21, 0x05	; 5
    3022:	0e 94 a6 14 	call	0x294c	; 0x294c <printxyd_P>
    3026:	08 95       	ret

00003028 <error_scr_draw>:
void error_scr_draw(void){
  /*if (prev_scr == ERR_SCR){
    prev_scr = MSR_SCR;
  }*/

  clear_dscreen();
    3028:	0e 94 ca 12 	call	0x2594	; 0x2594 <clear_dscreen>
  //akt_scr = ERR_SCR;
  if ((last_err >= 150)&&(last_err < 200)){
    302c:	80 91 d7 00 	lds	r24, 0x00D7
    3030:	86 59       	subi	r24, 0x96	; 150
    3032:	82 33       	cpi	r24, 0x32	; 50
    3034:	18 f0       	brcs	.+6      	; 0x303c <error_scr_draw+0x14>
    printxyd(0,0,err_str);
    mfree((void*)err_str);
    err_str = NULL;
  }
  else{
    print_err();
    3036:	0e 94 ff 16 	call	0x2dfe	; 0x2dfe <print_err>
    303a:	08 95       	ret
  }*/

  clear_dscreen();
  //akt_scr = ERR_SCR;
  if ((last_err >= 150)&&(last_err < 200)){
    printxyd(0,0,err_str);
    303c:	40 91 a5 01 	lds	r20, 0x01A5
    3040:	50 91 a6 01 	lds	r21, 0x01A6
    3044:	80 e0       	ldi	r24, 0x00	; 0
    3046:	90 e0       	ldi	r25, 0x00	; 0
    3048:	60 e0       	ldi	r22, 0x00	; 0
    304a:	70 e0       	ldi	r23, 0x00	; 0
    304c:	0e 94 85 15 	call	0x2b0a	; 0x2b0a <printxyd>
    mfree((void*)err_str);
    3050:	80 91 a5 01 	lds	r24, 0x01A5
    3054:	90 91 a6 01 	lds	r25, 0x01A6
    3058:	0e 94 98 1d 	call	0x3b30	; 0x3b30 <mfree>
    err_str = NULL;
    305c:	10 92 a6 01 	sts	0x01A6, r1
    3060:	10 92 a5 01 	sts	0x01A5, r1
    3064:	08 95       	ret

00003066 <new_error>:
}

/// Funkce vytváří novou chybu. Dojde k přepnutí na
/// "error screen" a k výpisu textu popisujícího tuto chybu.
/// @param err_num Identifikuje číslem chybovou hlášku.
void new_error(uint8_t err_num){
    3066:	1f 93       	push	r17
    3068:	18 2f       	mov	r17, r24
  char * msg;

  last_err = err_num;
    306a:	80 93 d7 00 	sts	0x00D7, r24
  new_err = 1;
    306e:	81 e0       	ldi	r24, 0x01	; 1
    3070:	80 93 a7 01 	sts	0x01A7, r24
  
  si_print_error(err_num);
    3074:	81 2f       	mov	r24, r17
    3076:	0e 94 b9 1b 	call	0x3772	; 0x3772 <si_print_error>



    msg =(void*) mmalloc (DATASIZE);
    307a:	8a e0       	ldi	r24, 0x0A	; 10
    307c:	90 e0       	ldi	r25, 0x00	; 0
    307e:	0e 94 a4 1d 	call	0x3b48	; 0x3b48 <mmalloc>
    3082:	fc 01       	movw	r30, r24
    msg[0] = MSGN_ERR;
    3084:	82 e6       	ldi	r24, 0x62	; 98
    3086:	80 83       	st	Z, r24
    msg[1] = err_num;
    3088:	11 83       	std	Z+1, r17	; 0x01
    new_msg(msg);
    308a:	cf 01       	movw	r24, r30
    308c:	0e 94 21 0a 	call	0x1442	; 0x1442 <new_msg>


  //prev_scr = akt_scr;
  //scr_ch(ERR_SCR);
 
}
    3090:	1f 91       	pop	r17
    3092:	08 95       	ret

00003094 <get_char>:
}
//TODO
/// Funkce vrátí poslední přijatý znak .

char get_char(void) {
  if (keyb_buff[0].flag == 1) {
    3094:	80 91 ad 01 	lds	r24, 0x01AD
    3098:	81 30       	cpi	r24, 0x01	; 1
    309a:	11 f0       	breq	.+4      	; 0x30a0 <get_char+0xc>
    309c:	20 e0       	ldi	r18, 0x00	; 0
    309e:	2e c0       	rjmp	.+92     	; 0x30fc <get_char+0x68>
static KEY get_key_from_buff(void) {
  int i = 0;
  KEY out;

  out.flag = keyb_buff[0].flag;
  out.kod = keyb_buff[0].kod;
    30a0:	20 91 ae 01 	lds	r18, 0x01AE
  if (keyb_buff[0].flag == 0)
    return out;

  for (i = 0; i < (KEYB_BUFF_SIZE - 1); i++) {
    if (keyb_buff[i + 1].flag != 0) {
    30a4:	90 91 af 01 	lds	r25, 0x01AF
    30a8:	99 23       	and	r25, r25
    30aa:	29 f4       	brne	.+10     	; 0x30b6 <get_char+0x22>
    30ac:	a1 e0       	ldi	r26, 0x01	; 1
    30ae:	b0 e0       	ldi	r27, 0x00	; 0
    30b0:	e0 e0       	ldi	r30, 0x00	; 0
    30b2:	f0 e0       	ldi	r31, 0x00	; 0
    30b4:	17 c0       	rjmp	.+46     	; 0x30e4 <get_char+0x50>
      keyb_buff[i] = keyb_buff[i + 1];
    30b6:	80 91 b0 01 	lds	r24, 0x01B0
    30ba:	80 93 ae 01 	sts	0x01AE, r24
    30be:	90 93 ad 01 	sts	0x01AD, r25
  out.kod = keyb_buff[0].kod;
  if (keyb_buff[0].flag == 0)
    return out;

  for (i = 0; i < (KEYB_BUFF_SIZE - 1); i++) {
    if (keyb_buff[i + 1].flag != 0) {
    30c2:	90 91 b1 01 	lds	r25, 0x01B1
    30c6:	99 23       	and	r25, r25
    30c8:	49 f0       	breq	.+18     	; 0x30dc <get_char+0x48>
      keyb_buff[i] = keyb_buff[i + 1];
    30ca:	80 91 b2 01 	lds	r24, 0x01B2
    30ce:	80 93 b0 01 	sts	0x01B0, r24
    30d2:	90 93 af 01 	sts	0x01AF, r25
    } else {
      keyb_buff[i] = keyb_buff[i + 1];
      return out;
    }
  }
  keyb_buff[KEYB_BUFF_SIZE - 1].flag = 0;
    30d6:	10 92 b1 01 	sts	0x01B1, r1
    30da:	10 c0       	rjmp	.+32     	; 0x30fc <get_char+0x68>
    30dc:	a2 e0       	ldi	r26, 0x02	; 2
    30de:	b0 e0       	ldi	r27, 0x00	; 0
    30e0:	e1 e0       	ldi	r30, 0x01	; 1
    30e2:	f0 e0       	ldi	r31, 0x00	; 0

  for (i = 0; i < (KEYB_BUFF_SIZE - 1); i++) {
    if (keyb_buff[i + 1].flag != 0) {
      keyb_buff[i] = keyb_buff[i + 1];
    } else {
      keyb_buff[i] = keyb_buff[i + 1];
    30e4:	ee 0f       	add	r30, r30
    30e6:	ff 1f       	adc	r31, r31
    30e8:	e3 55       	subi	r30, 0x53	; 83
    30ea:	fe 4f       	sbci	r31, 0xFE	; 254
    30ec:	aa 0f       	add	r26, r26
    30ee:	bb 1f       	adc	r27, r27
    30f0:	a3 55       	subi	r26, 0x53	; 83
    30f2:	be 4f       	sbci	r27, 0xFE	; 254
    30f4:	11 96       	adiw	r26, 0x01	; 1
    30f6:	8c 91       	ld	r24, X
    30f8:	81 83       	std	Z+1, r24	; 0x01
    30fa:	10 82       	st	Z, r1
char get_char(void) {
  if (keyb_buff[0].flag == 1) {
    return get_key_from_buff().kod;
  } else
    return 0;
}
    30fc:	82 2f       	mov	r24, r18
    30fe:	08 95       	ret

00003100 <get_spec>:

/// Funkce vrátí poslední přijatý stisk speciální klávesy.

char get_spec(void) {
  if (keyb_buff[0].flag == 2) {
    3100:	80 91 ad 01 	lds	r24, 0x01AD
    3104:	82 30       	cpi	r24, 0x02	; 2
    3106:	11 f0       	breq	.+4      	; 0x310c <get_spec+0xc>
    3108:	20 e0       	ldi	r18, 0x00	; 0
    310a:	2e c0       	rjmp	.+92     	; 0x3168 <get_spec+0x68>
static KEY get_key_from_buff(void) {
  int i = 0;
  KEY out;

  out.flag = keyb_buff[0].flag;
  out.kod = keyb_buff[0].kod;
    310c:	20 91 ae 01 	lds	r18, 0x01AE
  if (keyb_buff[0].flag == 0)
    return out;

  for (i = 0; i < (KEYB_BUFF_SIZE - 1); i++) {
    if (keyb_buff[i + 1].flag != 0) {
    3110:	90 91 af 01 	lds	r25, 0x01AF
    3114:	99 23       	and	r25, r25
    3116:	29 f4       	brne	.+10     	; 0x3122 <get_spec+0x22>
    3118:	a1 e0       	ldi	r26, 0x01	; 1
    311a:	b0 e0       	ldi	r27, 0x00	; 0
    311c:	e0 e0       	ldi	r30, 0x00	; 0
    311e:	f0 e0       	ldi	r31, 0x00	; 0
    3120:	17 c0       	rjmp	.+46     	; 0x3150 <get_spec+0x50>
      keyb_buff[i] = keyb_buff[i + 1];
    3122:	80 91 b0 01 	lds	r24, 0x01B0
    3126:	80 93 ae 01 	sts	0x01AE, r24
    312a:	90 93 ad 01 	sts	0x01AD, r25
  out.kod = keyb_buff[0].kod;
  if (keyb_buff[0].flag == 0)
    return out;

  for (i = 0; i < (KEYB_BUFF_SIZE - 1); i++) {
    if (keyb_buff[i + 1].flag != 0) {
    312e:	90 91 b1 01 	lds	r25, 0x01B1
    3132:	99 23       	and	r25, r25
    3134:	49 f0       	breq	.+18     	; 0x3148 <get_spec+0x48>
      keyb_buff[i] = keyb_buff[i + 1];
    3136:	80 91 b2 01 	lds	r24, 0x01B2
    313a:	80 93 b0 01 	sts	0x01B0, r24
    313e:	90 93 af 01 	sts	0x01AF, r25
    } else {
      keyb_buff[i] = keyb_buff[i + 1];
      return out;
    }
  }
  keyb_buff[KEYB_BUFF_SIZE - 1].flag = 0;
    3142:	10 92 b1 01 	sts	0x01B1, r1
    3146:	10 c0       	rjmp	.+32     	; 0x3168 <get_spec+0x68>
    3148:	a2 e0       	ldi	r26, 0x02	; 2
    314a:	b0 e0       	ldi	r27, 0x00	; 0
    314c:	e1 e0       	ldi	r30, 0x01	; 1
    314e:	f0 e0       	ldi	r31, 0x00	; 0

  for (i = 0; i < (KEYB_BUFF_SIZE - 1); i++) {
    if (keyb_buff[i + 1].flag != 0) {
      keyb_buff[i] = keyb_buff[i + 1];
    } else {
      keyb_buff[i] = keyb_buff[i + 1];
    3150:	ee 0f       	add	r30, r30
    3152:	ff 1f       	adc	r31, r31
    3154:	e3 55       	subi	r30, 0x53	; 83
    3156:	fe 4f       	sbci	r31, 0xFE	; 254
    3158:	aa 0f       	add	r26, r26
    315a:	bb 1f       	adc	r27, r27
    315c:	a3 55       	subi	r26, 0x53	; 83
    315e:	be 4f       	sbci	r27, 0xFE	; 254
    3160:	11 96       	adiw	r26, 0x01	; 1
    3162:	8c 91       	ld	r24, X
    3164:	81 83       	std	Z+1, r24	; 0x01
    3166:	10 82       	st	Z, r1
char get_spec(void) {
  if (keyb_buff[0].flag == 2) {
    return get_key_from_buff().kod;
  } else
    return 0;
}
    3168:	82 2f       	mov	r24, r18
    316a:	08 95       	ret

0000316c <keyboard_init>:

void keyboard_init(void) {
  MCUCR |= (1 << ISC11) | (0 << ISC10); // nastaven� p�eru�en� se sestupnou hranou
    316c:	85 b7       	in	r24, 0x35	; 53
    316e:	88 60       	ori	r24, 0x08	; 8
    3170:	85 bf       	out	0x35, r24	; 53
  GICR |= (1 << INT1);
    3172:	8b b7       	in	r24, 0x3b	; 59
    3174:	80 68       	ori	r24, 0x80	; 128
    3176:	8b bf       	out	0x3b, r24	; 59

  // nastaven� pull-up odporu na DATA pinu
  PORTC |= 1;
    3178:	a8 9a       	sbi	0x15, 0	; 21

  //nastaven� pull-up na CLK
  PORTD |= (1 << 3);
    317a:	93 9a       	sbi	0x12, 3	; 18
}
    317c:	08 95       	ret

0000317e <keyboard_recv_watchdog>:
/// řešení problému s s nesprávným přijetím zprávy a následným posunutím přijmu
/// funkce přijme třeba jen polovinu bitů, ale neví že už je konec vysílání a když 
/// dorazí první polovina dalšího kódu, zapíše je jako druhou část předchozího.

void keyboard_recv_watchdog(void) {
  wtch_dbg_info();
    317e:	88 ed       	ldi	r24, 0xD8	; 216
    3180:	90 e0       	ldi	r25, 0x00	; 0
    3182:	90 93 fe 00 	sts	0x00FE, r25
    3186:	80 93 fd 00 	sts	0x00FD, r24
    318a:	8c ef       	ldi	r24, 0xFC	; 252
    318c:	91 e0       	ldi	r25, 0x01	; 1
    318e:	90 93 00 01 	sts	0x0100, r25
    3192:	80 93 ff 00 	sts	0x00FF, r24
  if (keyb_recv_watchdog > KEYB_RECV_WATCH_N) {
    3196:	80 91 a8 01 	lds	r24, 0x01A8
    319a:	90 91 a9 01 	lds	r25, 0x01A9
    319e:	23 e0       	ldi	r18, 0x03	; 3
    31a0:	89 3e       	cpi	r24, 0xE9	; 233
    31a2:	92 07       	cpc	r25, r18
    31a4:	28 f0       	brcs	.+10     	; 0x31b0 <keyboard_recv_watchdog+0x32>
    data_counter = 0;
    31a6:	10 92 aa 01 	sts	0x01AA, r1
    recivedc = 0;
    31aa:	10 92 ab 01 	sts	0x01AB, r1
    31ae:	08 95       	ret
  } else
    keyb_recv_watchdog++;
    31b0:	01 96       	adiw	r24, 0x01	; 1
    31b2:	90 93 a9 01 	sts	0x01A9, r25
    31b6:	80 93 a8 01 	sts	0x01A8, r24
    31ba:	08 95       	ret

000031bc <keyb_in_buff>:
/// - 1 : přijat char
/// - 2 : efko, šipka
///
/// @param kod Vlastní kód klávesy.

void keyb_in_buff(char flag, char kod) {
    31bc:	0f 93       	push	r16
    31be:	1f 93       	push	r17
    31c0:	18 2f       	mov	r17, r24
    31c2:	06 2f       	mov	r16, r22
  char * msgkey;
  int i = 0;

  if (flag == 0)
    31c4:	88 23       	and	r24, r24
    31c6:	81 f1       	breq	.+96     	; 0x3228 <keyb_in_buff+0x6c>
    return;

  msgkey = (void*) mmalloc(LenOfMsg);
    31c8:	8b e0       	ldi	r24, 0x0B	; 11
    31ca:	90 e0       	ldi	r25, 0x00	; 0
    31cc:	0e 94 a4 1d 	call	0x3b48	; 0x3b48 <mmalloc>
    31d0:	fc 01       	movw	r30, r24

  msgkey[0] = MSGN_KEY;
    31d2:	80 e6       	ldi	r24, 0x60	; 96
    31d4:	80 83       	st	Z, r24
  msgkey[1] = flag;
    31d6:	11 83       	std	Z+1, r17	; 0x01
  msgkey[2] = kod;
    31d8:	02 83       	std	Z+2, r16	; 0x02
  new_msg(msgkey);
    31da:	cf 01       	movw	r24, r30
    31dc:	0e 94 21 0a 	call	0x1442	; 0x1442 <new_msg>

  for (i = 0; i < (KEYB_BUFF_SIZE - 1); i++) {
    if ((keyb_buff[i + 1].flag) != 0) {
    31e0:	90 91 af 01 	lds	r25, 0x01AF
    31e4:	99 23       	and	r25, r25
    31e6:	19 f4       	brne	.+6      	; 0x31ee <keyb_in_buff+0x32>
    31e8:	e0 e0       	ldi	r30, 0x00	; 0
    31ea:	f0 e0       	ldi	r31, 0x00	; 0
    31ec:	17 c0       	rjmp	.+46     	; 0x321c <keyb_in_buff+0x60>
      keyb_buff[i] = keyb_buff[i + 1];
    31ee:	80 91 b0 01 	lds	r24, 0x01B0
    31f2:	80 93 ae 01 	sts	0x01AE, r24
    31f6:	90 93 ad 01 	sts	0x01AD, r25
  msgkey[1] = flag;
  msgkey[2] = kod;
  new_msg(msgkey);

  for (i = 0; i < (KEYB_BUFF_SIZE - 1); i++) {
    if ((keyb_buff[i + 1].flag) != 0) {
    31fa:	90 91 b1 01 	lds	r25, 0x01B1
    31fe:	99 23       	and	r25, r25
    3200:	59 f0       	breq	.+22     	; 0x3218 <keyb_in_buff+0x5c>
      keyb_buff[i] = keyb_buff[i + 1];
    3202:	80 91 b2 01 	lds	r24, 0x01B2
    3206:	80 93 b0 01 	sts	0x01B0, r24
    320a:	90 93 af 01 	sts	0x01AF, r25
      keyb_buff[i].flag = flag;
      keyb_buff[i].kod = kod;
      return;
    }
  }
  keyb_buff[KEYB_BUFF_SIZE - 1].flag = flag;
    320e:	10 93 b1 01 	sts	0x01B1, r17
  keyb_buff[KEYB_BUFF_SIZE - 1].kod = kod;
    3212:	00 93 b2 01 	sts	0x01B2, r16
    3216:	08 c0       	rjmp	.+16     	; 0x3228 <keyb_in_buff+0x6c>
    3218:	e1 e0       	ldi	r30, 0x01	; 1
    321a:	f0 e0       	ldi	r31, 0x00	; 0

  for (i = 0; i < (KEYB_BUFF_SIZE - 1); i++) {
    if ((keyb_buff[i + 1].flag) != 0) {
      keyb_buff[i] = keyb_buff[i + 1];
    } else {
      keyb_buff[i].flag = flag;
    321c:	ee 0f       	add	r30, r30
    321e:	ff 1f       	adc	r31, r31
    3220:	e3 55       	subi	r30, 0x53	; 83
    3222:	fe 4f       	sbci	r31, 0xFE	; 254
    3224:	10 83       	st	Z, r17
      keyb_buff[i].kod = kod;
    3226:	01 83       	std	Z+1, r16	; 0x01
  }
  keyb_buff[KEYB_BUFF_SIZE - 1].flag = flag;
  keyb_buff[KEYB_BUFF_SIZE - 1].kod = kod;

  // pozor, sem funkce téměř nikdy nedoběhne, kvůli return ve for-cyklu
}
    3228:	1f 91       	pop	r17
    322a:	0f 91       	pop	r16
    322c:	08 95       	ret

0000322e <zpracuj_kod>:
/// je čtecím funkcím poskytnuta jeho jeho ASCII hodnota. V případě stiskutí klávesy
/// jiného typu je nastaven recive_flag a funkce pro čtení běžných znaků ( get_char() )
/// nic nevrátí. Pro načtení kódu speciální klávesy je nutno použít funkci get_spec().

void zpracuj_kod(char c) {
  if (minuly_kod == 0) {
    322e:	90 91 ac 01 	lds	r25, 0x01AC
    3232:	99 23       	and	r25, r25
    3234:	09 f0       	breq	.+2      	; 0x3238 <zpracuj_kod+0xa>
    3236:	d3 c0       	rjmp	.+422    	; 0x33de <zpracuj_kod+0x1b0>
    switch (c) {
    3238:	90 e0       	ldi	r25, 0x00	; 0
    323a:	fc 01       	movw	r30, r24
    323c:	31 97       	sbiw	r30, 0x01	; 1
    323e:	e0 3f       	cpi	r30, 0xF0	; 240
    3240:	f1 05       	cpc	r31, r1
    3242:	08 f0       	brcs	.+2      	; 0x3246 <zpracuj_kod+0x18>
    3244:	06 c1       	rjmp	.+524    	; 0x3452 <zpracuj_kod+0x224>
    3246:	e0 57       	subi	r30, 0x70	; 112
    3248:	fe 4f       	sbci	r31, 0xFE	; 254
    324a:	ee 0f       	add	r30, r30
    324c:	ff 1f       	adc	r31, r31
    324e:	05 90       	lpm	r0, Z+
    3250:	f4 91       	lpm	r31, Z+
    3252:	e0 2d       	mov	r30, r0
    3254:	09 94       	ijmp
        break;
      case (0x4e) :
                keyb_in_buff(1, '-');
        break;
      case (0x55) :
                keyb_in_buff(1, '=');
    3256:	81 e0       	ldi	r24, 0x01	; 1
    3258:	6d e3       	ldi	r22, 0x3D	; 61
    325a:	f3 c0       	rjmp	.+486    	; 0x3442 <zpracuj_kod+0x214>
        break;
      case (0x66) : //Backspace 1
                keyb_in_buff(2, 1);
    325c:	82 e0       	ldi	r24, 0x02	; 2
    325e:	61 e0       	ldi	r22, 0x01	; 1
    3260:	f0 c0       	rjmp	.+480    	; 0x3442 <zpracuj_kod+0x214>
        break;

      case (0x0d) : //Ta 2
                keyb_in_buff(2, 2);
    3262:	82 e0       	ldi	r24, 0x02	; 2
    3264:	62 e0       	ldi	r22, 0x02	; 2
    3266:	ed c0       	rjmp	.+474    	; 0x3442 <zpracuj_kod+0x214>
        break;
      case (0x15) :

                keyb_in_buff(1, 'Q');
    3268:	81 e0       	ldi	r24, 0x01	; 1
    326a:	61 e5       	ldi	r22, 0x51	; 81
    326c:	ea c0       	rjmp	.+468    	; 0x3442 <zpracuj_kod+0x214>

        break;
      case (0x1d) :
                keyb_in_buff(1, 'W');
    326e:	81 e0       	ldi	r24, 0x01	; 1
    3270:	67 e5       	ldi	r22, 0x57	; 87
    3272:	e7 c0       	rjmp	.+462    	; 0x3442 <zpracuj_kod+0x214>
        break;
      case (0x24) :
                keyb_in_buff(1, 'E');
    3274:	81 e0       	ldi	r24, 0x01	; 1
    3276:	65 e4       	ldi	r22, 0x45	; 69
    3278:	e4 c0       	rjmp	.+456    	; 0x3442 <zpracuj_kod+0x214>
        break;
      case (0x2d) :
                keyb_in_buff(1, 'R');
    327a:	81 e0       	ldi	r24, 0x01	; 1
    327c:	62 e5       	ldi	r22, 0x52	; 82
    327e:	e1 c0       	rjmp	.+450    	; 0x3442 <zpracuj_kod+0x214>
        break;
      case (0x2c) :
                keyb_in_buff(1, 'T');
    3280:	81 e0       	ldi	r24, 0x01	; 1
    3282:	64 e5       	ldi	r22, 0x54	; 84
    3284:	de c0       	rjmp	.+444    	; 0x3442 <zpracuj_kod+0x214>
        break;
      case (0x35) :
                keyb_in_buff(1, 'Y');
    3286:	81 e0       	ldi	r24, 0x01	; 1
    3288:	69 e5       	ldi	r22, 0x59	; 89
    328a:	db c0       	rjmp	.+438    	; 0x3442 <zpracuj_kod+0x214>
        break;
      case (0x3c) :
                keyb_in_buff(1, 'U');
    328c:	81 e0       	ldi	r24, 0x01	; 1
    328e:	65 e5       	ldi	r22, 0x55	; 85
    3290:	d8 c0       	rjmp	.+432    	; 0x3442 <zpracuj_kod+0x214>
        break;
      case (0x43) :
                keyb_in_buff(1, 'I');
    3292:	81 e0       	ldi	r24, 0x01	; 1
    3294:	69 e4       	ldi	r22, 0x49	; 73
    3296:	d5 c0       	rjmp	.+426    	; 0x3442 <zpracuj_kod+0x214>
        break;
      case (0x44) :
                keyb_in_buff(1, 'O');
    3298:	81 e0       	ldi	r24, 0x01	; 1
    329a:	6f e4       	ldi	r22, 0x4F	; 79
    329c:	d2 c0       	rjmp	.+420    	; 0x3442 <zpracuj_kod+0x214>
        break;
      case (0x4d) :
                keyb_in_buff(1, 'P');
    329e:	81 e0       	ldi	r24, 0x01	; 1
    32a0:	60 e5       	ldi	r22, 0x50	; 80
    32a2:	cf c0       	rjmp	.+414    	; 0x3442 <zpracuj_kod+0x214>
        break;
      case (0x54) :
                keyb_in_buff(1, '[');
    32a4:	81 e0       	ldi	r24, 0x01	; 1
    32a6:	6b e5       	ldi	r22, 0x5B	; 91
    32a8:	cc c0       	rjmp	.+408    	; 0x3442 <zpracuj_kod+0x214>
        break;
      case (0x5b) :
                keyb_in_buff(1, ']');
    32aa:	81 e0       	ldi	r24, 0x01	; 1
    32ac:	6d e5       	ldi	r22, 0x5D	; 93
    32ae:	c9 c0       	rjmp	.+402    	; 0x3442 <zpracuj_kod+0x214>
        break;
      case (0x5d) :
                keyb_in_buff(1, '\\');
    32b0:	81 e0       	ldi	r24, 0x01	; 1
    32b2:	6c e5       	ldi	r22, 0x5C	; 92
    32b4:	c6 c0       	rjmp	.+396    	; 0x3442 <zpracuj_kod+0x214>
        break;

      case (0x58) : //Caps Lock
                keyb_in_buff(2, 3);
    32b6:	82 e0       	ldi	r24, 0x02	; 2
    32b8:	63 e0       	ldi	r22, 0x03	; 3
    32ba:	c3 c0       	rjmp	.+390    	; 0x3442 <zpracuj_kod+0x214>
        break;
      case (0x1c) :
                keyb_in_buff(1, 'A');
    32bc:	81 e0       	ldi	r24, 0x01	; 1
    32be:	61 e4       	ldi	r22, 0x41	; 65
    32c0:	c0 c0       	rjmp	.+384    	; 0x3442 <zpracuj_kod+0x214>
        break;
      case (0x1b) :
                keyb_in_buff(1, 'S');
    32c2:	81 e0       	ldi	r24, 0x01	; 1
    32c4:	63 e5       	ldi	r22, 0x53	; 83
    32c6:	bd c0       	rjmp	.+378    	; 0x3442 <zpracuj_kod+0x214>
        break;
      case (0x23) :
                keyb_in_buff(1, 'D');
    32c8:	81 e0       	ldi	r24, 0x01	; 1
    32ca:	64 e4       	ldi	r22, 0x44	; 68
    32cc:	ba c0       	rjmp	.+372    	; 0x3442 <zpracuj_kod+0x214>
        break;
      case (0x2b) :
                keyb_in_buff(1, 'F');
    32ce:	81 e0       	ldi	r24, 0x01	; 1
    32d0:	66 e4       	ldi	r22, 0x46	; 70
    32d2:	b7 c0       	rjmp	.+366    	; 0x3442 <zpracuj_kod+0x214>
        break;
      case (0x34) :
                keyb_in_buff(1, 'G');
    32d4:	81 e0       	ldi	r24, 0x01	; 1
    32d6:	67 e4       	ldi	r22, 0x47	; 71
    32d8:	b4 c0       	rjmp	.+360    	; 0x3442 <zpracuj_kod+0x214>
        break;
      case (0x33) :
                keyb_in_buff(1,
    32da:	81 e0       	ldi	r24, 0x01	; 1
    32dc:	68 e4       	ldi	r22, 0x48	; 72
    32de:	b1 c0       	rjmp	.+354    	; 0x3442 <zpracuj_kod+0x214>
                'H');
        break;
      case (0x3b) :
                keyb_in_buff(1, 'J');
    32e0:	81 e0       	ldi	r24, 0x01	; 1
    32e2:	6a e4       	ldi	r22, 0x4A	; 74
    32e4:	ae c0       	rjmp	.+348    	; 0x3442 <zpracuj_kod+0x214>
        break;
      case (0x42) :
                keyb_in_buff(1, 'K');
    32e6:	81 e0       	ldi	r24, 0x01	; 1
    32e8:	6b e4       	ldi	r22, 0x4B	; 75
    32ea:	ab c0       	rjmp	.+342    	; 0x3442 <zpracuj_kod+0x214>
        break;
      case (0x4b) :
                keyb_in_buff(1, 'L');
    32ec:	81 e0       	ldi	r24, 0x01	; 1
    32ee:	6c e4       	ldi	r22, 0x4C	; 76
    32f0:	a8 c0       	rjmp	.+336    	; 0x3442 <zpracuj_kod+0x214>
        break;
      case (0x4c) :
                keyb_in_buff(1, ';');
    32f2:	81 e0       	ldi	r24, 0x01	; 1
    32f4:	6b e3       	ldi	r22, 0x3B	; 59
    32f6:	a5 c0       	rjmp	.+330    	; 0x3442 <zpracuj_kod+0x214>
        break;
      case (0x52) :
                keyb_in_buff(1, '\'');
    32f8:	81 e0       	ldi	r24, 0x01	; 1
    32fa:	67 e2       	ldi	r22, 0x27	; 39
    32fc:	a2 c0       	rjmp	.+324    	; 0x3442 <zpracuj_kod+0x214>
      case (0x5a) : //Enter
                keyb_in_buff(2, 4);
        break;

      case (0x1a) :
                keyb_in_buff(1, 'Z');
    32fe:	81 e0       	ldi	r24, 0x01	; 1
    3300:	6a e5       	ldi	r22, 0x5A	; 90
    3302:	9f c0       	rjmp	.+318    	; 0x3442 <zpracuj_kod+0x214>
        break;
      case (0x22) :
                keyb_in_buff(1, 'X');
    3304:	81 e0       	ldi	r24, 0x01	; 1
    3306:	68 e5       	ldi	r22, 0x58	; 88
    3308:	9c c0       	rjmp	.+312    	; 0x3442 <zpracuj_kod+0x214>
        break;
      case (0x21) :
                keyb_in_buff(1, 'C');
    330a:	81 e0       	ldi	r24, 0x01	; 1
    330c:	63 e4       	ldi	r22, 0x43	; 67
    330e:	99 c0       	rjmp	.+306    	; 0x3442 <zpracuj_kod+0x214>
        break;
      case (0x2a) :
                keyb_in_buff(1, 'V');
    3310:	81 e0       	ldi	r24, 0x01	; 1
    3312:	66 e5       	ldi	r22, 0x56	; 86
    3314:	96 c0       	rjmp	.+300    	; 0x3442 <zpracuj_kod+0x214>
        break;
      case (0x32) :
                keyb_in_buff(1, 'B');
    3316:	81 e0       	ldi	r24, 0x01	; 1
    3318:	62 e4       	ldi	r22, 0x42	; 66
    331a:	93 c0       	rjmp	.+294    	; 0x3442 <zpracuj_kod+0x214>
        break;
      case (0x31) :
                keyb_in_buff(1, 'N');
    331c:	81 e0       	ldi	r24, 0x01	; 1
    331e:	6e e4       	ldi	r22, 0x4E	; 78
    3320:	90 c0       	rjmp	.+288    	; 0x3442 <zpracuj_kod+0x214>
        break;
      case (0x3a) :
                keyb_in_buff(1, 'M');
    3322:	81 e0       	ldi	r24, 0x01	; 1
    3324:	6d e4       	ldi	r22, 0x4D	; 77
    3326:	8d c0       	rjmp	.+282    	; 0x3442 <zpracuj_kod+0x214>
        break;
      case (0x41) :
                keyb_in_buff(1, ',');
    3328:	81 e0       	ldi	r24, 0x01	; 1
    332a:	6c e2       	ldi	r22, 0x2C	; 44
    332c:	8a c0       	rjmp	.+276    	; 0x3442 <zpracuj_kod+0x214>
      case (0x4a) :
                keyb_in_buff(1, '/');
        break;

      case (0x29) :
                keyb_in_buff(1, ' ');
    332e:	81 e0       	ldi	r24, 0x01	; 1
    3330:	60 e2       	ldi	r22, 0x20	; 32
    3332:	87 c0       	rjmp	.+270    	; 0x3442 <zpracuj_kod+0x214>
        break;

      case (0x76) : //Esc
                keyb_in_buff(2, 5);
    3334:	82 e0       	ldi	r24, 0x02	; 2
    3336:	65 e0       	ldi	r22, 0x05	; 5
    3338:	84 c0       	rjmp	.+264    	; 0x3442 <zpracuj_kod+0x214>
        break;

      case 0x70: // 0_num
        keyb_in_buff(1, '0');
    333a:	81 e0       	ldi	r24, 0x01	; 1
    333c:	60 e3       	ldi	r22, 0x30	; 48
    333e:	81 c0       	rjmp	.+258    	; 0x3442 <zpracuj_kod+0x214>
        break;
      case 0x69: // 1_num
        keyb_in_buff(1, '1');
    3340:	81 e0       	ldi	r24, 0x01	; 1
    3342:	61 e3       	ldi	r22, 0x31	; 49
    3344:	7e c0       	rjmp	.+252    	; 0x3442 <zpracuj_kod+0x214>
        break;
      case 0x72: // 2_num
        keyb_in_buff(1, '2');
    3346:	81 e0       	ldi	r24, 0x01	; 1
    3348:	62 e3       	ldi	r22, 0x32	; 50
    334a:	7b c0       	rjmp	.+246    	; 0x3442 <zpracuj_kod+0x214>
        break;
      case 0x7A: // 3_num
        keyb_in_buff(1, '3');
    334c:	81 e0       	ldi	r24, 0x01	; 1
    334e:	63 e3       	ldi	r22, 0x33	; 51
    3350:	78 c0       	rjmp	.+240    	; 0x3442 <zpracuj_kod+0x214>
        break;
      case 0x6B: // 4_num
        keyb_in_buff(1, '4');
    3352:	81 e0       	ldi	r24, 0x01	; 1
    3354:	64 e3       	ldi	r22, 0x34	; 52
    3356:	75 c0       	rjmp	.+234    	; 0x3442 <zpracuj_kod+0x214>
        break;
      case 0x73: // 5_num
        keyb_in_buff(1, '5');
    3358:	81 e0       	ldi	r24, 0x01	; 1
    335a:	65 e3       	ldi	r22, 0x35	; 53
    335c:	72 c0       	rjmp	.+228    	; 0x3442 <zpracuj_kod+0x214>
        break;
      case 0x74: // 6_num
        keyb_in_buff(1, '6');
    335e:	81 e0       	ldi	r24, 0x01	; 1
    3360:	66 e3       	ldi	r22, 0x36	; 54
    3362:	6f c0       	rjmp	.+222    	; 0x3442 <zpracuj_kod+0x214>
        break;
      case 0x6C: // 7_num
        keyb_in_buff(1, '7');
    3364:	81 e0       	ldi	r24, 0x01	; 1
    3366:	67 e3       	ldi	r22, 0x37	; 55
    3368:	6c c0       	rjmp	.+216    	; 0x3442 <zpracuj_kod+0x214>
        break;
      case 0x75: // 8_num
        keyb_in_buff(1, '8');
    336a:	81 e0       	ldi	r24, 0x01	; 1
    336c:	68 e3       	ldi	r22, 0x38	; 56
    336e:	69 c0       	rjmp	.+210    	; 0x3442 <zpracuj_kod+0x214>
        break;
      case 0x7D: // 9_num
        keyb_in_buff(1, '9');
    3370:	81 e0       	ldi	r24, 0x01	; 1
    3372:	69 e3       	ldi	r22, 0x39	; 57
    3374:	66 c0       	rjmp	.+204    	; 0x3442 <zpracuj_kod+0x214>
        break;
      case 0x7B: // -_num
        keyb_in_buff(1, '-');
    3376:	81 e0       	ldi	r24, 0x01	; 1
    3378:	6d e2       	ldi	r22, 0x2D	; 45
    337a:	63 c0       	rjmp	.+198    	; 0x3442 <zpracuj_kod+0x214>
        break;
      case 0x71: // ._num
        keyb_in_buff(1, '.');
    337c:	81 e0       	ldi	r24, 0x01	; 1
    337e:	6e e2       	ldi	r22, 0x2E	; 46
    3380:	60 c0       	rjmp	.+192    	; 0x3442 <zpracuj_kod+0x214>
        break;
      case 0x7C: // *_num
        keyb_in_buff(1, '*');
    3382:	81 e0       	ldi	r24, 0x01	; 1
    3384:	6a e2       	ldi	r22, 0x2A	; 42
    3386:	5d c0       	rjmp	.+186    	; 0x3442 <zpracuj_kod+0x214>
        break;
      case 0x79: // +_num
        keyb_in_buff(1, '+');
    3388:	81 e0       	ldi	r24, 0x01	; 1
    338a:	6b e2       	ldi	r22, 0x2B	; 43
    338c:	5a c0       	rjmp	.+180    	; 0x3442 <zpracuj_kod+0x214>
        break;



      case (0x05) : //F1
                keyb_in_buff(2, 11);
    338e:	82 e0       	ldi	r24, 0x02	; 2
    3390:	6b e0       	ldi	r22, 0x0B	; 11
    3392:	57 c0       	rjmp	.+174    	; 0x3442 <zpracuj_kod+0x214>
        break;
      case (0x06) : //F2
                keyb_in_buff(2, 12);
    3394:	82 e0       	ldi	r24, 0x02	; 2
    3396:	6c e0       	ldi	r22, 0x0C	; 12
    3398:	54 c0       	rjmp	.+168    	; 0x3442 <zpracuj_kod+0x214>
        break;
      case (0x04) : //F3
                keyb_in_buff(2, 13);
    339a:	82 e0       	ldi	r24, 0x02	; 2
    339c:	6d e0       	ldi	r22, 0x0D	; 13
    339e:	51 c0       	rjmp	.+162    	; 0x3442 <zpracuj_kod+0x214>
        break;
      case (0x0c) : //F4
                keyb_in_buff(2, 14);
    33a0:	82 e0       	ldi	r24, 0x02	; 2
    33a2:	6e e0       	ldi	r22, 0x0E	; 14
    33a4:	4e c0       	rjmp	.+156    	; 0x3442 <zpracuj_kod+0x214>
        break;
      case (0x03) : //F5
                keyb_in_buff(2, 15);
    33a6:	82 e0       	ldi	r24, 0x02	; 2
    33a8:	6f e0       	ldi	r22, 0x0F	; 15
    33aa:	4b c0       	rjmp	.+150    	; 0x3442 <zpracuj_kod+0x214>
        break;
      case (0x0b) : //F6
                keyb_in_buff(2, 16);
    33ac:	82 e0       	ldi	r24, 0x02	; 2
    33ae:	60 e1       	ldi	r22, 0x10	; 16
    33b0:	48 c0       	rjmp	.+144    	; 0x3442 <zpracuj_kod+0x214>
        break;
      case (0x83) : //F7
                keyb_in_buff(2, 17);
    33b2:	82 e0       	ldi	r24, 0x02	; 2
    33b4:	61 e1       	ldi	r22, 0x11	; 17
    33b6:	45 c0       	rjmp	.+138    	; 0x3442 <zpracuj_kod+0x214>
        break;
      case (0x0a) : //F8
                keyb_in_buff(2, 18);
    33b8:	82 e0       	ldi	r24, 0x02	; 2
    33ba:	62 e1       	ldi	r22, 0x12	; 18
    33bc:	42 c0       	rjmp	.+132    	; 0x3442 <zpracuj_kod+0x214>
        break;
      case (0x01) : //F9
                keyb_in_buff(2, 19);
    33be:	82 e0       	ldi	r24, 0x02	; 2
    33c0:	63 e1       	ldi	r22, 0x13	; 19
    33c2:	3f c0       	rjmp	.+126    	; 0x3442 <zpracuj_kod+0x214>
        break;
      case (0x09) : //F10
                keyb_in_buff(2, 20);
    33c4:	82 e0       	ldi	r24, 0x02	; 2
    33c6:	64 e1       	ldi	r22, 0x14	; 20
    33c8:	3c c0       	rjmp	.+120    	; 0x3442 <zpracuj_kod+0x214>
        break;
      case (0x78) : //F11
                keyb_in_buff(2, 21);
    33ca:	82 e0       	ldi	r24, 0x02	; 2
    33cc:	65 e1       	ldi	r22, 0x15	; 21
    33ce:	39 c0       	rjmp	.+114    	; 0x3442 <zpracuj_kod+0x214>
        break;
      case (0x07) : //F12
                keyb_in_buff(2, 22);
    33d0:	82 e0       	ldi	r24, 0x02	; 2
    33d2:	66 e1       	ldi	r22, 0x16	; 22
    33d4:	36 c0       	rjmp	.+108    	; 0x3442 <zpracuj_kod+0x214>
        break;
      case (0xe0) :
                minuly_kod = 0xe0;
    33d6:	80 ee       	ldi	r24, 0xE0	; 224
    33d8:	37 c0       	rjmp	.+110    	; 0x3448 <zpracuj_kod+0x21a>
        break;

      case (0xf0) :
                minuly_kod = 0xf0;
    33da:	80 ef       	ldi	r24, 0xF0	; 240
    33dc:	35 c0       	rjmp	.+106    	; 0x3448 <zpracuj_kod+0x21a>
        //keyb_in_buff(0;
        //rec_buf = 0;
        break;

    }
  } else if (minuly_kod == 0xe0) {
    33de:	90 3e       	cpi	r25, 0xE0	; 224
    33e0:	b1 f5       	brne	.+108    	; 0x344e <zpracuj_kod+0x220>
    switch (c) {
    33e2:	82 37       	cpi	r24, 0x72	; 114
    33e4:	01 f1       	breq	.+64     	; 0x3426 <zpracuj_kod+0x1f8>
    33e6:	83 37       	cpi	r24, 0x73	; 115
    33e8:	60 f4       	brcc	.+24     	; 0x3402 <zpracuj_kod+0x1d4>
    33ea:	8a 35       	cpi	r24, 0x5A	; 90
    33ec:	29 f1       	breq	.+74     	; 0x3438 <zpracuj_kod+0x20a>
    33ee:	8b 35       	cpi	r24, 0x5B	; 91
    33f0:	18 f4       	brcc	.+6      	; 0x33f8 <zpracuj_kod+0x1ca>
    33f2:	8a 34       	cpi	r24, 0x4A	; 74
    33f4:	71 f5       	brne	.+92     	; 0x3452 <zpracuj_kod+0x224>
    33f6:	23 c0       	rjmp	.+70     	; 0x343e <zpracuj_kod+0x210>
    33f8:	8b 36       	cpi	r24, 0x6B	; 107
    33fa:	c1 f0       	breq	.+48     	; 0x342c <zpracuj_kod+0x1fe>
    33fc:	81 37       	cpi	r24, 0x71	; 113
    33fe:	49 f5       	brne	.+82     	; 0x3452 <zpracuj_kod+0x224>
    3400:	0c c0       	rjmp	.+24     	; 0x341a <zpracuj_kod+0x1ec>
    3402:	85 37       	cpi	r24, 0x75	; 117
    3404:	69 f0       	breq	.+26     	; 0x3420 <zpracuj_kod+0x1f2>
    3406:	86 37       	cpi	r24, 0x76	; 118
    3408:	18 f4       	brcc	.+6      	; 0x3410 <zpracuj_kod+0x1e2>
    340a:	84 37       	cpi	r24, 0x74	; 116
    340c:	11 f5       	brne	.+68     	; 0x3452 <zpracuj_kod+0x224>
    340e:	11 c0       	rjmp	.+34     	; 0x3432 <zpracuj_kod+0x204>
    3410:	80 3e       	cpi	r24, 0xE0	; 224
    3412:	d1 f0       	breq	.+52     	; 0x3448 <zpracuj_kod+0x21a>
    3414:	80 3f       	cpi	r24, 0xF0	; 240
    3416:	e9 f4       	brne	.+58     	; 0x3452 <zpracuj_kod+0x224>
    3418:	17 c0       	rjmp	.+46     	; 0x3448 <zpracuj_kod+0x21a>
      case 0x71: //Del
        keyb_in_buff(2, 6);
    341a:	82 e0       	ldi	r24, 0x02	; 2
    341c:	66 e0       	ldi	r22, 0x06	; 6
    341e:	11 c0       	rjmp	.+34     	; 0x3442 <zpracuj_kod+0x214>
        break;
      case 0x75: // Up
        keyb_in_buff(2, 7);
    3420:	82 e0       	ldi	r24, 0x02	; 2
    3422:	67 e0       	ldi	r22, 0x07	; 7
    3424:	0e c0       	rjmp	.+28     	; 0x3442 <zpracuj_kod+0x214>
        break;
      case 0x72: // Down
        keyb_in_buff(2, 8);
    3426:	82 e0       	ldi	r24, 0x02	; 2
    3428:	68 e0       	ldi	r22, 0x08	; 8
    342a:	0b c0       	rjmp	.+22     	; 0x3442 <zpracuj_kod+0x214>
        break;
      case 0x6B: // Left
        keyb_in_buff(2, 9);
    342c:	82 e0       	ldi	r24, 0x02	; 2
    342e:	69 e0       	ldi	r22, 0x09	; 9
    3430:	08 c0       	rjmp	.+16     	; 0x3442 <zpracuj_kod+0x214>
        break;
      case 0x74: // Right
        keyb_in_buff(2, 10);
    3432:	82 e0       	ldi	r24, 0x02	; 2
    3434:	6a e0       	ldi	r22, 0x0A	; 10
    3436:	05 c0       	rjmp	.+10     	; 0x3442 <zpracuj_kod+0x214>
        break;
      case 0x5A: // Enter_num
        keyb_in_buff(2, 4);
    3438:	82 e0       	ldi	r24, 0x02	; 2
    343a:	64 e0       	ldi	r22, 0x04	; 4
    343c:	02 c0       	rjmp	.+4      	; 0x3442 <zpracuj_kod+0x214>
        break;
      case 0x4A: // /_num
        keyb_in_buff(1, '/');
    343e:	81 e0       	ldi	r24, 0x01	; 1
    3440:	6f e2       	ldi	r22, 0x2F	; 47
    3442:	0e 94 de 18 	call	0x31bc	; 0x31bc <keyb_in_buff>
    3446:	08 95       	ret
        break;
      case 0xF0:
        minuly_kod = 0xF0;
        break;
      case 0xE0:
        minuly_kod = 0xE0;
    3448:	80 93 ac 01 	sts	0x01AC, r24
    344c:	08 95       	ret
    }
  } else if (minuly_kod == 0xF0) {
    // napriklad pri pusteni sipky
    minuly_kod = 0;
  } else {
    minuly_kod = 0;
    344e:	10 92 ac 01 	sts	0x01AC, r1
    3452:	08 95       	ret

00003454 <__vector_2>:
  }
  keyb_buff[KEYB_BUFF_SIZE - 1].flag = 0;
  return out;
}

SIGNAL(SIG_INTERRUPT1) {
    3454:	1f 92       	push	r1
    3456:	0f 92       	push	r0
    3458:	0f b6       	in	r0, 0x3f	; 63
    345a:	0f 92       	push	r0
    345c:	11 24       	eor	r1, r1
    345e:	2f 93       	push	r18
    3460:	3f 93       	push	r19
    3462:	4f 93       	push	r20
    3464:	5f 93       	push	r21
    3466:	6f 93       	push	r22
    3468:	7f 93       	push	r23
    346a:	8f 93       	push	r24
    346c:	9f 93       	push	r25
    346e:	af 93       	push	r26
    3470:	bf 93       	push	r27
    3472:	ef 93       	push	r30
    3474:	ff 93       	push	r31

  keyb_recv_watchdog = 0; //
    3476:	10 92 a9 01 	sts	0x01A9, r1
    347a:	10 92 a8 01 	sts	0x01A8, r1

  if ((data_counter > 0) && (data_counter < 9)) {
    347e:	20 91 aa 01 	lds	r18, 0x01AA
    3482:	82 2f       	mov	r24, r18
    3484:	81 50       	subi	r24, 0x01	; 1
    3486:	88 30       	cpi	r24, 0x08	; 8
    3488:	a0 f4       	brcc	.+40     	; 0x34b2 <__vector_2+0x5e>
    recivedc |= ((PINC & 1) << (data_counter - 1));
    348a:	83 b3       	in	r24, 0x13	; 19
    348c:	90 e0       	ldi	r25, 0x00	; 0
    348e:	81 70       	andi	r24, 0x01	; 1
    3490:	90 70       	andi	r25, 0x00	; 0
    3492:	33 27       	eor	r19, r19
    3494:	27 fd       	sbrc	r18, 7
    3496:	30 95       	com	r19
    3498:	21 50       	subi	r18, 0x01	; 1
    349a:	30 40       	sbci	r19, 0x00	; 0
    349c:	02 c0       	rjmp	.+4      	; 0x34a2 <__vector_2+0x4e>
    349e:	88 0f       	add	r24, r24
    34a0:	99 1f       	adc	r25, r25
    34a2:	2a 95       	dec	r18
    34a4:	e2 f7       	brpl	.-8      	; 0x349e <__vector_2+0x4a>
    34a6:	20 91 ab 01 	lds	r18, 0x01AB
    34aa:	28 2b       	or	r18, r24
    34ac:	20 93 ab 01 	sts	0x01AB, r18
    34b0:	0b c0       	rjmp	.+22     	; 0x34c8 <__vector_2+0x74>
  } else if (data_counter == 10) {
    34b2:	2a 30       	cpi	r18, 0x0A	; 10
    34b4:	49 f4       	brne	.+18     	; 0x34c8 <__vector_2+0x74>
    data_counter = -1;
    34b6:	8f ef       	ldi	r24, 0xFF	; 255
    34b8:	80 93 aa 01 	sts	0x01AA, r24
    //printxy(default_screen, 0,0,s);
    //printxy(default_screen, 0,2, int2string("   ",recivedc));
    zpracuj_kod(recivedc);
    34bc:	80 91 ab 01 	lds	r24, 0x01AB
    34c0:	0e 94 17 19 	call	0x322e	; 0x322e <zpracuj_kod>
    recivedc = 0;
    34c4:	10 92 ab 01 	sts	0x01AB, r1
  }
  //printxy(default_screen, 0,2, int2string("    ",data_counter));
  data_counter++;
    34c8:	80 91 aa 01 	lds	r24, 0x01AA
    34cc:	8f 5f       	subi	r24, 0xFF	; 255
    34ce:	80 93 aa 01 	sts	0x01AA, r24
}
    34d2:	ff 91       	pop	r31
    34d4:	ef 91       	pop	r30
    34d6:	bf 91       	pop	r27
    34d8:	af 91       	pop	r26
    34da:	9f 91       	pop	r25
    34dc:	8f 91       	pop	r24
    34de:	7f 91       	pop	r23
    34e0:	6f 91       	pop	r22
    34e2:	5f 91       	pop	r21
    34e4:	4f 91       	pop	r20
    34e6:	3f 91       	pop	r19
    34e8:	2f 91       	pop	r18
    34ea:	0f 90       	pop	r0
    34ec:	0f be       	out	0x3f, r0	; 63
    34ee:	0f 90       	pop	r0
    34f0:	1f 90       	pop	r1
    34f2:	18 95       	reti

000034f4 <buttons_init>:

void buttons_init(void){
  //Nastavení pull-up
  // Ve skutečnosti bude PORTC == 0xff, protože na prvním pinu je
  // klávesnice, která si jej taky nastaví.
  PORTC |= 0xFE;
    34f4:	85 b3       	in	r24, 0x15	; 21
    34f6:	8e 6f       	ori	r24, 0xFE	; 254
    34f8:	85 bb       	out	0x15, r24	; 21
  minuly_stav = 254; //PINC
    34fa:	8e ef       	ldi	r24, 0xFE	; 254
    34fc:	80 93 b3 01 	sts	0x01B3, r24
}
    3500:	08 95       	ret

00003502 <buttons>:

void buttons(void) {
    3502:	ff 92       	push	r15
    3504:	0f 93       	push	r16
    3506:	1f 93       	push	r17
    3508:	cf 93       	push	r28
    350a:	df 93       	push	r29
  char zmena;
  char vzorek_pinc = PINC;
    350c:	f3 b2       	in	r15, 0x13	; 19
  int i = 0;
  wtch_dbg_info();
    350e:	83 ee       	ldi	r24, 0xE3	; 227
    3510:	90 e0       	ldi	r25, 0x00	; 0
    3512:	90 93 fe 00 	sts	0x00FE, r25
    3516:	80 93 fd 00 	sts	0x00FD, r24
    351a:	8d e1       	ldi	r24, 0x1D	; 29
    351c:	90 e0       	ldi	r25, 0x00	; 0
    351e:	90 93 00 01 	sts	0x0100, r25
    3522:	80 93 ff 00 	sts	0x00FF, r24


  zmena = minuly_stav^vzorek_pinc;
    3526:	80 91 b3 01 	lds	r24, 0x01B3
    352a:	8f 25       	eor	r24, r15
    352c:	c1 e0       	ldi	r28, 0x01	; 1
    352e:	d0 e0       	ldi	r29, 0x00	; 0


  for (i = 1; i < 8; i++) {
    if (((zmena >> i) & 1) == 1) { //došlo-li ke změně na přslušném pinu
    3530:	08 2f       	mov	r16, r24
    3532:	10 e0       	ldi	r17, 0x00	; 0
    3534:	c8 01       	movw	r24, r16
    3536:	0c 2e       	mov	r0, r28
    3538:	02 c0       	rjmp	.+4      	; 0x353e <buttons+0x3c>
    353a:	95 95       	asr	r25
    353c:	87 95       	ror	r24
    353e:	0a 94       	dec	r0
    3540:	e2 f7       	brpl	.-8      	; 0x353a <buttons+0x38>
    3542:	80 ff       	sbrs	r24, 0
    3544:	33 c0       	rjmp	.+102    	; 0x35ac <buttons+0xaa>
      if (((minuly_stav >> i) & 1) == 1) { //sepnutí
    3546:	80 91 b3 01 	lds	r24, 0x01B3
    354a:	90 e0       	ldi	r25, 0x00	; 0
    354c:	0c 2e       	mov	r0, r28
    354e:	02 c0       	rjmp	.+4      	; 0x3554 <buttons+0x52>
    3550:	95 95       	asr	r25
    3552:	87 95       	ror	r24
    3554:	0a 94       	dec	r0
    3556:	e2 f7       	brpl	.-8      	; 0x3550 <buttons+0x4e>
    3558:	80 ff       	sbrs	r24, 0
    355a:	28 c0       	rjmp	.+80     	; 0x35ac <buttons+0xaa>
 * 
 * @param button
 * Udává které tlačítko bylo stisknuto.
 */
void button_on(char button){
  switch(button)
    355c:	c4 30       	cpi	r28, 0x04	; 4
    355e:	c9 f0       	breq	.+50     	; 0x3592 <buttons+0x90>
    3560:	c5 30       	cpi	r28, 0x05	; 5
    3562:	38 f4       	brcc	.+14     	; 0x3572 <buttons+0x70>
    3564:	c2 30       	cpi	r28, 0x02	; 2
    3566:	79 f0       	breq	.+30     	; 0x3586 <buttons+0x84>
    3568:	c3 30       	cpi	r28, 0x03	; 3
    356a:	80 f4       	brcc	.+32     	; 0x358c <buttons+0x8a>
    356c:	c1 30       	cpi	r28, 0x01	; 1
    356e:	f1 f4       	brne	.+60     	; 0x35ac <buttons+0xaa>
    3570:	07 c0       	rjmp	.+14     	; 0x3580 <buttons+0x7e>
    3572:	c6 30       	cpi	r28, 0x06	; 6
    3574:	a1 f0       	breq	.+40     	; 0x359e <buttons+0x9c>
    3576:	c6 30       	cpi	r28, 0x06	; 6
    3578:	78 f0       	brcs	.+30     	; 0x3598 <buttons+0x96>
    357a:	c7 30       	cpi	r28, 0x07	; 7
    357c:	b9 f4       	brne	.+46     	; 0x35ac <buttons+0xaa>
    357e:	12 c0       	rjmp	.+36     	; 0x35a4 <buttons+0xa2>
  {
  case 1:
    keyb_in_buff(2,22);
    3580:	82 e0       	ldi	r24, 0x02	; 2
    3582:	66 e1       	ldi	r22, 0x16	; 22
    3584:	11 c0       	rjmp	.+34     	; 0x35a8 <buttons+0xa6>
    break;
  case 2:
    keyb_in_buff(2,19);
    3586:	82 e0       	ldi	r24, 0x02	; 2
    3588:	63 e1       	ldi	r22, 0x13	; 19
    358a:	0e c0       	rjmp	.+28     	; 0x35a8 <buttons+0xa6>
    break;
  case 3:
    keyb_in_buff(2,21);
    358c:	82 e0       	ldi	r24, 0x02	; 2
    358e:	65 e1       	ldi	r22, 0x15	; 21
    3590:	0b c0       	rjmp	.+22     	; 0x35a8 <buttons+0xa6>
    break;
  case 4:
    keyb_in_buff(2,7);
    3592:	82 e0       	ldi	r24, 0x02	; 2
    3594:	67 e0       	ldi	r22, 0x07	; 7
    3596:	08 c0       	rjmp	.+16     	; 0x35a8 <buttons+0xa6>
    break;
  case 5:
    keyb_in_buff(2,8);
    3598:	82 e0       	ldi	r24, 0x02	; 2
    359a:	68 e0       	ldi	r22, 0x08	; 8
    359c:	05 c0       	rjmp	.+10     	; 0x35a8 <buttons+0xa6>
    break;
  case 6:
    keyb_in_buff(2,4);
    359e:	82 e0       	ldi	r24, 0x02	; 2
    35a0:	64 e0       	ldi	r22, 0x04	; 4
    35a2:	02 c0       	rjmp	.+4      	; 0x35a8 <buttons+0xa6>
    break;
  case 7:
    keyb_in_buff(2,5);
    35a4:	82 e0       	ldi	r24, 0x02	; 2
    35a6:	65 e0       	ldi	r22, 0x05	; 5
    35a8:	0e 94 de 18 	call	0x31bc	; 0x31bc <keyb_in_buff>


  zmena = minuly_stav^vzorek_pinc;


  for (i = 1; i < 8; i++) {
    35ac:	21 96       	adiw	r28, 0x01	; 1
    35ae:	c8 30       	cpi	r28, 0x08	; 8
    35b0:	d1 05       	cpc	r29, r1
    35b2:	09 f0       	breq	.+2      	; 0x35b6 <buttons+0xb4>
    35b4:	bf cf       	rjmp	.-130    	; 0x3534 <buttons+0x32>
      } else {
        // button_off((char)i);
      }
    }
  }
  minuly_stav = vzorek_pinc;
    35b6:	f0 92 b3 01 	sts	0x01B3, r15
}
    35ba:	df 91       	pop	r29
    35bc:	cf 91       	pop	r28
    35be:	1f 91       	pop	r17
    35c0:	0f 91       	pop	r16
    35c2:	ff 90       	pop	r15
    35c4:	08 95       	ret

000035c6 <wtch_init>:
/// Čítač mého watchdogu. pokud bude větší než 200, dojde k výpisu chybové hlášky.
int16_t wtch_counter = 0;


void wtch_init(void){
  wtch_enable2();
    35c6:	10 92 b5 01 	sts	0x01B5, r1
    35ca:	10 92 b4 01 	sts	0x01B4, r1
    35ce:	2f e0       	ldi	r18, 0x0F	; 15
    35d0:	88 e1       	ldi	r24, 0x18	; 24
    35d2:	90 e0       	ldi	r25, 0x00	; 0
    35d4:	0f b6       	in	r0, 0x3f	; 63
    35d6:	f8 94       	cli
    35d8:	a8 95       	wdr
    35da:	81 bd       	out	0x21, r24	; 33
    35dc:	0f be       	out	0x3f, r0	; 63
    35de:	21 bd       	out	0x21, r18	; 33
//  wdt_enable(WDTO_2S);
}
    35e0:	08 95       	ret

000035e2 <wtch_main>:
 * nějaké vnitřní smyčce, je vypsán chybový výpis, data jsou uložena
 * do eeprom a program je uveden do nekonečné smyčky, ve které čeká na
 * reset prostřednictvím softwarového watchdogu.
 * Watchdog lze deaktivovat nastavením čítače na zápornou hodnotu.
 */
void wtch_main(void){
    35e2:	0f 93       	push	r16
    35e4:	1f 93       	push	r17
    35e6:	df 93       	push	r29
    35e8:	cf 93       	push	r28
    35ea:	cd b7       	in	r28, 0x3d	; 61
    35ec:	de b7       	in	r29, 0x3e	; 62
    35ee:	2a 97       	sbiw	r28, 0x0a	; 10
    35f0:	0f b6       	in	r0, 0x3f	; 63
    35f2:	f8 94       	cli
    35f4:	de bf       	out	0x3e, r29	; 62
    35f6:	0f be       	out	0x3f, r0	; 63
    35f8:	cd bf       	out	0x3d, r28	; 61
  if (wtch_counter < 0){ // Služba je vypnuta
    35fa:	80 91 b4 01 	lds	r24, 0x01B4
    35fe:	90 91 b5 01 	lds	r25, 0x01B5
    3602:	97 fd       	sbrc	r25, 7
    3604:	5e c0       	rjmp	.+188    	; 0x36c2 <wtch_main+0xe0>

  }
  else if (wtch_counter < MY_WATCHDOG){// všechno v pořádku
    3606:	23 e1       	ldi	r18, 0x13	; 19
    3608:	88 38       	cpi	r24, 0x88	; 136
    360a:	92 07       	cpc	r25, r18
    360c:	34 f4       	brge	.+12     	; 0x361a <wtch_main+0x38>
    wtch_counter++;
    360e:	01 96       	adiw	r24, 0x01	; 1
    3610:	90 93 b5 01 	sts	0x01B5, r25
    3614:	80 93 b4 01 	sts	0x01B4, r24
    3618:	54 c0       	rjmp	.+168    	; 0x36c2 <wtch_main+0xe0>
  }
  else { // Nastal problém
    int i;
    char str[10];
    lcd_w_inst(0x01);
    361a:	81 e0       	ldi	r24, 0x01	; 1
    361c:	0e 94 71 13 	call	0x26e2	; 0x26e2 <lcd_w_inst>
    printnt_P((void *)err97);
    3620:	86 e2       	ldi	r24, 0x26	; 38
    3622:	9d e0       	ldi	r25, 0x0D	; 13
    3624:	0e 94 1a 13 	call	0x2634	; 0x2634 <printnt_P>

    eeprom_save();
    3628:	0e 94 58 12 	call	0x24b0	; 0x24b0 <eeprom_save>

    lcd_w_inst(0x01);
    362c:	81 e0       	ldi	r24, 0x01	; 1
    362e:	0e 94 71 13 	call	0x26e2	; 0x26e2 <lcd_w_inst>
    printnt_P((void *)err97b);
    3632:	8c e5       	ldi	r24, 0x5C	; 92
    3634:	9d e0       	ldi	r25, 0x0D	; 13
    3636:	0e 94 1a 13 	call	0x2634	; 0x2634 <printnt_P>
    printnt(" ");
    363a:	8d ee       	ldi	r24, 0xED	; 237
    363c:	90 e0       	ldi	r25, 0x00	; 0
    363e:	0e 94 28 13 	call	0x2650	; 0x2650 <printnt>
    printnt(wtch_sfile);
    3642:	80 91 fd 00 	lds	r24, 0x00FD
    3646:	90 91 fe 00 	lds	r25, 0x00FE
    364a:	0e 94 28 13 	call	0x2650	; 0x2650 <printnt>
    printnt(" ");
    364e:	8d ee       	ldi	r24, 0xED	; 237
    3650:	90 e0       	ldi	r25, 0x00	; 0
    3652:	0e 94 28 13 	call	0x2650	; 0x2650 <printnt>
    sprintf(str,"%i",wtch_sline);
    3656:	00 d0       	rcall	.+0      	; 0x3658 <wtch_main+0x76>
    3658:	00 d0       	rcall	.+0      	; 0x365a <wtch_main+0x78>
    365a:	00 d0       	rcall	.+0      	; 0x365c <wtch_main+0x7a>
    365c:	ed b7       	in	r30, 0x3d	; 61
    365e:	fe b7       	in	r31, 0x3e	; 62
    3660:	31 96       	adiw	r30, 0x01	; 1
    3662:	8e 01       	movw	r16, r28
    3664:	0f 5f       	subi	r16, 0xFF	; 255
    3666:	1f 4f       	sbci	r17, 0xFF	; 255
    3668:	ad b7       	in	r26, 0x3d	; 61
    366a:	be b7       	in	r27, 0x3e	; 62
    366c:	12 96       	adiw	r26, 0x02	; 2
    366e:	1c 93       	st	X, r17
    3670:	0e 93       	st	-X, r16
    3672:	11 97       	sbiw	r26, 0x01	; 1
    3674:	8f ee       	ldi	r24, 0xEF	; 239
    3676:	90 e0       	ldi	r25, 0x00	; 0
    3678:	93 83       	std	Z+3, r25	; 0x03
    367a:	82 83       	std	Z+2, r24	; 0x02
    367c:	80 91 ff 00 	lds	r24, 0x00FF
    3680:	90 91 00 01 	lds	r25, 0x0100
    3684:	95 83       	std	Z+5, r25	; 0x05
    3686:	84 83       	std	Z+4, r24	; 0x04
    3688:	0e 94 3d 1f 	call	0x3e7a	; 0x3e7a <sprintf>
    printnt(str);
    368c:	8d b7       	in	r24, 0x3d	; 61
    368e:	9e b7       	in	r25, 0x3e	; 62
    3690:	06 96       	adiw	r24, 0x06	; 6
    3692:	0f b6       	in	r0, 0x3f	; 63
    3694:	f8 94       	cli
    3696:	9e bf       	out	0x3e, r25	; 62
    3698:	0f be       	out	0x3f, r0	; 63
    369a:	8d bf       	out	0x3d, r24	; 61
    369c:	c8 01       	movw	r24, r16
    369e:	0e 94 28 13 	call	0x2650	; 0x2650 <printnt>
    //printnt(" ");
    //printnt(wtch_sfunction);
    wtch_reset2();
    36a2:	a8 95       	wdr
    36a4:	20 e0       	ldi	r18, 0x00	; 0
    36a6:	30 e0       	ldi	r19, 0x00	; 0
    36a8:	40 ed       	ldi	r20, 0xD0	; 208
    36aa:	57 e0       	ldi	r21, 0x07	; 7
    36ac:	ca 01       	movw	r24, r20
    36ae:	01 97       	sbiw	r24, 0x01	; 1
    36b0:	f1 f7       	brne	.-4      	; 0x36ae <wtch_main+0xcc>

    for(i=0 ; i < 3000;i++){
      _delay_ms(1);
      wtch_reset2();
    36b2:	a8 95       	wdr
    printnt(str);
    //printnt(" ");
    //printnt(wtch_sfunction);
    wtch_reset2();

    for(i=0 ; i < 3000;i++){
    36b4:	2f 5f       	subi	r18, 0xFF	; 255
    36b6:	3f 4f       	sbci	r19, 0xFF	; 255
    36b8:	9b e0       	ldi	r25, 0x0B	; 11
    36ba:	28 3b       	cpi	r18, 0xB8	; 184
    36bc:	39 07       	cpc	r19, r25
    36be:	b1 f7       	brne	.-20     	; 0x36ac <wtch_main+0xca>
    36c0:	ff cf       	rjmp	.-2      	; 0x36c0 <wtch_main+0xde>
    for(;;){
      //tohle je resetování softwarového watchodogu.
      wtch_reset();
    };
  }
}
    36c2:	2a 96       	adiw	r28, 0x0a	; 10
    36c4:	0f b6       	in	r0, 0x3f	; 63
    36c6:	f8 94       	cli
    36c8:	de bf       	out	0x3e, r29	; 62
    36ca:	0f be       	out	0x3f, r0	; 63
    36cc:	cd bf       	out	0x3d, r28	; 61
    36ce:	cf 91       	pop	r28
    36d0:	df 91       	pop	r29
    36d2:	1f 91       	pop	r17
    36d4:	0f 91       	pop	r16
    36d6:	08 95       	ret

000036d8 <si_set_flag>:
/**
 * Funkce nastaví vlajkové bity, podle kterých jsou či nejsou zobrazovány
 * systémové informace
 */
void si_set_flag(char flag){
  sysinfo_flag = flag;
    36d8:	80 93 b6 01 	sts	0x01B6, r24
}
    36dc:	08 95       	ret

000036de <si_print_mem>:
    printcxyd(0,0,c + '0');
  }
}
*/

void si_print_mem(void){
    36de:	0f 93       	push	r16
    36e0:	1f 93       	push	r17
  if (((sysinfo_flag >> SI_SHOW_MEM)&1) == 1) {
    36e2:	80 91 b6 01 	lds	r24, 0x01B6
    36e6:	80 ff       	sbrs	r24, 0
    36e8:	27 c0       	rjmp	.+78     	; 0x3738 <si_print_mem+0x5a>
      uint16_t mem;
      mem = used_mem();
    36ea:	0e 94 93 1d 	call	0x3b26	; 0x3b26 <used_mem>
      sprintf(str_buf, "M%3d", mem);
    36ee:	00 d0       	rcall	.+0      	; 0x36f0 <si_print_mem+0x12>
    36f0:	00 d0       	rcall	.+0      	; 0x36f2 <si_print_mem+0x14>
    36f2:	00 d0       	rcall	.+0      	; 0x36f4 <si_print_mem+0x16>
    36f4:	ed b7       	in	r30, 0x3d	; 61
    36f6:	fe b7       	in	r31, 0x3e	; 62
    36f8:	31 96       	adiw	r30, 0x01	; 1
    36fa:	0a eb       	ldi	r16, 0xBA	; 186
    36fc:	11 e0       	ldi	r17, 0x01	; 1
    36fe:	ad b7       	in	r26, 0x3d	; 61
    3700:	be b7       	in	r27, 0x3e	; 62
    3702:	12 96       	adiw	r26, 0x02	; 2
    3704:	1c 93       	st	X, r17
    3706:	0e 93       	st	-X, r16
    3708:	11 97       	sbiw	r26, 0x01	; 1
    370a:	21 e0       	ldi	r18, 0x01	; 1
    370c:	31 e0       	ldi	r19, 0x01	; 1
    370e:	33 83       	std	Z+3, r19	; 0x03
    3710:	22 83       	std	Z+2, r18	; 0x02
    3712:	95 83       	std	Z+5, r25	; 0x05
    3714:	84 83       	std	Z+4, r24	; 0x04
    3716:	0e 94 3d 1f 	call	0x3e7a	; 0x3e7a <sprintf>
      printxyd(0, 36, str_buf);
    371a:	8d b7       	in	r24, 0x3d	; 61
    371c:	9e b7       	in	r25, 0x3e	; 62
    371e:	06 96       	adiw	r24, 0x06	; 6
    3720:	0f b6       	in	r0, 0x3f	; 63
    3722:	f8 94       	cli
    3724:	9e bf       	out	0x3e, r25	; 62
    3726:	0f be       	out	0x3f, r0	; 63
    3728:	8d bf       	out	0x3d, r24	; 61
    372a:	80 e0       	ldi	r24, 0x00	; 0
    372c:	90 e0       	ldi	r25, 0x00	; 0
    372e:	64 e2       	ldi	r22, 0x24	; 36
    3730:	70 e0       	ldi	r23, 0x00	; 0
    3732:	a8 01       	movw	r20, r16
    3734:	0e 94 85 15 	call	0x2b0a	; 0x2b0a <printxyd>
    }
}
    3738:	1f 91       	pop	r17
    373a:	0f 91       	pop	r16
    373c:	08 95       	ret

0000373e <sysinfo>:
 * nastavení. Výpis probíhá jedmnou za deset volání.
 */
void sysinfo(void) {
  static char counter = 0;

  wtch_dbg_info();
    373e:	86 e0       	ldi	r24, 0x06	; 6
    3740:	91 e0       	ldi	r25, 0x01	; 1
    3742:	90 93 fe 00 	sts	0x00FE, r25
    3746:	80 93 fd 00 	sts	0x00FD, r24
    374a:	80 e6       	ldi	r24, 0x60	; 96
    374c:	90 e0       	ldi	r25, 0x00	; 0
    374e:	90 93 00 01 	sts	0x0100, r25
    3752:	80 93 ff 00 	sts	0x00FF, r24
  if (counter > 50) {
    3756:	80 91 b7 01 	lds	r24, 0x01B7
    375a:	83 33       	cpi	r24, 0x33	; 51
    375c:	20 f0       	brcs	.+8      	; 0x3766 <sysinfo+0x28>
    si_print_mem();
    375e:	0e 94 6f 1b 	call	0x36de	; 0x36de <si_print_mem>
    //si_print_recv_buffer();
    counter = 0;
    3762:	10 92 b7 01 	sts	0x01B7, r1
  }
  counter++;
    3766:	80 91 b7 01 	lds	r24, 0x01B7
    376a:	8f 5f       	subi	r24, 0xFF	; 255
    376c:	80 93 b7 01 	sts	0x01B7, r24
    3770:	08 95       	ret

00003772 <si_print_error>:


/**
 * Funkce vypisuje číslo erroru.
 */
void si_print_error(char err_num) {
    3772:	0f 93       	push	r16
    3774:	1f 93       	push	r17
    3776:	28 2f       	mov	r18, r24
  if (((sysinfo_flag >> SI_SHOW_ERR)&1) == 1) {
    3778:	80 91 b6 01 	lds	r24, 0x01B6
    377c:	86 95       	lsr	r24
    377e:	86 95       	lsr	r24
    3780:	86 95       	lsr	r24
    3782:	80 ff       	sbrs	r24, 0
    3784:	25 c0       	rjmp	.+74     	; 0x37d0 <si_print_error+0x5e>
    sprintf(str_buf, "E%3d", err_num);
    3786:	00 d0       	rcall	.+0      	; 0x3788 <si_print_error+0x16>
    3788:	00 d0       	rcall	.+0      	; 0x378a <si_print_error+0x18>
    378a:	00 d0       	rcall	.+0      	; 0x378c <si_print_error+0x1a>
    378c:	ed b7       	in	r30, 0x3d	; 61
    378e:	fe b7       	in	r31, 0x3e	; 62
    3790:	31 96       	adiw	r30, 0x01	; 1
    3792:	0a eb       	ldi	r16, 0xBA	; 186
    3794:	11 e0       	ldi	r17, 0x01	; 1
    3796:	ad b7       	in	r26, 0x3d	; 61
    3798:	be b7       	in	r27, 0x3e	; 62
    379a:	12 96       	adiw	r26, 0x02	; 2
    379c:	1c 93       	st	X, r17
    379e:	0e 93       	st	-X, r16
    37a0:	11 97       	sbiw	r26, 0x01	; 1
    37a2:	80 e1       	ldi	r24, 0x10	; 16
    37a4:	91 e0       	ldi	r25, 0x01	; 1
    37a6:	93 83       	std	Z+3, r25	; 0x03
    37a8:	82 83       	std	Z+2, r24	; 0x02
    37aa:	24 83       	std	Z+4, r18	; 0x04
    37ac:	15 82       	std	Z+5, r1	; 0x05
    37ae:	0e 94 3d 1f 	call	0x3e7a	; 0x3e7a <sprintf>
    printxyd(0, 32, str_buf);
    37b2:	8d b7       	in	r24, 0x3d	; 61
    37b4:	9e b7       	in	r25, 0x3e	; 62
    37b6:	06 96       	adiw	r24, 0x06	; 6
    37b8:	0f b6       	in	r0, 0x3f	; 63
    37ba:	f8 94       	cli
    37bc:	9e bf       	out	0x3e, r25	; 62
    37be:	0f be       	out	0x3f, r0	; 63
    37c0:	8d bf       	out	0x3d, r24	; 61
    37c2:	80 e0       	ldi	r24, 0x00	; 0
    37c4:	90 e0       	ldi	r25, 0x00	; 0
    37c6:	60 e2       	ldi	r22, 0x20	; 32
    37c8:	70 e0       	ldi	r23, 0x00	; 0
    37ca:	a8 01       	movw	r20, r16
    37cc:	0e 94 85 15 	call	0x2b0a	; 0x2b0a <printxyd>
  }
}
    37d0:	1f 91       	pop	r17
    37d2:	0f 91       	pop	r16
    37d4:	08 95       	ret

000037d6 <si_print_recv_buffer>:


/**
 * Funkce vypíše obsah přijímacího bufferu.
 */
void si_print_recv_buffer(void){
    37d6:	ef 92       	push	r14
    37d8:	ff 92       	push	r15
    37da:	0f 93       	push	r16
    37dc:	1f 93       	push	r17
  if (((sysinfo_flag >> SI_SHOW_RECV_BUFF)&1) == 1) {
    37de:	80 91 b6 01 	lds	r24, 0x01B6
    37e2:	86 95       	lsr	r24
    37e4:	80 ff       	sbrs	r24, 0
    37e6:	a9 c0       	rjmp	.+338    	; 0x393a <si_print_recv_buffer+0x164>
    char * rb;
    rb = get_recv_buffer();
    37e8:	0e 94 bf 08 	call	0x117e	; 0x117e <get_recv_buffer>
    37ec:	8c 01       	movw	r16, r24
    sprintf(str_buf, "%2x,%2x,%2x,%2x,%2x,%2x,%2x,%2x,%2x,%2x",
    37ee:	8d b7       	in	r24, 0x3d	; 61
    37f0:	9e b7       	in	r25, 0x3e	; 62
    37f2:	48 97       	sbiw	r24, 0x18	; 24
    37f4:	0f b6       	in	r0, 0x3f	; 63
    37f6:	f8 94       	cli
    37f8:	9e bf       	out	0x3e, r25	; 62
    37fa:	0f be       	out	0x3f, r0	; 63
    37fc:	8d bf       	out	0x3d, r24	; 61
    37fe:	ed b7       	in	r30, 0x3d	; 61
    3800:	fe b7       	in	r31, 0x3e	; 62
    3802:	31 96       	adiw	r30, 0x01	; 1
    3804:	8a eb       	ldi	r24, 0xBA	; 186
    3806:	e8 2e       	mov	r14, r24
    3808:	81 e0       	ldi	r24, 0x01	; 1
    380a:	f8 2e       	mov	r15, r24
    380c:	ad b7       	in	r26, 0x3d	; 61
    380e:	be b7       	in	r27, 0x3e	; 62
    3810:	12 96       	adiw	r26, 0x02	; 2
    3812:	fc 92       	st	X, r15
    3814:	ee 92       	st	-X, r14
    3816:	11 97       	sbiw	r26, 0x01	; 1
    3818:	85 e1       	ldi	r24, 0x15	; 21
    381a:	91 e0       	ldi	r25, 0x01	; 1
    381c:	93 83       	std	Z+3, r25	; 0x03
    381e:	82 83       	std	Z+2, r24	; 0x02
    3820:	d8 01       	movw	r26, r16
    3822:	8c 91       	ld	r24, X
    3824:	84 83       	std	Z+4, r24	; 0x04
    3826:	15 82       	std	Z+5, r1	; 0x05
    3828:	11 96       	adiw	r26, 0x01	; 1
    382a:	8c 91       	ld	r24, X
    382c:	11 97       	sbiw	r26, 0x01	; 1
    382e:	86 83       	std	Z+6, r24	; 0x06
    3830:	17 82       	std	Z+7, r1	; 0x07
    3832:	12 96       	adiw	r26, 0x02	; 2
    3834:	8c 91       	ld	r24, X
    3836:	12 97       	sbiw	r26, 0x02	; 2
    3838:	80 87       	std	Z+8, r24	; 0x08
    383a:	11 86       	std	Z+9, r1	; 0x09
    383c:	13 96       	adiw	r26, 0x03	; 3
    383e:	8c 91       	ld	r24, X
    3840:	13 97       	sbiw	r26, 0x03	; 3
    3842:	82 87       	std	Z+10, r24	; 0x0a
    3844:	13 86       	std	Z+11, r1	; 0x0b
    3846:	14 96       	adiw	r26, 0x04	; 4
    3848:	8c 91       	ld	r24, X
    384a:	14 97       	sbiw	r26, 0x04	; 4
    384c:	84 87       	std	Z+12, r24	; 0x0c
    384e:	15 86       	std	Z+13, r1	; 0x0d
    3850:	15 96       	adiw	r26, 0x05	; 5
    3852:	8c 91       	ld	r24, X
    3854:	15 97       	sbiw	r26, 0x05	; 5
    3856:	86 87       	std	Z+14, r24	; 0x0e
    3858:	17 86       	std	Z+15, r1	; 0x0f
    385a:	16 96       	adiw	r26, 0x06	; 6
    385c:	8c 91       	ld	r24, X
    385e:	16 97       	sbiw	r26, 0x06	; 6
    3860:	80 8b       	std	Z+16, r24	; 0x10
    3862:	11 8a       	std	Z+17, r1	; 0x11
    3864:	17 96       	adiw	r26, 0x07	; 7
    3866:	8c 91       	ld	r24, X
    3868:	17 97       	sbiw	r26, 0x07	; 7
    386a:	82 8b       	std	Z+18, r24	; 0x12
    386c:	13 8a       	std	Z+19, r1	; 0x13
    386e:	18 96       	adiw	r26, 0x08	; 8
    3870:	8c 91       	ld	r24, X
    3872:	18 97       	sbiw	r26, 0x08	; 8
    3874:	84 8b       	std	Z+20, r24	; 0x14
    3876:	15 8a       	std	Z+21, r1	; 0x15
    3878:	19 96       	adiw	r26, 0x09	; 9
    387a:	8c 91       	ld	r24, X
    387c:	86 8b       	std	Z+22, r24	; 0x16
    387e:	17 8a       	std	Z+23, r1	; 0x17
    3880:	0e 94 3d 1f 	call	0x3e7a	; 0x3e7a <sprintf>
            (unsigned int) rb[0], (unsigned int) rb[1], (unsigned int) rb[2], (unsigned int) rb[3],
            (unsigned int) rb[4], (unsigned int) rb[5], (unsigned int) rb[6], (unsigned int) rb[7],
            (unsigned int) rb[8], (unsigned int) rb[9]
            );
    printxyd(2, 0, str_buf);
    3884:	8d b7       	in	r24, 0x3d	; 61
    3886:	9e b7       	in	r25, 0x3e	; 62
    3888:	48 96       	adiw	r24, 0x18	; 24
    388a:	0f b6       	in	r0, 0x3f	; 63
    388c:	f8 94       	cli
    388e:	9e bf       	out	0x3e, r25	; 62
    3890:	0f be       	out	0x3f, r0	; 63
    3892:	8d bf       	out	0x3d, r24	; 61
    3894:	82 e0       	ldi	r24, 0x02	; 2
    3896:	90 e0       	ldi	r25, 0x00	; 0
    3898:	60 e0       	ldi	r22, 0x00	; 0
    389a:	70 e0       	ldi	r23, 0x00	; 0
    389c:	a7 01       	movw	r20, r14
    389e:	0e 94 85 15 	call	0x2b0a	; 0x2b0a <printxyd>

    sprintf(str_buf, "%2x,%2x,%2x,%2x,%2x,%2x,%2x,%2x",
    38a2:	ad b7       	in	r26, 0x3d	; 61
    38a4:	be b7       	in	r27, 0x3e	; 62
    38a6:	54 97       	sbiw	r26, 0x14	; 20
    38a8:	0f b6       	in	r0, 0x3f	; 63
    38aa:	f8 94       	cli
    38ac:	be bf       	out	0x3e, r27	; 62
    38ae:	0f be       	out	0x3f, r0	; 63
    38b0:	ad bf       	out	0x3d, r26	; 61
    38b2:	ed b7       	in	r30, 0x3d	; 61
    38b4:	fe b7       	in	r31, 0x3e	; 62
    38b6:	31 96       	adiw	r30, 0x01	; 1
    38b8:	12 96       	adiw	r26, 0x02	; 2
    38ba:	fc 92       	st	X, r15
    38bc:	ee 92       	st	-X, r14
    38be:	11 97       	sbiw	r26, 0x01	; 1
    38c0:	8d e3       	ldi	r24, 0x3D	; 61
    38c2:	91 e0       	ldi	r25, 0x01	; 1
    38c4:	93 83       	std	Z+3, r25	; 0x03
    38c6:	82 83       	std	Z+2, r24	; 0x02
    38c8:	d8 01       	movw	r26, r16
    38ca:	1a 96       	adiw	r26, 0x0a	; 10
    38cc:	8c 91       	ld	r24, X
    38ce:	1a 97       	sbiw	r26, 0x0a	; 10
    38d0:	84 83       	std	Z+4, r24	; 0x04
    38d2:	15 82       	std	Z+5, r1	; 0x05
    38d4:	1b 96       	adiw	r26, 0x0b	; 11
    38d6:	8c 91       	ld	r24, X
    38d8:	1b 97       	sbiw	r26, 0x0b	; 11
    38da:	86 83       	std	Z+6, r24	; 0x06
    38dc:	17 82       	std	Z+7, r1	; 0x07
    38de:	1c 96       	adiw	r26, 0x0c	; 12
    38e0:	8c 91       	ld	r24, X
    38e2:	1c 97       	sbiw	r26, 0x0c	; 12
    38e4:	80 87       	std	Z+8, r24	; 0x08
    38e6:	11 86       	std	Z+9, r1	; 0x09
    38e8:	1d 96       	adiw	r26, 0x0d	; 13
    38ea:	8c 91       	ld	r24, X
    38ec:	1d 97       	sbiw	r26, 0x0d	; 13
    38ee:	82 87       	std	Z+10, r24	; 0x0a
    38f0:	13 86       	std	Z+11, r1	; 0x0b
    38f2:	1e 96       	adiw	r26, 0x0e	; 14
    38f4:	8c 91       	ld	r24, X
    38f6:	1e 97       	sbiw	r26, 0x0e	; 14
    38f8:	84 87       	std	Z+12, r24	; 0x0c
    38fa:	15 86       	std	Z+13, r1	; 0x0d
    38fc:	1f 96       	adiw	r26, 0x0f	; 15
    38fe:	8c 91       	ld	r24, X
    3900:	1f 97       	sbiw	r26, 0x0f	; 15
    3902:	86 87       	std	Z+14, r24	; 0x0e
    3904:	17 86       	std	Z+15, r1	; 0x0f
    3906:	50 96       	adiw	r26, 0x10	; 16
    3908:	8c 91       	ld	r24, X
    390a:	50 97       	sbiw	r26, 0x10	; 16
    390c:	80 8b       	std	Z+16, r24	; 0x10
    390e:	11 8a       	std	Z+17, r1	; 0x11
    3910:	51 96       	adiw	r26, 0x11	; 17
    3912:	8c 91       	ld	r24, X
    3914:	82 8b       	std	Z+18, r24	; 0x12
    3916:	13 8a       	std	Z+19, r1	; 0x13
    3918:	0e 94 3d 1f 	call	0x3e7a	; 0x3e7a <sprintf>
            (unsigned int) rb[10], (unsigned int) rb[11], (unsigned int) rb[12], (unsigned int) rb[13],
            (unsigned int) rb[14], (unsigned int) rb[15], (unsigned int) rb[16], (unsigned int) rb[17]
            );
    printxyd(3, 0, str_buf);
    391c:	8d b7       	in	r24, 0x3d	; 61
    391e:	9e b7       	in	r25, 0x3e	; 62
    3920:	44 96       	adiw	r24, 0x14	; 20
    3922:	0f b6       	in	r0, 0x3f	; 63
    3924:	f8 94       	cli
    3926:	9e bf       	out	0x3e, r25	; 62
    3928:	0f be       	out	0x3f, r0	; 63
    392a:	8d bf       	out	0x3d, r24	; 61
    392c:	83 e0       	ldi	r24, 0x03	; 3
    392e:	90 e0       	ldi	r25, 0x00	; 0
    3930:	60 e0       	ldi	r22, 0x00	; 0
    3932:	70 e0       	ldi	r23, 0x00	; 0
    3934:	a7 01       	movw	r20, r14
    3936:	0e 94 85 15 	call	0x2b0a	; 0x2b0a <printxyd>
  }
}
    393a:	1f 91       	pop	r17
    393c:	0f 91       	pop	r16
    393e:	ff 90       	pop	r15
    3940:	ef 90       	pop	r14
    3942:	08 95       	ret

00003944 <inout_init>:
/** @} */

void inout_init(void){
  // msrled
  //io_msr_led_off();
}
    3944:	08 95       	ret

00003946 <io_msr_led_on>:

void io_msr_led_on(void){
  MSR_LED_PORT |= _BV(MSR_LED_BIT);
    3946:	c7 9a       	sbi	0x18, 7	; 24
}
    3948:	08 95       	ret

0000394a <io_msr_led_off>:

void io_msr_led_off(void){
  MSR_LED_PORT &= ~_BV(MSR_LED_BIT);
    394a:	c7 98       	cbi	0x18, 7	; 24
}
    394c:	08 95       	ret

0000394e <io_irc2_options>:
}

///  Funkce nastavuje parametry irc2
/// @param k2 milimetry na otáčku
/// @param q2 kolik milimetrů od počátku je setpoint
void io_irc2_options(uint16_t k2, uint32_t q2){
    394e:	ef 92       	push	r14
    3950:	ff 92       	push	r15
    3952:	0f 93       	push	r16
    3954:	1f 93       	push	r17
    3956:	7a 01       	movw	r14, r20
    3958:	8b 01       	movw	r16, r22
  set_irc2_k_mm ( k2) ;
    395a:	0e 94 a7 11 	call	0x234e	; 0x234e <set_irc2_k_mm>
  set_irc2_set_on_value_mm( q2);
    395e:	c8 01       	movw	r24, r16
    3960:	b7 01       	movw	r22, r14
    3962:	0e 94 74 11 	call	0x22e8	; 0x22e8 <set_irc2_set_on_value_mm>
}
    3966:	1f 91       	pop	r17
    3968:	0f 91       	pop	r16
    396a:	ff 90       	pop	r15
    396c:	ef 90       	pop	r14
    396e:	08 95       	ret

00003970 <io_irc1_options>:
}

///  Funkce nastavuje parametry irc1
/// @param k1 milimetry na otáčku
/// @param q1 kolik milimetrů od počátku je setpoint
void io_irc1_options(uint16_t k1, uint32_t q1){
    3970:	ef 92       	push	r14
    3972:	ff 92       	push	r15
    3974:	0f 93       	push	r16
    3976:	1f 93       	push	r17
    3978:	7a 01       	movw	r14, r20
    397a:	8b 01       	movw	r16, r22
  set_irc1_k_mm ( k1) ;
    397c:	0e 94 e8 0f 	call	0x1fd0	; 0x1fd0 <set_irc1_k_mm>
  set_irc1_set_on_value_mm( q1);
    3980:	c8 01       	movw	r24, r16
    3982:	b7 01       	movw	r22, r14
    3984:	0e 94 b5 0f 	call	0x1f6a	; 0x1f6a <set_irc1_set_on_value_mm>
}
    3988:	1f 91       	pop	r17
    398a:	0f 91       	pop	r16
    398c:	ff 90       	pop	r15
    398e:	ef 90       	pop	r14
    3990:	08 95       	ret

00003992 <default_scr_control>:



}

void default_scr_control(void){
    3992:	0f 93       	push	r16
    3994:	1f 93       	push	r17
    3996:	cf 93       	push	r28
    3998:	df 93       	push	r29
  /*sprintf(str_buf,"%d",toc());
  printxyd(0,20,str_buf); */
  //printxyd( 1,38, int2strn(str_buf,2,(irc1_get_l() % 100)));
  //str_buf[0] = ' ';

  tmp = irc1_get_l();
    399a:	0e 94 93 0e 	call	0x1d26	; 0x1d26 <irc1_get_l>
    399e:	ec 01       	movw	r28, r24
  if (tmp != tmp1){
    39a0:	80 91 66 01 	lds	r24, 0x0166
    39a4:	90 91 67 01 	lds	r25, 0x0167
    39a8:	c8 17       	cp	r28, r24
    39aa:	d9 07       	cpc	r29, r25
    39ac:	d1 f1       	breq	.+116    	; 0x3a22 <default_scr_control+0x90>
    sprintf(str_buf,"%2d.%d",(tmp/100), tmp%100);// / 100.0));
    39ae:	8d b7       	in	r24, 0x3d	; 61
    39b0:	9e b7       	in	r25, 0x3e	; 62
    39b2:	08 97       	sbiw	r24, 0x08	; 8
    39b4:	0f b6       	in	r0, 0x3f	; 63
    39b6:	f8 94       	cli
    39b8:	9e bf       	out	0x3e, r25	; 62
    39ba:	0f be       	out	0x3f, r0	; 63
    39bc:	8d bf       	out	0x3d, r24	; 61
    39be:	ed b7       	in	r30, 0x3d	; 61
    39c0:	fe b7       	in	r31, 0x3e	; 62
    39c2:	31 96       	adiw	r30, 0x01	; 1
    39c4:	0a eb       	ldi	r16, 0xBA	; 186
    39c6:	11 e0       	ldi	r17, 0x01	; 1
    39c8:	ad b7       	in	r26, 0x3d	; 61
    39ca:	be b7       	in	r27, 0x3e	; 62
    39cc:	12 96       	adiw	r26, 0x02	; 2
    39ce:	1c 93       	st	X, r17
    39d0:	0e 93       	st	-X, r16
    39d2:	11 97       	sbiw	r26, 0x01	; 1
    39d4:	8d e5       	ldi	r24, 0x5D	; 93
    39d6:	91 e0       	ldi	r25, 0x01	; 1
    39d8:	93 83       	std	Z+3, r25	; 0x03
    39da:	82 83       	std	Z+2, r24	; 0x02
    39dc:	ce 01       	movw	r24, r28
    39de:	64 e6       	ldi	r22, 0x64	; 100
    39e0:	70 e0       	ldi	r23, 0x00	; 0
    39e2:	0e 94 94 23 	call	0x4728	; 0x4728 <__udivmodhi4>
    39e6:	75 83       	std	Z+5, r23	; 0x05
    39e8:	64 83       	std	Z+4, r22	; 0x04
    39ea:	ce 01       	movw	r24, r28
    39ec:	64 e6       	ldi	r22, 0x64	; 100
    39ee:	70 e0       	ldi	r23, 0x00	; 0
    39f0:	0e 94 94 23 	call	0x4728	; 0x4728 <__udivmodhi4>
    39f4:	97 83       	std	Z+7, r25	; 0x07
    39f6:	86 83       	std	Z+6, r24	; 0x06
    39f8:	0e 94 3d 1f 	call	0x3e7a	; 0x3e7a <sprintf>
    printxyd( 1,34, str_buf);
    39fc:	8d b7       	in	r24, 0x3d	; 61
    39fe:	9e b7       	in	r25, 0x3e	; 62
    3a00:	08 96       	adiw	r24, 0x08	; 8
    3a02:	0f b6       	in	r0, 0x3f	; 63
    3a04:	f8 94       	cli
    3a06:	9e bf       	out	0x3e, r25	; 62
    3a08:	0f be       	out	0x3f, r0	; 63
    3a0a:	8d bf       	out	0x3d, r24	; 61
    3a0c:	81 e0       	ldi	r24, 0x01	; 1
    3a0e:	90 e0       	ldi	r25, 0x00	; 0
    3a10:	62 e2       	ldi	r22, 0x22	; 34
    3a12:	70 e0       	ldi	r23, 0x00	; 0
    3a14:	a8 01       	movw	r20, r16
    3a16:	0e 94 85 15 	call	0x2b0a	; 0x2b0a <printxyd>
    tmp1 = tmp;
    3a1a:	d0 93 67 01 	sts	0x0167, r29
    3a1e:	c0 93 66 01 	sts	0x0166, r28
  }
  
  tmp = irc2_get_l();
    3a22:	0e 94 4d 10 	call	0x209a	; 0x209a <irc2_get_l>
    3a26:	ec 01       	movw	r28, r24
  if (tmp != tmp2){
    3a28:	80 91 64 01 	lds	r24, 0x0164
    3a2c:	90 91 65 01 	lds	r25, 0x0165
    3a30:	c8 17       	cp	r28, r24
    3a32:	d9 07       	cpc	r29, r25
    3a34:	c1 f1       	breq	.+112    	; 0x3aa6 <default_scr_control+0x114>
    sprintf(str_buf,"%2d.%d",tmp/10,tmp%10);//) / 10.0);
    3a36:	ad b7       	in	r26, 0x3d	; 61
    3a38:	be b7       	in	r27, 0x3e	; 62
    3a3a:	18 97       	sbiw	r26, 0x08	; 8
    3a3c:	0f b6       	in	r0, 0x3f	; 63
    3a3e:	f8 94       	cli
    3a40:	be bf       	out	0x3e, r27	; 62
    3a42:	0f be       	out	0x3f, r0	; 63
    3a44:	ad bf       	out	0x3d, r26	; 61
    3a46:	ed b7       	in	r30, 0x3d	; 61
    3a48:	fe b7       	in	r31, 0x3e	; 62
    3a4a:	31 96       	adiw	r30, 0x01	; 1
    3a4c:	0a eb       	ldi	r16, 0xBA	; 186
    3a4e:	11 e0       	ldi	r17, 0x01	; 1
    3a50:	12 96       	adiw	r26, 0x02	; 2
    3a52:	1c 93       	st	X, r17
    3a54:	0e 93       	st	-X, r16
    3a56:	11 97       	sbiw	r26, 0x01	; 1
    3a58:	8d e5       	ldi	r24, 0x5D	; 93
    3a5a:	91 e0       	ldi	r25, 0x01	; 1
    3a5c:	93 83       	std	Z+3, r25	; 0x03
    3a5e:	82 83       	std	Z+2, r24	; 0x02
    3a60:	ce 01       	movw	r24, r28
    3a62:	6a e0       	ldi	r22, 0x0A	; 10
    3a64:	70 e0       	ldi	r23, 0x00	; 0
    3a66:	0e 94 94 23 	call	0x4728	; 0x4728 <__udivmodhi4>
    3a6a:	75 83       	std	Z+5, r23	; 0x05
    3a6c:	64 83       	std	Z+4, r22	; 0x04
    3a6e:	ce 01       	movw	r24, r28
    3a70:	6a e0       	ldi	r22, 0x0A	; 10
    3a72:	70 e0       	ldi	r23, 0x00	; 0
    3a74:	0e 94 94 23 	call	0x4728	; 0x4728 <__udivmodhi4>
    3a78:	97 83       	std	Z+7, r25	; 0x07
    3a7a:	86 83       	std	Z+6, r24	; 0x06
    3a7c:	0e 94 3d 1f 	call	0x3e7a	; 0x3e7a <sprintf>
    printxyd( 2,34,str_buf);
    3a80:	8d b7       	in	r24, 0x3d	; 61
    3a82:	9e b7       	in	r25, 0x3e	; 62
    3a84:	08 96       	adiw	r24, 0x08	; 8
    3a86:	0f b6       	in	r0, 0x3f	; 63
    3a88:	f8 94       	cli
    3a8a:	9e bf       	out	0x3e, r25	; 62
    3a8c:	0f be       	out	0x3f, r0	; 63
    3a8e:	8d bf       	out	0x3d, r24	; 61
    3a90:	82 e0       	ldi	r24, 0x02	; 2
    3a92:	90 e0       	ldi	r25, 0x00	; 0
    3a94:	62 e2       	ldi	r22, 0x22	; 34
    3a96:	70 e0       	ldi	r23, 0x00	; 0
    3a98:	a8 01       	movw	r20, r16
    3a9a:	0e 94 85 15 	call	0x2b0a	; 0x2b0a <printxyd>
  //printxyd( 2,34, int2strn(str_buf,3,(irc2_get_l() / 10)));
    tmp2=tmp;
    3a9e:	d0 93 65 01 	sts	0x0165, r29
    3aa2:	c0 93 64 01 	sts	0x0164, r28
  }

  //printcxyd( 2,38,(irc2_get_l()  % 10) + 48);
    3aa6:	df 91       	pop	r29
    3aa8:	cf 91       	pop	r28
    3aaa:	1f 91       	pop	r17
    3aac:	0f 91       	pop	r16
    3aae:	08 95       	ret

00003ab0 <default_scr_draw>:
static char s_msr_delka[] PROGMEM =    "Zmerena delka     ";
static char s_msr_domereno[] PROGMEM = "Mereni dokonceno  ";
static char s_msr_pause[] PROGMEM =    "Mereni pozastaveno";
// @}

void default_scr_draw(void){
    3ab0:	0f 93       	push	r16
    3ab2:	1f 93       	push	r17
  clear_dscreen();
    3ab4:	0e 94 ca 12 	call	0x2594	; 0x2594 <clear_dscreen>
//  akt_scr = MSR_SCR;
  printxyd(1,0, strcpy_P(str_buf,s_zakz));
    3ab8:	0a eb       	ldi	r16, 0xBA	; 186
    3aba:	11 e0       	ldi	r17, 0x01	; 1
    3abc:	c8 01       	movw	r24, r16
    3abe:	6b e7       	ldi	r22, 0x7B	; 123
    3ac0:	7d e0       	ldi	r23, 0x0D	; 13
    3ac2:	0e 94 ca 1e 	call	0x3d94	; 0x3d94 <strcpy_P>
    3ac6:	ac 01       	movw	r20, r24
    3ac8:	81 e0       	ldi	r24, 0x01	; 1
    3aca:	90 e0       	ldi	r25, 0x00	; 0
    3acc:	60 e0       	ldi	r22, 0x00	; 0
    3ace:	70 e0       	ldi	r23, 0x00	; 0
    3ad0:	0e 94 85 15 	call	0x2b0a	; 0x2b0a <printxyd>
  //printxyd(1,0, strcpy_P(str_buf,s_drev));
  //printxyd(2,0, strcpy_P(str_buf,s_oper));
  //printxyd_P(3,0, (void*) s_dat_scr);

  printxyd(1, 25, strcpy_P(str_buf,s_delka));
    3ad4:	c8 01       	movw	r24, r16
    3ad6:	6d e8       	ldi	r22, 0x8D	; 141
    3ad8:	7d e0       	ldi	r23, 0x0D	; 13
    3ada:	0e 94 ca 1e 	call	0x3d94	; 0x3d94 <strcpy_P>
    3ade:	ac 01       	movw	r20, r24
    3ae0:	81 e0       	ldi	r24, 0x01	; 1
    3ae2:	90 e0       	ldi	r25, 0x00	; 0
    3ae4:	69 e1       	ldi	r22, 0x19	; 25
    3ae6:	70 e0       	ldi	r23, 0x00	; 0
    3ae8:	0e 94 85 15 	call	0x2b0a	; 0x2b0a <printxyd>
  printxyd(2, 25, strcpy_P(str_buf,s_prumer_v));
    3aec:	c8 01       	movw	r24, r16
    3aee:	63 e9       	ldi	r22, 0x93	; 147
    3af0:	7d e0       	ldi	r23, 0x0D	; 13
    3af2:	0e 94 ca 1e 	call	0x3d94	; 0x3d94 <strcpy_P>
    3af6:	ac 01       	movw	r20, r24
    3af8:	82 e0       	ldi	r24, 0x02	; 2
    3afa:	90 e0       	ldi	r25, 0x00	; 0
    3afc:	69 e1       	ldi	r22, 0x19	; 25
    3afe:	70 e0       	ldi	r23, 0x00	; 0
    3b00:	0e 94 85 15 	call	0x2b0a	; 0x2b0a <printxyd>


  printcxyd(1,37, '.');
    3b04:	81 e0       	ldi	r24, 0x01	; 1
    3b06:	90 e0       	ldi	r25, 0x00	; 0
    3b08:	65 e2       	ldi	r22, 0x25	; 37
    3b0a:	70 e0       	ldi	r23, 0x00	; 0
    3b0c:	4e e2       	ldi	r20, 0x2E	; 46
    3b0e:	0e 94 34 13 	call	0x2668	; 0x2668 <printcxyd>
  printcxyd(2,37, '.');
    3b12:	82 e0       	ldi	r24, 0x02	; 2
    3b14:	90 e0       	ldi	r25, 0x00	; 0
    3b16:	65 e2       	ldi	r22, 0x25	; 37
    3b18:	70 e0       	ldi	r23, 0x00	; 0
    3b1a:	4e e2       	ldi	r20, 0x2E	; 46
    3b1c:	0e 94 34 13 	call	0x2668	; 0x2668 <printcxyd>



}
    3b20:	1f 91       	pop	r17
    3b22:	0f 91       	pop	r16
    3b24:	08 95       	ret

00003b26 <used_mem>:
}


uint16_t used_mem(void){
  return used_mem_blocks;
}
    3b26:	80 91 b8 01 	lds	r24, 0x01B8
    3b2a:	90 91 b9 01 	lds	r25, 0x01B9
    3b2e:	08 95       	ret

00003b30 <mfree>:



void mfree(void * pointer){
  //wtch_dbg_info();
  free(pointer);
    3b30:	0e 94 69 1e 	call	0x3cd2	; 0x3cd2 <free>
  used_mem_blocks--;
    3b34:	80 91 b8 01 	lds	r24, 0x01B8
    3b38:	90 91 b9 01 	lds	r25, 0x01B9
    3b3c:	01 97       	sbiw	r24, 0x01	; 1
    3b3e:	90 93 b9 01 	sts	0x01B9, r25
    3b42:	80 93 b8 01 	sts	0x01B8, r24
}
    3b46:	08 95       	ret

00003b48 <mmalloc>:
/// Počet použitých paměťových bloků
uint16_t used_mem_blocks = 0;

/// Má alokační funkce. Testuje, zda nebyla naplněna paměť. Pokud ano, vypíše
/// chybovou hlášku.
void * mmalloc (unsigned int size){
    3b48:	cf 93       	push	r28
    3b4a:	df 93       	push	r29
  void * pointer;
  pointer = malloc (size);
    3b4c:	0e 94 bc 1d 	call	0x3b78	; 0x3b78 <malloc>
    3b50:	ec 01       	movw	r28, r24
  if (pointer == NULL){
    3b52:	00 97       	sbiw	r24, 0x00	; 0
    3b54:	21 f4       	brne	.+8      	; 0x3b5e <mmalloc+0x16>
    new_error(88);
    3b56:	88 e5       	ldi	r24, 0x58	; 88
    3b58:	0e 94 33 18 	call	0x3066	; 0x3066 <new_error>
    3b5c:	09 c0       	rjmp	.+18     	; 0x3b70 <mmalloc+0x28>
    return NULL;
  }
  else {
    used_mem_blocks++;
    3b5e:	80 91 b8 01 	lds	r24, 0x01B8
    3b62:	90 91 b9 01 	lds	r25, 0x01B9
    3b66:	01 96       	adiw	r24, 0x01	; 1
    3b68:	90 93 b9 01 	sts	0x01B9, r25
    3b6c:	80 93 b8 01 	sts	0x01B8, r24
    return pointer;
    
  }
}
    3b70:	ce 01       	movw	r24, r28
    3b72:	df 91       	pop	r29
    3b74:	cf 91       	pop	r28
    3b76:	08 95       	ret

00003b78 <malloc>:
    3b78:	cf 93       	push	r28
    3b7a:	df 93       	push	r29
    3b7c:	bc 01       	movw	r22, r24
    3b7e:	82 30       	cpi	r24, 0x02	; 2
    3b80:	91 05       	cpc	r25, r1
    3b82:	10 f4       	brcc	.+4      	; 0x3b88 <malloc+0x10>
    3b84:	62 e0       	ldi	r22, 0x02	; 2
    3b86:	70 e0       	ldi	r23, 0x00	; 0
    3b88:	a0 91 ba 03 	lds	r26, 0x03BA
    3b8c:	b0 91 bb 03 	lds	r27, 0x03BB
    3b90:	ed 01       	movw	r28, r26
    3b92:	e0 e0       	ldi	r30, 0x00	; 0
    3b94:	f0 e0       	ldi	r31, 0x00	; 0
    3b96:	40 e0       	ldi	r20, 0x00	; 0
    3b98:	50 e0       	ldi	r21, 0x00	; 0
    3b9a:	21 c0       	rjmp	.+66     	; 0x3bde <malloc+0x66>
    3b9c:	88 81       	ld	r24, Y
    3b9e:	99 81       	ldd	r25, Y+1	; 0x01
    3ba0:	86 17       	cp	r24, r22
    3ba2:	97 07       	cpc	r25, r23
    3ba4:	69 f4       	brne	.+26     	; 0x3bc0 <malloc+0x48>
    3ba6:	8a 81       	ldd	r24, Y+2	; 0x02
    3ba8:	9b 81       	ldd	r25, Y+3	; 0x03
    3baa:	30 97       	sbiw	r30, 0x00	; 0
    3bac:	19 f0       	breq	.+6      	; 0x3bb4 <malloc+0x3c>
    3bae:	93 83       	std	Z+3, r25	; 0x03
    3bb0:	82 83       	std	Z+2, r24	; 0x02
    3bb2:	04 c0       	rjmp	.+8      	; 0x3bbc <malloc+0x44>
    3bb4:	90 93 bb 03 	sts	0x03BB, r25
    3bb8:	80 93 ba 03 	sts	0x03BA, r24
    3bbc:	fe 01       	movw	r30, r28
    3bbe:	34 c0       	rjmp	.+104    	; 0x3c28 <malloc+0xb0>
    3bc0:	68 17       	cp	r22, r24
    3bc2:	79 07       	cpc	r23, r25
    3bc4:	38 f4       	brcc	.+14     	; 0x3bd4 <malloc+0x5c>
    3bc6:	41 15       	cp	r20, r1
    3bc8:	51 05       	cpc	r21, r1
    3bca:	19 f0       	breq	.+6      	; 0x3bd2 <malloc+0x5a>
    3bcc:	84 17       	cp	r24, r20
    3bce:	95 07       	cpc	r25, r21
    3bd0:	08 f4       	brcc	.+2      	; 0x3bd4 <malloc+0x5c>
    3bd2:	ac 01       	movw	r20, r24
    3bd4:	fe 01       	movw	r30, r28
    3bd6:	8a 81       	ldd	r24, Y+2	; 0x02
    3bd8:	9b 81       	ldd	r25, Y+3	; 0x03
    3bda:	9c 01       	movw	r18, r24
    3bdc:	e9 01       	movw	r28, r18
    3bde:	20 97       	sbiw	r28, 0x00	; 0
    3be0:	e9 f6       	brne	.-70     	; 0x3b9c <malloc+0x24>
    3be2:	41 15       	cp	r20, r1
    3be4:	51 05       	cpc	r21, r1
    3be6:	a9 f1       	breq	.+106    	; 0x3c52 <malloc+0xda>
    3be8:	ca 01       	movw	r24, r20
    3bea:	86 1b       	sub	r24, r22
    3bec:	97 0b       	sbc	r25, r23
    3bee:	04 97       	sbiw	r24, 0x04	; 4
    3bf0:	08 f4       	brcc	.+2      	; 0x3bf4 <malloc+0x7c>
    3bf2:	ba 01       	movw	r22, r20
    3bf4:	e0 e0       	ldi	r30, 0x00	; 0
    3bf6:	f0 e0       	ldi	r31, 0x00	; 0
    3bf8:	2a c0       	rjmp	.+84     	; 0x3c4e <malloc+0xd6>
    3bfa:	8d 91       	ld	r24, X+
    3bfc:	9c 91       	ld	r25, X
    3bfe:	11 97       	sbiw	r26, 0x01	; 1
    3c00:	84 17       	cp	r24, r20
    3c02:	95 07       	cpc	r25, r21
    3c04:	f9 f4       	brne	.+62     	; 0x3c44 <malloc+0xcc>
    3c06:	64 17       	cp	r22, r20
    3c08:	75 07       	cpc	r23, r21
    3c0a:	81 f4       	brne	.+32     	; 0x3c2c <malloc+0xb4>
    3c0c:	12 96       	adiw	r26, 0x02	; 2
    3c0e:	8d 91       	ld	r24, X+
    3c10:	9c 91       	ld	r25, X
    3c12:	13 97       	sbiw	r26, 0x03	; 3
    3c14:	30 97       	sbiw	r30, 0x00	; 0
    3c16:	19 f0       	breq	.+6      	; 0x3c1e <malloc+0xa6>
    3c18:	93 83       	std	Z+3, r25	; 0x03
    3c1a:	82 83       	std	Z+2, r24	; 0x02
    3c1c:	04 c0       	rjmp	.+8      	; 0x3c26 <malloc+0xae>
    3c1e:	90 93 bb 03 	sts	0x03BB, r25
    3c22:	80 93 ba 03 	sts	0x03BA, r24
    3c26:	fd 01       	movw	r30, r26
    3c28:	32 96       	adiw	r30, 0x02	; 2
    3c2a:	4f c0       	rjmp	.+158    	; 0x3cca <malloc+0x152>
    3c2c:	ca 01       	movw	r24, r20
    3c2e:	86 1b       	sub	r24, r22
    3c30:	97 0b       	sbc	r25, r23
    3c32:	fd 01       	movw	r30, r26
    3c34:	e8 0f       	add	r30, r24
    3c36:	f9 1f       	adc	r31, r25
    3c38:	61 93       	st	Z+, r22
    3c3a:	71 93       	st	Z+, r23
    3c3c:	02 97       	sbiw	r24, 0x02	; 2
    3c3e:	8d 93       	st	X+, r24
    3c40:	9c 93       	st	X, r25
    3c42:	43 c0       	rjmp	.+134    	; 0x3cca <malloc+0x152>
    3c44:	fd 01       	movw	r30, r26
    3c46:	82 81       	ldd	r24, Z+2	; 0x02
    3c48:	93 81       	ldd	r25, Z+3	; 0x03
    3c4a:	9c 01       	movw	r18, r24
    3c4c:	d9 01       	movw	r26, r18
    3c4e:	10 97       	sbiw	r26, 0x00	; 0
    3c50:	a1 f6       	brne	.-88     	; 0x3bfa <malloc+0x82>
    3c52:	80 91 b8 03 	lds	r24, 0x03B8
    3c56:	90 91 b9 03 	lds	r25, 0x03B9
    3c5a:	89 2b       	or	r24, r25
    3c5c:	41 f4       	brne	.+16     	; 0x3c6e <malloc+0xf6>
    3c5e:	80 91 6a 01 	lds	r24, 0x016A
    3c62:	90 91 6b 01 	lds	r25, 0x016B
    3c66:	90 93 b9 03 	sts	0x03B9, r25
    3c6a:	80 93 b8 03 	sts	0x03B8, r24
    3c6e:	40 91 6c 01 	lds	r20, 0x016C
    3c72:	50 91 6d 01 	lds	r21, 0x016D
    3c76:	41 15       	cp	r20, r1
    3c78:	51 05       	cpc	r21, r1
    3c7a:	41 f4       	brne	.+16     	; 0x3c8c <malloc+0x114>
    3c7c:	4d b7       	in	r20, 0x3d	; 61
    3c7e:	5e b7       	in	r21, 0x3e	; 62
    3c80:	80 91 68 01 	lds	r24, 0x0168
    3c84:	90 91 69 01 	lds	r25, 0x0169
    3c88:	48 1b       	sub	r20, r24
    3c8a:	59 0b       	sbc	r21, r25
    3c8c:	20 91 b8 03 	lds	r18, 0x03B8
    3c90:	30 91 b9 03 	lds	r19, 0x03B9
    3c94:	24 17       	cp	r18, r20
    3c96:	35 07       	cpc	r19, r21
    3c98:	b0 f4       	brcc	.+44     	; 0x3cc6 <malloc+0x14e>
    3c9a:	ca 01       	movw	r24, r20
    3c9c:	82 1b       	sub	r24, r18
    3c9e:	93 0b       	sbc	r25, r19
    3ca0:	86 17       	cp	r24, r22
    3ca2:	97 07       	cpc	r25, r23
    3ca4:	80 f0       	brcs	.+32     	; 0x3cc6 <malloc+0x14e>
    3ca6:	ab 01       	movw	r20, r22
    3ca8:	4e 5f       	subi	r20, 0xFE	; 254
    3caa:	5f 4f       	sbci	r21, 0xFF	; 255
    3cac:	84 17       	cp	r24, r20
    3cae:	95 07       	cpc	r25, r21
    3cb0:	50 f0       	brcs	.+20     	; 0x3cc6 <malloc+0x14e>
    3cb2:	42 0f       	add	r20, r18
    3cb4:	53 1f       	adc	r21, r19
    3cb6:	50 93 b9 03 	sts	0x03B9, r21
    3cba:	40 93 b8 03 	sts	0x03B8, r20
    3cbe:	f9 01       	movw	r30, r18
    3cc0:	61 93       	st	Z+, r22
    3cc2:	71 93       	st	Z+, r23
    3cc4:	02 c0       	rjmp	.+4      	; 0x3cca <malloc+0x152>
    3cc6:	e0 e0       	ldi	r30, 0x00	; 0
    3cc8:	f0 e0       	ldi	r31, 0x00	; 0
    3cca:	cf 01       	movw	r24, r30
    3ccc:	df 91       	pop	r29
    3cce:	cf 91       	pop	r28
    3cd0:	08 95       	ret

00003cd2 <free>:
    3cd2:	cf 93       	push	r28
    3cd4:	df 93       	push	r29
    3cd6:	00 97       	sbiw	r24, 0x00	; 0
    3cd8:	09 f4       	brne	.+2      	; 0x3cdc <free+0xa>
    3cda:	50 c0       	rjmp	.+160    	; 0x3d7c <free+0xaa>
    3cdc:	ec 01       	movw	r28, r24
    3cde:	22 97       	sbiw	r28, 0x02	; 2
    3ce0:	1b 82       	std	Y+3, r1	; 0x03
    3ce2:	1a 82       	std	Y+2, r1	; 0x02
    3ce4:	a0 91 ba 03 	lds	r26, 0x03BA
    3ce8:	b0 91 bb 03 	lds	r27, 0x03BB
    3cec:	10 97       	sbiw	r26, 0x00	; 0
    3cee:	09 f1       	breq	.+66     	; 0x3d32 <free+0x60>
    3cf0:	40 e0       	ldi	r20, 0x00	; 0
    3cf2:	50 e0       	ldi	r21, 0x00	; 0
    3cf4:	ac 17       	cp	r26, r28
    3cf6:	bd 07       	cpc	r27, r29
    3cf8:	08 f1       	brcs	.+66     	; 0x3d3c <free+0x6a>
    3cfa:	bb 83       	std	Y+3, r27	; 0x03
    3cfc:	aa 83       	std	Y+2, r26	; 0x02
    3cfe:	fe 01       	movw	r30, r28
    3d00:	21 91       	ld	r18, Z+
    3d02:	31 91       	ld	r19, Z+
    3d04:	e2 0f       	add	r30, r18
    3d06:	f3 1f       	adc	r31, r19
    3d08:	ae 17       	cp	r26, r30
    3d0a:	bf 07       	cpc	r27, r31
    3d0c:	79 f4       	brne	.+30     	; 0x3d2c <free+0x5a>
    3d0e:	8d 91       	ld	r24, X+
    3d10:	9c 91       	ld	r25, X
    3d12:	11 97       	sbiw	r26, 0x01	; 1
    3d14:	28 0f       	add	r18, r24
    3d16:	39 1f       	adc	r19, r25
    3d18:	2e 5f       	subi	r18, 0xFE	; 254
    3d1a:	3f 4f       	sbci	r19, 0xFF	; 255
    3d1c:	39 83       	std	Y+1, r19	; 0x01
    3d1e:	28 83       	st	Y, r18
    3d20:	12 96       	adiw	r26, 0x02	; 2
    3d22:	8d 91       	ld	r24, X+
    3d24:	9c 91       	ld	r25, X
    3d26:	13 97       	sbiw	r26, 0x03	; 3
    3d28:	9b 83       	std	Y+3, r25	; 0x03
    3d2a:	8a 83       	std	Y+2, r24	; 0x02
    3d2c:	41 15       	cp	r20, r1
    3d2e:	51 05       	cpc	r21, r1
    3d30:	71 f4       	brne	.+28     	; 0x3d4e <free+0x7c>
    3d32:	d0 93 bb 03 	sts	0x03BB, r29
    3d36:	c0 93 ba 03 	sts	0x03BA, r28
    3d3a:	20 c0       	rjmp	.+64     	; 0x3d7c <free+0xaa>
    3d3c:	12 96       	adiw	r26, 0x02	; 2
    3d3e:	8d 91       	ld	r24, X+
    3d40:	9c 91       	ld	r25, X
    3d42:	13 97       	sbiw	r26, 0x03	; 3
    3d44:	ad 01       	movw	r20, r26
    3d46:	00 97       	sbiw	r24, 0x00	; 0
    3d48:	11 f0       	breq	.+4      	; 0x3d4e <free+0x7c>
    3d4a:	dc 01       	movw	r26, r24
    3d4c:	d3 cf       	rjmp	.-90     	; 0x3cf4 <free+0x22>
    3d4e:	fa 01       	movw	r30, r20
    3d50:	d3 83       	std	Z+3, r29	; 0x03
    3d52:	c2 83       	std	Z+2, r28	; 0x02
    3d54:	21 91       	ld	r18, Z+
    3d56:	31 91       	ld	r19, Z+
    3d58:	e2 0f       	add	r30, r18
    3d5a:	f3 1f       	adc	r31, r19
    3d5c:	ce 17       	cp	r28, r30
    3d5e:	df 07       	cpc	r29, r31
    3d60:	69 f4       	brne	.+26     	; 0x3d7c <free+0xaa>
    3d62:	88 81       	ld	r24, Y
    3d64:	99 81       	ldd	r25, Y+1	; 0x01
    3d66:	28 0f       	add	r18, r24
    3d68:	39 1f       	adc	r19, r25
    3d6a:	2e 5f       	subi	r18, 0xFE	; 254
    3d6c:	3f 4f       	sbci	r19, 0xFF	; 255
    3d6e:	fa 01       	movw	r30, r20
    3d70:	31 83       	std	Z+1, r19	; 0x01
    3d72:	20 83       	st	Z, r18
    3d74:	8a 81       	ldd	r24, Y+2	; 0x02
    3d76:	9b 81       	ldd	r25, Y+3	; 0x03
    3d78:	93 83       	std	Z+3, r25	; 0x03
    3d7a:	82 83       	std	Z+2, r24	; 0x02
    3d7c:	df 91       	pop	r29
    3d7e:	cf 91       	pop	r28
    3d80:	08 95       	ret

00003d82 <memcpy_P>:
    3d82:	fb 01       	movw	r30, r22
    3d84:	dc 01       	movw	r26, r24
    3d86:	02 c0       	rjmp	.+4      	; 0x3d8c <memcpy_P+0xa>
    3d88:	05 90       	lpm	r0, Z+
    3d8a:	0d 92       	st	X+, r0
    3d8c:	41 50       	subi	r20, 0x01	; 1
    3d8e:	50 40       	sbci	r21, 0x00	; 0
    3d90:	d8 f7       	brcc	.-10     	; 0x3d88 <memcpy_P+0x6>
    3d92:	08 95       	ret

00003d94 <strcpy_P>:
    3d94:	fb 01       	movw	r30, r22
    3d96:	dc 01       	movw	r26, r24
    3d98:	05 90       	lpm	r0, Z+
    3d9a:	0d 92       	st	X+, r0
    3d9c:	00 20       	and	r0, r0
    3d9e:	e1 f7       	brne	.-8      	; 0x3d98 <strcpy_P+0x4>
    3da0:	08 95       	ret

00003da2 <strlen_P>:
    3da2:	fc 01       	movw	r30, r24
    3da4:	05 90       	lpm	r0, Z+
    3da6:	00 20       	and	r0, r0
    3da8:	e9 f7       	brne	.-6      	; 0x3da4 <strlen_P+0x2>
    3daa:	80 95       	com	r24
    3dac:	90 95       	com	r25
    3dae:	8e 0f       	add	r24, r30
    3db0:	9f 1f       	adc	r25, r31
    3db2:	08 95       	ret

00003db4 <__eerd_block>:
    3db4:	a0 e0       	ldi	r26, 0x00	; 0
    3db6:	b0 e0       	ldi	r27, 0x00	; 0
    3db8:	e0 ee       	ldi	r30, 0xE0	; 224
    3dba:	fe e1       	ldi	r31, 0x1E	; 30
    3dbc:	0c 94 b2 23 	jmp	0x4764	; 0x4764 <__prologue_saves__+0x14>
    3dc0:	7c 01       	movw	r14, r24
    3dc2:	eb 01       	movw	r28, r22
    3dc4:	8a 01       	movw	r16, r20
    3dc6:	69 01       	movw	r12, r18
    3dc8:	09 c0       	rjmp	.+18     	; 0x3ddc <__eerd_block+0x28>
    3dca:	ce 01       	movw	r24, r28
    3dcc:	21 96       	adiw	r28, 0x01	; 1
    3dce:	f6 01       	movw	r30, r12
    3dd0:	09 95       	icall
    3dd2:	f7 01       	movw	r30, r14
    3dd4:	81 93       	st	Z+, r24
    3dd6:	7f 01       	movw	r14, r30
    3dd8:	01 50       	subi	r16, 0x01	; 1
    3dda:	10 40       	sbci	r17, 0x00	; 0
    3ddc:	01 15       	cp	r16, r1
    3dde:	11 05       	cpc	r17, r1
    3de0:	a1 f7       	brne	.-24     	; 0x3dca <__eerd_block+0x16>
    3de2:	cd b7       	in	r28, 0x3d	; 61
    3de4:	de b7       	in	r29, 0x3e	; 62
    3de6:	e8 e0       	ldi	r30, 0x08	; 8
    3de8:	0c 94 ce 23 	jmp	0x479c	; 0x479c <__epilogue_restores__+0x14>

00003dec <__eerd_word>:
    3dec:	df 92       	push	r13
    3dee:	ef 92       	push	r14
    3df0:	ff 92       	push	r15
    3df2:	0f 93       	push	r16
    3df4:	1f 93       	push	r17
    3df6:	7b 01       	movw	r14, r22
    3df8:	8c 01       	movw	r16, r24
    3dfa:	fb 01       	movw	r30, r22
    3dfc:	09 95       	icall
    3dfe:	d8 2e       	mov	r13, r24
    3e00:	c8 01       	movw	r24, r16
    3e02:	01 96       	adiw	r24, 0x01	; 1
    3e04:	f7 01       	movw	r30, r14
    3e06:	09 95       	icall
    3e08:	98 2f       	mov	r25, r24
    3e0a:	8d 2d       	mov	r24, r13
    3e0c:	1f 91       	pop	r17
    3e0e:	0f 91       	pop	r16
    3e10:	ff 90       	pop	r15
    3e12:	ef 90       	pop	r14
    3e14:	df 90       	pop	r13
    3e16:	08 95       	ret

00003e18 <__eewr_block>:
    3e18:	a0 e0       	ldi	r26, 0x00	; 0
    3e1a:	b0 e0       	ldi	r27, 0x00	; 0
    3e1c:	e2 e1       	ldi	r30, 0x12	; 18
    3e1e:	ff e1       	ldi	r31, 0x1F	; 31
    3e20:	0c 94 b2 23 	jmp	0x4764	; 0x4764 <__prologue_saves__+0x14>
    3e24:	ec 01       	movw	r28, r24
    3e26:	7b 01       	movw	r14, r22
    3e28:	8a 01       	movw	r16, r20
    3e2a:	69 01       	movw	r12, r18
    3e2c:	09 c0       	rjmp	.+18     	; 0x3e40 <__eewr_block+0x28>
    3e2e:	ce 01       	movw	r24, r28
    3e30:	21 96       	adiw	r28, 0x01	; 1
    3e32:	f7 01       	movw	r30, r14
    3e34:	61 91       	ld	r22, Z+
    3e36:	7f 01       	movw	r14, r30
    3e38:	f6 01       	movw	r30, r12
    3e3a:	09 95       	icall
    3e3c:	01 50       	subi	r16, 0x01	; 1
    3e3e:	10 40       	sbci	r17, 0x00	; 0
    3e40:	01 15       	cp	r16, r1
    3e42:	11 05       	cpc	r17, r1
    3e44:	a1 f7       	brne	.-24     	; 0x3e2e <__eewr_block+0x16>
    3e46:	cd b7       	in	r28, 0x3d	; 61
    3e48:	de b7       	in	r29, 0x3e	; 62
    3e4a:	e8 e0       	ldi	r30, 0x08	; 8
    3e4c:	0c 94 ce 23 	jmp	0x479c	; 0x479c <__epilogue_restores__+0x14>

00003e50 <__eewr_word>:
    3e50:	df 92       	push	r13
    3e52:	ef 92       	push	r14
    3e54:	ff 92       	push	r15
    3e56:	0f 93       	push	r16
    3e58:	1f 93       	push	r17
    3e5a:	d7 2e       	mov	r13, r23
    3e5c:	7a 01       	movw	r14, r20
    3e5e:	8c 01       	movw	r16, r24
    3e60:	fa 01       	movw	r30, r20
    3e62:	09 95       	icall
    3e64:	c8 01       	movw	r24, r16
    3e66:	01 96       	adiw	r24, 0x01	; 1
    3e68:	6d 2d       	mov	r22, r13
    3e6a:	f7 01       	movw	r30, r14
    3e6c:	09 95       	icall
    3e6e:	1f 91       	pop	r17
    3e70:	0f 91       	pop	r16
    3e72:	ff 90       	pop	r15
    3e74:	ef 90       	pop	r14
    3e76:	df 90       	pop	r13
    3e78:	08 95       	ret

00003e7a <sprintf>:
    3e7a:	ae e0       	ldi	r26, 0x0E	; 14
    3e7c:	b0 e0       	ldi	r27, 0x00	; 0
    3e7e:	e3 e4       	ldi	r30, 0x43	; 67
    3e80:	ff e1       	ldi	r31, 0x1F	; 31
    3e82:	0c 94 b6 23 	jmp	0x476c	; 0x476c <__prologue_saves__+0x1c>
    3e86:	0d 89       	ldd	r16, Y+21	; 0x15
    3e88:	1e 89       	ldd	r17, Y+22	; 0x16
    3e8a:	86 e0       	ldi	r24, 0x06	; 6
    3e8c:	8c 83       	std	Y+4, r24	; 0x04
    3e8e:	1a 83       	std	Y+2, r17	; 0x02
    3e90:	09 83       	std	Y+1, r16	; 0x01
    3e92:	8f ef       	ldi	r24, 0xFF	; 255
    3e94:	9f e7       	ldi	r25, 0x7F	; 127
    3e96:	9e 83       	std	Y+6, r25	; 0x06
    3e98:	8d 83       	std	Y+5, r24	; 0x05
    3e9a:	9e 01       	movw	r18, r28
    3e9c:	27 5e       	subi	r18, 0xE7	; 231
    3e9e:	3f 4f       	sbci	r19, 0xFF	; 255
    3ea0:	ce 01       	movw	r24, r28
    3ea2:	01 96       	adiw	r24, 0x01	; 1
    3ea4:	6f 89       	ldd	r22, Y+23	; 0x17
    3ea6:	78 8d       	ldd	r23, Y+24	; 0x18
    3ea8:	a9 01       	movw	r20, r18
    3eaa:	0e 94 61 1f 	call	0x3ec2	; 0x3ec2 <vfprintf>
    3eae:	2f 81       	ldd	r18, Y+7	; 0x07
    3eb0:	38 85       	ldd	r19, Y+8	; 0x08
    3eb2:	02 0f       	add	r16, r18
    3eb4:	13 1f       	adc	r17, r19
    3eb6:	f8 01       	movw	r30, r16
    3eb8:	10 82       	st	Z, r1
    3eba:	2e 96       	adiw	r28, 0x0e	; 14
    3ebc:	e4 e0       	ldi	r30, 0x04	; 4
    3ebe:	0c 94 d2 23 	jmp	0x47a4	; 0x47a4 <__epilogue_restores__+0x1c>

00003ec2 <vfprintf>:
    3ec2:	ab e0       	ldi	r26, 0x0B	; 11
    3ec4:	b0 e0       	ldi	r27, 0x00	; 0
    3ec6:	e7 e6       	ldi	r30, 0x67	; 103
    3ec8:	ff e1       	ldi	r31, 0x1F	; 31
    3eca:	0c 94 a8 23 	jmp	0x4750	; 0x4750 <__prologue_saves__>
    3ece:	3c 01       	movw	r6, r24
    3ed0:	2b 01       	movw	r4, r22
    3ed2:	5a 01       	movw	r10, r20
    3ed4:	fc 01       	movw	r30, r24
    3ed6:	17 82       	std	Z+7, r1	; 0x07
    3ed8:	16 82       	std	Z+6, r1	; 0x06
    3eda:	83 81       	ldd	r24, Z+3	; 0x03
    3edc:	81 fd       	sbrc	r24, 1
    3ede:	03 c0       	rjmp	.+6      	; 0x3ee6 <vfprintf+0x24>
    3ee0:	6f ef       	ldi	r22, 0xFF	; 255
    3ee2:	7f ef       	ldi	r23, 0xFF	; 255
    3ee4:	c6 c1       	rjmp	.+908    	; 0x4272 <vfprintf+0x3b0>
    3ee6:	9a e0       	ldi	r25, 0x0A	; 10
    3ee8:	89 2e       	mov	r8, r25
    3eea:	1e 01       	movw	r2, r28
    3eec:	08 94       	sec
    3eee:	21 1c       	adc	r2, r1
    3ef0:	31 1c       	adc	r3, r1
    3ef2:	f3 01       	movw	r30, r6
    3ef4:	23 81       	ldd	r18, Z+3	; 0x03
    3ef6:	f2 01       	movw	r30, r4
    3ef8:	23 fd       	sbrc	r18, 3
    3efa:	85 91       	lpm	r24, Z+
    3efc:	23 ff       	sbrs	r18, 3
    3efe:	81 91       	ld	r24, Z+
    3f00:	2f 01       	movw	r4, r30
    3f02:	88 23       	and	r24, r24
    3f04:	09 f4       	brne	.+2      	; 0x3f08 <vfprintf+0x46>
    3f06:	b2 c1       	rjmp	.+868    	; 0x426c <vfprintf+0x3aa>
    3f08:	85 32       	cpi	r24, 0x25	; 37
    3f0a:	39 f4       	brne	.+14     	; 0x3f1a <vfprintf+0x58>
    3f0c:	23 fd       	sbrc	r18, 3
    3f0e:	85 91       	lpm	r24, Z+
    3f10:	23 ff       	sbrs	r18, 3
    3f12:	81 91       	ld	r24, Z+
    3f14:	2f 01       	movw	r4, r30
    3f16:	85 32       	cpi	r24, 0x25	; 37
    3f18:	29 f4       	brne	.+10     	; 0x3f24 <vfprintf+0x62>
    3f1a:	90 e0       	ldi	r25, 0x00	; 0
    3f1c:	b3 01       	movw	r22, r6
    3f1e:	0e 94 54 21 	call	0x42a8	; 0x42a8 <fputc>
    3f22:	e7 cf       	rjmp	.-50     	; 0x3ef2 <vfprintf+0x30>
    3f24:	98 2f       	mov	r25, r24
    3f26:	ff 24       	eor	r15, r15
    3f28:	ee 24       	eor	r14, r14
    3f2a:	99 24       	eor	r9, r9
    3f2c:	ff e1       	ldi	r31, 0x1F	; 31
    3f2e:	ff 15       	cp	r31, r15
    3f30:	d0 f0       	brcs	.+52     	; 0x3f66 <vfprintf+0xa4>
    3f32:	9b 32       	cpi	r25, 0x2B	; 43
    3f34:	69 f0       	breq	.+26     	; 0x3f50 <vfprintf+0x8e>
    3f36:	9c 32       	cpi	r25, 0x2C	; 44
    3f38:	28 f4       	brcc	.+10     	; 0x3f44 <vfprintf+0x82>
    3f3a:	90 32       	cpi	r25, 0x20	; 32
    3f3c:	59 f0       	breq	.+22     	; 0x3f54 <vfprintf+0x92>
    3f3e:	93 32       	cpi	r25, 0x23	; 35
    3f40:	91 f4       	brne	.+36     	; 0x3f66 <vfprintf+0xa4>
    3f42:	0e c0       	rjmp	.+28     	; 0x3f60 <vfprintf+0x9e>
    3f44:	9d 32       	cpi	r25, 0x2D	; 45
    3f46:	49 f0       	breq	.+18     	; 0x3f5a <vfprintf+0x98>
    3f48:	90 33       	cpi	r25, 0x30	; 48
    3f4a:	69 f4       	brne	.+26     	; 0x3f66 <vfprintf+0xa4>
    3f4c:	41 e0       	ldi	r20, 0x01	; 1
    3f4e:	24 c0       	rjmp	.+72     	; 0x3f98 <vfprintf+0xd6>
    3f50:	52 e0       	ldi	r21, 0x02	; 2
    3f52:	f5 2a       	or	r15, r21
    3f54:	84 e0       	ldi	r24, 0x04	; 4
    3f56:	f8 2a       	or	r15, r24
    3f58:	28 c0       	rjmp	.+80     	; 0x3faa <vfprintf+0xe8>
    3f5a:	98 e0       	ldi	r25, 0x08	; 8
    3f5c:	f9 2a       	or	r15, r25
    3f5e:	25 c0       	rjmp	.+74     	; 0x3faa <vfprintf+0xe8>
    3f60:	e0 e1       	ldi	r30, 0x10	; 16
    3f62:	fe 2a       	or	r15, r30
    3f64:	22 c0       	rjmp	.+68     	; 0x3faa <vfprintf+0xe8>
    3f66:	f7 fc       	sbrc	r15, 7
    3f68:	29 c0       	rjmp	.+82     	; 0x3fbc <vfprintf+0xfa>
    3f6a:	89 2f       	mov	r24, r25
    3f6c:	80 53       	subi	r24, 0x30	; 48
    3f6e:	8a 30       	cpi	r24, 0x0A	; 10
    3f70:	70 f4       	brcc	.+28     	; 0x3f8e <vfprintf+0xcc>
    3f72:	f6 fe       	sbrs	r15, 6
    3f74:	05 c0       	rjmp	.+10     	; 0x3f80 <vfprintf+0xbe>
    3f76:	98 9c       	mul	r9, r8
    3f78:	90 2c       	mov	r9, r0
    3f7a:	11 24       	eor	r1, r1
    3f7c:	98 0e       	add	r9, r24
    3f7e:	15 c0       	rjmp	.+42     	; 0x3faa <vfprintf+0xe8>
    3f80:	e8 9c       	mul	r14, r8
    3f82:	e0 2c       	mov	r14, r0
    3f84:	11 24       	eor	r1, r1
    3f86:	e8 0e       	add	r14, r24
    3f88:	f0 e2       	ldi	r31, 0x20	; 32
    3f8a:	ff 2a       	or	r15, r31
    3f8c:	0e c0       	rjmp	.+28     	; 0x3faa <vfprintf+0xe8>
    3f8e:	9e 32       	cpi	r25, 0x2E	; 46
    3f90:	29 f4       	brne	.+10     	; 0x3f9c <vfprintf+0xda>
    3f92:	f6 fc       	sbrc	r15, 6
    3f94:	6b c1       	rjmp	.+726    	; 0x426c <vfprintf+0x3aa>
    3f96:	40 e4       	ldi	r20, 0x40	; 64
    3f98:	f4 2a       	or	r15, r20
    3f9a:	07 c0       	rjmp	.+14     	; 0x3faa <vfprintf+0xe8>
    3f9c:	9c 36       	cpi	r25, 0x6C	; 108
    3f9e:	19 f4       	brne	.+6      	; 0x3fa6 <vfprintf+0xe4>
    3fa0:	50 e8       	ldi	r21, 0x80	; 128
    3fa2:	f5 2a       	or	r15, r21
    3fa4:	02 c0       	rjmp	.+4      	; 0x3faa <vfprintf+0xe8>
    3fa6:	98 36       	cpi	r25, 0x68	; 104
    3fa8:	49 f4       	brne	.+18     	; 0x3fbc <vfprintf+0xfa>
    3faa:	f2 01       	movw	r30, r4
    3fac:	23 fd       	sbrc	r18, 3
    3fae:	95 91       	lpm	r25, Z+
    3fb0:	23 ff       	sbrs	r18, 3
    3fb2:	91 91       	ld	r25, Z+
    3fb4:	2f 01       	movw	r4, r30
    3fb6:	99 23       	and	r25, r25
    3fb8:	09 f0       	breq	.+2      	; 0x3fbc <vfprintf+0xfa>
    3fba:	b8 cf       	rjmp	.-144    	; 0x3f2c <vfprintf+0x6a>
    3fbc:	89 2f       	mov	r24, r25
    3fbe:	85 54       	subi	r24, 0x45	; 69
    3fc0:	83 30       	cpi	r24, 0x03	; 3
    3fc2:	18 f0       	brcs	.+6      	; 0x3fca <vfprintf+0x108>
    3fc4:	80 52       	subi	r24, 0x20	; 32
    3fc6:	83 30       	cpi	r24, 0x03	; 3
    3fc8:	38 f4       	brcc	.+14     	; 0x3fd8 <vfprintf+0x116>
    3fca:	44 e0       	ldi	r20, 0x04	; 4
    3fcc:	50 e0       	ldi	r21, 0x00	; 0
    3fce:	a4 0e       	add	r10, r20
    3fd0:	b5 1e       	adc	r11, r21
    3fd2:	5f e3       	ldi	r21, 0x3F	; 63
    3fd4:	59 83       	std	Y+1, r21	; 0x01
    3fd6:	0f c0       	rjmp	.+30     	; 0x3ff6 <vfprintf+0x134>
    3fd8:	93 36       	cpi	r25, 0x63	; 99
    3fda:	31 f0       	breq	.+12     	; 0x3fe8 <vfprintf+0x126>
    3fdc:	93 37       	cpi	r25, 0x73	; 115
    3fde:	79 f0       	breq	.+30     	; 0x3ffe <vfprintf+0x13c>
    3fe0:	93 35       	cpi	r25, 0x53	; 83
    3fe2:	09 f0       	breq	.+2      	; 0x3fe6 <vfprintf+0x124>
    3fe4:	56 c0       	rjmp	.+172    	; 0x4092 <vfprintf+0x1d0>
    3fe6:	20 c0       	rjmp	.+64     	; 0x4028 <vfprintf+0x166>
    3fe8:	f5 01       	movw	r30, r10
    3fea:	80 81       	ld	r24, Z
    3fec:	89 83       	std	Y+1, r24	; 0x01
    3fee:	42 e0       	ldi	r20, 0x02	; 2
    3ff0:	50 e0       	ldi	r21, 0x00	; 0
    3ff2:	a4 0e       	add	r10, r20
    3ff4:	b5 1e       	adc	r11, r21
    3ff6:	61 01       	movw	r12, r2
    3ff8:	01 e0       	ldi	r16, 0x01	; 1
    3ffa:	10 e0       	ldi	r17, 0x00	; 0
    3ffc:	12 c0       	rjmp	.+36     	; 0x4022 <vfprintf+0x160>
    3ffe:	f5 01       	movw	r30, r10
    4000:	c0 80       	ld	r12, Z
    4002:	d1 80       	ldd	r13, Z+1	; 0x01
    4004:	f6 fc       	sbrc	r15, 6
    4006:	03 c0       	rjmp	.+6      	; 0x400e <vfprintf+0x14c>
    4008:	6f ef       	ldi	r22, 0xFF	; 255
    400a:	7f ef       	ldi	r23, 0xFF	; 255
    400c:	02 c0       	rjmp	.+4      	; 0x4012 <vfprintf+0x150>
    400e:	69 2d       	mov	r22, r9
    4010:	70 e0       	ldi	r23, 0x00	; 0
    4012:	42 e0       	ldi	r20, 0x02	; 2
    4014:	50 e0       	ldi	r21, 0x00	; 0
    4016:	a4 0e       	add	r10, r20
    4018:	b5 1e       	adc	r11, r21
    401a:	c6 01       	movw	r24, r12
    401c:	0e 94 49 21 	call	0x4292	; 0x4292 <strnlen>
    4020:	8c 01       	movw	r16, r24
    4022:	5f e7       	ldi	r21, 0x7F	; 127
    4024:	f5 22       	and	r15, r21
    4026:	14 c0       	rjmp	.+40     	; 0x4050 <vfprintf+0x18e>
    4028:	f5 01       	movw	r30, r10
    402a:	c0 80       	ld	r12, Z
    402c:	d1 80       	ldd	r13, Z+1	; 0x01
    402e:	f6 fc       	sbrc	r15, 6
    4030:	03 c0       	rjmp	.+6      	; 0x4038 <vfprintf+0x176>
    4032:	6f ef       	ldi	r22, 0xFF	; 255
    4034:	7f ef       	ldi	r23, 0xFF	; 255
    4036:	02 c0       	rjmp	.+4      	; 0x403c <vfprintf+0x17a>
    4038:	69 2d       	mov	r22, r9
    403a:	70 e0       	ldi	r23, 0x00	; 0
    403c:	42 e0       	ldi	r20, 0x02	; 2
    403e:	50 e0       	ldi	r21, 0x00	; 0
    4040:	a4 0e       	add	r10, r20
    4042:	b5 1e       	adc	r11, r21
    4044:	c6 01       	movw	r24, r12
    4046:	0e 94 3e 21 	call	0x427c	; 0x427c <strnlen_P>
    404a:	8c 01       	movw	r16, r24
    404c:	50 e8       	ldi	r21, 0x80	; 128
    404e:	f5 2a       	or	r15, r21
    4050:	f3 fe       	sbrs	r15, 3
    4052:	07 c0       	rjmp	.+14     	; 0x4062 <vfprintf+0x1a0>
    4054:	1a c0       	rjmp	.+52     	; 0x408a <vfprintf+0x1c8>
    4056:	80 e2       	ldi	r24, 0x20	; 32
    4058:	90 e0       	ldi	r25, 0x00	; 0
    405a:	b3 01       	movw	r22, r6
    405c:	0e 94 54 21 	call	0x42a8	; 0x42a8 <fputc>
    4060:	ea 94       	dec	r14
    4062:	8e 2d       	mov	r24, r14
    4064:	90 e0       	ldi	r25, 0x00	; 0
    4066:	08 17       	cp	r16, r24
    4068:	19 07       	cpc	r17, r25
    406a:	a8 f3       	brcs	.-22     	; 0x4056 <vfprintf+0x194>
    406c:	0e c0       	rjmp	.+28     	; 0x408a <vfprintf+0x1c8>
    406e:	f6 01       	movw	r30, r12
    4070:	f7 fc       	sbrc	r15, 7
    4072:	85 91       	lpm	r24, Z+
    4074:	f7 fe       	sbrs	r15, 7
    4076:	81 91       	ld	r24, Z+
    4078:	6f 01       	movw	r12, r30
    407a:	90 e0       	ldi	r25, 0x00	; 0
    407c:	b3 01       	movw	r22, r6
    407e:	0e 94 54 21 	call	0x42a8	; 0x42a8 <fputc>
    4082:	e1 10       	cpse	r14, r1
    4084:	ea 94       	dec	r14
    4086:	01 50       	subi	r16, 0x01	; 1
    4088:	10 40       	sbci	r17, 0x00	; 0
    408a:	01 15       	cp	r16, r1
    408c:	11 05       	cpc	r17, r1
    408e:	79 f7       	brne	.-34     	; 0x406e <vfprintf+0x1ac>
    4090:	ea c0       	rjmp	.+468    	; 0x4266 <vfprintf+0x3a4>
    4092:	94 36       	cpi	r25, 0x64	; 100
    4094:	11 f0       	breq	.+4      	; 0x409a <vfprintf+0x1d8>
    4096:	99 36       	cpi	r25, 0x69	; 105
    4098:	69 f5       	brne	.+90     	; 0x40f4 <vfprintf+0x232>
    409a:	f7 fe       	sbrs	r15, 7
    409c:	08 c0       	rjmp	.+16     	; 0x40ae <vfprintf+0x1ec>
    409e:	f5 01       	movw	r30, r10
    40a0:	20 81       	ld	r18, Z
    40a2:	31 81       	ldd	r19, Z+1	; 0x01
    40a4:	42 81       	ldd	r20, Z+2	; 0x02
    40a6:	53 81       	ldd	r21, Z+3	; 0x03
    40a8:	84 e0       	ldi	r24, 0x04	; 4
    40aa:	90 e0       	ldi	r25, 0x00	; 0
    40ac:	0a c0       	rjmp	.+20     	; 0x40c2 <vfprintf+0x200>
    40ae:	f5 01       	movw	r30, r10
    40b0:	80 81       	ld	r24, Z
    40b2:	91 81       	ldd	r25, Z+1	; 0x01
    40b4:	9c 01       	movw	r18, r24
    40b6:	44 27       	eor	r20, r20
    40b8:	37 fd       	sbrc	r19, 7
    40ba:	40 95       	com	r20
    40bc:	54 2f       	mov	r21, r20
    40be:	82 e0       	ldi	r24, 0x02	; 2
    40c0:	90 e0       	ldi	r25, 0x00	; 0
    40c2:	a8 0e       	add	r10, r24
    40c4:	b9 1e       	adc	r11, r25
    40c6:	9f e6       	ldi	r25, 0x6F	; 111
    40c8:	f9 22       	and	r15, r25
    40ca:	57 ff       	sbrs	r21, 7
    40cc:	09 c0       	rjmp	.+18     	; 0x40e0 <vfprintf+0x21e>
    40ce:	50 95       	com	r21
    40d0:	40 95       	com	r20
    40d2:	30 95       	com	r19
    40d4:	21 95       	neg	r18
    40d6:	3f 4f       	sbci	r19, 0xFF	; 255
    40d8:	4f 4f       	sbci	r20, 0xFF	; 255
    40da:	5f 4f       	sbci	r21, 0xFF	; 255
    40dc:	e0 e8       	ldi	r30, 0x80	; 128
    40de:	fe 2a       	or	r15, r30
    40e0:	ca 01       	movw	r24, r20
    40e2:	b9 01       	movw	r22, r18
    40e4:	a1 01       	movw	r20, r2
    40e6:	2a e0       	ldi	r18, 0x0A	; 10
    40e8:	30 e0       	ldi	r19, 0x00	; 0
    40ea:	0e 94 80 21 	call	0x4300	; 0x4300 <__ultoa_invert>
    40ee:	d8 2e       	mov	r13, r24
    40f0:	d2 18       	sub	r13, r2
    40f2:	40 c0       	rjmp	.+128    	; 0x4174 <vfprintf+0x2b2>
    40f4:	95 37       	cpi	r25, 0x75	; 117
    40f6:	29 f4       	brne	.+10     	; 0x4102 <vfprintf+0x240>
    40f8:	1f 2d       	mov	r17, r15
    40fa:	1f 7e       	andi	r17, 0xEF	; 239
    40fc:	2a e0       	ldi	r18, 0x0A	; 10
    40fe:	30 e0       	ldi	r19, 0x00	; 0
    4100:	1d c0       	rjmp	.+58     	; 0x413c <vfprintf+0x27a>
    4102:	1f 2d       	mov	r17, r15
    4104:	19 7f       	andi	r17, 0xF9	; 249
    4106:	9f 36       	cpi	r25, 0x6F	; 111
    4108:	61 f0       	breq	.+24     	; 0x4122 <vfprintf+0x260>
    410a:	90 37       	cpi	r25, 0x70	; 112
    410c:	20 f4       	brcc	.+8      	; 0x4116 <vfprintf+0x254>
    410e:	98 35       	cpi	r25, 0x58	; 88
    4110:	09 f0       	breq	.+2      	; 0x4114 <vfprintf+0x252>
    4112:	ac c0       	rjmp	.+344    	; 0x426c <vfprintf+0x3aa>
    4114:	0f c0       	rjmp	.+30     	; 0x4134 <vfprintf+0x272>
    4116:	90 37       	cpi	r25, 0x70	; 112
    4118:	39 f0       	breq	.+14     	; 0x4128 <vfprintf+0x266>
    411a:	98 37       	cpi	r25, 0x78	; 120
    411c:	09 f0       	breq	.+2      	; 0x4120 <vfprintf+0x25e>
    411e:	a6 c0       	rjmp	.+332    	; 0x426c <vfprintf+0x3aa>
    4120:	04 c0       	rjmp	.+8      	; 0x412a <vfprintf+0x268>
    4122:	28 e0       	ldi	r18, 0x08	; 8
    4124:	30 e0       	ldi	r19, 0x00	; 0
    4126:	0a c0       	rjmp	.+20     	; 0x413c <vfprintf+0x27a>
    4128:	10 61       	ori	r17, 0x10	; 16
    412a:	14 fd       	sbrc	r17, 4
    412c:	14 60       	ori	r17, 0x04	; 4
    412e:	20 e1       	ldi	r18, 0x10	; 16
    4130:	30 e0       	ldi	r19, 0x00	; 0
    4132:	04 c0       	rjmp	.+8      	; 0x413c <vfprintf+0x27a>
    4134:	14 fd       	sbrc	r17, 4
    4136:	16 60       	ori	r17, 0x06	; 6
    4138:	20 e1       	ldi	r18, 0x10	; 16
    413a:	32 e0       	ldi	r19, 0x02	; 2
    413c:	17 ff       	sbrs	r17, 7
    413e:	08 c0       	rjmp	.+16     	; 0x4150 <vfprintf+0x28e>
    4140:	f5 01       	movw	r30, r10
    4142:	60 81       	ld	r22, Z
    4144:	71 81       	ldd	r23, Z+1	; 0x01
    4146:	82 81       	ldd	r24, Z+2	; 0x02
    4148:	93 81       	ldd	r25, Z+3	; 0x03
    414a:	44 e0       	ldi	r20, 0x04	; 4
    414c:	50 e0       	ldi	r21, 0x00	; 0
    414e:	08 c0       	rjmp	.+16     	; 0x4160 <vfprintf+0x29e>
    4150:	f5 01       	movw	r30, r10
    4152:	80 81       	ld	r24, Z
    4154:	91 81       	ldd	r25, Z+1	; 0x01
    4156:	bc 01       	movw	r22, r24
    4158:	80 e0       	ldi	r24, 0x00	; 0
    415a:	90 e0       	ldi	r25, 0x00	; 0
    415c:	42 e0       	ldi	r20, 0x02	; 2
    415e:	50 e0       	ldi	r21, 0x00	; 0
    4160:	a4 0e       	add	r10, r20
    4162:	b5 1e       	adc	r11, r21
    4164:	a1 01       	movw	r20, r2
    4166:	0e 94 80 21 	call	0x4300	; 0x4300 <__ultoa_invert>
    416a:	d8 2e       	mov	r13, r24
    416c:	d2 18       	sub	r13, r2
    416e:	8f e7       	ldi	r24, 0x7F	; 127
    4170:	f8 2e       	mov	r15, r24
    4172:	f1 22       	and	r15, r17
    4174:	f6 fe       	sbrs	r15, 6
    4176:	0b c0       	rjmp	.+22     	; 0x418e <vfprintf+0x2cc>
    4178:	5e ef       	ldi	r21, 0xFE	; 254
    417a:	f5 22       	and	r15, r21
    417c:	d9 14       	cp	r13, r9
    417e:	38 f4       	brcc	.+14     	; 0x418e <vfprintf+0x2cc>
    4180:	f4 fe       	sbrs	r15, 4
    4182:	07 c0       	rjmp	.+14     	; 0x4192 <vfprintf+0x2d0>
    4184:	f2 fc       	sbrc	r15, 2
    4186:	05 c0       	rjmp	.+10     	; 0x4192 <vfprintf+0x2d0>
    4188:	8f ee       	ldi	r24, 0xEF	; 239
    418a:	f8 22       	and	r15, r24
    418c:	02 c0       	rjmp	.+4      	; 0x4192 <vfprintf+0x2d0>
    418e:	1d 2d       	mov	r17, r13
    4190:	01 c0       	rjmp	.+2      	; 0x4194 <vfprintf+0x2d2>
    4192:	19 2d       	mov	r17, r9
    4194:	f4 fe       	sbrs	r15, 4
    4196:	0d c0       	rjmp	.+26     	; 0x41b2 <vfprintf+0x2f0>
    4198:	fe 01       	movw	r30, r28
    419a:	ed 0d       	add	r30, r13
    419c:	f1 1d       	adc	r31, r1
    419e:	80 81       	ld	r24, Z
    41a0:	80 33       	cpi	r24, 0x30	; 48
    41a2:	19 f4       	brne	.+6      	; 0x41aa <vfprintf+0x2e8>
    41a4:	99 ee       	ldi	r25, 0xE9	; 233
    41a6:	f9 22       	and	r15, r25
    41a8:	08 c0       	rjmp	.+16     	; 0x41ba <vfprintf+0x2f8>
    41aa:	1f 5f       	subi	r17, 0xFF	; 255
    41ac:	f2 fe       	sbrs	r15, 2
    41ae:	05 c0       	rjmp	.+10     	; 0x41ba <vfprintf+0x2f8>
    41b0:	03 c0       	rjmp	.+6      	; 0x41b8 <vfprintf+0x2f6>
    41b2:	8f 2d       	mov	r24, r15
    41b4:	86 78       	andi	r24, 0x86	; 134
    41b6:	09 f0       	breq	.+2      	; 0x41ba <vfprintf+0x2f8>
    41b8:	1f 5f       	subi	r17, 0xFF	; 255
    41ba:	0f 2d       	mov	r16, r15
    41bc:	f3 fc       	sbrc	r15, 3
    41be:	14 c0       	rjmp	.+40     	; 0x41e8 <vfprintf+0x326>
    41c0:	f0 fe       	sbrs	r15, 0
    41c2:	0f c0       	rjmp	.+30     	; 0x41e2 <vfprintf+0x320>
    41c4:	1e 15       	cp	r17, r14
    41c6:	10 f0       	brcs	.+4      	; 0x41cc <vfprintf+0x30a>
    41c8:	9d 2c       	mov	r9, r13
    41ca:	0b c0       	rjmp	.+22     	; 0x41e2 <vfprintf+0x320>
    41cc:	9d 2c       	mov	r9, r13
    41ce:	9e 0c       	add	r9, r14
    41d0:	91 1a       	sub	r9, r17
    41d2:	1e 2d       	mov	r17, r14
    41d4:	06 c0       	rjmp	.+12     	; 0x41e2 <vfprintf+0x320>
    41d6:	80 e2       	ldi	r24, 0x20	; 32
    41d8:	90 e0       	ldi	r25, 0x00	; 0
    41da:	b3 01       	movw	r22, r6
    41dc:	0e 94 54 21 	call	0x42a8	; 0x42a8 <fputc>
    41e0:	1f 5f       	subi	r17, 0xFF	; 255
    41e2:	1e 15       	cp	r17, r14
    41e4:	c0 f3       	brcs	.-16     	; 0x41d6 <vfprintf+0x314>
    41e6:	04 c0       	rjmp	.+8      	; 0x41f0 <vfprintf+0x32e>
    41e8:	1e 15       	cp	r17, r14
    41ea:	10 f4       	brcc	.+4      	; 0x41f0 <vfprintf+0x32e>
    41ec:	e1 1a       	sub	r14, r17
    41ee:	01 c0       	rjmp	.+2      	; 0x41f2 <vfprintf+0x330>
    41f0:	ee 24       	eor	r14, r14
    41f2:	04 ff       	sbrs	r16, 4
    41f4:	0f c0       	rjmp	.+30     	; 0x4214 <vfprintf+0x352>
    41f6:	80 e3       	ldi	r24, 0x30	; 48
    41f8:	90 e0       	ldi	r25, 0x00	; 0
    41fa:	b3 01       	movw	r22, r6
    41fc:	0e 94 54 21 	call	0x42a8	; 0x42a8 <fputc>
    4200:	02 ff       	sbrs	r16, 2
    4202:	1d c0       	rjmp	.+58     	; 0x423e <vfprintf+0x37c>
    4204:	01 fd       	sbrc	r16, 1
    4206:	03 c0       	rjmp	.+6      	; 0x420e <vfprintf+0x34c>
    4208:	88 e7       	ldi	r24, 0x78	; 120
    420a:	90 e0       	ldi	r25, 0x00	; 0
    420c:	0e c0       	rjmp	.+28     	; 0x422a <vfprintf+0x368>
    420e:	88 e5       	ldi	r24, 0x58	; 88
    4210:	90 e0       	ldi	r25, 0x00	; 0
    4212:	0b c0       	rjmp	.+22     	; 0x422a <vfprintf+0x368>
    4214:	80 2f       	mov	r24, r16
    4216:	86 78       	andi	r24, 0x86	; 134
    4218:	91 f0       	breq	.+36     	; 0x423e <vfprintf+0x37c>
    421a:	01 ff       	sbrs	r16, 1
    421c:	02 c0       	rjmp	.+4      	; 0x4222 <vfprintf+0x360>
    421e:	8b e2       	ldi	r24, 0x2B	; 43
    4220:	01 c0       	rjmp	.+2      	; 0x4224 <vfprintf+0x362>
    4222:	80 e2       	ldi	r24, 0x20	; 32
    4224:	f7 fc       	sbrc	r15, 7
    4226:	8d e2       	ldi	r24, 0x2D	; 45
    4228:	90 e0       	ldi	r25, 0x00	; 0
    422a:	b3 01       	movw	r22, r6
    422c:	0e 94 54 21 	call	0x42a8	; 0x42a8 <fputc>
    4230:	06 c0       	rjmp	.+12     	; 0x423e <vfprintf+0x37c>
    4232:	80 e3       	ldi	r24, 0x30	; 48
    4234:	90 e0       	ldi	r25, 0x00	; 0
    4236:	b3 01       	movw	r22, r6
    4238:	0e 94 54 21 	call	0x42a8	; 0x42a8 <fputc>
    423c:	9a 94       	dec	r9
    423e:	d9 14       	cp	r13, r9
    4240:	c0 f3       	brcs	.-16     	; 0x4232 <vfprintf+0x370>
    4242:	da 94       	dec	r13
    4244:	f1 01       	movw	r30, r2
    4246:	ed 0d       	add	r30, r13
    4248:	f1 1d       	adc	r31, r1
    424a:	80 81       	ld	r24, Z
    424c:	90 e0       	ldi	r25, 0x00	; 0
    424e:	b3 01       	movw	r22, r6
    4250:	0e 94 54 21 	call	0x42a8	; 0x42a8 <fputc>
    4254:	dd 20       	and	r13, r13
    4256:	a9 f7       	brne	.-22     	; 0x4242 <vfprintf+0x380>
    4258:	06 c0       	rjmp	.+12     	; 0x4266 <vfprintf+0x3a4>
    425a:	80 e2       	ldi	r24, 0x20	; 32
    425c:	90 e0       	ldi	r25, 0x00	; 0
    425e:	b3 01       	movw	r22, r6
    4260:	0e 94 54 21 	call	0x42a8	; 0x42a8 <fputc>
    4264:	ea 94       	dec	r14
    4266:	ee 20       	and	r14, r14
    4268:	c1 f7       	brne	.-16     	; 0x425a <vfprintf+0x398>
    426a:	43 ce       	rjmp	.-890    	; 0x3ef2 <vfprintf+0x30>
    426c:	f3 01       	movw	r30, r6
    426e:	66 81       	ldd	r22, Z+6	; 0x06
    4270:	77 81       	ldd	r23, Z+7	; 0x07
    4272:	cb 01       	movw	r24, r22
    4274:	2b 96       	adiw	r28, 0x0b	; 11
    4276:	e2 e1       	ldi	r30, 0x12	; 18
    4278:	0c 94 c4 23 	jmp	0x4788	; 0x4788 <__epilogue_restores__>

0000427c <strnlen_P>:
    427c:	fc 01       	movw	r30, r24
    427e:	05 90       	lpm	r0, Z+
    4280:	61 50       	subi	r22, 0x01	; 1
    4282:	70 40       	sbci	r23, 0x00	; 0
    4284:	01 10       	cpse	r0, r1
    4286:	d8 f7       	brcc	.-10     	; 0x427e <strnlen_P+0x2>
    4288:	80 95       	com	r24
    428a:	90 95       	com	r25
    428c:	8e 0f       	add	r24, r30
    428e:	9f 1f       	adc	r25, r31
    4290:	08 95       	ret

00004292 <strnlen>:
    4292:	fc 01       	movw	r30, r24
    4294:	61 50       	subi	r22, 0x01	; 1
    4296:	70 40       	sbci	r23, 0x00	; 0
    4298:	01 90       	ld	r0, Z+
    429a:	01 10       	cpse	r0, r1
    429c:	d8 f7       	brcc	.-10     	; 0x4294 <strnlen+0x2>
    429e:	80 95       	com	r24
    42a0:	90 95       	com	r25
    42a2:	8e 0f       	add	r24, r30
    42a4:	9f 1f       	adc	r25, r31
    42a6:	08 95       	ret

000042a8 <fputc>:
    42a8:	0f 93       	push	r16
    42aa:	1f 93       	push	r17
    42ac:	cf 93       	push	r28
    42ae:	df 93       	push	r29
    42b0:	8c 01       	movw	r16, r24
    42b2:	eb 01       	movw	r28, r22
    42b4:	8b 81       	ldd	r24, Y+3	; 0x03
    42b6:	81 ff       	sbrs	r24, 1
    42b8:	1b c0       	rjmp	.+54     	; 0x42f0 <fputc+0x48>
    42ba:	82 ff       	sbrs	r24, 2
    42bc:	0d c0       	rjmp	.+26     	; 0x42d8 <fputc+0x30>
    42be:	2e 81       	ldd	r18, Y+6	; 0x06
    42c0:	3f 81       	ldd	r19, Y+7	; 0x07
    42c2:	8c 81       	ldd	r24, Y+4	; 0x04
    42c4:	9d 81       	ldd	r25, Y+5	; 0x05
    42c6:	28 17       	cp	r18, r24
    42c8:	39 07       	cpc	r19, r25
    42ca:	64 f4       	brge	.+24     	; 0x42e4 <fputc+0x3c>
    42cc:	e8 81       	ld	r30, Y
    42ce:	f9 81       	ldd	r31, Y+1	; 0x01
    42d0:	01 93       	st	Z+, r16
    42d2:	f9 83       	std	Y+1, r31	; 0x01
    42d4:	e8 83       	st	Y, r30
    42d6:	06 c0       	rjmp	.+12     	; 0x42e4 <fputc+0x3c>
    42d8:	e8 85       	ldd	r30, Y+8	; 0x08
    42da:	f9 85       	ldd	r31, Y+9	; 0x09
    42dc:	80 2f       	mov	r24, r16
    42de:	09 95       	icall
    42e0:	89 2b       	or	r24, r25
    42e2:	31 f4       	brne	.+12     	; 0x42f0 <fputc+0x48>
    42e4:	8e 81       	ldd	r24, Y+6	; 0x06
    42e6:	9f 81       	ldd	r25, Y+7	; 0x07
    42e8:	01 96       	adiw	r24, 0x01	; 1
    42ea:	9f 83       	std	Y+7, r25	; 0x07
    42ec:	8e 83       	std	Y+6, r24	; 0x06
    42ee:	02 c0       	rjmp	.+4      	; 0x42f4 <fputc+0x4c>
    42f0:	0f ef       	ldi	r16, 0xFF	; 255
    42f2:	1f ef       	ldi	r17, 0xFF	; 255
    42f4:	c8 01       	movw	r24, r16
    42f6:	df 91       	pop	r29
    42f8:	cf 91       	pop	r28
    42fa:	1f 91       	pop	r17
    42fc:	0f 91       	pop	r16
    42fe:	08 95       	ret

00004300 <__ultoa_invert>:
    4300:	fa 01       	movw	r30, r20
    4302:	aa 27       	eor	r26, r26
    4304:	28 30       	cpi	r18, 0x08	; 8
    4306:	51 f1       	breq	.+84     	; 0x435c <__ultoa_invert+0x5c>
    4308:	20 31       	cpi	r18, 0x10	; 16
    430a:	81 f1       	breq	.+96     	; 0x436c <__ultoa_invert+0x6c>
    430c:	e8 94       	clt
    430e:	6f 93       	push	r22
    4310:	6e 7f       	andi	r22, 0xFE	; 254
    4312:	6e 5f       	subi	r22, 0xFE	; 254
    4314:	7f 4f       	sbci	r23, 0xFF	; 255
    4316:	8f 4f       	sbci	r24, 0xFF	; 255
    4318:	9f 4f       	sbci	r25, 0xFF	; 255
    431a:	af 4f       	sbci	r26, 0xFF	; 255
    431c:	b1 e0       	ldi	r27, 0x01	; 1
    431e:	3e d0       	rcall	.+124    	; 0x439c <__ultoa_invert+0x9c>
    4320:	b4 e0       	ldi	r27, 0x04	; 4
    4322:	3c d0       	rcall	.+120    	; 0x439c <__ultoa_invert+0x9c>
    4324:	67 0f       	add	r22, r23
    4326:	78 1f       	adc	r23, r24
    4328:	89 1f       	adc	r24, r25
    432a:	9a 1f       	adc	r25, r26
    432c:	a1 1d       	adc	r26, r1
    432e:	68 0f       	add	r22, r24
    4330:	79 1f       	adc	r23, r25
    4332:	8a 1f       	adc	r24, r26
    4334:	91 1d       	adc	r25, r1
    4336:	a1 1d       	adc	r26, r1
    4338:	6a 0f       	add	r22, r26
    433a:	71 1d       	adc	r23, r1
    433c:	81 1d       	adc	r24, r1
    433e:	91 1d       	adc	r25, r1
    4340:	a1 1d       	adc	r26, r1
    4342:	20 d0       	rcall	.+64     	; 0x4384 <__ultoa_invert+0x84>
    4344:	09 f4       	brne	.+2      	; 0x4348 <__ultoa_invert+0x48>
    4346:	68 94       	set
    4348:	3f 91       	pop	r19
    434a:	2a e0       	ldi	r18, 0x0A	; 10
    434c:	26 9f       	mul	r18, r22
    434e:	11 24       	eor	r1, r1
    4350:	30 19       	sub	r19, r0
    4352:	30 5d       	subi	r19, 0xD0	; 208
    4354:	31 93       	st	Z+, r19
    4356:	de f6       	brtc	.-74     	; 0x430e <__ultoa_invert+0xe>
    4358:	cf 01       	movw	r24, r30
    435a:	08 95       	ret
    435c:	46 2f       	mov	r20, r22
    435e:	47 70       	andi	r20, 0x07	; 7
    4360:	40 5d       	subi	r20, 0xD0	; 208
    4362:	41 93       	st	Z+, r20
    4364:	b3 e0       	ldi	r27, 0x03	; 3
    4366:	0f d0       	rcall	.+30     	; 0x4386 <__ultoa_invert+0x86>
    4368:	c9 f7       	brne	.-14     	; 0x435c <__ultoa_invert+0x5c>
    436a:	f6 cf       	rjmp	.-20     	; 0x4358 <__ultoa_invert+0x58>
    436c:	46 2f       	mov	r20, r22
    436e:	4f 70       	andi	r20, 0x0F	; 15
    4370:	40 5d       	subi	r20, 0xD0	; 208
    4372:	4a 33       	cpi	r20, 0x3A	; 58
    4374:	18 f0       	brcs	.+6      	; 0x437c <__ultoa_invert+0x7c>
    4376:	49 5d       	subi	r20, 0xD9	; 217
    4378:	31 fd       	sbrc	r19, 1
    437a:	40 52       	subi	r20, 0x20	; 32
    437c:	41 93       	st	Z+, r20
    437e:	02 d0       	rcall	.+4      	; 0x4384 <__ultoa_invert+0x84>
    4380:	a9 f7       	brne	.-22     	; 0x436c <__ultoa_invert+0x6c>
    4382:	ea cf       	rjmp	.-44     	; 0x4358 <__ultoa_invert+0x58>
    4384:	b4 e0       	ldi	r27, 0x04	; 4
    4386:	a6 95       	lsr	r26
    4388:	97 95       	ror	r25
    438a:	87 95       	ror	r24
    438c:	77 95       	ror	r23
    438e:	67 95       	ror	r22
    4390:	ba 95       	dec	r27
    4392:	c9 f7       	brne	.-14     	; 0x4386 <__ultoa_invert+0x86>
    4394:	00 97       	sbiw	r24, 0x00	; 0
    4396:	61 05       	cpc	r22, r1
    4398:	71 05       	cpc	r23, r1
    439a:	08 95       	ret
    439c:	9b 01       	movw	r18, r22
    439e:	ac 01       	movw	r20, r24
    43a0:	0a 2e       	mov	r0, r26
    43a2:	06 94       	lsr	r0
    43a4:	57 95       	ror	r21
    43a6:	47 95       	ror	r20
    43a8:	37 95       	ror	r19
    43aa:	27 95       	ror	r18
    43ac:	ba 95       	dec	r27
    43ae:	c9 f7       	brne	.-14     	; 0x43a2 <__ultoa_invert+0xa2>
    43b0:	62 0f       	add	r22, r18
    43b2:	73 1f       	adc	r23, r19
    43b4:	84 1f       	adc	r24, r20
    43b6:	95 1f       	adc	r25, r21
    43b8:	a0 1d       	adc	r26, r0
    43ba:	08 95       	ret

000043bc <__cmpsf2>:
    43bc:	d9 d0       	rcall	.+434    	; 0x4570 <__fp_cmp>
    43be:	08 f4       	brcc	.+2      	; 0x43c2 <__cmpsf2+0x6>
    43c0:	81 e0       	ldi	r24, 0x01	; 1
    43c2:	08 95       	ret

000043c4 <__divsf3>:
    43c4:	0c d0       	rcall	.+24     	; 0x43de <__divsf3x>
    43c6:	0f c1       	rjmp	.+542    	; 0x45e6 <__fp_round>
    43c8:	07 d1       	rcall	.+526    	; 0x45d8 <__fp_pscB>
    43ca:	40 f0       	brcs	.+16     	; 0x43dc <__divsf3+0x18>
    43cc:	fe d0       	rcall	.+508    	; 0x45ca <__fp_pscA>
    43ce:	30 f0       	brcs	.+12     	; 0x43dc <__divsf3+0x18>
    43d0:	21 f4       	brne	.+8      	; 0x43da <__divsf3+0x16>
    43d2:	5f 3f       	cpi	r21, 0xFF	; 255
    43d4:	19 f0       	breq	.+6      	; 0x43dc <__divsf3+0x18>
    43d6:	f0 c0       	rjmp	.+480    	; 0x45b8 <__fp_inf>
    43d8:	51 11       	cpse	r21, r1
    43da:	39 c1       	rjmp	.+626    	; 0x464e <__fp_szero>
    43dc:	f3 c0       	rjmp	.+486    	; 0x45c4 <__fp_nan>

000043de <__divsf3x>:
    43de:	14 d1       	rcall	.+552    	; 0x4608 <__fp_split3>
    43e0:	98 f3       	brcs	.-26     	; 0x43c8 <__divsf3+0x4>

000043e2 <__divsf3_pse>:
    43e2:	99 23       	and	r25, r25
    43e4:	c9 f3       	breq	.-14     	; 0x43d8 <__divsf3+0x14>
    43e6:	55 23       	and	r21, r21
    43e8:	b1 f3       	breq	.-20     	; 0x43d6 <__divsf3+0x12>
    43ea:	95 1b       	sub	r25, r21
    43ec:	55 0b       	sbc	r21, r21
    43ee:	bb 27       	eor	r27, r27
    43f0:	aa 27       	eor	r26, r26
    43f2:	62 17       	cp	r22, r18
    43f4:	73 07       	cpc	r23, r19
    43f6:	84 07       	cpc	r24, r20
    43f8:	38 f0       	brcs	.+14     	; 0x4408 <__divsf3_pse+0x26>
    43fa:	9f 5f       	subi	r25, 0xFF	; 255
    43fc:	5f 4f       	sbci	r21, 0xFF	; 255
    43fe:	22 0f       	add	r18, r18
    4400:	33 1f       	adc	r19, r19
    4402:	44 1f       	adc	r20, r20
    4404:	aa 1f       	adc	r26, r26
    4406:	a9 f3       	breq	.-22     	; 0x43f2 <__divsf3_pse+0x10>
    4408:	33 d0       	rcall	.+102    	; 0x4470 <__divsf3_pse+0x8e>
    440a:	0e 2e       	mov	r0, r30
    440c:	3a f0       	brmi	.+14     	; 0x441c <__divsf3_pse+0x3a>
    440e:	e0 e8       	ldi	r30, 0x80	; 128
    4410:	30 d0       	rcall	.+96     	; 0x4472 <__divsf3_pse+0x90>
    4412:	91 50       	subi	r25, 0x01	; 1
    4414:	50 40       	sbci	r21, 0x00	; 0
    4416:	e6 95       	lsr	r30
    4418:	00 1c       	adc	r0, r0
    441a:	ca f7       	brpl	.-14     	; 0x440e <__divsf3_pse+0x2c>
    441c:	29 d0       	rcall	.+82     	; 0x4470 <__divsf3_pse+0x8e>
    441e:	fe 2f       	mov	r31, r30
    4420:	27 d0       	rcall	.+78     	; 0x4470 <__divsf3_pse+0x8e>
    4422:	66 0f       	add	r22, r22
    4424:	77 1f       	adc	r23, r23
    4426:	88 1f       	adc	r24, r24
    4428:	bb 1f       	adc	r27, r27
    442a:	26 17       	cp	r18, r22
    442c:	37 07       	cpc	r19, r23
    442e:	48 07       	cpc	r20, r24
    4430:	ab 07       	cpc	r26, r27
    4432:	b0 e8       	ldi	r27, 0x80	; 128
    4434:	09 f0       	breq	.+2      	; 0x4438 <__divsf3_pse+0x56>
    4436:	bb 0b       	sbc	r27, r27
    4438:	80 2d       	mov	r24, r0
    443a:	bf 01       	movw	r22, r30
    443c:	ff 27       	eor	r31, r31
    443e:	93 58       	subi	r25, 0x83	; 131
    4440:	5f 4f       	sbci	r21, 0xFF	; 255
    4442:	2a f0       	brmi	.+10     	; 0x444e <__divsf3_pse+0x6c>
    4444:	9e 3f       	cpi	r25, 0xFE	; 254
    4446:	51 05       	cpc	r21, r1
    4448:	68 f0       	brcs	.+26     	; 0x4464 <__divsf3_pse+0x82>
    444a:	b6 c0       	rjmp	.+364    	; 0x45b8 <__fp_inf>
    444c:	00 c1       	rjmp	.+512    	; 0x464e <__fp_szero>
    444e:	5f 3f       	cpi	r21, 0xFF	; 255
    4450:	ec f3       	brlt	.-6      	; 0x444c <__divsf3_pse+0x6a>
    4452:	98 3e       	cpi	r25, 0xE8	; 232
    4454:	dc f3       	brlt	.-10     	; 0x444c <__divsf3_pse+0x6a>
    4456:	86 95       	lsr	r24
    4458:	77 95       	ror	r23
    445a:	67 95       	ror	r22
    445c:	b7 95       	ror	r27
    445e:	f7 95       	ror	r31
    4460:	9f 5f       	subi	r25, 0xFF	; 255
    4462:	c9 f7       	brne	.-14     	; 0x4456 <__divsf3_pse+0x74>
    4464:	88 0f       	add	r24, r24
    4466:	91 1d       	adc	r25, r1
    4468:	96 95       	lsr	r25
    446a:	87 95       	ror	r24
    446c:	97 f9       	bld	r25, 7
    446e:	08 95       	ret
    4470:	e1 e0       	ldi	r30, 0x01	; 1
    4472:	66 0f       	add	r22, r22
    4474:	77 1f       	adc	r23, r23
    4476:	88 1f       	adc	r24, r24
    4478:	bb 1f       	adc	r27, r27
    447a:	62 17       	cp	r22, r18
    447c:	73 07       	cpc	r23, r19
    447e:	84 07       	cpc	r24, r20
    4480:	ba 07       	cpc	r27, r26
    4482:	20 f0       	brcs	.+8      	; 0x448c <__divsf3_pse+0xaa>
    4484:	62 1b       	sub	r22, r18
    4486:	73 0b       	sbc	r23, r19
    4488:	84 0b       	sbc	r24, r20
    448a:	ba 0b       	sbc	r27, r26
    448c:	ee 1f       	adc	r30, r30
    448e:	88 f7       	brcc	.-30     	; 0x4472 <__divsf3_pse+0x90>
    4490:	e0 95       	com	r30
    4492:	08 95       	ret

00004494 <__fixsfsi>:
    4494:	04 d0       	rcall	.+8      	; 0x449e <__fixunssfsi>
    4496:	68 94       	set
    4498:	b1 11       	cpse	r27, r1
    449a:	d9 c0       	rjmp	.+434    	; 0x464e <__fp_szero>
    449c:	08 95       	ret

0000449e <__fixunssfsi>:
    449e:	bc d0       	rcall	.+376    	; 0x4618 <__fp_splitA>
    44a0:	88 f0       	brcs	.+34     	; 0x44c4 <__fixunssfsi+0x26>
    44a2:	9f 57       	subi	r25, 0x7F	; 127
    44a4:	90 f0       	brcs	.+36     	; 0x44ca <__fixunssfsi+0x2c>
    44a6:	b9 2f       	mov	r27, r25
    44a8:	99 27       	eor	r25, r25
    44aa:	b7 51       	subi	r27, 0x17	; 23
    44ac:	a0 f0       	brcs	.+40     	; 0x44d6 <__fixunssfsi+0x38>
    44ae:	d1 f0       	breq	.+52     	; 0x44e4 <__fixunssfsi+0x46>
    44b0:	66 0f       	add	r22, r22
    44b2:	77 1f       	adc	r23, r23
    44b4:	88 1f       	adc	r24, r24
    44b6:	99 1f       	adc	r25, r25
    44b8:	1a f0       	brmi	.+6      	; 0x44c0 <__fixunssfsi+0x22>
    44ba:	ba 95       	dec	r27
    44bc:	c9 f7       	brne	.-14     	; 0x44b0 <__fixunssfsi+0x12>
    44be:	12 c0       	rjmp	.+36     	; 0x44e4 <__fixunssfsi+0x46>
    44c0:	b1 30       	cpi	r27, 0x01	; 1
    44c2:	81 f0       	breq	.+32     	; 0x44e4 <__fixunssfsi+0x46>
    44c4:	c3 d0       	rcall	.+390    	; 0x464c <__fp_zero>
    44c6:	b1 e0       	ldi	r27, 0x01	; 1
    44c8:	08 95       	ret
    44ca:	c0 c0       	rjmp	.+384    	; 0x464c <__fp_zero>
    44cc:	67 2f       	mov	r22, r23
    44ce:	78 2f       	mov	r23, r24
    44d0:	88 27       	eor	r24, r24
    44d2:	b8 5f       	subi	r27, 0xF8	; 248
    44d4:	39 f0       	breq	.+14     	; 0x44e4 <__fixunssfsi+0x46>
    44d6:	b9 3f       	cpi	r27, 0xF9	; 249
    44d8:	cc f3       	brlt	.-14     	; 0x44cc <__fixunssfsi+0x2e>
    44da:	86 95       	lsr	r24
    44dc:	77 95       	ror	r23
    44de:	67 95       	ror	r22
    44e0:	b3 95       	inc	r27
    44e2:	d9 f7       	brne	.-10     	; 0x44da <__fixunssfsi+0x3c>
    44e4:	3e f4       	brtc	.+14     	; 0x44f4 <__fixunssfsi+0x56>
    44e6:	90 95       	com	r25
    44e8:	80 95       	com	r24
    44ea:	70 95       	com	r23
    44ec:	61 95       	neg	r22
    44ee:	7f 4f       	sbci	r23, 0xFF	; 255
    44f0:	8f 4f       	sbci	r24, 0xFF	; 255
    44f2:	9f 4f       	sbci	r25, 0xFF	; 255
    44f4:	08 95       	ret

000044f6 <__floatunsisf>:
    44f6:	e8 94       	clt
    44f8:	09 c0       	rjmp	.+18     	; 0x450c <__floatsisf+0x12>

000044fa <__floatsisf>:
    44fa:	97 fb       	bst	r25, 7
    44fc:	3e f4       	brtc	.+14     	; 0x450c <__floatsisf+0x12>
    44fe:	90 95       	com	r25
    4500:	80 95       	com	r24
    4502:	70 95       	com	r23
    4504:	61 95       	neg	r22
    4506:	7f 4f       	sbci	r23, 0xFF	; 255
    4508:	8f 4f       	sbci	r24, 0xFF	; 255
    450a:	9f 4f       	sbci	r25, 0xFF	; 255
    450c:	99 23       	and	r25, r25
    450e:	a9 f0       	breq	.+42     	; 0x453a <__floatsisf+0x40>
    4510:	f9 2f       	mov	r31, r25
    4512:	96 e9       	ldi	r25, 0x96	; 150
    4514:	bb 27       	eor	r27, r27
    4516:	93 95       	inc	r25
    4518:	f6 95       	lsr	r31
    451a:	87 95       	ror	r24
    451c:	77 95       	ror	r23
    451e:	67 95       	ror	r22
    4520:	b7 95       	ror	r27
    4522:	f1 11       	cpse	r31, r1
    4524:	f8 cf       	rjmp	.-16     	; 0x4516 <__floatsisf+0x1c>
    4526:	fa f4       	brpl	.+62     	; 0x4566 <__floatsisf+0x6c>
    4528:	bb 0f       	add	r27, r27
    452a:	11 f4       	brne	.+4      	; 0x4530 <__floatsisf+0x36>
    452c:	60 ff       	sbrs	r22, 0
    452e:	1b c0       	rjmp	.+54     	; 0x4566 <__floatsisf+0x6c>
    4530:	6f 5f       	subi	r22, 0xFF	; 255
    4532:	7f 4f       	sbci	r23, 0xFF	; 255
    4534:	8f 4f       	sbci	r24, 0xFF	; 255
    4536:	9f 4f       	sbci	r25, 0xFF	; 255
    4538:	16 c0       	rjmp	.+44     	; 0x4566 <__floatsisf+0x6c>
    453a:	88 23       	and	r24, r24
    453c:	11 f0       	breq	.+4      	; 0x4542 <__floatsisf+0x48>
    453e:	96 e9       	ldi	r25, 0x96	; 150
    4540:	11 c0       	rjmp	.+34     	; 0x4564 <__floatsisf+0x6a>
    4542:	77 23       	and	r23, r23
    4544:	21 f0       	breq	.+8      	; 0x454e <__floatsisf+0x54>
    4546:	9e e8       	ldi	r25, 0x8E	; 142
    4548:	87 2f       	mov	r24, r23
    454a:	76 2f       	mov	r23, r22
    454c:	05 c0       	rjmp	.+10     	; 0x4558 <__floatsisf+0x5e>
    454e:	66 23       	and	r22, r22
    4550:	71 f0       	breq	.+28     	; 0x456e <__floatsisf+0x74>
    4552:	96 e8       	ldi	r25, 0x86	; 134
    4554:	86 2f       	mov	r24, r22
    4556:	70 e0       	ldi	r23, 0x00	; 0
    4558:	60 e0       	ldi	r22, 0x00	; 0
    455a:	2a f0       	brmi	.+10     	; 0x4566 <__floatsisf+0x6c>
    455c:	9a 95       	dec	r25
    455e:	66 0f       	add	r22, r22
    4560:	77 1f       	adc	r23, r23
    4562:	88 1f       	adc	r24, r24
    4564:	da f7       	brpl	.-10     	; 0x455c <__floatsisf+0x62>
    4566:	88 0f       	add	r24, r24
    4568:	96 95       	lsr	r25
    456a:	87 95       	ror	r24
    456c:	97 f9       	bld	r25, 7
    456e:	08 95       	ret

00004570 <__fp_cmp>:
    4570:	99 0f       	add	r25, r25
    4572:	00 08       	sbc	r0, r0
    4574:	55 0f       	add	r21, r21
    4576:	aa 0b       	sbc	r26, r26
    4578:	e0 e8       	ldi	r30, 0x80	; 128
    457a:	fe ef       	ldi	r31, 0xFE	; 254
    457c:	16 16       	cp	r1, r22
    457e:	17 06       	cpc	r1, r23
    4580:	e8 07       	cpc	r30, r24
    4582:	f9 07       	cpc	r31, r25
    4584:	c0 f0       	brcs	.+48     	; 0x45b6 <__fp_cmp+0x46>
    4586:	12 16       	cp	r1, r18
    4588:	13 06       	cpc	r1, r19
    458a:	e4 07       	cpc	r30, r20
    458c:	f5 07       	cpc	r31, r21
    458e:	98 f0       	brcs	.+38     	; 0x45b6 <__fp_cmp+0x46>
    4590:	62 1b       	sub	r22, r18
    4592:	73 0b       	sbc	r23, r19
    4594:	84 0b       	sbc	r24, r20
    4596:	95 0b       	sbc	r25, r21
    4598:	39 f4       	brne	.+14     	; 0x45a8 <__fp_cmp+0x38>
    459a:	0a 26       	eor	r0, r26
    459c:	61 f0       	breq	.+24     	; 0x45b6 <__fp_cmp+0x46>
    459e:	23 2b       	or	r18, r19
    45a0:	24 2b       	or	r18, r20
    45a2:	25 2b       	or	r18, r21
    45a4:	21 f4       	brne	.+8      	; 0x45ae <__fp_cmp+0x3e>
    45a6:	08 95       	ret
    45a8:	0a 26       	eor	r0, r26
    45aa:	09 f4       	brne	.+2      	; 0x45ae <__fp_cmp+0x3e>
    45ac:	a1 40       	sbci	r26, 0x01	; 1
    45ae:	a6 95       	lsr	r26
    45b0:	8f ef       	ldi	r24, 0xFF	; 255
    45b2:	81 1d       	adc	r24, r1
    45b4:	81 1d       	adc	r24, r1
    45b6:	08 95       	ret

000045b8 <__fp_inf>:
    45b8:	97 f9       	bld	r25, 7
    45ba:	9f 67       	ori	r25, 0x7F	; 127
    45bc:	80 e8       	ldi	r24, 0x80	; 128
    45be:	70 e0       	ldi	r23, 0x00	; 0
    45c0:	60 e0       	ldi	r22, 0x00	; 0
    45c2:	08 95       	ret

000045c4 <__fp_nan>:
    45c4:	9f ef       	ldi	r25, 0xFF	; 255
    45c6:	80 ec       	ldi	r24, 0xC0	; 192
    45c8:	08 95       	ret

000045ca <__fp_pscA>:
    45ca:	00 24       	eor	r0, r0
    45cc:	0a 94       	dec	r0
    45ce:	16 16       	cp	r1, r22
    45d0:	17 06       	cpc	r1, r23
    45d2:	18 06       	cpc	r1, r24
    45d4:	09 06       	cpc	r0, r25
    45d6:	08 95       	ret

000045d8 <__fp_pscB>:
    45d8:	00 24       	eor	r0, r0
    45da:	0a 94       	dec	r0
    45dc:	12 16       	cp	r1, r18
    45de:	13 06       	cpc	r1, r19
    45e0:	14 06       	cpc	r1, r20
    45e2:	05 06       	cpc	r0, r21
    45e4:	08 95       	ret

000045e6 <__fp_round>:
    45e6:	09 2e       	mov	r0, r25
    45e8:	03 94       	inc	r0
    45ea:	00 0c       	add	r0, r0
    45ec:	11 f4       	brne	.+4      	; 0x45f2 <__fp_round+0xc>
    45ee:	88 23       	and	r24, r24
    45f0:	52 f0       	brmi	.+20     	; 0x4606 <__fp_round+0x20>
    45f2:	bb 0f       	add	r27, r27
    45f4:	40 f4       	brcc	.+16     	; 0x4606 <__fp_round+0x20>
    45f6:	bf 2b       	or	r27, r31
    45f8:	11 f4       	brne	.+4      	; 0x45fe <__fp_round+0x18>
    45fa:	60 ff       	sbrs	r22, 0
    45fc:	04 c0       	rjmp	.+8      	; 0x4606 <__fp_round+0x20>
    45fe:	6f 5f       	subi	r22, 0xFF	; 255
    4600:	7f 4f       	sbci	r23, 0xFF	; 255
    4602:	8f 4f       	sbci	r24, 0xFF	; 255
    4604:	9f 4f       	sbci	r25, 0xFF	; 255
    4606:	08 95       	ret

00004608 <__fp_split3>:
    4608:	57 fd       	sbrc	r21, 7
    460a:	90 58       	subi	r25, 0x80	; 128
    460c:	44 0f       	add	r20, r20
    460e:	55 1f       	adc	r21, r21
    4610:	59 f0       	breq	.+22     	; 0x4628 <__fp_splitA+0x10>
    4612:	5f 3f       	cpi	r21, 0xFF	; 255
    4614:	71 f0       	breq	.+28     	; 0x4632 <__fp_splitA+0x1a>
    4616:	47 95       	ror	r20

00004618 <__fp_splitA>:
    4618:	88 0f       	add	r24, r24
    461a:	97 fb       	bst	r25, 7
    461c:	99 1f       	adc	r25, r25
    461e:	61 f0       	breq	.+24     	; 0x4638 <__fp_splitA+0x20>
    4620:	9f 3f       	cpi	r25, 0xFF	; 255
    4622:	79 f0       	breq	.+30     	; 0x4642 <__fp_splitA+0x2a>
    4624:	87 95       	ror	r24
    4626:	08 95       	ret
    4628:	12 16       	cp	r1, r18
    462a:	13 06       	cpc	r1, r19
    462c:	14 06       	cpc	r1, r20
    462e:	55 1f       	adc	r21, r21
    4630:	f2 cf       	rjmp	.-28     	; 0x4616 <__fp_split3+0xe>
    4632:	46 95       	lsr	r20
    4634:	f1 df       	rcall	.-30     	; 0x4618 <__fp_splitA>
    4636:	08 c0       	rjmp	.+16     	; 0x4648 <__fp_splitA+0x30>
    4638:	16 16       	cp	r1, r22
    463a:	17 06       	cpc	r1, r23
    463c:	18 06       	cpc	r1, r24
    463e:	99 1f       	adc	r25, r25
    4640:	f1 cf       	rjmp	.-30     	; 0x4624 <__fp_splitA+0xc>
    4642:	86 95       	lsr	r24
    4644:	71 05       	cpc	r23, r1
    4646:	61 05       	cpc	r22, r1
    4648:	08 94       	sec
    464a:	08 95       	ret

0000464c <__fp_zero>:
    464c:	e8 94       	clt

0000464e <__fp_szero>:
    464e:	bb 27       	eor	r27, r27
    4650:	66 27       	eor	r22, r22
    4652:	77 27       	eor	r23, r23
    4654:	cb 01       	movw	r24, r22
    4656:	97 f9       	bld	r25, 7
    4658:	08 95       	ret

0000465a <__gesf2>:
    465a:	8a df       	rcall	.-236    	; 0x4570 <__fp_cmp>
    465c:	08 f4       	brcc	.+2      	; 0x4660 <__gesf2+0x6>
    465e:	8f ef       	ldi	r24, 0xFF	; 255
    4660:	08 95       	ret

00004662 <__mulsf3>:
    4662:	0b d0       	rcall	.+22     	; 0x467a <__mulsf3x>
    4664:	c0 cf       	rjmp	.-128    	; 0x45e6 <__fp_round>
    4666:	b1 df       	rcall	.-158    	; 0x45ca <__fp_pscA>
    4668:	28 f0       	brcs	.+10     	; 0x4674 <__mulsf3+0x12>
    466a:	b6 df       	rcall	.-148    	; 0x45d8 <__fp_pscB>
    466c:	18 f0       	brcs	.+6      	; 0x4674 <__mulsf3+0x12>
    466e:	95 23       	and	r25, r21
    4670:	09 f0       	breq	.+2      	; 0x4674 <__mulsf3+0x12>
    4672:	a2 cf       	rjmp	.-188    	; 0x45b8 <__fp_inf>
    4674:	a7 cf       	rjmp	.-178    	; 0x45c4 <__fp_nan>
    4676:	11 24       	eor	r1, r1
    4678:	ea cf       	rjmp	.-44     	; 0x464e <__fp_szero>

0000467a <__mulsf3x>:
    467a:	c6 df       	rcall	.-116    	; 0x4608 <__fp_split3>
    467c:	a0 f3       	brcs	.-24     	; 0x4666 <__mulsf3+0x4>

0000467e <__mulsf3_pse>:
    467e:	95 9f       	mul	r25, r21
    4680:	d1 f3       	breq	.-12     	; 0x4676 <__mulsf3+0x14>
    4682:	95 0f       	add	r25, r21
    4684:	50 e0       	ldi	r21, 0x00	; 0
    4686:	55 1f       	adc	r21, r21
    4688:	62 9f       	mul	r22, r18
    468a:	f0 01       	movw	r30, r0
    468c:	72 9f       	mul	r23, r18
    468e:	bb 27       	eor	r27, r27
    4690:	f0 0d       	add	r31, r0
    4692:	b1 1d       	adc	r27, r1
    4694:	63 9f       	mul	r22, r19
    4696:	aa 27       	eor	r26, r26
    4698:	f0 0d       	add	r31, r0
    469a:	b1 1d       	adc	r27, r1
    469c:	aa 1f       	adc	r26, r26
    469e:	64 9f       	mul	r22, r20
    46a0:	66 27       	eor	r22, r22
    46a2:	b0 0d       	add	r27, r0
    46a4:	a1 1d       	adc	r26, r1
    46a6:	66 1f       	adc	r22, r22
    46a8:	82 9f       	mul	r24, r18
    46aa:	22 27       	eor	r18, r18
    46ac:	b0 0d       	add	r27, r0
    46ae:	a1 1d       	adc	r26, r1
    46b0:	62 1f       	adc	r22, r18
    46b2:	73 9f       	mul	r23, r19
    46b4:	b0 0d       	add	r27, r0
    46b6:	a1 1d       	adc	r26, r1
    46b8:	62 1f       	adc	r22, r18
    46ba:	83 9f       	mul	r24, r19
    46bc:	a0 0d       	add	r26, r0
    46be:	61 1d       	adc	r22, r1
    46c0:	22 1f       	adc	r18, r18
    46c2:	74 9f       	mul	r23, r20
    46c4:	33 27       	eor	r19, r19
    46c6:	a0 0d       	add	r26, r0
    46c8:	61 1d       	adc	r22, r1
    46ca:	23 1f       	adc	r18, r19
    46cc:	84 9f       	mul	r24, r20
    46ce:	60 0d       	add	r22, r0
    46d0:	21 1d       	adc	r18, r1
    46d2:	82 2f       	mov	r24, r18
    46d4:	76 2f       	mov	r23, r22
    46d6:	6a 2f       	mov	r22, r26
    46d8:	11 24       	eor	r1, r1
    46da:	9f 57       	subi	r25, 0x7F	; 127
    46dc:	50 40       	sbci	r21, 0x00	; 0
    46de:	8a f0       	brmi	.+34     	; 0x4702 <__mulsf3_pse+0x84>
    46e0:	e1 f0       	breq	.+56     	; 0x471a <__mulsf3_pse+0x9c>
    46e2:	88 23       	and	r24, r24
    46e4:	4a f0       	brmi	.+18     	; 0x46f8 <__mulsf3_pse+0x7a>
    46e6:	ee 0f       	add	r30, r30
    46e8:	ff 1f       	adc	r31, r31
    46ea:	bb 1f       	adc	r27, r27
    46ec:	66 1f       	adc	r22, r22
    46ee:	77 1f       	adc	r23, r23
    46f0:	88 1f       	adc	r24, r24
    46f2:	91 50       	subi	r25, 0x01	; 1
    46f4:	50 40       	sbci	r21, 0x00	; 0
    46f6:	a9 f7       	brne	.-22     	; 0x46e2 <__mulsf3_pse+0x64>
    46f8:	9e 3f       	cpi	r25, 0xFE	; 254
    46fa:	51 05       	cpc	r21, r1
    46fc:	70 f0       	brcs	.+28     	; 0x471a <__mulsf3_pse+0x9c>
    46fe:	5c cf       	rjmp	.-328    	; 0x45b8 <__fp_inf>
    4700:	a6 cf       	rjmp	.-180    	; 0x464e <__fp_szero>
    4702:	5f 3f       	cpi	r21, 0xFF	; 255
    4704:	ec f3       	brlt	.-6      	; 0x4700 <__mulsf3_pse+0x82>
    4706:	98 3e       	cpi	r25, 0xE8	; 232
    4708:	dc f3       	brlt	.-10     	; 0x4700 <__mulsf3_pse+0x82>
    470a:	86 95       	lsr	r24
    470c:	77 95       	ror	r23
    470e:	67 95       	ror	r22
    4710:	b7 95       	ror	r27
    4712:	f7 95       	ror	r31
    4714:	e7 95       	ror	r30
    4716:	9f 5f       	subi	r25, 0xFF	; 255
    4718:	c1 f7       	brne	.-16     	; 0x470a <__mulsf3_pse+0x8c>
    471a:	fe 2b       	or	r31, r30
    471c:	88 0f       	add	r24, r24
    471e:	91 1d       	adc	r25, r1
    4720:	96 95       	lsr	r25
    4722:	87 95       	ror	r24
    4724:	97 f9       	bld	r25, 7
    4726:	08 95       	ret

00004728 <__udivmodhi4>:
    4728:	aa 1b       	sub	r26, r26
    472a:	bb 1b       	sub	r27, r27
    472c:	51 e1       	ldi	r21, 0x11	; 17
    472e:	07 c0       	rjmp	.+14     	; 0x473e <__udivmodhi4_ep>

00004730 <__udivmodhi4_loop>:
    4730:	aa 1f       	adc	r26, r26
    4732:	bb 1f       	adc	r27, r27
    4734:	a6 17       	cp	r26, r22
    4736:	b7 07       	cpc	r27, r23
    4738:	10 f0       	brcs	.+4      	; 0x473e <__udivmodhi4_ep>
    473a:	a6 1b       	sub	r26, r22
    473c:	b7 0b       	sbc	r27, r23

0000473e <__udivmodhi4_ep>:
    473e:	88 1f       	adc	r24, r24
    4740:	99 1f       	adc	r25, r25
    4742:	5a 95       	dec	r21
    4744:	a9 f7       	brne	.-22     	; 0x4730 <__udivmodhi4_loop>
    4746:	80 95       	com	r24
    4748:	90 95       	com	r25
    474a:	bc 01       	movw	r22, r24
    474c:	cd 01       	movw	r24, r26
    474e:	08 95       	ret

00004750 <__prologue_saves__>:
    4750:	2f 92       	push	r2
    4752:	3f 92       	push	r3
    4754:	4f 92       	push	r4
    4756:	5f 92       	push	r5
    4758:	6f 92       	push	r6
    475a:	7f 92       	push	r7
    475c:	8f 92       	push	r8
    475e:	9f 92       	push	r9
    4760:	af 92       	push	r10
    4762:	bf 92       	push	r11
    4764:	cf 92       	push	r12
    4766:	df 92       	push	r13
    4768:	ef 92       	push	r14
    476a:	ff 92       	push	r15
    476c:	0f 93       	push	r16
    476e:	1f 93       	push	r17
    4770:	cf 93       	push	r28
    4772:	df 93       	push	r29
    4774:	cd b7       	in	r28, 0x3d	; 61
    4776:	de b7       	in	r29, 0x3e	; 62
    4778:	ca 1b       	sub	r28, r26
    477a:	db 0b       	sbc	r29, r27
    477c:	0f b6       	in	r0, 0x3f	; 63
    477e:	f8 94       	cli
    4780:	de bf       	out	0x3e, r29	; 62
    4782:	0f be       	out	0x3f, r0	; 63
    4784:	cd bf       	out	0x3d, r28	; 61
    4786:	09 94       	ijmp

00004788 <__epilogue_restores__>:
    4788:	2a 88       	ldd	r2, Y+18	; 0x12
    478a:	39 88       	ldd	r3, Y+17	; 0x11
    478c:	48 88       	ldd	r4, Y+16	; 0x10
    478e:	5f 84       	ldd	r5, Y+15	; 0x0f
    4790:	6e 84       	ldd	r6, Y+14	; 0x0e
    4792:	7d 84       	ldd	r7, Y+13	; 0x0d
    4794:	8c 84       	ldd	r8, Y+12	; 0x0c
    4796:	9b 84       	ldd	r9, Y+11	; 0x0b
    4798:	aa 84       	ldd	r10, Y+10	; 0x0a
    479a:	b9 84       	ldd	r11, Y+9	; 0x09
    479c:	c8 84       	ldd	r12, Y+8	; 0x08
    479e:	df 80       	ldd	r13, Y+7	; 0x07
    47a0:	ee 80       	ldd	r14, Y+6	; 0x06
    47a2:	fd 80       	ldd	r15, Y+5	; 0x05
    47a4:	0c 81       	ldd	r16, Y+4	; 0x04
    47a6:	1b 81       	ldd	r17, Y+3	; 0x03
    47a8:	aa 81       	ldd	r26, Y+2	; 0x02
    47aa:	b9 81       	ldd	r27, Y+1	; 0x01
    47ac:	ce 0f       	add	r28, r30
    47ae:	d1 1d       	adc	r29, r1
    47b0:	0f b6       	in	r0, 0x3f	; 63
    47b2:	f8 94       	cli
    47b4:	de bf       	out	0x3e, r29	; 62
    47b6:	0f be       	out	0x3f, r0	; 63
    47b8:	cd bf       	out	0x3d, r28	; 61
    47ba:	ed 01       	movw	r28, r26
    47bc:	08 95       	ret

000047be <_exit>:
    47be:	f8 94       	cli

000047c0 <__stop_program>:
    47c0:	ff cf       	rjmp	.-2      	; 0x47c0 <__stop_program>
