
main.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         0000781e  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         000000dc  00800060  0000781e  000078b2  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000506  0080013c  0080013c  0000798e  2**0
                  ALLOC
  3 .debug_aranges 000002e0  00000000  00000000  0000798e  2**0
                  CONTENTS, READONLY, DEBUGGING
  4 .debug_pubnames 00001f9d  00000000  00000000  00007c6e  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_info   00007409  00000000  00000000  00009c0b  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_abbrev 0000219e  00000000  00000000  00011014  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_line   00004eb8  00000000  00000000  000131b2  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_frame  00000c20  00000000  00000000  0001806c  2**2
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_str    00001278  00000000  00000000  00018c8c  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_loc    00002ea2  00000000  00000000  00019f04  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_ranges 00000220  00000000  00000000  0001cda6  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 94 06 	jmp	0xd28	; 0xd28 <__ctors_end>
       4:	0c 94 b1 06 	jmp	0xd62	; 0xd62 <__bad_interrupt>
       8:	0c 94 6c 1c 	jmp	0x38d8	; 0x38d8 <__vector_2>
       c:	0c 94 b1 06 	jmp	0xd62	; 0xd62 <__bad_interrupt>
      10:	0c 94 b1 06 	jmp	0xd62	; 0xd62 <__bad_interrupt>
      14:	0c 94 b1 06 	jmp	0xd62	; 0xd62 <__bad_interrupt>
      18:	0c 94 b1 06 	jmp	0xd62	; 0xd62 <__bad_interrupt>
      1c:	0c 94 13 07 	jmp	0xe26	; 0xe26 <__vector_7>
      20:	0c 94 b1 06 	jmp	0xd62	; 0xd62 <__bad_interrupt>
      24:	0c 94 b1 06 	jmp	0xd62	; 0xd62 <__bad_interrupt>
      28:	0c 94 b1 06 	jmp	0xd62	; 0xd62 <__bad_interrupt>
      2c:	0c 94 b1 06 	jmp	0xd62	; 0xd62 <__bad_interrupt>
      30:	0c 94 b1 06 	jmp	0xd62	; 0xd62 <__bad_interrupt>
      34:	0c 94 50 0d 	jmp	0x1aa0	; 0x1aa0 <__vector_13>
      38:	0c 94 0d 0e 	jmp	0x1c1a	; 0x1c1a <__vector_14>
      3c:	0c 94 b1 06 	jmp	0xd62	; 0xd62 <__bad_interrupt>
      40:	0c 94 b1 06 	jmp	0xd62	; 0xd62 <__bad_interrupt>
      44:	0c 94 b1 06 	jmp	0xd62	; 0xd62 <__bad_interrupt>
      48:	0c 94 b1 06 	jmp	0xd62	; 0xd62 <__bad_interrupt>
      4c:	0c 94 b1 06 	jmp	0xd62	; 0xd62 <__bad_interrupt>
      50:	0c 94 b1 06 	jmp	0xd62	; 0xd62 <__bad_interrupt>
      54:	21 1c       	adc	r2, r1
      56:	6b 1c       	adc	r6, r11
      58:	15 1c       	adc	r1, r5
      5a:	0f 1c       	adc	r0, r15
      5c:	09 1c       	adc	r0, r9
      5e:	0c 1c       	adc	r0, r12
      60:	2a 1c       	adc	r2, r10
      62:	6b 1c       	adc	r6, r11
      64:	24 1c       	adc	r2, r4
      66:	1e 1c       	adc	r1, r14
      68:	18 1c       	adc	r1, r8
      6a:	12 1c       	adc	r1, r2
      6c:	73 1b       	sub	r23, r19
      6e:	6b 1c       	adc	r6, r11
      70:	6b 1c       	adc	r6, r11
      72:	6b 1c       	adc	r6, r11
      74:	6b 1c       	adc	r6, r11
      76:	6b 1c       	adc	r6, r11
      78:	6b 1c       	adc	r6, r11
      7a:	6b 1c       	adc	r6, r11
      7c:	76 1b       	sub	r23, r22
      7e:	e2 1b       	sub	r30, r18
      80:	6b 1c       	adc	r6, r11
      82:	6b 1c       	adc	r6, r11
      84:	6b 1c       	adc	r6, r11
      86:	c1 1b       	sub	r28, r17
      88:	a3 1b       	sub	r26, r19
      8a:	a0 1b       	sub	r26, r16
      8c:	79 1b       	sub	r23, r25
      8e:	e5 1b       	sub	r30, r21
      90:	6b 1c       	adc	r6, r11
      92:	6b 1c       	adc	r6, r11
      94:	c7 1b       	sub	r28, r23
      96:	c4 1b       	sub	r28, r20
      98:	a6 1b       	sub	r26, r22
      9a:	7c 1b       	sub	r23, r28
      9c:	eb 1b       	sub	r30, r27
      9e:	e8 1b       	sub	r30, r24
      a0:	6b 1c       	adc	r6, r11
      a2:	6b 1c       	adc	r6, r11
      a4:	d9 1b       	sub	r29, r25
      a6:	ca 1b       	sub	r28, r26
      a8:	a9 1b       	sub	r26, r25
      aa:	82 1b       	sub	r24, r18
      ac:	7f 1b       	sub	r23, r31
      ae:	ee 1b       	sub	r30, r30
      b0:	6b 1c       	adc	r6, r11
      b2:	6b 1c       	adc	r6, r11
      b4:	d0 1b       	sub	r29, r16
      b6:	cd 1b       	sub	r28, r29
      b8:	af 1b       	sub	r26, r31
      ba:	ac 1b       	sub	r26, r28
      bc:	85 1b       	sub	r24, r21
      be:	f1 1b       	sub	r31, r17
      c0:	6b 1c       	adc	r6, r11
      c2:	6b 1c       	adc	r6, r11
      c4:	6b 1c       	adc	r6, r11
      c6:	d3 1b       	sub	r29, r19
      c8:	b2 1b       	sub	r27, r18
      ca:	88 1b       	sub	r24, r24
      cc:	f4 1b       	sub	r31, r20
      ce:	f7 1b       	sub	r31, r23
      d0:	6b 1c       	adc	r6, r11
      d2:	6b 1c       	adc	r6, r11
      d4:	d6 1b       	sub	r29, r22
      d6:	b5 1b       	sub	r27, r21
      d8:	8b 1b       	sub	r24, r27
      da:	8e 1b       	sub	r24, r30
      dc:	df 1b       	sub	r29, r31
      de:	fa 1b       	sub	r31, r26
      e0:	6b 1c       	adc	r6, r11
      e2:	6b 1c       	adc	r6, r11
      e4:	00 1c       	adc	r0, r0
      e6:	61 1c       	adc	r6, r1
      e8:	b8 1b       	sub	r27, r24
      ea:	bb 1b       	sub	r27, r27
      ec:	91 1b       	sub	r25, r17
      ee:	fd 1b       	sub	r31, r29
      f0:	6b 1c       	adc	r6, r11
      f2:	6b 1c       	adc	r6, r11
      f4:	6b 1c       	adc	r6, r11
      f6:	be 1b       	sub	r27, r30
      f8:	6b 1c       	adc	r6, r11
      fa:	94 1b       	sub	r25, r20
      fc:	6d 1b       	sub	r22, r29
      fe:	6b 1c       	adc	r6, r11
     100:	6b 1c       	adc	r6, r11
     102:	9d 1b       	sub	r25, r29
     104:	6b 1c       	adc	r6, r11
     106:	5e 1c       	adc	r5, r14
     108:	97 1b       	sub	r25, r23
     10a:	6b 1c       	adc	r6, r11
     10c:	9a 1b       	sub	r25, r26
     10e:	6b 1c       	adc	r6, r11
     110:	6b 1c       	adc	r6, r11
     112:	6b 1c       	adc	r6, r11
     114:	6b 1c       	adc	r6, r11
     116:	6b 1c       	adc	r6, r11
     118:	6b 1c       	adc	r6, r11
     11a:	6b 1c       	adc	r6, r11
     11c:	6b 1c       	adc	r6, r11
     11e:	70 1b       	sub	r23, r16
     120:	6b 1c       	adc	r6, r11
     122:	6b 1c       	adc	r6, r11
     124:	e2 1b       	sub	r30, r18
     126:	6b 1c       	adc	r6, r11
     128:	eb 1b       	sub	r30, r27
     12a:	f4 1b       	sub	r31, r20
     12c:	6b 1c       	adc	r6, r11
     12e:	6b 1c       	adc	r6, r11
     130:	6b 1c       	adc	r6, r11
     132:	df 1b       	sub	r29, r31
     134:	00 1c       	adc	r0, r0
     136:	e5 1b       	sub	r30, r21
     138:	ee 1b       	sub	r30, r30
     13a:	f1 1b       	sub	r31, r17
     13c:	f7 1b       	sub	r31, r23
     13e:	dc 1b       	sub	r29, r28
     140:	6b 1c       	adc	r6, r11
     142:	27 1c       	adc	r2, r7
     144:	06 1c       	adc	r0, r6
     146:	e8 1b       	sub	r30, r24
     148:	fd 1b       	sub	r31, r29
     14a:	03 1c       	adc	r0, r3
     14c:	fa 1b       	sub	r31, r26
     14e:	6b 1c       	adc	r6, r11
     150:	6b 1c       	adc	r6, r11
     152:	6b 1c       	adc	r6, r11
     154:	6b 1c       	adc	r6, r11
     156:	6b 1c       	adc	r6, r11
     158:	1b 1c       	adc	r1, r11
     15a:	6b 1c       	adc	r6, r11
     15c:	6b 1c       	adc	r6, r11
     15e:	6b 1c       	adc	r6, r11
     160:	6b 1c       	adc	r6, r11
     162:	6b 1c       	adc	r6, r11
     164:	6b 1c       	adc	r6, r11
     166:	6b 1c       	adc	r6, r11
     168:	6b 1c       	adc	r6, r11
     16a:	6b 1c       	adc	r6, r11
     16c:	6b 1c       	adc	r6, r11
     16e:	6b 1c       	adc	r6, r11
     170:	6b 1c       	adc	r6, r11
     172:	6b 1c       	adc	r6, r11
     174:	6b 1c       	adc	r6, r11
     176:	6b 1c       	adc	r6, r11
     178:	6b 1c       	adc	r6, r11
     17a:	6b 1c       	adc	r6, r11
     17c:	6b 1c       	adc	r6, r11
     17e:	6b 1c       	adc	r6, r11
     180:	6b 1c       	adc	r6, r11
     182:	6b 1c       	adc	r6, r11
     184:	6b 1c       	adc	r6, r11
     186:	6b 1c       	adc	r6, r11
     188:	6b 1c       	adc	r6, r11
     18a:	6b 1c       	adc	r6, r11
     18c:	6b 1c       	adc	r6, r11
     18e:	6b 1c       	adc	r6, r11
     190:	6b 1c       	adc	r6, r11
     192:	6b 1c       	adc	r6, r11
     194:	6b 1c       	adc	r6, r11
     196:	6b 1c       	adc	r6, r11
     198:	6b 1c       	adc	r6, r11
     19a:	6b 1c       	adc	r6, r11
     19c:	6b 1c       	adc	r6, r11
     19e:	6b 1c       	adc	r6, r11
     1a0:	6b 1c       	adc	r6, r11
     1a2:	6b 1c       	adc	r6, r11
     1a4:	6b 1c       	adc	r6, r11
     1a6:	6b 1c       	adc	r6, r11
     1a8:	6b 1c       	adc	r6, r11
     1aa:	6b 1c       	adc	r6, r11
     1ac:	6b 1c       	adc	r6, r11
     1ae:	6b 1c       	adc	r6, r11
     1b0:	6b 1c       	adc	r6, r11
     1b2:	6b 1c       	adc	r6, r11
     1b4:	6b 1c       	adc	r6, r11
     1b6:	6b 1c       	adc	r6, r11
     1b8:	6b 1c       	adc	r6, r11
     1ba:	6b 1c       	adc	r6, r11
     1bc:	6b 1c       	adc	r6, r11
     1be:	6b 1c       	adc	r6, r11
     1c0:	6b 1c       	adc	r6, r11
     1c2:	6b 1c       	adc	r6, r11
     1c4:	6b 1c       	adc	r6, r11
     1c6:	6b 1c       	adc	r6, r11
     1c8:	6b 1c       	adc	r6, r11
     1ca:	6b 1c       	adc	r6, r11
     1cc:	6b 1c       	adc	r6, r11
     1ce:	6b 1c       	adc	r6, r11
     1d0:	6b 1c       	adc	r6, r11
     1d2:	6b 1c       	adc	r6, r11
     1d4:	6b 1c       	adc	r6, r11
     1d6:	6b 1c       	adc	r6, r11
     1d8:	6b 1c       	adc	r6, r11
     1da:	6b 1c       	adc	r6, r11
     1dc:	6b 1c       	adc	r6, r11
     1de:	6b 1c       	adc	r6, r11
     1e0:	6b 1c       	adc	r6, r11
     1e2:	6b 1c       	adc	r6, r11
     1e4:	6b 1c       	adc	r6, r11
     1e6:	6b 1c       	adc	r6, r11
     1e8:	6b 1c       	adc	r6, r11
     1ea:	6b 1c       	adc	r6, r11
     1ec:	6b 1c       	adc	r6, r11
     1ee:	6b 1c       	adc	r6, r11
     1f0:	6b 1c       	adc	r6, r11
     1f2:	6b 1c       	adc	r6, r11
     1f4:	6b 1c       	adc	r6, r11
     1f6:	6b 1c       	adc	r6, r11
     1f8:	6b 1c       	adc	r6, r11
     1fa:	6b 1c       	adc	r6, r11
     1fc:	6b 1c       	adc	r6, r11
     1fe:	6b 1c       	adc	r6, r11
     200:	6b 1c       	adc	r6, r11
     202:	6b 1c       	adc	r6, r11
     204:	6b 1c       	adc	r6, r11
     206:	6b 1c       	adc	r6, r11
     208:	6b 1c       	adc	r6, r11
     20a:	6b 1c       	adc	r6, r11
     20c:	6b 1c       	adc	r6, r11
     20e:	6b 1c       	adc	r6, r11
     210:	6b 1c       	adc	r6, r11
     212:	2d 1c       	adc	r2, r13
     214:	6b 1c       	adc	r6, r11
     216:	6b 1c       	adc	r6, r11
     218:	6b 1c       	adc	r6, r11
     21a:	6b 1c       	adc	r6, r11
     21c:	6b 1c       	adc	r6, r11
     21e:	6b 1c       	adc	r6, r11
     220:	6b 1c       	adc	r6, r11
     222:	6b 1c       	adc	r6, r11
     224:	6b 1c       	adc	r6, r11
     226:	6b 1c       	adc	r6, r11
     228:	6b 1c       	adc	r6, r11
     22a:	6b 1c       	adc	r6, r11
     22c:	6b 1c       	adc	r6, r11
     22e:	6b 1c       	adc	r6, r11
     230:	6b 1c       	adc	r6, r11
     232:	2f 1c       	adc	r2, r15

00000234 <err98>:
     234:	45 72 72 6f 72 20 39 38 3a 20 44 6f 73 6c 6f 20     Error 98: Doslo 
     244:	6b 65 20 6b 72 e1 74 6b e9 6d 75 20 76 fd 70 61     ke kr.tk.mu v.pa
     254:	64 6b 75 20 20 20 20 20 6e 61 70 e1 6a 65 6e ed     dku     nap.jen.
     264:	2e 20 44 61 74 61 20 75 6c 6f 7a 65 6e 61 2e 20     . Data ulozena. 
     274:	52 65 73 65 74 2e 00                                Reset..

0000027b <msg14>:
     27b:	14 6f 6b 20 20 00 00 00 00 00 00 00                 .ok  .......

00000287 <msg0A>:
     287:	0a 20 20 20 20 00 00 00 00 00 00 00                 .    .......

00000293 <s_ok>:
     293:	4f 6b 20 28 45 6e 74 65 72 29 00                    Ok (Enter).

0000029e <s_storno>:
     29e:	53 74 6f 72 6e 6f 20 28 45 73 63 29 00              Storno (Esc).

000002ab <err1>:
     2ab:	45 72 72 6f 72 20 31 3a 20 44 6f 73 6c 6f 20 6b     Error 1: Doslo k
     2bb:	20 63 68 79 62 65 20 76 20 6b 6f 6e 74 72 6f 6c      chybe v kontrol
     2cb:	6e 69 6d 0a 73 6f 75 63 74 75 20 70 72 69 20 70     nim.souctu pri p
     2db:	72 69 6a 6d 75 20 7a 70 72 61 76 79 20 6e 61 20     rijmu zpravy na 
     2eb:	6b 61 74 72 75 2e 20 0a 4e 65 6d 75 73 69 20 74     katru. .Nemusi t
     2fb:	6f 20 7a 6e 61 6d 65 6e 61 74 20 7a 61 64 6e 65     o znamenat zadne
     30b:	20 70 6f 74 69 7a 65 2e 00                           potize..

00000314 <err4>:
     314:	45 72 72 6f 72 20 34 3a 20 43 68 79 62 61 20 49     Error 4: Chyba I
     324:	52 43 0a 52 79 63 68 6c 65 20 6f 74 6f 63 65 6e     RC.Rychle otocen
     334:	69 20 49 52 43 20 6e 61 20 6b 61 74 72 75 00        i IRC na katru.

00000343 <err6>:
     343:	45 72 72 6f 72 20 36 3a 20 43 68 79 62 61 20 49     Error 6: Chyba I
     353:	52 43 0a 52 79 63 68 6c 65 20 6f 74 6f 63 65 6e     RC.Rychle otocen
     363:	69 20 49 52 43 20 6e 61 20 76 6f 7a 69 6b 75 00     i IRC na voziku.

00000373 <err7>:
     373:	45 72 72 6f 72 20 37 3a 20 50 6c 6e 61 20 6f 64     Error 7: Plna od
     383:	65 73 69 6c 61 63 69 20 66 72 6f 6e 74 61 20 6e     esilaci fronta n
     393:	61 20 6b 61 74 72 75 2e 0a 4e 65 6d 75 73 69 20     a katru..Nemusi 
     3a3:	74 6f 20 7a 6e 61 6d 65 6e 61 74 20 7a 61 64 6e     to znamenat zadn
     3b3:	79 20 70 72 6f 62 6c 65 6d 2e 00                    y problem..

000003be <err10>:
     3be:	45 72 72 6f 72 20 31 30 3a 20 0a 20 44 45 42 55     Error 10: . DEBU
     3ce:	47 00                                               G.

000003d0 <err11>:
     3d0:	45 72 72 6f 72 20 31 31 3a 20 0a 20 44 45 42 55     Error 11: . DEBU
     3e0:	47 20 32 00                                         G 2.

000003e4 <err80>:
     3e4:	45 72 72 6f 72 20 38 30 3a 20 43 68 79 62 61 20     Error 80: Chyba 
     3f4:	4c 43 44 0a 50 72 65 6b 72 6f 63 65 6e 69 20 72     LCD.Prekroceni r
     404:	6f 7a 73 61 68 75 0a 4c 43 44 20 70 6f 20 6f 64     ozsahu.LCD po od
     414:	72 61 64 6b 6f 76 61 6e 69 00                       radkovani.

0000041e <err81>:
     41e:	45 72 72 6f 72 20 38 31 3a 20 43 68 79 62 61 20     Error 81: Chyba 
     42e:	4c 43 44 0a 54 65 78 74 20 70 72 65 73 61 68 75     LCD.Text presahu
     43e:	6a 65 0a 6f 6b 72 61 6a 20 4c 43 44 00              je.okraj LCD.

0000044b <err82>:
     44b:	45 72 72 6f 72 20 38 32 3a 20 43 68 79 62 61 20     Error 82: Chyba 
     45b:	4c 43 44 0a 50 6f 63 61 74 65 6b 20 74 65 78 74     LCD.Pocatek text
     46b:	75 0a 6d 69 6d 6f 20 64 69 73 70 6c 65 6a 00        u.mimo displej.

0000047a <err83>:
     47a:	45 72 72 6f 72 20 38 33 3a 20 43 68 79 62 61 20     Error 83: Chyba 
     48a:	49 52 43 0a 4f 70 72 61 76 61 20 6e 61 20 72 65     IRC.Oprava na re
     49a:	66 65 72 65 6e 2e 0a 62 6f 64 65 20 6f 20 76 69     feren..bode o vi
     4aa:	63 65 20 6e 65 7a 0a 20 31 30 20 63 6d 00           ce nez. 10 cm.

000004b8 <err84>:
     4b8:	45 72 72 6f 72 20 38 34 3a 20 0a 4e 65 6c 7a 65     Error 84: .Nelze
     4c8:	20 7a 61 68 61 6a 69 74 20 6d 65 72 65 6e 69 0a      zahajit mereni.
     4d8:	64 6f 6b 75 64 20 6e 65 6e 69 0a 75 6b 6f 6e 63     dokud neni.ukonc
     4e8:	65 6e 6f 20 70 72 65 64 63 68 6f 7a 69 2e 00        eno predchozi..

000004f7 <err85>:
     4f7:	45 72 72 6f 72 20 38 35 3a 20 43 68 79 62 61 20     Error 85: Chyba 
     507:	6b 6f 6e 76 65 72 7a 65 20 69 6e 74 32 73 74 72     konverze int2str
     517:	69 6e 67 2e 0a 50 72 65 76 61 64 65 6e 65 20 63     ing..Prevadene c
     527:	69 73 6c 6f 20 6a 65 20 70 72 69 6c 69 73 20 64     islo je prilis d
     537:	6c 6f 75 68 65 2e 0a 44 6f 63 68 61 7a 69 20 6b     louhe..Dochazi k
     547:	20 70 72 65 74 65 6b 61 6e 69 20 76 65 20 76 79      pretekani ve vy
     557:	70 69 73 75 2e 00                                   pisu..

0000055d <err86>:
     55d:	45 72 72 6f 72 20 38 36 3a 20 44 6f 73 6c 6f 20     Error 86: Doslo 
     56d:	6b 20 63 68 79 62 65 20 76 20 6b 6f 6e 74 72 6f     k chybe v kontro
     57d:	6c 6e 69 6d 0a 73 6f 75 63 74 75 20 70 72 69 20     lnim.souctu pri 
     58d:	70 72 69 6a 6d 75 20 7a 70 72 61 76 79 0a 6e 61     prijmu zpravy.na
     59d:	20 76 6f 7a 69 6b 75 2e 0a 4e 65 6d 75 73 69 20      voziku..Nemusi 
     5ad:	74 6f 20 7a 6e 61 6d 65 6e 61 74 20 7a 61 64 6e     to znamenat zadn
     5bd:	65 20 70 6f 74 69 7a 65 2e 00                       e potize..

000005c7 <err87>:
     5c7:	45 72 72 6f 72 20 38 37 3a 20 50 72 69 20 70 72     Error 87: Pri pr
     5d7:	69 6a 6d 75 20 7a 70 72 61 76 79 20 6e 61 0a 76     ijmu zpravy na.v
     5e7:	6f 7a 69 6b 75 20 62 79 6c 61 20 6b 6f 6d 75 6e     oziku byla komun
     5f7:	69 6b 61 63 65 20 7a 61 68 61 6a 65 6e 61 0a 6e     ikace zahajena.n
     607:	65 73 70 72 76 6e 79 6d 20 7a 6e 61 6b 65 6d 00     esprvnym znakem.

00000617 <err88>:
     617:	45 72 72 6f 72 20 38 38 3a 20 4e 65 64 6f 73 74     Error 88: Nedost
     627:	61 74 65 6b 20 70 61 6d 65 74 69 00                 atek pameti.

00000633 <err89>:
     633:	45 72 72 6f 72 20 38 39 3a 20 0a 50 72 65 6b 72     Error 89: .Prekr
     643:	6f 63 65 6e 20 72 6f 7a 73 61 68 20 75 6c 6f 7a     ocen rozsah uloz
     653:	69 74 65 6c 6e 65 20 64 65 6c 6b 79 2e 0a 4d 61     itelne delky..Ma
     663:	78 69 6d 61 6c 6e 69 20 75 6c 6f 7a 69 74 65 6c     ximalni ulozitel
     673:	6e 61 20 64 65 6c 6b 61 20 6a 65 20 32 35 2e 35     na delka je 25.5
     683:	20 6d 00                                             m.

00000686 <err90>:
     686:	45 72 72 6f 72 20 39 30 3a 20 0a 50 72 65 6b 72     Error 90: .Prekr
     696:	6f 63 65 6e 20 72 6f 7a 73 61 68 20 75 6c 6f 7a     ocen rozsah uloz
     6a6:	69 74 65 6c 6e 65 68 6f 20 70 72 75 6d 65 72 75     itelneho prumeru
     6b6:	2e 0a 4d 61 78 69 6d 61 6c 6e 69 20 75 6c 6f 7a     ..Maximalni uloz
     6c6:	69 74 65 6c 6e 79 20 70 72 75 6d 65 72 20 6a 65     itelny prumer je
     6d6:	20 36 33 2e 35 20 63 6d 00                           63.5 cm.

000006df <err91>:
     6df:	45 72 72 6f 72 20 39 31 3a 20 0a 50 72 65 6b 72     Error 91: .Prekr
     6ef:	6f 63 65 6e 61 20 6d 61 78 69 6d 61 6c 6e 69 20     ocena maximalni 
     6ff:	64 6f 62 61 20 6f 64 65 7a 76 79 20 6e 61 20 0a     doba odezvy na .
     70f:	7a 70 72 61 76 75 2e 00                             zpravu..

00000717 <err92>:
     717:	45 72 72 6f 72 20 39 32 3a 20 0a 56 20 64 75 73     Error 92: .V dus
     727:	6c 65 64 6b 75 20 6f 64 6a 65 7a 64 75 20 76 6f     ledku odjezdu vo
     737:	7a 69 6b 75 20 6f 64 20 6b 61 74 72 75 20 0a 73     ziku od katru .s
     747:	65 20 6e 65 70 6f 64 61 72 69 6c 6f 20 70 72 6f     e nepodarilo pro
     757:	76 65 73 74 20 64 6f 73 74 61 74 65 6b 20 6d 65     vest dostatek me
     767:	72 65 6e 69 2e 0a 4e 61 6d 65 72 65 6e 61 20 64     reni..Namerena d
     777:	61 74 61 20 6d 6f 68 6f 75 20 62 79 74 20 6e 65     ata mohou byt ne
     787:	70 72 65 73 6e 61 2e 00                             presna..

0000078f <err93>:
     78f:	45 72 72 6f 72 20 39 33 3a 20 0a 56 20 64 75 73     Error 93: .V dus
     79f:	6c 65 64 6b 75 20 6f 64 6a 65 7a 64 75 20 76 6f     ledku odjezdu vo
     7af:	7a 69 6b 75 20 6f 64 20 6b 61 74 72 75 2c 20 0a     ziku od katru, .
     7bf:	6e 65 62 79 6c 6f 20 7a 61 6a 69 73 74 65 6e 6f     nebylo zajisteno
     7cf:	20 64 6f 73 74 61 74 65 6b 20 64 61 74 2e 0a 4d      dostatek dat..M
     7df:	65 72 65 6e 69 20 6a 65 20 7a 72 75 73 65 6e 6f     ereni je zruseno
     7ef:	2e 00                                               ..

000007f1 <err94>:
     7f1:	45 72 72 6f 72 20 39 34 3a 20 0a 4a 65 20 6e 75     Error 94: .Je nu
     801:	74 6e 65 20 6e 65 6a 64 72 69 76 65 20 7a 61 64     tne nejdrive zad
     811:	61 74 20 6a 6d 65 6e 6f 20 7a 61 6b 61 7a 6e 69     at jmeno zakazni
     821:	6b 61 2e 00                                         ka..

00000825 <err95>:
     825:	45 72 72 6f 72 20 39 35 3a 20 5a 61 6b 61 7a 6e     Error 95: Zakazn
     835:	69 6b 61 20 6e 65 6c 7a 65 20 6f 64 73 74 72 61     ika nelze odstra
     845:	6e 69 74 2e 20 0a 42 79 6c 6f 20 70 72 6f 20 6e     nit. .Bylo pro n
     855:	65 6a 20 6a 69 7a 20 6e 61 6d 65 72 65 6e 6f 20     ej jiz namereno 
     865:	6e 65 6b 6f 6c 69 6b 20 6b 6d 65 6e 75 2e 0a 50     nekolik kmenu..P
     875:	72 65 64 20 6f 64 73 74 72 61 6e 65 6e 69 6d 20     red odstranenim 
     885:	6a 65 20 6e 75 74 6e 65 20 74 61 74 6f 20 6d 65     je nutne tato me
     895:	72 65 6e 69 0a 73 6d 61 7a 61 74 2e 00              reni.smazat..

000008a2 <err96>:
     8a2:	45 72 72 6f 72 20 39 36 3a 20 0a 44 6f 73 6c 6f     Error 96: .Doslo
     8b2:	20 6b 20 70 72 65 70 6c 6e 65 6e 69 20 6f 64 65      k preplneni ode
     8c2:	73 69 6c 61 63 69 68 6f 20 62 75 66 66 65 72 75     silaciho bufferu
     8d2:	20 0a 73 65 72 69 6f 76 65 68 6f 20 6b 61 6e 61      .serioveho kana
     8e2:	6c 75 20 6e 61 20 6b 61 74 72 75 2e 20 4e 65 6d     lu na katru. Nem
     8f2:	75 73 69 20 74 6f 20 0a 7a 6e 61 6d 65 6e 61 74     usi to .znamenat
     902:	20 7a 61 64 6e 65 20 70 6f 74 69 7a 65 2e 00         zadne potize..

00000911 <err99>:
     911:	45 72 72 6f 72 20 39 39 3a 20 0a 50 6f 6b 75 73     Error 99: .Pokus
     921:	20 6f 20 6d 65 72 65 6e 69 20 70 72 69 6c 69 73      o mereni prilis
     931:	20 6b 72 61 74 6b 65 68 6f 20 6b 6d 65 6e 75 2e      kratkeho kmenu.
     941:	0a 4e 65 6a 6b 72 61 74 73 69 20 6d 65 72 69 74     .Nejkratsi merit
     951:	65 6c 6e 79 20 6b 6d 65 6e 20 6a 65 20 32 6d 2e     elny kmen je 2m.
	...

00000962 <err100>:
     962:	45 72 72 6f 72 20 31 30 30 3a 20 0a 4e 65 73 70     Error 100: .Nesp
     972:	72 61 76 6e 65 20 7a 61 64 61 6e 65 20 63 69 73     ravne zadane cis
     982:	6c 6f 2e 00                                         lo..

00000986 <err101>:
     986:	45 72 72 6f 72 20 31 30 31 3a 20 50 61 6d 65 74     Error 101: Pamet
     996:	20 7a 61 7a 6e 61 6d 75 20 7a 61 70 6c 6e 65 6e      zaznamu zaplnen
     9a6:	61 2e 0a 4e 65 6c 7a 65 20 75 6b 6c 61 64 61 74     a..Nelze ukladat
     9b6:	20 64 61 6c 73 69 20 7a 61 7a 6e 61 6d 79 2e 20      dalsi zaznamy. 
     9c6:	4f 64 65 73 6c 65 74 65 0a 64 61 74 61 20 6e 61     Odeslete.data na
     9d6:	20 73 65 72 76 65 72 2e 00                           server..

000009df <err102>:
     9df:	45 72 72 6f 72 20 31 30 32 3a 20 0a 43 68 79 62     Error 102: .Chyb
     9ef:	61 20 70 72 69 20 6b 6f 6d 75 6e 69 6b 61 63 69     a pri komunikaci
     9ff:	20 73 65 20 73 65 72 76 65 72 65 6d 2e 00            se serverem..

00000a0d <err200>:
     a0d:	0a 20 20 20 20 20 20 20 20 20 20 20 20 20 44 61     .             Da
     a1d:	74 61 20 6f 64 65 73 6c 61 6e 61 2e 00              ta odeslana..

00000a2a <err201>:
     a2a:	0a 50 61 6d 65 74 20 7a 61 7a 6e 61 6d 75 20 74     .Pamet zaznamu t
     a3a:	65 6d 65 72 20 7a 61 70 6c 6e 65 6e 61 2e 0a 5a     emer zaplnena..Z
     a4a:	62 79 76 61 20 6d 69 73 74 6f 20 6e 61 20 6d 65     byva misto na me
     a5a:	6e 65 20 6e 65 7a 20 31 30 20 7a 61 7a 6e 61 6d     ne nez 10 zaznam
     a6a:	75 2e 00                                            u..

00000a6d <s_prazdne>:
     a6d:	70 72 61 7a 64 6e 65 00                             prazdne.

00000a75 <s_msr_zahajeno>:
     a75:	4d 65 72 65 6e 69 20 7a 61 68 61 6a 65 6e 6f 20     Mereni zahajeno 
     a85:	20 20 00                                              .

00000a88 <s_msr_delka>:
     a88:	5a 6d 65 72 65 6e 61 20 64 65 6c 6b 61 20 20 20     Zmerena delka   
     a98:	20 20 00                                              .

00000a9b <s_msr_domereno>:
     a9b:	4d 65 72 65 6e 69 20 64 6f 6b 6f 6e 63 65 6e 6f     Mereni dokonceno
     aab:	20 20 00                                              .

00000aae <s_msr_pause>:
     aae:	4d 65 72 65 6e 69 20 70 6f 7a 61 73 74 61 76 65     Mereni pozastave
     abe:	6e 6f 00                                            no.

00000ac1 <s_smazat>:
     ac1:	20 0a 20 20 4f 70 72 61 76 64 75 20 6f 64 73 74      .  Opravdu odst
     ad1:	72 61 6e 69 74 20 6a 6d 65 6e 6f 20 7a 65 20 73     ranit jmeno ze s
     ae1:	65 7a 6e 61 6d 75 3f 00                             eznamu?.

00000ae9 <s_zakz>:
     ae9:	5a 61 6b 7a 00                                      Zakz.

00000aee <s_drev>:
     aee:	44 72 65 76 00                                      Drev.

00000af3 <s_oper>:
     af3:	4f 70 65 72 00                                      Oper.

00000af8 <s_dat_scr>:
     af8:	44 61 74 61 00                                      Data.

00000afd <s_delka>:
     afd:	44 65 6c 6b 61 00                                   Delka.

00000b03 <s_prumer_v>:
     b03:	70 72 75 6d 5f 76 00                                prum_v.

00000b0a <s_prumer_h>:
     b0a:	70 72 75 6d 5f 68 00                                prum_h.

00000b11 <msr1>:
     b11:	4f 62 72 61 7a 6f 76 6b 61 20 6d 65 72 65 6e 69     Obrazovka mereni
     b21:	3a 20 46 31 30 20 2d 20 5a 61 68 61 6a 65 6e 69     : F10 - Zahajeni
     b31:	20 6d 65 72 65 6e 69 0a 46 31 31 20 2d 20 55 6c      mereni.F11 - Ul
     b41:	6f 7a 69 74 20 6d 65 72 65 6e 69 0a 54 61 62 20     ozit mereni.Tab 
     b51:	2d 20 50 6f 6c 6f 7a 6b 61 2c 20 4d 65 7a 65 72     - Polozka, Mezer
     b61:	20 2d 20 48 6f 64 6e 6f 74 61 20 70 6f 6c 6f 7a      - Hodnota poloz
     b71:	6b 79 0a 45 6e 74 65 72 20 2d 20 53 65 7a 6e 61     ky.Enter - Sezna
     b81:	6d 00                                               m.

00000b83 <lst1>:
     b83:	53 65 7a 6e 61 6d 3a 20 45 6e 74 65 72 28 4f 4b     Seznam: Enter(OK
     b93:	29 20 2d 20 56 79 62 65 72 2f 76 6c 6f 7a 65 6e     ) - Vyber/vlozen
     ba3:	69 20 6a 6d 65 6e 61 0a 45 73 63 28 5a 52 55 53     i jmena.Esc(ZRUS
     bb3:	49 54 29 20 2d 20 5a 70 65 74 00                    IT) - Zpet.

00000bbe <dat1>:
     bbe:	53 65 7a 6e 61 6d 20 6d 65 72 65 6e 69 3a 20 0a     Seznam mereni: .
     bce:	45 6e 74 65 72 28 4f 4b 29 20 2d 20 55 70 72 61     Enter(OK) - Upra
     bde:	76 69 74 20 72 61 64 65 6b 00                       vit radek.

00000be8 <err1>:
     be8:	43 68 79 62 6f 76 61 20 6f 62 72 61 7a 6f 76 6b     Chybova obrazovk
     bf8:	61 3a 20 0a 45 6e 74 65 72 28 4f 4b 29 2c 20 45     a: .Enter(OK), E
     c08:	73 63 28 5a 52 55 53 49 54 29 20 2d 20 6f 64 63     sc(ZRUSIT) - odc
     c18:	68 6f 64 00                                         hod.

00000c1c <smrk>:
     c1c:	53 6d 72 6b 00                                      Smrk.

00000c21 <boro_k>:
     c21:	42 6f 72 4b 00                                      BorK.

00000c26 <boro_b>:
     c26:	42 6f 72 42 00                                      BorB.

00000c2b <buk>:
     c2b:	42 75 6b 20 00                                      Buk .

00000c30 <dub>:
     c30:	44 75 62 20 00                                      Dub .

00000c35 <n1>:
     c35:	31 00                                               1.

00000c37 <n2>:
     c37:	32 00                                               2.

00000c39 <ctyr>:
     c39:	73 61 6d 6f 00                                      samo.

00000c3e <paso>:
     c3e:	70 61 73 6f 00                                      paso.

00000c43 <man>:
     c43:	6d 61 6e 00                                         man.

00000c47 <s_smazat_mereni>:
     c47:	20 0a 20 20 4f 70 72 61 76 64 75 20 63 68 63 65      .  Opravdu chce
     c57:	74 65 20 6f 64 73 74 72 61 6e 69 74 20 6d 65 72     te odstranit mer
     c67:	65 6e 69 3f 00                                      eni?.

00000c6c <s_smazat>:
     c6c:	20 0a 20 20 4f 70 72 61 76 64 75 20 6f 64 73 74      .  Opravdu odst
     c7c:	72 61 6e 69 74 20 6a 6d 65 6e 6f 20 7a 65 20 73     ranit jmeno ze s
     c8c:	65 7a 6e 61 6d 75 3f 00                             eznamu?.

00000c94 <err97>:
     c94:	45 72 72 6f 72 20 39 37 3a 20 56 61 7a 6e 61 20     Error 97: Vazna 
     ca4:	63 68 79 62 61 20 62 65 68 75 20 70 72 6f 67 72     chyba behu progr
     cb4:	61 6d 75 2e 20 20 20 20 55 6b 6c 61 64 61 6e 69     amu.    Ukladani
     cc4:	20 64 61 74 2e 00                                    dat..

00000cca <err97b>:
     cca:	45 72 72 6f 72 20 39 37 3a 20 44 61 74 61 20 75     Error 97: Data u
     cda:	6c 6f 7a 65 6e 61 2e 20 52 65 73 65 74 2e 00        lozena. Reset..

00000ce9 <s_stp_scr>:
     ce9:	6b 5f 69 72 63 5f 6b 20 20 20 20 20 20 20 20 20     k_irc_k         
     cf9:	20 20 20 20 6c 69 73 74 61 0a 6b 5f 69 72 63 5f         lista.k_irc_
     d09:	6c 0a 76 5f 69 72 63 5f 6b 0a 76 5f 69 72 63 5f     l.v_irc_k.v_irc_
     d19:	6c 00                                               l.

00000d1b <__c.1971>:
     d1b:	63 64 69 6e 6f 70 73 75 78 58 5b 00 00              cdinopsuxX[..

00000d28 <__ctors_end>:
     d28:	11 24       	eor	r1, r1
     d2a:	1f be       	out	0x3f, r1	; 63
     d2c:	cf e5       	ldi	r28, 0x5F	; 95
     d2e:	d8 e0       	ldi	r29, 0x08	; 8
     d30:	de bf       	out	0x3e, r29	; 62
     d32:	cd bf       	out	0x3d, r28	; 61

00000d34 <__do_copy_data>:
     d34:	11 e0       	ldi	r17, 0x01	; 1
     d36:	a0 e6       	ldi	r26, 0x60	; 96
     d38:	b0 e0       	ldi	r27, 0x00	; 0
     d3a:	ee e1       	ldi	r30, 0x1E	; 30
     d3c:	f8 e7       	ldi	r31, 0x78	; 120
     d3e:	02 c0       	rjmp	.+4      	; 0xd44 <.do_copy_data_start>

00000d40 <.do_copy_data_loop>:
     d40:	05 90       	lpm	r0, Z+
     d42:	0d 92       	st	X+, r0

00000d44 <.do_copy_data_start>:
     d44:	ac 33       	cpi	r26, 0x3C	; 60
     d46:	b1 07       	cpc	r27, r17
     d48:	d9 f7       	brne	.-10     	; 0xd40 <.do_copy_data_loop>

00000d4a <__do_clear_bss>:
     d4a:	16 e0       	ldi	r17, 0x06	; 6
     d4c:	ac e3       	ldi	r26, 0x3C	; 60
     d4e:	b1 e0       	ldi	r27, 0x01	; 1
     d50:	01 c0       	rjmp	.+2      	; 0xd54 <.do_clear_bss_start>

00000d52 <.do_clear_bss_loop>:
     d52:	1d 92       	st	X+, r1

00000d54 <.do_clear_bss_start>:
     d54:	a2 34       	cpi	r26, 0x42	; 66
     d56:	b1 07       	cpc	r27, r17
     d58:	e1 f7       	brne	.-8      	; 0xd52 <.do_clear_bss_loop>
     d5a:	0e 94 80 07 	call	0xf00	; 0xf00 <main>
     d5e:	0c 94 0d 3c 	jmp	0x781a	; 0x781a <_exit>

00000d62 <__bad_interrupt>:
     d62:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000d66 <ioinit>:
/// Inicializace ËÌtaËe pro vol·nÌ inkrement·lnÌho Ëidla
void ioinit (void) {
  int pocet_cyklu = 500;

  // citac bude citat v kaûdÈm cyklu, reûim - Clear Timer on Compare (CTC)
  TCCR1B = (1 << CS10) | (1 << WGM12);
     d66:	89 e0       	ldi	r24, 0x09	; 9
     d68:	8e bd       	out	0x2e, r24	; 46
  // nastaveni p¯eruöenÌ p¯i porovn·nÌ
  TIMSK = (1 << OCIE1A);
     d6a:	80 e1       	ldi	r24, 0x10	; 16
     d6c:	89 bf       	out	0x39, r24	; 57

  // NastavenÌ jak Ëasto se bude volat 
  OCR1AH = (unsigned char)(pocet_cyklu >> 8);
     d6e:	81 e0       	ldi	r24, 0x01	; 1
     d70:	8b bd       	out	0x2b, r24	; 43
  OCR1AL = (unsigned char) pocet_cyklu;
     d72:	84 ef       	ldi	r24, 0xF4	; 244
     d74:	8a bd       	out	0x2a, r24	; 42
}
     d76:	08 95       	ret

00000d78 <prazdna>:
void err102(void){
  new_error(102); // chyba p¯i komunikaci se serverem
}

void prazdna(char* s){
}
     d78:	08 95       	ret

00000d7a <err102>:
    msg2[1] = (unsigned char) 1;
    new_msg(msg2);
}

void err102(void){
  new_error(102); // chyba p¯i komunikaci se serverem
     d7a:	86 e6       	ldi	r24, 0x66	; 102
     d7c:	0e 94 4e 19 	call	0x329c	; 0x329c <new_error>
}
     d80:	08 95       	ret

00000d82 <mmalloc>:
  return p_pom;
}

/// M· alokaËnÌ funkce. Testuje, zda nebyla naplnÏna pamÏù. Pokud ano, vypÌöe
/// chybovou hl·öku.
void * mmalloc (unsigned int size){
     d82:	cf 93       	push	r28
     d84:	df 93       	push	r29
  void * pointer;
  pointer = malloc (size);
     d86:	0e 94 19 32 	call	0x6432	; 0x6432 <malloc>
     d8a:	ec 01       	movw	r28, r24
  if (pointer == NULL){
     d8c:	00 97       	sbiw	r24, 0x00	; 0
     d8e:	19 f4       	brne	.+6      	; 0xd96 <mmalloc+0x14>
    new_error(88);
     d90:	88 e5       	ldi	r24, 0x58	; 88
     d92:	0e 94 4e 19 	call	0x329c	; 0x329c <new_error>
    return NULL;
  }
  else {
    return pointer;
  }
}
     d96:	ce 01       	movw	r24, r28
     d98:	df 91       	pop	r29
     d9a:	cf 91       	pop	r28
     d9c:	08 95       	ret

00000d9e <get_data_from_server>:
Funkce je vol·na v p¯ÌpadÏ, ûe je nastaveno zÌsk·v·nÌ dat o öÌ¯ce ze serveru.
Zajiöùuje v˝zvu k odesÌl·nÌ pro server a Ëek·nÌ na odpovÏÔ.
@todo P¯epsat. Chce to zajistit umlËenÌ katru.
*/
void get_data_from_server(void){
  char * msg = (char *)mmalloc(DATASIZE);
     d9e:	8a e0       	ldi	r24, 0x0A	; 10
     da0:	90 e0       	ldi	r25, 0x00	; 0
     da2:	0e 94 c1 06 	call	0xd82	; 0xd82 <mmalloc>
     da6:	fc 01       	movw	r30, r24
  msg[0] = '\x46';
     da8:	86 e4       	ldi	r24, 0x46	; 70
     daa:	80 83       	st	Z, r24
  new_ack_msg(msg, 0,prazdna,err102);
     dac:	cf 01       	movw	r24, r30
     dae:	60 e0       	ldi	r22, 0x00	; 0
     db0:	4c eb       	ldi	r20, 0xBC	; 188
     db2:	56 e0       	ldi	r21, 0x06	; 6
     db4:	2d eb       	ldi	r18, 0xBD	; 189
     db6:	36 e0       	ldi	r19, 0x06	; 6
     db8:	0e 94 c8 0c 	call	0x1990	; 0x1990 <new_ack_msg>
}
     dbc:	08 95       	ret

00000dbe <get_data_from_katr>:


/**
Tato funkce je vol·na p¯i startu jednoËipu. JejÌm ˙kolem je zÌskat data z katru.
*/
void get_data_from_katr(void){
     dbe:	1f 93       	push	r17
    char * msg1;
    char * msg2;
    msg1 =(void*) mmalloc (DATASIZE);
     dc0:	8a e0       	ldi	r24, 0x0A	; 10
     dc2:	90 e0       	ldi	r25, 0x00	; 0
     dc4:	0e 94 c1 06 	call	0xd82	; 0xd82 <mmalloc>
     dc8:	fc 01       	movw	r30, r24

    msg1[0] = '\x09';
     dca:	89 e0       	ldi	r24, 0x09	; 9
     dcc:	80 83       	st	Z, r24
    msg1[1] = (unsigned char) 1;
     dce:	11 e0       	ldi	r17, 0x01	; 1
     dd0:	11 83       	std	Z+1, r17	; 0x01
    new_msg(msg1);
     dd2:	cf 01       	movw	r24, r30
     dd4:	0e 94 46 0c 	call	0x188c	; 0x188c <new_msg>


    msg2 =(void*) mmalloc (DATASIZE);
     dd8:	8a e0       	ldi	r24, 0x0A	; 10
     dda:	90 e0       	ldi	r25, 0x00	; 0
     ddc:	0e 94 c1 06 	call	0xd82	; 0xd82 <mmalloc>
     de0:	fc 01       	movw	r30, r24
    
    msg2[0] = '\x16';
     de2:	86 e1       	ldi	r24, 0x16	; 22
     de4:	80 83       	st	Z, r24
    msg2[1] = (unsigned char) 1;
     de6:	11 83       	std	Z+1, r17	; 0x01
    new_msg(msg2);
     de8:	cf 01       	movw	r24, r30
     dea:	0e 94 46 0c 	call	0x188c	; 0x188c <new_msg>
}
     dee:	1f 91       	pop	r17
     df0:	08 95       	ret

00000df2 <getstr_P>:
 * pamÏù pro uloûenÌ ¯etÏzce do SRAM, ¯etÏzec tam zkopÌruje a vr·tÌ ukazatel na
 * toto mÌsto.
 * @param s_p Ukazatel do programovÈ pamÏti.
 * @return Ukazatel v pamÏti SRAM, kam je zkopÌrov·n ¯etÏzec z \a s_p
 **/
char * getstr_P( PGM_P s_p){
     df2:	0f 93       	push	r16
     df4:	1f 93       	push	r17
     df6:	cf 93       	push	r28
     df8:	df 93       	push	r29
     dfa:	8c 01       	movw	r16, r24
  char * p_pom;

  p_pom = (char *) malloc(strlen_P(s_p) + 1);
     dfc:	0e 94 2e 33 	call	0x665c	; 0x665c <strlen_P>
     e00:	01 96       	adiw	r24, 0x01	; 1
     e02:	0e 94 19 32 	call	0x6432	; 0x6432 <malloc>
     e06:	ec 01       	movw	r28, r24
  if(p_pom == NULL){
     e08:	00 97       	sbiw	r24, 0x00	; 0
     e0a:	21 f4       	brne	.+8      	; 0xe14 <getstr_P+0x22>
    new_error(88);
     e0c:	88 e5       	ldi	r24, 0x58	; 88
     e0e:	0e 94 4e 19 	call	0x329c	; 0x329c <new_error>
     e12:	03 c0       	rjmp	.+6      	; 0xe1a <getstr_P+0x28>
    return NULL;
  }
  else{
    strcpy_P(p_pom, s_p);
     e14:	b8 01       	movw	r22, r16
     e16:	0e 94 27 33 	call	0x664e	; 0x664e <strcpy_P>
  }

  return p_pom;
}
     e1a:	ce 01       	movw	r24, r28
     e1c:	df 91       	pop	r29
     e1e:	cf 91       	pop	r28
     e20:	1f 91       	pop	r17
     e22:	0f 91       	pop	r16
     e24:	08 95       	ret

00000e26 <__vector_7>:
    // a pokraËujeme v programu
  }
}

/// Obsluha inkrement·lnÌho Ëidla je vol·na v p¯eruöenÌ ËÌtaËe
SIGNAL (SIG_OUTPUT_COMPARE1A) {
     e26:	1f 92       	push	r1
     e28:	0f 92       	push	r0
     e2a:	0f b6       	in	r0, 0x3f	; 63
     e2c:	0f 92       	push	r0
     e2e:	11 24       	eor	r1, r1
     e30:	2f 93       	push	r18
     e32:	3f 93       	push	r19
     e34:	4f 93       	push	r20
     e36:	5f 93       	push	r21
     e38:	6f 93       	push	r22
     e3a:	7f 93       	push	r23
     e3c:	8f 93       	push	r24
     e3e:	9f 93       	push	r25
     e40:	af 93       	push	r26
     e42:	bf 93       	push	r27
     e44:	ef 93       	push	r30
     e46:	ff 93       	push	r31
  t_lcd++;
     e48:	80 91 3c 01 	lds	r24, 0x013C
     e4c:	90 91 3d 01 	lds	r25, 0x013D
     e50:	01 96       	adiw	r24, 0x01	; 1
     e52:	90 93 3d 01 	sts	0x013D, r25
     e56:	80 93 3c 01 	sts	0x013C, r24
  
  irc_watch();
     e5a:	0e 94 62 0f 	call	0x1ec4	; 0x1ec4 <irc_watch>
  wtch_main();
     e5e:	0e 94 15 30 	call	0x602a	; 0x602a <wtch_main>
  
}
     e62:	ff 91       	pop	r31
     e64:	ef 91       	pop	r30
     e66:	bf 91       	pop	r27
     e68:	af 91       	pop	r26
     e6a:	9f 91       	pop	r25
     e6c:	8f 91       	pop	r24
     e6e:	7f 91       	pop	r23
     e70:	6f 91       	pop	r22
     e72:	5f 91       	pop	r21
     e74:	4f 91       	pop	r20
     e76:	3f 91       	pop	r19
     e78:	2f 91       	pop	r18
     e7a:	0f 90       	pop	r0
     e7c:	0f be       	out	0x3f, r0	; 63
     e7e:	0f 90       	pop	r0
     e80:	1f 90       	pop	r1
     e82:	18 95       	reti

00000e84 <test_shutdown>:
void test_shutdown(void){
  uint8_t time = 0;
  uint16_t i = 0;
//  char * s = __FILE__;

  if (((PIND >> 2) & (0x01)) == 0){
     e84:	80 b3       	in	r24, 0x10	; 16
     e86:	86 95       	lsr	r24
     e88:	86 95       	lsr	r24
     e8a:	80 fd       	sbrc	r24, 0
     e8c:	38 c0       	rjmp	.+112    	; 0xefe <test_shutdown+0x7a>
    eeprom_save();
     e8e:	0e 94 d9 10 	call	0x21b2	; 0x21b2 <eeprom_save>
     e92:	20 e0       	ldi	r18, 0x00	; 0
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
     e94:	40 ed       	ldi	r20, 0xD0	; 208
     e96:	57 e0       	ldi	r21, 0x07	; 7
     e98:	01 c0       	rjmp	.+2      	; 0xe9c <test_shutdown+0x18>
     e9a:	20 e0       	ldi	r18, 0x00	; 0
     e9c:	ca 01       	movw	r24, r20
     e9e:	01 97       	sbiw	r24, 0x01	; 1
     ea0:	f1 f7       	brne	.-4      	; 0xe9e <test_shutdown+0x1a>

    //Tenhle while bÏh· dokola. Pokud alespÚ na 5 ms naskoËÌ na pinu 2 portu d
    //jedniËka, Ëek·nÌ skonËÌ.
    while(1){
      _delay_ms(1);
      wtch_reset2();
     ea2:	a8 95       	wdr

      if (((PIND >> 2) & (0x01)) == 0)
     ea4:	82 9b       	sbis	0x10, 2	; 16
     ea6:	f9 cf       	rjmp	.-14     	; 0xe9a <test_shutdown+0x16>
        time = 0;
      else
        time++;
     ea8:	2f 5f       	subi	r18, 0xFF	; 255

      if (time > 5)
     eaa:	26 30       	cpi	r18, 0x06	; 6
     eac:	b8 f3       	brcs	.-18     	; 0xe9c <test_shutdown+0x18>
     eae:	20 e0       	ldi	r18, 0x00	; 0
     eb0:	30 e0       	ldi	r19, 0x00	; 0
     eb2:	40 ed       	ldi	r20, 0xD0	; 208
     eb4:	57 e0       	ldi	r21, 0x07	; 7
    }

    // poËk·me vte¯inku
    // to je kv˘li tomu, aby napötÌ na kondenz·toru vylezlo nad 4.5 V, coû je nutnÈ pro chod LCD
    for(i=0 ; i < 500;i++){
      wtch_reset2();
     eb6:	a8 95       	wdr
     eb8:	ca 01       	movw	r24, r20
     eba:	01 97       	sbiw	r24, 0x01	; 1
     ebc:	f1 f7       	brne	.-4      	; 0xeba <test_shutdown+0x36>
        break;
    }

    // poËk·me vte¯inku
    // to je kv˘li tomu, aby napötÌ na kondenz·toru vylezlo nad 4.5 V, coû je nutnÈ pro chod LCD
    for(i=0 ; i < 500;i++){
     ebe:	2f 5f       	subi	r18, 0xFF	; 255
     ec0:	3f 4f       	sbci	r19, 0xFF	; 255
     ec2:	81 e0       	ldi	r24, 0x01	; 1
     ec4:	24 3f       	cpi	r18, 0xF4	; 244
     ec6:	38 07       	cpc	r19, r24
     ec8:	b1 f7       	brne	.-20     	; 0xeb6 <test_shutdown+0x32>
     eca:	10 92 18 02 	sts	0x0218, r1
     ece:	10 92 17 02 	sts	0x0217, r1
      wtch_reset2();
      _delay_ms(1);
    }
    lcd_w_inst(0x01);
     ed2:	81 e0       	ldi	r24, 0x01	; 1
     ed4:	0e 94 12 12 	call	0x2424	; 0x2424 <lcd_w_inst>
    printnt_P((void *)err98); // V˝padek nap·jenÌ - reset.
     ed8:	84 e3       	ldi	r24, 0x34	; 52
     eda:	92 e0       	ldi	r25, 0x02	; 2
     edc:	0e 94 ee 11 	call	0x23dc	; 0x23dc <printnt_P>
     ee0:	20 e0       	ldi	r18, 0x00	; 0
     ee2:	30 e0       	ldi	r19, 0x00	; 0
     ee4:	40 ed       	ldi	r20, 0xD0	; 208
     ee6:	57 e0       	ldi	r21, 0x07	; 7

    for(i=0 ; i < 5000;i++){
       wtch_reset2();
     ee8:	a8 95       	wdr
     eea:	ca 01       	movw	r24, r20
     eec:	01 97       	sbiw	r24, 0x01	; 1
     eee:	f1 f7       	brne	.-4      	; 0xeec <test_shutdown+0x68>
      _delay_ms(1);
    }
    lcd_w_inst(0x01);
    printnt_P((void *)err98); // V˝padek nap·jenÌ - reset.

    for(i=0 ; i < 5000;i++){
     ef0:	2f 5f       	subi	r18, 0xFF	; 255
     ef2:	3f 4f       	sbci	r19, 0xFF	; 255
     ef4:	83 e1       	ldi	r24, 0x13	; 19
     ef6:	28 38       	cpi	r18, 0x88	; 136
     ef8:	38 07       	cpc	r19, r24
     efa:	b1 f7       	brne	.-20     	; 0xee8 <test_shutdown+0x64>
     efc:	ff cf       	rjmp	.-2      	; 0xefc <test_shutdown+0x78>
     efe:	08 95       	ret

00000f00 <main>:
 * kterÈ obsluhujÌ LCD, kl·vesnici, zajiö_tujÌ mÏ¯enÌ atd.
 *
 * »·st funkcÌ (nap¯ obsluha LCD, nebo kontrola IRC) je ËasovÏ kritick·. Jejich
 * vol·nÌ je proto prov·dÏno v z·vislosti na ËasocaËi.
 */
int main(void){
     f00:	20 e0       	ldi	r18, 0x00	; 0
     f02:	40 ed       	ldi	r20, 0xD0	; 208
     f04:	57 e0       	ldi	r21, 0x07	; 7
     f06:	ca 01       	movw	r24, r20
     f08:	01 97       	sbiw	r24, 0x01	; 1
     f0a:	f1 f7       	brne	.-4      	; 0xf08 <main+0x8>
  char c = 0;
  char i;


  for(i=0 ; i <200;i++){
     f0c:	2f 5f       	subi	r18, 0xFF	; 255
     f0e:	28 3c       	cpi	r18, 0xC8	; 200
     f10:	d1 f7       	brne	.-12     	; 0xf06 <main+0x6>
/// Inicializace ËÌtaËe pro vol·nÌ inkrement·lnÌho Ëidla
void ioinit (void) {
  int pocet_cyklu = 500;

  // citac bude citat v kaûdÈm cyklu, reûim - Clear Timer on Compare (CTC)
  TCCR1B = (1 << CS10) | (1 << WGM12);
     f12:	89 e0       	ldi	r24, 0x09	; 9
     f14:	8e bd       	out	0x2e, r24	; 46
  // nastaveni p¯eruöenÌ p¯i porovn·nÌ
  TIMSK = (1 << OCIE1A);
     f16:	80 e1       	ldi	r24, 0x10	; 16
     f18:	89 bf       	out	0x39, r24	; 57

  // NastavenÌ jak Ëasto se bude volat 
  OCR1AH = (unsigned char)(pocet_cyklu >> 8);
     f1a:	81 e0       	ldi	r24, 0x01	; 1
     f1c:	8b bd       	out	0x2b, r24	; 43
  OCR1AL = (unsigned char) pocet_cyklu;
     f1e:	84 ef       	ldi	r24, 0xF4	; 244
     f20:	8a bd       	out	0x2a, r24	; 42
  }

  // ioinit prehodit lcd_control, zapnout cas na zacatku
  ioinit();

  DDRC = 128; //testy
     f22:	80 e8       	ldi	r24, 0x80	; 128
     f24:	84 bb       	out	0x14, r24	; 20
  PORTC=0;
     f26:	15 ba       	out	0x15, r1	; 21
  PORTD = _BV(7);
     f28:	82 bb       	out	0x12, r24	; 18
  
  irc_init();
     f2a:	0e 94 26 0f 	call	0x1e4c	; 0x1e4c <irc_init>
  lcd_init();
     f2e:	0e 94 2a 12 	call	0x2454	; 0x2454 <lcd_init>
  
  eeprom_load();
     f32:	0e 94 30 11 	call	0x2260	; 0x2260 <eeprom_load>

  gui_init();
     f36:	0e 94 02 19 	call	0x3204	; 0x3204 <gui_init>

  keyboard_init();
     f3a:	0e 94 28 1d 	call	0x3a50	; 0x3a50 <keyboard_init>

  buttons_init();
     f3e:	0e 94 56 2f 	call	0x5eac	; 0x5eac <buttons_init>
  USART_Init(51);
     f42:	83 e3       	ldi	r24, 0x33	; 51
     f44:	90 e0       	ldi	r25, 0x00	; 0
     f46:	0e 94 da 0b 	call	0x17b4	; 0x17b4 <USART_Init>
  msr_init();
     f4a:	0e 94 7a 0a 	call	0x14f4	; 0x14f4 <msr_init>
  wtch_init();
     f4e:	0e 94 07 30 	call	0x600e	; 0x600e <wtch_init>



  sei();
     f52:	78 94       	sei

  get_data_from_katr();
     f54:	0e 94 df 06 	call	0xdbe	; 0xdbe <get_data_from_katr>
  while(1){
    c++;

    if (t_lcd > T_LCD_MAX){
     f58:	80 91 3c 01 	lds	r24, 0x013C
     f5c:	90 91 3d 01 	lds	r25, 0x013D
     f60:	06 97       	sbiw	r24, 0x06	; 6
     f62:	60 f0       	brcs	.+24     	; 0xf7c <main+0x7c>
      lcd_control();
     f64:	0e 94 b9 12 	call	0x2572	; 0x2572 <lcd_control>
      t_lcd = 0;
     f68:	10 92 3d 01 	sts	0x013D, r1
     f6c:	10 92 3c 01 	sts	0x013C, r1
      gui_control();
     f70:	0e 94 d5 18 	call	0x31aa	; 0x31aa <gui_control>
      keyboard_recv_watchdog();
     f74:	0e 94 31 1d 	call	0x3a62	; 0x3a62 <keyboard_recv_watchdog>
      serial_msg_ack_timer();
     f78:	0e 94 8c 0c 	call	0x1918	; 0x1918 <serial_msg_ack_timer>
     
      
    } 

    buttons();
     f7c:	0e 94 5d 2f 	call	0x5eba	; 0x5eba <buttons>
    measure();
     f80:	0e 94 25 0b 	call	0x164a	; 0x164a <measure>
    test_shutdown();
     f84:	0e 94 42 07 	call	0xe84	; 0xe84 <test_shutdown>
    err_control();
     f88:	0e 94 b3 19 	call	0x3366	; 0x3366 <err_control>
    wtch_reset2();
     f8c:	10 92 18 02 	sts	0x0218, r1
     f90:	10 92 17 02 	sts	0x0217, r1
     f94:	a8 95       	wdr
     f96:	e0 cf       	rjmp	.-64     	; 0xf58 <main+0x58>

00000f98 <msr_storno>:

/**
 * Funkce p¯eruöÌ mÏ¯enÌ. 
 */
void msr_storno(void){
  msr_status = VOLNO;
     f98:	10 92 44 01 	sts	0x0144, r1
  n_mereni = 0;
     f9c:	10 92 63 00 	sts	0x0063, r1
}
     fa0:	08 95       	ret

00000fa2 <msr_pause>:

void msr_pause(void){
  msr_status = (msr_status + 3);
     fa2:	80 91 44 01 	lds	r24, 0x0144
     fa6:	8d 5f       	subi	r24, 0xFD	; 253
     fa8:	80 93 44 01 	sts	0x0144, r24
}
     fac:	08 95       	ret

00000fae <prumeruj>:
    (i * ((float)(1.0 / (POCET_MERENI - 1))) * (msr_delka - (MIN_VZDAL_OD_KATRU + MIN_VZDAL_OD_VOZIKU)));
  }
}

/// Funkce pr˘mÏuje hodnoty pole
uint16_t prumeruj(uint16_t pole[], uint8_t len){
     fae:	ef 92       	push	r14
     fb0:	ff 92       	push	r15
     fb2:	0f 93       	push	r16
     fb4:	1f 93       	push	r17
     fb6:	fc 01       	movw	r30, r24
     fb8:	20 e0       	ldi	r18, 0x00	; 0
     fba:	30 e0       	ldi	r19, 0x00	; 0
     fbc:	ee 24       	eor	r14, r14
     fbe:	ff 24       	eor	r15, r15
     fc0:	87 01       	movw	r16, r14
  int i;
  uint32_t suma = 0;
  for (i = 0; i < len; i++){
     fc2:	46 2f       	mov	r20, r22
     fc4:	50 e0       	ldi	r21, 0x00	; 0
     fc6:	0a c0       	rjmp	.+20     	; 0xfdc <prumeruj+0x2e>
    suma += pole[i];
     fc8:	81 91       	ld	r24, Z+
     fca:	91 91       	ld	r25, Z+
     fcc:	a0 e0       	ldi	r26, 0x00	; 0
     fce:	b0 e0       	ldi	r27, 0x00	; 0
     fd0:	e8 0e       	add	r14, r24
     fd2:	f9 1e       	adc	r15, r25
     fd4:	0a 1f       	adc	r16, r26
     fd6:	1b 1f       	adc	r17, r27

/// Funkce pr˘mÏuje hodnoty pole
uint16_t prumeruj(uint16_t pole[], uint8_t len){
  int i;
  uint32_t suma = 0;
  for (i = 0; i < len; i++){
     fd8:	2f 5f       	subi	r18, 0xFF	; 255
     fda:	3f 4f       	sbci	r19, 0xFF	; 255
     fdc:	24 17       	cp	r18, r20
     fde:	35 07       	cpc	r19, r21
     fe0:	9c f3       	brlt	.-26     	; 0xfc8 <prumeruj+0x1a>
     fe2:	26 2f       	mov	r18, r22
     fe4:	30 e0       	ldi	r19, 0x00	; 0
     fe6:	40 e0       	ldi	r20, 0x00	; 0
     fe8:	50 e0       	ldi	r21, 0x00	; 0
     fea:	c8 01       	movw	r24, r16
     fec:	b7 01       	movw	r22, r14
     fee:	0e 94 a9 3b 	call	0x7752	; 0x7752 <__udivmodsi4>
     ff2:	c9 01       	movw	r24, r18
    suma += pole[i];
  }
  return (suma / len);
}
     ff4:	1f 91       	pop	r17
     ff6:	0f 91       	pop	r16
     ff8:	ff 90       	pop	r15
     ffa:	ef 90       	pop	r14
     ffc:	08 95       	ret

00000ffe <get_k>:


/// V˝poËet metody line·rnÌ regrese.
/// @returns VracÌ hodnotu k
float get_k(uint16_t pole_d[],uint16_t pole_l [], uint8_t len){
     ffe:	2f 92       	push	r2
    1000:	3f 92       	push	r3
    1002:	4f 92       	push	r4
    1004:	5f 92       	push	r5
    1006:	6f 92       	push	r6
    1008:	7f 92       	push	r7
    100a:	8f 92       	push	r8
    100c:	9f 92       	push	r9
    100e:	af 92       	push	r10
    1010:	bf 92       	push	r11
    1012:	cf 92       	push	r12
    1014:	df 92       	push	r13
    1016:	ef 92       	push	r14
    1018:	ff 92       	push	r15
    101a:	0f 93       	push	r16
    101c:	1f 93       	push	r17
    101e:	df 93       	push	r29
    1020:	cf 93       	push	r28
    1022:	cd b7       	in	r28, 0x3d	; 61
    1024:	de b7       	in	r29, 0x3e	; 62
    1026:	28 97       	sbiw	r28, 0x08	; 8
    1028:	0f b6       	in	r0, 0x3f	; 63
    102a:	f8 94       	cli
    102c:	de bf       	out	0x3e, r29	; 62
    102e:	0f be       	out	0x3f, r0	; 63
    1030:	cd bf       	out	0x3d, r28	; 61
    1032:	b8 2e       	mov	r11, r24
    1034:	a9 2e       	mov	r10, r25
  int i;
  float l_str = 0;  
  float citatel = 0; // \sum (I - \overline{I}) F_I
  float jmenovatel = 0; // \sum( (I - \overline{I})^2 )

  if (len < 2){			/* Osetreni nizkeho poctu mereni */
    1036:	42 30       	cpi	r20, 0x02	; 2
    1038:	28 f4       	brcc	.+10     	; 0x1044 <get_k+0x46>
    103a:	e0 e0       	ldi	r30, 0x00	; 0
    103c:	70 e0       	ldi	r23, 0x00	; 0
    103e:	80 e0       	ldi	r24, 0x00	; 0
    1040:	60 e0       	ldi	r22, 0x00	; 0
    1042:	91 c0       	rjmp	.+290    	; 0x1166 <get_k+0x168>
    1044:	1b 01       	movw	r2, r22
    1046:	6b 01       	movw	r12, r22
    1048:	88 24       	eor	r8, r8
    104a:	99 24       	eor	r9, r9
    104c:	0f 2e       	mov	r0, r31
    104e:	f0 e0       	ldi	r31, 0x00	; 0
    1050:	ef 2e       	mov	r14, r31
    1052:	f0 e0       	ldi	r31, 0x00	; 0
    1054:	ff 2e       	mov	r15, r31
    1056:	f0 e0       	ldi	r31, 0x00	; 0
    1058:	0f 2f       	mov	r16, r31
    105a:	f0 e0       	ldi	r31, 0x00	; 0
    105c:	1f 2f       	mov	r17, r31
    105e:	f0 2d       	mov	r31, r0
    return 0;
  }

  
  for (i = 0; i < len; i++){
    1060:	44 2e       	mov	r4, r20
    1062:	55 24       	eor	r5, r5
    1064:	13 c0       	rjmp	.+38     	; 0x108c <get_k+0x8e>
    l_str += pole_l[i];
    1066:	f6 01       	movw	r30, r12
    1068:	61 91       	ld	r22, Z+
    106a:	71 91       	ld	r23, Z+
    106c:	6f 01       	movw	r12, r30
    106e:	80 e0       	ldi	r24, 0x00	; 0
    1070:	90 e0       	ldi	r25, 0x00	; 0
    1072:	0e 94 69 3a 	call	0x74d2	; 0x74d2 <__floatunsisf>
    1076:	9b 01       	movw	r18, r22
    1078:	ac 01       	movw	r20, r24
    107a:	c8 01       	movw	r24, r16
    107c:	b7 01       	movw	r22, r14
    107e:	0e 94 68 39 	call	0x72d0	; 0x72d0 <__addsf3>
    1082:	7b 01       	movw	r14, r22
    1084:	8c 01       	movw	r16, r24
  if (len < 2){			/* Osetreni nizkeho poctu mereni */
    return 0;
  }

  
  for (i = 0; i < len; i++){
    1086:	08 94       	sec
    1088:	81 1c       	adc	r8, r1
    108a:	91 1c       	adc	r9, r1
    108c:	84 14       	cp	r8, r4
    108e:	95 04       	cpc	r9, r5
    1090:	54 f3       	brlt	.-44     	; 0x1066 <get_k+0x68>
    l_str += pole_l[i];
  }

  l_str = l_str / len; // st¯ednÌ hodnota l
    1092:	b2 01       	movw	r22, r4
    1094:	88 27       	eor	r24, r24
    1096:	77 fd       	sbrc	r23, 7
    1098:	80 95       	com	r24
    109a:	98 2f       	mov	r25, r24
    109c:	0e 94 6b 3a 	call	0x74d6	; 0x74d6 <__floatsisf>
    10a0:	9b 01       	movw	r18, r22
    10a2:	ac 01       	movw	r20, r24
    10a4:	c8 01       	movw	r24, r16
    10a6:	b7 01       	movw	r22, r14
    10a8:	0e 94 d0 39 	call	0x73a0	; 0x73a0 <__divsf3>
    10ac:	69 83       	std	Y+1, r22	; 0x01
    10ae:	7a 83       	std	Y+2, r23	; 0x02
    10b0:	8b 83       	std	Y+3, r24	; 0x03
    10b2:	9c 83       	std	Y+4, r25	; 0x04
    10b4:	2b 2d       	mov	r18, r11
    10b6:	3a 2d       	mov	r19, r10
    10b8:	c9 01       	movw	r24, r18
    10ba:	9e 83       	std	Y+6, r25	; 0x06
    10bc:	8d 83       	std	Y+5, r24	; 0x05
    10be:	18 86       	std	Y+8, r1	; 0x08
    10c0:	1f 82       	std	Y+7, r1	; 0x07
    10c2:	0f 2e       	mov	r0, r31
    10c4:	f0 e0       	ldi	r31, 0x00	; 0
    10c6:	6f 2e       	mov	r6, r31
    10c8:	f0 e0       	ldi	r31, 0x00	; 0
    10ca:	7f 2e       	mov	r7, r31
    10cc:	f0 e0       	ldi	r31, 0x00	; 0
    10ce:	8f 2e       	mov	r8, r31
    10d0:	f0 e0       	ldi	r31, 0x00	; 0
    10d2:	9f 2e       	mov	r9, r31
    10d4:	f0 2d       	mov	r31, r0
    10d6:	64 01       	movw	r12, r8
    10d8:	53 01       	movw	r10, r6
  
  for (i = 0; i < len; i++){
    citatel += (pole_l[i] - l_str) * pole_d[i];
    10da:	f1 01       	movw	r30, r2
    10dc:	61 91       	ld	r22, Z+
    10de:	71 91       	ld	r23, Z+
    10e0:	1f 01       	movw	r2, r30
    10e2:	80 e0       	ldi	r24, 0x00	; 0
    10e4:	90 e0       	ldi	r25, 0x00	; 0
    10e6:	0e 94 69 3a 	call	0x74d2	; 0x74d2 <__floatunsisf>
    10ea:	29 81       	ldd	r18, Y+1	; 0x01
    10ec:	3a 81       	ldd	r19, Y+2	; 0x02
    10ee:	4b 81       	ldd	r20, Y+3	; 0x03
    10f0:	5c 81       	ldd	r21, Y+4	; 0x04
    10f2:	0e 94 67 39 	call	0x72ce	; 0x72ce <__subsf3>
    10f6:	7b 01       	movw	r14, r22
    10f8:	8c 01       	movw	r16, r24
    10fa:	ed 81       	ldd	r30, Y+5	; 0x05
    10fc:	fe 81       	ldd	r31, Y+6	; 0x06
    10fe:	61 91       	ld	r22, Z+
    1100:	71 91       	ld	r23, Z+
    1102:	fe 83       	std	Y+6, r31	; 0x06
    1104:	ed 83       	std	Y+5, r30	; 0x05
    1106:	80 e0       	ldi	r24, 0x00	; 0
    1108:	90 e0       	ldi	r25, 0x00	; 0
    110a:	0e 94 69 3a 	call	0x74d2	; 0x74d2 <__floatunsisf>
    110e:	9b 01       	movw	r18, r22
    1110:	ac 01       	movw	r20, r24
    1112:	c8 01       	movw	r24, r16
    1114:	b7 01       	movw	r22, r14
    1116:	0e 94 1f 3b 	call	0x763e	; 0x763e <__mulsf3>
    111a:	9b 01       	movw	r18, r22
    111c:	ac 01       	movw	r20, r24
    111e:	c4 01       	movw	r24, r8
    1120:	b3 01       	movw	r22, r6
    1122:	0e 94 68 39 	call	0x72d0	; 0x72d0 <__addsf3>
    1126:	3b 01       	movw	r6, r22
    1128:	4c 01       	movw	r8, r24
    jmenovatel += (pole_l[i] - l_str) * (pole_l[i] - l_str);
    112a:	c8 01       	movw	r24, r16
    112c:	b7 01       	movw	r22, r14
    112e:	a8 01       	movw	r20, r16
    1130:	97 01       	movw	r18, r14
    1132:	0e 94 1f 3b 	call	0x763e	; 0x763e <__mulsf3>
    1136:	9b 01       	movw	r18, r22
    1138:	ac 01       	movw	r20, r24
    113a:	c6 01       	movw	r24, r12
    113c:	b5 01       	movw	r22, r10
    113e:	0e 94 68 39 	call	0x72d0	; 0x72d0 <__addsf3>
    1142:	5b 01       	movw	r10, r22
    1144:	6c 01       	movw	r12, r24
    l_str += pole_l[i];
  }

  l_str = l_str / len; // st¯ednÌ hodnota l
  
  for (i = 0; i < len; i++){
    1146:	8f 81       	ldd	r24, Y+7	; 0x07
    1148:	98 85       	ldd	r25, Y+8	; 0x08
    114a:	01 96       	adiw	r24, 0x01	; 1
    114c:	98 87       	std	Y+8, r25	; 0x08
    114e:	8f 83       	std	Y+7, r24	; 0x07
    1150:	84 15       	cp	r24, r4
    1152:	95 05       	cpc	r25, r5
    1154:	14 f2       	brlt	.-124    	; 0x10da <get_k+0xdc>
    citatel += (pole_l[i] - l_str) * pole_d[i];
    jmenovatel += (pole_l[i] - l_str) * (pole_l[i] - l_str);
  }
  return (float) (((float)citatel) / jmenovatel);
    1156:	c4 01       	movw	r24, r8
    1158:	b3 01       	movw	r22, r6
    115a:	a6 01       	movw	r20, r12
    115c:	95 01       	movw	r18, r10
    115e:	0e 94 d0 39 	call	0x73a0	; 0x73a0 <__divsf3>
    1162:	e6 2f       	mov	r30, r22
    1164:	69 2f       	mov	r22, r25
}
    1166:	2e 2f       	mov	r18, r30
    1168:	37 2f       	mov	r19, r23
    116a:	48 2f       	mov	r20, r24
    116c:	56 2f       	mov	r21, r22
    116e:	b9 01       	movw	r22, r18
    1170:	ca 01       	movw	r24, r20
    1172:	28 96       	adiw	r28, 0x08	; 8
    1174:	0f b6       	in	r0, 0x3f	; 63
    1176:	f8 94       	cli
    1178:	de bf       	out	0x3e, r29	; 62
    117a:	0f be       	out	0x3f, r0	; 63
    117c:	cd bf       	out	0x3d, r28	; 61
    117e:	cf 91       	pop	r28
    1180:	df 91       	pop	r29
    1182:	1f 91       	pop	r17
    1184:	0f 91       	pop	r16
    1186:	ff 90       	pop	r15
    1188:	ef 90       	pop	r14
    118a:	df 90       	pop	r13
    118c:	cf 90       	pop	r12
    118e:	bf 90       	pop	r11
    1190:	af 90       	pop	r10
    1192:	9f 90       	pop	r9
    1194:	8f 90       	pop	r8
    1196:	7f 90       	pop	r7
    1198:	6f 90       	pop	r6
    119a:	5f 90       	pop	r5
    119c:	4f 90       	pop	r4
    119e:	3f 90       	pop	r3
    11a0:	2f 90       	pop	r2
    11a2:	08 95       	ret

000011a4 <get_q>:

float get_q(uint16_t pole_d[],uint16_t pole_l [], uint8_t len, float k){
    11a4:	2f 92       	push	r2
    11a6:	3f 92       	push	r3
    11a8:	4f 92       	push	r4
    11aa:	5f 92       	push	r5
    11ac:	6f 92       	push	r6
    11ae:	7f 92       	push	r7
    11b0:	8f 92       	push	r8
    11b2:	9f 92       	push	r9
    11b4:	af 92       	push	r10
    11b6:	bf 92       	push	r11
    11b8:	cf 92       	push	r12
    11ba:	df 92       	push	r13
    11bc:	ef 92       	push	r14
    11be:	ff 92       	push	r15
    11c0:	0f 93       	push	r16
    11c2:	1f 93       	push	r17
    11c4:	df 93       	push	r29
    11c6:	cf 93       	push	r28
    11c8:	00 d0       	rcall	.+0      	; 0x11ca <get_q+0x26>
    11ca:	00 d0       	rcall	.+0      	; 0x11cc <get_q+0x28>
    11cc:	cd b7       	in	r28, 0x3d	; 61
    11ce:	de b7       	in	r29, 0x3e	; 62
    11d0:	58 2f       	mov	r21, r24
    11d2:	e9 2f       	mov	r30, r25
    11d4:	09 83       	std	Y+1, r16	; 0x01
    11d6:	1a 83       	std	Y+2, r17	; 0x02
    11d8:	2b 83       	std	Y+3, r18	; 0x03
    11da:	3c 83       	std	Y+4, r19	; 0x04
  int i;
  float l_str = 0;  
  float d_str = 0;

  if (len < 1){
    11dc:	44 23       	and	r20, r20
    11de:	29 f4       	brne	.+10     	; 0x11ea <get_q+0x46>
    11e0:	e0 e0       	ldi	r30, 0x00	; 0
    11e2:	70 e0       	ldi	r23, 0x00	; 0
    11e4:	80 e0       	ldi	r24, 0x00	; 0
    11e6:	60 e0       	ldi	r22, 0x00	; 0
    11e8:	62 c0       	rjmp	.+196    	; 0x12ae <get_q+0x10a>
    11ea:	2b 01       	movw	r4, r22
    11ec:	25 2f       	mov	r18, r21
    11ee:	3e 2f       	mov	r19, r30
    11f0:	c9 01       	movw	r24, r18
    11f2:	7c 01       	movw	r14, r24
    11f4:	00 e0       	ldi	r16, 0x00	; 0
    11f6:	10 e0       	ldi	r17, 0x00	; 0
    11f8:	0f 2e       	mov	r0, r31
    11fa:	f0 e0       	ldi	r31, 0x00	; 0
    11fc:	6f 2e       	mov	r6, r31
    11fe:	f0 e0       	ldi	r31, 0x00	; 0
    1200:	7f 2e       	mov	r7, r31
    1202:	f0 e0       	ldi	r31, 0x00	; 0
    1204:	8f 2e       	mov	r8, r31
    1206:	f0 e0       	ldi	r31, 0x00	; 0
    1208:	9f 2e       	mov	r9, r31
    120a:	f0 2d       	mov	r31, r0
    120c:	64 01       	movw	r12, r8
    120e:	53 01       	movw	r10, r6
    return 0;
  }

  for (i = 0; i < len; i++){
    1210:	24 2e       	mov	r2, r20
    1212:	33 24       	eor	r3, r3
    1214:	22 c0       	rjmp	.+68     	; 0x125a <get_q+0xb6>
    l_str += pole_l[i];
    1216:	d2 01       	movw	r26, r4
    1218:	6d 91       	ld	r22, X+
    121a:	7d 91       	ld	r23, X+
    121c:	2d 01       	movw	r4, r26
    121e:	80 e0       	ldi	r24, 0x00	; 0
    1220:	90 e0       	ldi	r25, 0x00	; 0
    1222:	0e 94 69 3a 	call	0x74d2	; 0x74d2 <__floatunsisf>
    1226:	9b 01       	movw	r18, r22
    1228:	ac 01       	movw	r20, r24
    122a:	c4 01       	movw	r24, r8
    122c:	b3 01       	movw	r22, r6
    122e:	0e 94 68 39 	call	0x72d0	; 0x72d0 <__addsf3>
    1232:	3b 01       	movw	r6, r22
    1234:	4c 01       	movw	r8, r24
    d_str += pole_d[i];
    1236:	f7 01       	movw	r30, r14
    1238:	61 91       	ld	r22, Z+
    123a:	71 91       	ld	r23, Z+
    123c:	7f 01       	movw	r14, r30
    123e:	80 e0       	ldi	r24, 0x00	; 0
    1240:	90 e0       	ldi	r25, 0x00	; 0
    1242:	0e 94 69 3a 	call	0x74d2	; 0x74d2 <__floatunsisf>
    1246:	9b 01       	movw	r18, r22
    1248:	ac 01       	movw	r20, r24
    124a:	c6 01       	movw	r24, r12
    124c:	b5 01       	movw	r22, r10
    124e:	0e 94 68 39 	call	0x72d0	; 0x72d0 <__addsf3>
    1252:	5b 01       	movw	r10, r22
    1254:	6c 01       	movw	r12, r24

  if (len < 1){
    return 0;
  }

  for (i = 0; i < len; i++){
    1256:	0f 5f       	subi	r16, 0xFF	; 255
    1258:	1f 4f       	sbci	r17, 0xFF	; 255
    125a:	02 15       	cp	r16, r2
    125c:	13 05       	cpc	r17, r3
    125e:	dc f2       	brlt	.-74     	; 0x1216 <get_q+0x72>
    l_str += pole_l[i];
    d_str += pole_d[i];
  }
  l_str = l_str / len; // st¯ednÌ hodnota l
    1260:	b1 01       	movw	r22, r2
    1262:	88 27       	eor	r24, r24
    1264:	77 fd       	sbrc	r23, 7
    1266:	80 95       	com	r24
    1268:	98 2f       	mov	r25, r24
    126a:	0e 94 6b 3a 	call	0x74d6	; 0x74d6 <__floatsisf>
    126e:	7b 01       	movw	r14, r22
    1270:	8c 01       	movw	r16, r24
  d_str = d_str / len;

  return d_str - (k * l_str);
    1272:	c6 01       	movw	r24, r12
    1274:	b5 01       	movw	r22, r10
    1276:	a8 01       	movw	r20, r16
    1278:	97 01       	movw	r18, r14
    127a:	0e 94 d0 39 	call	0x73a0	; 0x73a0 <__divsf3>
    127e:	5b 01       	movw	r10, r22
    1280:	6c 01       	movw	r12, r24
    1282:	c4 01       	movw	r24, r8
    1284:	b3 01       	movw	r22, r6
    1286:	a8 01       	movw	r20, r16
    1288:	97 01       	movw	r18, r14
    128a:	0e 94 d0 39 	call	0x73a0	; 0x73a0 <__divsf3>
    128e:	9b 01       	movw	r18, r22
    1290:	ac 01       	movw	r20, r24
    1292:	69 81       	ldd	r22, Y+1	; 0x01
    1294:	7a 81       	ldd	r23, Y+2	; 0x02
    1296:	8b 81       	ldd	r24, Y+3	; 0x03
    1298:	9c 81       	ldd	r25, Y+4	; 0x04
    129a:	0e 94 1f 3b 	call	0x763e	; 0x763e <__mulsf3>
    129e:	9b 01       	movw	r18, r22
    12a0:	ac 01       	movw	r20, r24
    12a2:	c6 01       	movw	r24, r12
    12a4:	b5 01       	movw	r22, r10
    12a6:	0e 94 67 39 	call	0x72ce	; 0x72ce <__subsf3>
    12aa:	e6 2f       	mov	r30, r22
    12ac:	69 2f       	mov	r22, r25
}
    12ae:	2e 2f       	mov	r18, r30
    12b0:	37 2f       	mov	r19, r23
    12b2:	48 2f       	mov	r20, r24
    12b4:	56 2f       	mov	r21, r22
    12b6:	b9 01       	movw	r22, r18
    12b8:	ca 01       	movw	r24, r20
    12ba:	0f 90       	pop	r0
    12bc:	0f 90       	pop	r0
    12be:	0f 90       	pop	r0
    12c0:	0f 90       	pop	r0
    12c2:	cf 91       	pop	r28
    12c4:	df 91       	pop	r29
    12c6:	1f 91       	pop	r17
    12c8:	0f 91       	pop	r16
    12ca:	ff 90       	pop	r15
    12cc:	ef 90       	pop	r14
    12ce:	df 90       	pop	r13
    12d0:	cf 90       	pop	r12
    12d2:	bf 90       	pop	r11
    12d4:	af 90       	pop	r10
    12d6:	9f 90       	pop	r9
    12d8:	8f 90       	pop	r8
    12da:	7f 90       	pop	r7
    12dc:	6f 90       	pop	r6
    12de:	5f 90       	pop	r5
    12e0:	4f 90       	pop	r4
    12e2:	3f 90       	pop	r3
    12e4:	2f 90       	pop	r2
    12e6:	08 95       	ret

000012e8 <msr_end>:
  // indikace stavu svÏtlem
  indikace_stavu_control();
}

/// Prov·dÌ v˝poËty po ukonËenÌ mÏ¯enÌ.
void msr_end(void){
    12e8:	4f 92       	push	r4
    12ea:	5f 92       	push	r5
    12ec:	6f 92       	push	r6
    12ee:	7f 92       	push	r7
    12f0:	8f 92       	push	r8
    12f2:	9f 92       	push	r9
    12f4:	af 92       	push	r10
    12f6:	bf 92       	push	r11
    12f8:	cf 92       	push	r12
    12fa:	df 92       	push	r13
    12fc:	ef 92       	push	r14
    12fe:	ff 92       	push	r15
    1300:	0f 93       	push	r16
    1302:	1f 93       	push	r17
    1304:	df 93       	push	r29
    1306:	cf 93       	push	r28
    1308:	cd b7       	in	r28, 0x3d	; 61
    130a:	de b7       	in	r29, 0x3e	; 62
    130c:	2c 97       	sbiw	r28, 0x0c	; 12
    130e:	0f b6       	in	r0, 0x3f	; 63
    1310:	f8 94       	cli
    1312:	de bf       	out	0x3e, r29	; 62
    1314:	0f be       	out	0x3f, r0	; 63
    1316:	cd bf       	out	0x3d, r28	; 61
  float k1,q1,k2,q2;
  
  k1 = get_k(mereni_d_v, mereni_l, n_mereni);
    1318:	b0 90 63 00 	lds	r11, 0x0063
    131c:	87 e4       	ldi	r24, 0x47	; 71
    131e:	91 e0       	ldi	r25, 0x01	; 1
    1320:	67 e6       	ldi	r22, 0x67	; 103
    1322:	71 e0       	ldi	r23, 0x01	; 1
    1324:	4b 2d       	mov	r20, r11
    1326:	0e 94 ff 07 	call	0xffe	; 0xffe <get_k>
    132a:	2b 01       	movw	r4, r22
    132c:	3c 01       	movw	r6, r24
  q1 = get_q(mereni_d_v, mereni_l, n_mereni, k1); 
    132e:	87 e4       	ldi	r24, 0x47	; 71
    1330:	91 e0       	ldi	r25, 0x01	; 1
    1332:	67 e6       	ldi	r22, 0x67	; 103
    1334:	71 e0       	ldi	r23, 0x01	; 1
    1336:	4b 2d       	mov	r20, r11
    1338:	93 01       	movw	r18, r6
    133a:	82 01       	movw	r16, r4
    133c:	0e 94 d2 08 	call	0x11a4	; 0x11a4 <get_q>
    1340:	69 87       	std	Y+9, r22	; 0x09
    1342:	7a 87       	std	Y+10, r23	; 0x0a
    1344:	8b 87       	std	Y+11, r24	; 0x0b
    1346:	9c 87       	std	Y+12, r25	; 0x0c
  
  msr_prumer_v = (uint16_t) ((k1 * (msr_delka / 2.0)) + q1);
    1348:	60 91 3e 01 	lds	r22, 0x013E
    134c:	70 91 3f 01 	lds	r23, 0x013F
    1350:	80 e0       	ldi	r24, 0x00	; 0
    1352:	90 e0       	ldi	r25, 0x00	; 0
    1354:	0e 94 69 3a 	call	0x74d2	; 0x74d2 <__floatunsisf>
    1358:	20 e0       	ldi	r18, 0x00	; 0
    135a:	30 e0       	ldi	r19, 0x00	; 0
    135c:	40 e0       	ldi	r20, 0x00	; 0
    135e:	5f e3       	ldi	r21, 0x3F	; 63
    1360:	0e 94 1f 3b 	call	0x763e	; 0x763e <__mulsf3>
    1364:	9b 01       	movw	r18, r22
    1366:	ac 01       	movw	r20, r24
    1368:	c3 01       	movw	r24, r6
    136a:	b2 01       	movw	r22, r4
    136c:	0e 94 1f 3b 	call	0x763e	; 0x763e <__mulsf3>
    1370:	29 85       	ldd	r18, Y+9	; 0x09
    1372:	3a 85       	ldd	r19, Y+10	; 0x0a
    1374:	4b 85       	ldd	r20, Y+11	; 0x0b
    1376:	5c 85       	ldd	r21, Y+12	; 0x0c
    1378:	0e 94 68 39 	call	0x72d0	; 0x72d0 <__addsf3>
    137c:	0e 94 3d 3a 	call	0x747a	; 0x747a <__fixunssfsi>
    1380:	70 93 19 03 	sts	0x0319, r23
    1384:	60 93 18 03 	sts	0x0318, r22
  
  k2 = get_k(mereni_d_h, mereni_l, n_mereni);
    1388:	87 e5       	ldi	r24, 0x57	; 87
    138a:	91 e0       	ldi	r25, 0x01	; 1
    138c:	67 e6       	ldi	r22, 0x67	; 103
    138e:	71 e0       	ldi	r23, 0x01	; 1
    1390:	4b 2d       	mov	r20, r11
    1392:	0e 94 ff 07 	call	0xffe	; 0xffe <get_k>
    1396:	6b 01       	movw	r12, r22
    1398:	7c 01       	movw	r14, r24
  q2 = get_q(mereni_d_h, mereni_l, n_mereni, k2); 
    139a:	87 e5       	ldi	r24, 0x57	; 87
    139c:	91 e0       	ldi	r25, 0x01	; 1
    139e:	67 e6       	ldi	r22, 0x67	; 103
    13a0:	71 e0       	ldi	r23, 0x01	; 1
    13a2:	4b 2d       	mov	r20, r11
    13a4:	97 01       	movw	r18, r14
    13a6:	86 01       	movw	r16, r12
    13a8:	0e 94 d2 08 	call	0x11a4	; 0x11a4 <get_q>
    13ac:	6d 83       	std	Y+5, r22	; 0x05
    13ae:	7e 83       	std	Y+6, r23	; 0x06
    13b0:	8f 83       	std	Y+7, r24	; 0x07
    13b2:	98 87       	std	Y+8, r25	; 0x08
  
  msr_prumer_h = (uint16_t) ((k2 * (msr_delka / 2.0)) + q2);
    13b4:	60 91 3e 01 	lds	r22, 0x013E
    13b8:	70 91 3f 01 	lds	r23, 0x013F
    13bc:	80 e0       	ldi	r24, 0x00	; 0
    13be:	90 e0       	ldi	r25, 0x00	; 0
    13c0:	0e 94 69 3a 	call	0x74d2	; 0x74d2 <__floatunsisf>
    13c4:	69 83       	std	Y+1, r22	; 0x01
    13c6:	7a 83       	std	Y+2, r23	; 0x02
    13c8:	8b 83       	std	Y+3, r24	; 0x03
    13ca:	9c 83       	std	Y+4, r25	; 0x04
    13cc:	20 e0       	ldi	r18, 0x00	; 0
    13ce:	30 e0       	ldi	r19, 0x00	; 0
    13d0:	40 e0       	ldi	r20, 0x00	; 0
    13d2:	5f e3       	ldi	r21, 0x3F	; 63
    13d4:	0e 94 1f 3b 	call	0x763e	; 0x763e <__mulsf3>
    13d8:	4b 01       	movw	r8, r22
    13da:	5c 01       	movw	r10, r24
    13dc:	c7 01       	movw	r24, r14
    13de:	b6 01       	movw	r22, r12
    13e0:	a5 01       	movw	r20, r10
    13e2:	94 01       	movw	r18, r8
    13e4:	0e 94 1f 3b 	call	0x763e	; 0x763e <__mulsf3>
    13e8:	7b 01       	movw	r14, r22
    13ea:	8c 01       	movw	r16, r24
    13ec:	2d 81       	ldd	r18, Y+5	; 0x05
    13ee:	3e 81       	ldd	r19, Y+6	; 0x06
    13f0:	4f 81       	ldd	r20, Y+7	; 0x07
    13f2:	58 85       	ldd	r21, Y+8	; 0x08
    13f4:	0e 94 68 39 	call	0x72d0	; 0x72d0 <__addsf3>
    13f8:	0e 94 3d 3a 	call	0x747a	; 0x747a <__fixunssfsi>
    13fc:	70 93 53 02 	sts	0x0253, r23
    1400:	60 93 52 02 	sts	0x0252, r22
  
  //msr_prumer = (uint16_t) ((((k1 * (msr_delka / 2.0)) + q1 +(k2 * (msr_delka / 2.0)) + q2)) / 2);
  switch (width_src){
    1404:	80 91 60 00 	lds	r24, 0x0060
    1408:	88 23       	and	r24, r24
    140a:	f9 f0       	breq	.+62     	; 0x144a <msr_end+0x162>
    140c:	83 30       	cpi	r24, 0x03	; 3
    140e:	78 f5       	brcc	.+94     	; 0x146e <msr_end+0x186>
  case 1:
  case 2:
    msr_prumer = (uint16_t) ((((k1 * (msr_delka / 2.0)) + q1 +(k2 * (msr_delka / 2.0)) + q2)) / 2);
    1410:	c3 01       	movw	r24, r6
    1412:	b2 01       	movw	r22, r4
    1414:	a5 01       	movw	r20, r10
    1416:	94 01       	movw	r18, r8
    1418:	0e 94 1f 3b 	call	0x763e	; 0x763e <__mulsf3>
    141c:	29 85       	ldd	r18, Y+9	; 0x09
    141e:	3a 85       	ldd	r19, Y+10	; 0x0a
    1420:	4b 85       	ldd	r20, Y+11	; 0x0b
    1422:	5c 85       	ldd	r21, Y+12	; 0x0c
    1424:	0e 94 68 39 	call	0x72d0	; 0x72d0 <__addsf3>
    1428:	a8 01       	movw	r20, r16
    142a:	97 01       	movw	r18, r14
    142c:	0e 94 68 39 	call	0x72d0	; 0x72d0 <__addsf3>
    1430:	2d 81       	ldd	r18, Y+5	; 0x05
    1432:	3e 81       	ldd	r19, Y+6	; 0x06
    1434:	4f 81       	ldd	r20, Y+7	; 0x07
    1436:	58 85       	ldd	r21, Y+8	; 0x08
    1438:	0e 94 68 39 	call	0x72d0	; 0x72d0 <__addsf3>
    143c:	20 e0       	ldi	r18, 0x00	; 0
    143e:	30 e0       	ldi	r19, 0x00	; 0
    1440:	40 e0       	ldi	r20, 0x00	; 0
    1442:	5f e3       	ldi	r21, 0x3F	; 63
    1444:	0e 94 1f 3b 	call	0x763e	; 0x763e <__mulsf3>
    1448:	0c c0       	rjmp	.+24     	; 0x1462 <msr_end+0x17a>
    break;
  case 0:
    msr_prumer = (uint16_t) ((k1 * (msr_delka / 2.0)) + q1);
    144a:	c3 01       	movw	r24, r6
    144c:	b2 01       	movw	r22, r4
    144e:	a5 01       	movw	r20, r10
    1450:	94 01       	movw	r18, r8
    1452:	0e 94 1f 3b 	call	0x763e	; 0x763e <__mulsf3>
    1456:	29 85       	ldd	r18, Y+9	; 0x09
    1458:	3a 85       	ldd	r19, Y+10	; 0x0a
    145a:	4b 85       	ldd	r20, Y+11	; 0x0b
    145c:	5c 85       	ldd	r21, Y+12	; 0x0c
    145e:	0e 94 68 39 	call	0x72d0	; 0x72d0 <__addsf3>
    1462:	0e 94 3d 3a 	call	0x747a	; 0x747a <__fixunssfsi>
    1466:	70 93 41 01 	sts	0x0141, r23
    146a:	60 93 40 01 	sts	0x0140, r22
  default:
    break;
  }
  
  
  msr_objem = (uint32_t)(((3.1415 * (msr_prumer * msr_prumer)/400000.0) * msr_delka)); //00000000
    146e:	80 91 40 01 	lds	r24, 0x0140
    1472:	90 91 41 01 	lds	r25, 0x0141
    1476:	88 9f       	mul	r24, r24
    1478:	b0 01       	movw	r22, r0
    147a:	89 9f       	mul	r24, r25
    147c:	70 0d       	add	r23, r0
    147e:	98 9f       	mul	r25, r24
    1480:	70 0d       	add	r23, r0
    1482:	11 24       	eor	r1, r1
    1484:	80 e0       	ldi	r24, 0x00	; 0
    1486:	90 e0       	ldi	r25, 0x00	; 0
    1488:	0e 94 69 3a 	call	0x74d2	; 0x74d2 <__floatunsisf>
    148c:	26 e5       	ldi	r18, 0x56	; 86
    148e:	3e e0       	ldi	r19, 0x0E	; 14
    1490:	49 e4       	ldi	r20, 0x49	; 73
    1492:	50 e4       	ldi	r21, 0x40	; 64
    1494:	0e 94 1f 3b 	call	0x763e	; 0x763e <__mulsf3>
    1498:	20 e0       	ldi	r18, 0x00	; 0
    149a:	30 e5       	ldi	r19, 0x50	; 80
    149c:	43 ec       	ldi	r20, 0xC3	; 195
    149e:	58 e4       	ldi	r21, 0x48	; 72
    14a0:	0e 94 d0 39 	call	0x73a0	; 0x73a0 <__divsf3>
    14a4:	29 81       	ldd	r18, Y+1	; 0x01
    14a6:	3a 81       	ldd	r19, Y+2	; 0x02
    14a8:	4b 81       	ldd	r20, Y+3	; 0x03
    14aa:	5c 81       	ldd	r21, Y+4	; 0x04
    14ac:	0e 94 1f 3b 	call	0x763e	; 0x763e <__mulsf3>
    14b0:	0e 94 3d 3a 	call	0x747a	; 0x747a <__fixunssfsi>
    14b4:	70 93 43 01 	sts	0x0143, r23
    14b8:	60 93 42 01 	sts	0x0142, r22
  
  msr_status = ZMERENY_PRUMERY;
    14bc:	83 e0       	ldi	r24, 0x03	; 3
    14be:	80 93 44 01 	sts	0x0144, r24
  n_mereni = 0;
    14c2:	10 92 63 00 	sts	0x0063, r1
}
    14c6:	2c 96       	adiw	r28, 0x0c	; 12
    14c8:	0f b6       	in	r0, 0x3f	; 63
    14ca:	f8 94       	cli
    14cc:	de bf       	out	0x3e, r29	; 62
    14ce:	0f be       	out	0x3f, r0	; 63
    14d0:	cd bf       	out	0x3d, r28	; 61
    14d2:	cf 91       	pop	r28
    14d4:	df 91       	pop	r29
    14d6:	1f 91       	pop	r17
    14d8:	0f 91       	pop	r16
    14da:	ff 90       	pop	r15
    14dc:	ef 90       	pop	r14
    14de:	df 90       	pop	r13
    14e0:	cf 90       	pop	r12
    14e2:	bf 90       	pop	r11
    14e4:	af 90       	pop	r10
    14e6:	9f 90       	pop	r9
    14e8:	8f 90       	pop	r8
    14ea:	7f 90       	pop	r7
    14ec:	6f 90       	pop	r6
    14ee:	5f 90       	pop	r5
    14f0:	4f 90       	pop	r4
    14f2:	08 95       	ret

000014f4 <msr_init>:
  }
}


void msr_init(void){
  INDIKACE_DDR |= _BV(INDIKACE_BIT);
    14f4:	bb 9a       	sbi	0x17, 3	; 23
}
    14f6:	08 95       	ret

000014f8 <msr_unpause>:
void msr_pause(void){
  msr_status = (msr_status + 3);
}

void msr_unpause(void){
  msr_status = (msr_status - 3);
    14f8:	80 91 44 01 	lds	r24, 0x0144
    14fc:	83 50       	subi	r24, 0x03	; 3
    14fe:	80 93 44 01 	sts	0x0144, r24
  min_vzdal = irc_get_l();
    1502:	0e 94 30 0f 	call	0x1e60	; 0x1e60 <irc_get_l>
    1506:	90 93 62 00 	sts	0x0062, r25
    150a:	80 93 61 00 	sts	0x0061, r24
}
    150e:	08 95       	ret

00001510 <msr_zmer_l>:

void msr_zmer_l (void){
    1510:	2f 92       	push	r2
    1512:	3f 92       	push	r3
    1514:	4f 92       	push	r4
    1516:	5f 92       	push	r5
    1518:	6f 92       	push	r6
    151a:	7f 92       	push	r7
    151c:	8f 92       	push	r8
    151e:	9f 92       	push	r9
    1520:	af 92       	push	r10
    1522:	bf 92       	push	r11
    1524:	cf 92       	push	r12
    1526:	df 92       	push	r13
    1528:	ef 92       	push	r14
    152a:	ff 92       	push	r15
    152c:	0f 93       	push	r16
    152e:	1f 93       	push	r17
    1530:	df 93       	push	r29
    1532:	cf 93       	push	r28
    1534:	00 d0       	rcall	.+0      	; 0x1536 <msr_zmer_l+0x26>
    1536:	00 d0       	rcall	.+0      	; 0x1538 <msr_zmer_l+0x28>
    1538:	00 d0       	rcall	.+0      	; 0x153a <msr_zmer_l+0x2a>
    153a:	cd b7       	in	r28, 0x3d	; 61
    153c:	de b7       	in	r29, 0x3e	; 62
  msr_delka = irc_get_l();
    153e:	0e 94 30 0f 	call	0x1e60	; 0x1e60 <irc_get_l>
    1542:	9e 83       	std	Y+6, r25	; 0x06
    1544:	8d 83       	std	Y+5, r24	; 0x05
    1546:	90 93 3f 01 	sts	0x013F, r25
    154a:	80 93 3e 01 	sts	0x013E, r24
  if (msr_delka > (MIN_VZDAL_OD_VOZIKU + MIN_VZDAL_OD_KATRU)){
    154e:	89 3c       	cpi	r24, 0xC9	; 201
    1550:	91 05       	cpc	r25, r1
    1552:	08 f4       	brcc	.+2      	; 0x1556 <msr_zmer_l+0x46>
    1554:	5a c0       	rjmp	.+180    	; 0x160a <msr_zmer_l+0xfa>
    //  n_mereni = POCET_MERENI;
    //pristi_mereni = (uint16_t) (skok_mereni * msr_delka * (n_mereni + 1));
    n_mereni = 0;
    1556:	10 92 63 00 	sts	0x0063, r1
    155a:	27 e6       	ldi	r18, 0x67	; 103
    155c:	22 2e       	mov	r2, r18
    155e:	21 e0       	ldi	r18, 0x01	; 1
    1560:	32 2e       	mov	r3, r18
    1562:	88 24       	eor	r8, r8
    1564:	99 24       	eor	r9, r9

/// Funkce p¯ed zapoËetÌm mÏ¯enÌ urËÌ vzd·lenosti, ve kter˝ch dojde k mÏ¯enÌ
static void vypocti_vzdalenosti(void){
  int i;
  for (i = 0; i < POCET_MERENI; i++){
    mereni_l[i] = msr_delka - MIN_VZDAL_OD_KATRU - 
    1566:	c2 97       	sbiw	r24, 0x32	; 50
    1568:	9e 83       	std	Y+6, r25	; 0x06
    156a:	8d 83       	std	Y+5, r24	; 0x05
    156c:	a0 e0       	ldi	r26, 0x00	; 0
    156e:	b0 e0       	ldi	r27, 0x00	; 0
    1570:	89 83       	std	Y+1, r24	; 0x01
    1572:	9a 83       	std	Y+2, r25	; 0x02
    1574:	ab 83       	std	Y+3, r26	; 0x03
    1576:	bc 83       	std	Y+4, r27	; 0x04
    1578:	ed 81       	ldd	r30, Y+5	; 0x05
    157a:	fe 81       	ldd	r31, Y+6	; 0x06
    157c:	e6 59       	subi	r30, 0x96	; 150
    157e:	f0 40       	sbci	r31, 0x00	; 0
    1580:	2f 01       	movw	r4, r30
    1582:	66 24       	eor	r6, r6
    1584:	77 24       	eor	r7, r7
    1586:	e8 53       	subi	r30, 0x38	; 56
    1588:	ff 4f       	sbci	r31, 0xFF	; 255
    158a:	fe 83       	std	Y+6, r31	; 0x06
    158c:	ed 83       	std	Y+5, r30	; 0x05
    158e:	69 81       	ldd	r22, Y+1	; 0x01
    1590:	7a 81       	ldd	r23, Y+2	; 0x02
    1592:	8b 81       	ldd	r24, Y+3	; 0x03
    1594:	9c 81       	ldd	r25, Y+4	; 0x04
    1596:	0e 94 69 3a 	call	0x74d2	; 0x74d2 <__floatunsisf>
    159a:	5b 01       	movw	r10, r22
    159c:	6c 01       	movw	r12, r24
    159e:	b4 01       	movw	r22, r8
    15a0:	88 27       	eor	r24, r24
    15a2:	77 fd       	sbrc	r23, 7
    15a4:	80 95       	com	r24
    15a6:	98 2f       	mov	r25, r24
    15a8:	0e 94 6b 3a 	call	0x74d6	; 0x74d6 <__floatsisf>
    15ac:	25 e2       	ldi	r18, 0x25	; 37
    15ae:	39 e4       	ldi	r19, 0x49	; 73
    15b0:	42 e1       	ldi	r20, 0x12	; 18
    15b2:	5e eb       	ldi	r21, 0xBE	; 190
    15b4:	0e 94 1f 3b 	call	0x763e	; 0x763e <__mulsf3>
    15b8:	7b 01       	movw	r14, r22
    15ba:	8c 01       	movw	r16, r24
    15bc:	c3 01       	movw	r24, r6
    15be:	b2 01       	movw	r22, r4
    15c0:	0e 94 69 3a 	call	0x74d2	; 0x74d2 <__floatunsisf>
    15c4:	9b 01       	movw	r18, r22
    15c6:	ac 01       	movw	r20, r24
    15c8:	c8 01       	movw	r24, r16
    15ca:	b7 01       	movw	r22, r14
    15cc:	0e 94 1f 3b 	call	0x763e	; 0x763e <__mulsf3>
    15d0:	9b 01       	movw	r18, r22
    15d2:	ac 01       	movw	r20, r24
    15d4:	c6 01       	movw	r24, r12
    15d6:	b5 01       	movw	r22, r10
    15d8:	0e 94 68 39 	call	0x72d0	; 0x72d0 <__addsf3>
    15dc:	0e 94 3d 3a 	call	0x747a	; 0x747a <__fixunssfsi>
    15e0:	d1 01       	movw	r26, r2
    15e2:	6d 93       	st	X+, r22
    15e4:	7d 93       	st	X+, r23
    15e6:	1d 01       	movw	r2, r26


/// Funkce p¯ed zapoËetÌm mÏ¯enÌ urËÌ vzd·lenosti, ve kter˝ch dojde k mÏ¯enÌ
static void vypocti_vzdalenosti(void){
  int i;
  for (i = 0; i < POCET_MERENI; i++){
    15e8:	08 94       	sec
    15ea:	81 1c       	adc	r8, r1
    15ec:	91 1c       	adc	r9, r1
    15ee:	b8 e0       	ldi	r27, 0x08	; 8
    15f0:	8b 16       	cp	r8, r27
    15f2:	91 04       	cpc	r9, r1
    15f4:	61 f6       	brne	.-104    	; 0x158e <msr_zmer_l+0x7e>
    //  n_mereni = POCET_MERENI;
    //pristi_mereni = (uint16_t) (skok_mereni * msr_delka * (n_mereni + 1));
    n_mereni = 0;
    vypocti_vzdalenosti();
    
    msr_status = L_ZMERENO;
    15f6:	82 e0       	ldi	r24, 0x02	; 2
    15f8:	80 93 44 01 	sts	0x0144, r24
    min_vzdal = msr_delka;
    15fc:	ed 81       	ldd	r30, Y+5	; 0x05
    15fe:	fe 81       	ldd	r31, Y+6	; 0x06
    1600:	f0 93 62 00 	sts	0x0062, r31
    1604:	e0 93 61 00 	sts	0x0061, r30
    1608:	07 c0       	rjmp	.+14     	; 0x1618 <msr_zmer_l+0x108>
  }
  else{
    new_error(99);
    160a:	83 e6       	ldi	r24, 0x63	; 99
    160c:	0e 94 4e 19 	call	0x329c	; 0x329c <new_error>

/**
 * Funkce p¯eruöÌ mÏ¯enÌ. 
 */
void msr_storno(void){
  msr_status = VOLNO;
    1610:	10 92 44 01 	sts	0x0144, r1
  n_mereni = 0;
    1614:	10 92 63 00 	sts	0x0063, r1
  }
  else{
    new_error(99);
    msr_storno();
  }
}
    1618:	26 96       	adiw	r28, 0x06	; 6
    161a:	0f b6       	in	r0, 0x3f	; 63
    161c:	f8 94       	cli
    161e:	de bf       	out	0x3e, r29	; 62
    1620:	0f be       	out	0x3f, r0	; 63
    1622:	cd bf       	out	0x3d, r28	; 61
    1624:	cf 91       	pop	r28
    1626:	df 91       	pop	r29
    1628:	1f 91       	pop	r17
    162a:	0f 91       	pop	r16
    162c:	ff 90       	pop	r15
    162e:	ef 90       	pop	r14
    1630:	df 90       	pop	r13
    1632:	cf 90       	pop	r12
    1634:	bf 90       	pop	r11
    1636:	af 90       	pop	r10
    1638:	9f 90       	pop	r9
    163a:	8f 90       	pop	r8
    163c:	7f 90       	pop	r7
    163e:	6f 90       	pop	r6
    1640:	5f 90       	pop	r5
    1642:	4f 90       	pop	r4
    1644:	3f 90       	pop	r3
    1646:	2f 90       	pop	r2
    1648:	08 95       	ret

0000164a <measure>:

  return d_str - (k * l_str);
}


void measure(void) {
    164a:	cf 93       	push	r28
    164c:	df 93       	push	r29
  //msr_pocet_mereni = n_mereni;
  switch (msr_status){
    164e:	80 91 44 01 	lds	r24, 0x0144
    1652:	81 30       	cpi	r24, 0x01	; 1
    1654:	21 f0       	breq	.+8      	; 0x165e <measure+0x14>
    1656:	82 30       	cpi	r24, 0x02	; 2
    1658:	09 f0       	breq	.+2      	; 0x165c <measure+0x12>
    165a:	5e c0       	rjmp	.+188    	; 0x1718 <measure+0xce>
    165c:	0e c0       	rjmp	.+28     	; 0x167a <measure+0x30>
  case L_NEZMERENO:
    if (width_src == 1){
    165e:	80 91 60 00 	lds	r24, 0x0060
    1662:	81 30       	cpi	r24, 0x01	; 1
    1664:	39 f4       	brne	.+14     	; 0x1674 <measure+0x2a>
      if (prumer_h > MIN_START_PRUMER){
    1666:	80 91 50 02 	lds	r24, 0x0250
    166a:	90 91 51 02 	lds	r25, 0x0251
    166e:	0b 97       	sbiw	r24, 0x0b	; 11
    1670:	08 f4       	brcc	.+2      	; 0x1674 <measure+0x2a>
    1672:	52 c0       	rjmp	.+164    	; 0x1718 <measure+0xce>
        msr_zmer_l();
      }
    }
    else{
      msr_zmer_l();
    1674:	0e 94 88 0a 	call	0x1510	; 0x1510 <msr_zmer_l>
    1678:	4f c0       	rjmp	.+158    	; 0x1718 <measure+0xce>
    }
    break;
  case L_ZMERENO: 
    {
      uint16_t vzdalenost;
      vzdalenost = irc_get_l();
    167a:	0e 94 30 0f 	call	0x1e60	; 0x1e60 <irc_get_l>
    167e:	ec 01       	movw	r28, r24
      
      if (min_vzdal > vzdalenost){ /* zjiötujeme, zda se vozÌk uû nevracÌ */
    1680:	80 91 61 00 	lds	r24, 0x0061
    1684:	90 91 62 00 	lds	r25, 0x0062
    1688:	c8 17       	cp	r28, r24
    168a:	d9 07       	cpc	r29, r25
    168c:	28 f4       	brcc	.+10     	; 0x1698 <measure+0x4e>
        min_vzdal = vzdalenost;
    168e:	d0 93 62 00 	sts	0x0062, r29
    1692:	c0 93 61 00 	sts	0x0061, r28
    1696:	19 c0       	rjmp	.+50     	; 0x16ca <measure+0x80>
      }
      else{ // znamen· to, ûe s vozÌk pohnul smÏrem vzad
        if ((vzdalenost - min_vzdal) > BACK_MOVE_TOLERANCE){
    1698:	9e 01       	movw	r18, r28
    169a:	28 1b       	sub	r18, r24
    169c:	39 0b       	sbc	r19, r25
    169e:	23 33       	cpi	r18, 0x33	; 51
    16a0:	31 05       	cpc	r19, r1
    16a2:	98 f0       	brcs	.+38     	; 0x16ca <measure+0x80>
          if (n_mereni < 2){
    16a4:	80 91 63 00 	lds	r24, 0x0063
    16a8:	82 30       	cpi	r24, 0x02	; 2
    16aa:	40 f4       	brcc	.+16     	; 0x16bc <measure+0x72>
            new_error(93); // Mereni zruseno
    16ac:	8d e5       	ldi	r24, 0x5D	; 93
    16ae:	0e 94 4e 19 	call	0x329c	; 0x329c <new_error>

/**
 * Funkce p¯eruöÌ mÏ¯enÌ. 
 */
void msr_storno(void){
  msr_status = VOLNO;
    16b2:	10 92 44 01 	sts	0x0144, r1
  n_mereni = 0;
    16b6:	10 92 63 00 	sts	0x0063, r1
    16ba:	07 c0       	rjmp	.+14     	; 0x16ca <measure+0x80>
          if (n_mereni < 2){
            new_error(93); // Mereni zruseno
            msr_storno();
          }
          else {
            if (n_mereni < MIN_POCET_MERENI){
    16bc:	84 30       	cpi	r24, 0x04	; 4
    16be:	18 f4       	brcc	.+6      	; 0x16c6 <measure+0x7c>
              new_error(92);// varovani: mereni nepresne
    16c0:	8c e5       	ldi	r24, 0x5C	; 92
    16c2:	0e 94 4e 19 	call	0x329c	; 0x329c <new_error>
              msr_end();
            }
            else { // jinak je mereni normalne ukoceno
              msr_end();
    16c6:	0e 94 74 09 	call	0x12e8	; 0x12e8 <msr_end>
            }
          }
        }
      }
      if (vzdalenost < mereni_l[n_mereni]){ // pokud nastal okamûik mÏ¯enÌ ...
    16ca:	20 91 63 00 	lds	r18, 0x0063
    16ce:	a2 2f       	mov	r26, r18
    16d0:	b0 e0       	ldi	r27, 0x00	; 0
    16d2:	aa 0f       	add	r26, r26
    16d4:	bb 1f       	adc	r27, r27
    16d6:	fd 01       	movw	r30, r26
    16d8:	e9 59       	subi	r30, 0x99	; 153
    16da:	fe 4f       	sbci	r31, 0xFE	; 254
    16dc:	80 81       	ld	r24, Z
    16de:	91 81       	ldd	r25, Z+1	; 0x01
    16e0:	c8 17       	cp	r28, r24
    16e2:	d9 07       	cpc	r29, r25
    16e4:	c8 f4       	brcc	.+50     	; 0x1718 <measure+0xce>
        // uloû okamûitÈ hodnoty do pole namÏ¯en˝ch dat
        mereni_d_v[n_mereni] = prumer_v;     //TODO
    16e6:	fd 01       	movw	r30, r26
    16e8:	e9 5b       	subi	r30, 0xB9	; 185
    16ea:	fe 4f       	sbci	r31, 0xFE	; 254
    16ec:	80 91 16 03 	lds	r24, 0x0316
    16f0:	90 91 17 03 	lds	r25, 0x0317
    16f4:	91 83       	std	Z+1, r25	; 0x01
    16f6:	80 83       	st	Z, r24
        mereni_d_h[n_mereni] = prumer_h;
    16f8:	a9 5a       	subi	r26, 0xA9	; 169
    16fa:	be 4f       	sbci	r27, 0xFE	; 254
    16fc:	80 91 50 02 	lds	r24, 0x0250
    1700:	90 91 51 02 	lds	r25, 0x0251
    1704:	8d 93       	st	X+, r24
    1706:	9c 93       	st	X, r25
        
        n_mereni++;
    1708:	82 2f       	mov	r24, r18
    170a:	8f 5f       	subi	r24, 0xFF	; 255
    170c:	80 93 63 00 	sts	0x0063, r24
        if (n_mereni == POCET_MERENI){  // poslednÌ mÏ¯enÌ
    1710:	88 30       	cpi	r24, 0x08	; 8
    1712:	11 f4       	brne	.+4      	; 0x1718 <measure+0xce>
          msr_end();
    1714:	0e 94 74 09 	call	0x12e8	; 0x12e8 <msr_end>
 * @todo dopsat  
 */
inline void indikace_stavu_control(void){
  static int casovac = 0;
  
  switch(msr_status){
    1718:	80 91 44 01 	lds	r24, 0x0144
    171c:	83 30       	cpi	r24, 0x03	; 3
    171e:	18 f4       	brcc	.+6      	; 0x1726 <measure+0xdc>
    1720:	81 30       	cpi	r24, 0x01	; 1
    1722:	30 f4       	brcc	.+12     	; 0x1730 <measure+0xe6>
    1724:	07 c0       	rjmp	.+14     	; 0x1734 <measure+0xea>
    1726:	83 30       	cpi	r24, 0x03	; 3
    1728:	29 f0       	breq	.+10     	; 0x1734 <measure+0xea>
    172a:	86 30       	cpi	r24, 0x06	; 6
    172c:	f0 f4       	brcc	.+60     	; 0x176a <measure+0x120>
    172e:	04 c0       	rjmp	.+8      	; 0x1738 <measure+0xee>
  case L_NEZMERENO:
  case L_ZMERENO:
    INDIKACE_PORT |= _BV(INDIKACE_BIT); // jako I_PORT = I_PORT | (1 << I_BIT)
    1730:	c3 9a       	sbi	0x18, 3	; 24
    1732:	1b c0       	rjmp	.+54     	; 0x176a <measure+0x120>
    break;
  case VOLNO:
  case ZMERENY_PRUMERY:
    INDIKACE_PORT &= ~_BV(INDIKACE_BIT); 
    1734:	c3 98       	cbi	0x18, 3	; 24
    1736:	19 c0       	rjmp	.+50     	; 0x176a <measure+0x120>
    break;
  case PAUSE_L_NEZMERENO:
  case PAUSE_L_ZMERENO:
    if (casovac < 4000){
    1738:	80 91 45 01 	lds	r24, 0x0145
    173c:	90 91 46 01 	lds	r25, 0x0146
    1740:	3f e0       	ldi	r19, 0x0F	; 15
    1742:	80 3a       	cpi	r24, 0xA0	; 160
    1744:	93 07       	cpc	r25, r19
    1746:	6c f4       	brge	.+26     	; 0x1762 <measure+0x118>
      if (casovac < 2000)
    1748:	27 e0       	ldi	r18, 0x07	; 7
    174a:	80 3d       	cpi	r24, 0xD0	; 208
    174c:	92 07       	cpc	r25, r18
    174e:	14 f4       	brge	.+4      	; 0x1754 <measure+0x10a>
        INDIKACE_PORT |= _BV(INDIKACE_BIT);
    1750:	c3 9a       	sbi	0x18, 3	; 24
    1752:	01 c0       	rjmp	.+2      	; 0x1756 <measure+0x10c>
      else 
        INDIKACE_PORT &= ~_BV(INDIKACE_BIT); 
    1754:	c3 98       	cbi	0x18, 3	; 24
      casovac++;
    1756:	01 96       	adiw	r24, 0x01	; 1
    1758:	90 93 46 01 	sts	0x0146, r25
    175c:	80 93 45 01 	sts	0x0145, r24
    1760:	04 c0       	rjmp	.+8      	; 0x176a <measure+0x120>
    }
    else{
      casovac = 0;
    1762:	10 92 46 01 	sts	0x0146, r1
    1766:	10 92 45 01 	sts	0x0145, r1
    break;
  }
  
  // indikace stavu svÏtlem
  indikace_stavu_control();
}
    176a:	df 91       	pop	r29
    176c:	cf 91       	pop	r28
    176e:	08 95       	ret

00001770 <msr_start>:
/**
 * Funkce zajiöùuje spr·vnÈ zah·jenÌ mÏ¯ÌcÌho procesu. V p¯ÌpadÏ, ûe bylo mÏ¯enÌ
 * pozastaveno, dojde k obnovÏ.
 */
void msr_start(void){
  switch(msr_status){
    1770:	80 91 44 01 	lds	r24, 0x0144
    1774:	83 30       	cpi	r24, 0x03	; 3
    1776:	18 f4       	brcc	.+6      	; 0x177e <msr_start+0xe>
    1778:	81 30       	cpi	r24, 0x01	; 1
    177a:	c0 f4       	brcc	.+48     	; 0x17ac <msr_start+0x3c>
    177c:	02 c0       	rjmp	.+4      	; 0x1782 <msr_start+0x12>
    177e:	83 30       	cpi	r24, 0x03	; 3
    1780:	c1 f4       	brne	.+48     	; 0x17b2 <msr_start+0x42>
  case VOLNO:
  case ZMERENY_PRUMERY:
    // osetreni naplneni pameti
    if (data_top >= (DATA_MAX_POCET_ZAZNAMU - 2)){
    1782:	80 91 9b 01 	lds	r24, 0x019B
    1786:	90 91 9c 01 	lds	r25, 0x019C
    178a:	80 3d       	cpi	r24, 0xD0	; 208
    178c:	91 05       	cpc	r25, r1
    178e:	24 f0       	brlt	.+8      	; 0x1798 <msr_start+0x28>
      new_error(101); // pamÏù mereni plna
    1790:	85 e6       	ldi	r24, 0x65	; 101
    1792:	0e 94 4e 19 	call	0x329c	; 0x329c <new_error>
    1796:	08 95       	ret
    }
    else{
      if (data_top >= (DATA_MAX_POCET_ZAZNAMU - 11)){
    1798:	87 3c       	cpi	r24, 0xC7	; 199
    179a:	91 05       	cpc	r25, r1
    179c:	1c f0       	brlt	.+6      	; 0x17a4 <msr_start+0x34>
        new_error(201);
    179e:	89 ec       	ldi	r24, 0xC9	; 201
    17a0:	0e 94 4e 19 	call	0x329c	; 0x329c <new_error>
      }
      msr_status = L_NEZMERENO;
    17a4:	81 e0       	ldi	r24, 0x01	; 1
    17a6:	80 93 44 01 	sts	0x0144, r24
    17aa:	08 95       	ret
    }
    break;
  case L_NEZMERENO:
  case L_ZMERENO:
    new_error(84);
    17ac:	84 e5       	ldi	r24, 0x54	; 84
    17ae:	0e 94 4e 19 	call	0x329c	; 0x329c <new_error>
    17b2:	08 95       	ret

000017b4 <USART_Init>:
 * Inicializace usartu
 */
void USART_Init( unsigned int baud ){
  int i = 0;
  /* Set baud rate */
  UBRRH = (unsigned char)(baud>>8);
    17b4:	90 bd       	out	0x20, r25	; 32
  UBRRL = (unsigned char)baud;
    17b6:	89 b9       	out	0x09, r24	; 9
  /* Enable Receiver and Transmitter */
  /* Data,RX interrupt enable*/
  UCSRB = (1<<RXEN)|(1<<TXEN)|(1<<RXCIE); // |(1<<UDRIE)
    17b8:	88 e9       	ldi	r24, 0x98	; 152
    17ba:	8a b9       	out	0x0a, r24	; 10
  /* Set frame format: 8data, 2stop bit */
  UCSRC = (1<<URSEL)|(1<<USBS)|(3<<UCSZ0);
    17bc:	8e e8       	ldi	r24, 0x8E	; 142
    17be:	80 bd       	out	0x20, r24	; 32
    17c0:	ec e4       	ldi	r30, 0x4C	; 76
    17c2:	f3 e0       	ldi	r31, 0x03	; 3

  // Clear usart recive buffer
  for (i = 0; i < LenOfRecvBuff; i++){
    usart_recv_buff[i] = 0;
    17c4:	11 92       	st	Z+, r1
  UCSRB = (1<<RXEN)|(1<<TXEN)|(1<<RXCIE); // |(1<<UDRIE)
  /* Set frame format: 8data, 2stop bit */
  UCSRC = (1<<URSEL)|(1<<USBS)|(3<<UCSZ0);

  // Clear usart recive buffer
  for (i = 0; i < LenOfRecvBuff; i++){
    17c6:	83 e0       	ldi	r24, 0x03	; 3
    17c8:	ee 35       	cpi	r30, 0x5E	; 94
    17ca:	f8 07       	cpc	r31, r24
    17cc:	d9 f7       	brne	.-10     	; 0x17c4 <USART_Init+0x10>
    17ce:	e5 e2       	ldi	r30, 0x25	; 37
    17d0:	f3 e0       	ldi	r31, 0x03	; 3
    usart_recv_buff[i] = 0;
  }

  // Clear usart transmitt buffer
  for (i = 0; i < LenOfTransBuff; i++){
    usart_trans_buff[i] = 0;
    17d2:	11 92       	st	Z+, r1
  for (i = 0; i < LenOfRecvBuff; i++){
    usart_recv_buff[i] = 0;
  }

  // Clear usart transmitt buffer
  for (i = 0; i < LenOfTransBuff; i++){
    17d4:	83 e0       	ldi	r24, 0x03	; 3
    17d6:	e7 33       	cpi	r30, 0x37	; 55
    17d8:	f8 07       	cpc	r31, r24
    17da:	d9 f7       	brne	.-10     	; 0x17d2 <USART_Init+0x1e>
    usart_trans_buff_2[i] = 0;
  }
  */

//  UDR = 0;
  DDRD = DDRD | (1 << 4); // p¯epÌn·nÌ sÈriov˝ch linek
    17dc:	8c 9a       	sbi	0x11, 4	; 17


}
    17de:	08 95       	ret

000017e0 <test_message>:

/// Funkce tesuje spravnost zpravy
/// @return 
/// Pokud je zprava v poradku vrati 1,
/// pokud je ve zprave chyba vrati funkce 0.
int test_message(char *msg){
    17e0:	cf 93       	push	r28
    17e2:	df 93       	push	r29
    17e4:	ec 01       	movw	r28, r24
  int i=0;

  if (msg[0] != 255){
    17e6:	88 81       	ld	r24, Y
    17e8:	8f 3f       	cpi	r24, 0xFF	; 255
    17ea:	e9 f4       	brne	.+58     	; 0x1826 <test_message+0x46>
    17ec:	de 01       	movw	r26, r28
    17ee:	40 e0       	ldi	r20, 0x00	; 0
    17f0:	50 e0       	ldi	r21, 0x00	; 0
    a = msg[i+2];
    b = msg[i+3];
    c = 2 + DATASIZE + 1 + (i/2);
    d = msg[c];
    //printf("%i ^ %i = %i, compare with buffer[%i] = %i\n",a,b,a^b,c,d);
    if ((a^b) != d){
    17f2:	13 96       	adiw	r26, 0x03	; 3
    17f4:	2c 91       	ld	r18, X
    17f6:	13 97       	sbiw	r26, 0x03	; 3
    17f8:	12 96       	adiw	r26, 0x02	; 2
    17fa:	8c 91       	ld	r24, X
    17fc:	12 97       	sbiw	r26, 0x02	; 2
    17fe:	28 27       	eor	r18, r24
    1800:	ca 01       	movw	r24, r20
    1802:	95 95       	asr	r25
    1804:	87 95       	ror	r24
    1806:	83 5f       	subi	r24, 0xF3	; 243
    1808:	fe 01       	movw	r30, r28
    180a:	e8 0f       	add	r30, r24
    180c:	f1 1d       	adc	r31, r1
    180e:	80 81       	ld	r24, Z
    1810:	28 17       	cp	r18, r24
    1812:	49 f4       	brne	.+18     	; 0x1826 <test_message+0x46>

  if (msg[0] != 255){
    return 0;
  }
//  printf("zacatek ok!\n");
  for(i=0;i < DATASIZE;i=i+2){
    1814:	4e 5f       	subi	r20, 0xFE	; 254
    1816:	5f 4f       	sbci	r21, 0xFF	; 255
    1818:	12 96       	adiw	r26, 0x02	; 2
    181a:	4a 30       	cpi	r20, 0x0A	; 10
    181c:	51 05       	cpc	r21, r1
    181e:	49 f7       	brne	.-46     	; 0x17f2 <test_message+0x12>
    1820:	21 e0       	ldi	r18, 0x01	; 1
    1822:	30 e0       	ldi	r19, 0x00	; 0
    1824:	02 c0       	rjmp	.+4      	; 0x182a <test_message+0x4a>
    1826:	20 e0       	ldi	r18, 0x00	; 0
    1828:	30 e0       	ldi	r19, 0x00	; 0
	//printf("fuckoff");
      return 0;
    }
  }
  return 1;
}
    182a:	c9 01       	movw	r24, r18
    182c:	df 91       	pop	r29
    182e:	cf 91       	pop	r28
    1830:	08 95       	ret

00001832 <msg_ack_fcn>:
 * Funkce je vol·na p¯i p¯Ìjmu potvrzovacÌ zpr·vy. Zavol· funkci,
 * kter· m· b˝t vol·na po potvrzenÌ.
*/
void msg_ack_fcn(char * msg){
  //static int i = 0;
  if (p_ack_fcn != NULL){
    1832:	e0 91 78 01 	lds	r30, 0x0178
    1836:	f0 91 79 01 	lds	r31, 0x0179
    183a:	30 97       	sbiw	r30, 0x00	; 0
    183c:	69 f0       	breq	.+26     	; 0x1858 <msg_ack_fcn+0x26>
    void (*p_fcn_tmp)(char*s);
    p_fcn_tmp = p_ack_fcn;
    p_ack_fcn = NULL;
    183e:	10 92 79 01 	sts	0x0179, r1
    1842:	10 92 78 01 	sts	0x0178, r1
    p_nack_fcn = NULL; // tohle musÌ b˝t p¯ed vol·nÌm tÈ funkce, protoûe v nÌ je
    1846:	10 92 7e 01 	sts	0x017E, r1
    184a:	10 92 7d 01 	sts	0x017D, r1
                //znovu zah·jeno vysÌl·nÌ zpr·vy a tady by se to zase zastavilo.
    p_fcn_tmp(msg);
    184e:	09 95       	icall
    msg_ack_timer = 0;
    1850:	10 92 7b 01 	sts	0x017B, r1
    1854:	10 92 7a 01 	sts	0x017A, r1
    1858:	08 95       	ret

0000185a <msg_nack_fcn>:
/**
 * Funkce uzavÌr· komunikaci p¯i ne˙spÏönÈm pokusu o odesl·nÌ zpr·vy s
 * odpovÏdÌ.
 */
void msg_nack_fcn(void){
  if (p_nack_fcn != NULL){
    185a:	e0 91 7d 01 	lds	r30, 0x017D
    185e:	f0 91 7e 01 	lds	r31, 0x017E
    1862:	30 97       	sbiw	r30, 0x00	; 0
    1864:	09 f0       	breq	.+2      	; 0x1868 <msg_nack_fcn+0xe>
    p_nack_fcn();
    1866:	09 95       	icall
  }
  //new_error(91);
  msg_ack_timer = 0;
    1868:	10 92 7b 01 	sts	0x017B, r1
    186c:	10 92 7a 01 	sts	0x017A, r1
  p_ack_fcn = NULL;
    1870:	10 92 79 01 	sts	0x0179, r1
    1874:	10 92 78 01 	sts	0x0178, r1
  p_nack_fcn = NULL;
    1878:	10 92 7e 01 	sts	0x017E, r1
    187c:	10 92 7d 01 	sts	0x017D, r1
}
    1880:	08 95       	ret

00001882 <usart_get_recv_buff>:
    }
  }
}
    
/// Funkce vracÌ p¯Ìsluön˝ znak z p¯ijÌmacÌho bufferu sÈriovÈho kan·lu.
char usart_get_recv_buff(int i){
    1882:	fc 01       	movw	r30, r24
    1884:	e4 5b       	subi	r30, 0xB4	; 180
    1886:	fc 4f       	sbci	r31, 0xFC	; 252
  return usart_recv_buff[i];
}
    1888:	80 81       	ld	r24, Z
    188a:	08 95       	ret

0000188c <new_msg>:


/// Vstupem do teto funkce je ukazatel na zpravu
/// pokud se ukazatel uz v seznamu nenachazi, tak je zarazen na konec seznamu.
/// Prostor musÌ b˝t spr·vnÏ naalokovan˝. Po odesl·nÌ zpr·vy je pamÏù uvolnÏna.
void new_msg (char *msg){
    188c:	cf 93       	push	r28
    188e:	df 93       	push	r29
    1890:	ec 01       	movw	r28, r24
  //if (prepinani == 0){
  if (1){

  // pokud zadna zprava v seznamu neni, tak ji strc na nulty misto
  // a nastartuj citac a zapni preruseni od datovaho bufferu.
    if (msg_buffer_counter == -1){
    1892:	40 91 70 00 	lds	r20, 0x0070
    1896:	50 91 71 00 	lds	r21, 0x0071
    189a:	8f ef       	ldi	r24, 0xFF	; 255
    189c:	4f 3f       	cpi	r20, 0xFF	; 255
    189e:	58 07       	cpc	r21, r24
    18a0:	51 f4       	brne	.+20     	; 0x18b6 <new_msg+0x2a>
      msg_buffer_counter = 0;
    18a2:	10 92 71 00 	sts	0x0071, r1
    18a6:	10 92 70 00 	sts	0x0070, r1
      msg_buffer[msg_buffer_counter] = msg;
    18aa:	d0 93 38 03 	sts	0x0338, r29
    18ae:	c0 93 37 03 	sts	0x0337, r28
      UCSRB = UCSRB | (1 << UDRIE);
    18b2:	55 9a       	sbi	0x0a, 5	; 10
    18b4:	2e c0       	rjmp	.+92     	; 0x1912 <new_msg+0x86>
    else{
      int i = 0;

      // testujeme, zda uz zprava neni v seznamu
      for (i = 0; i < LenOfMsgBuffer; i++){
        if (msg_buffer[i][0] == msg[0]){
    18b6:	98 81       	ld	r25, Y
    18b8:	a7 e3       	ldi	r26, 0x37	; 55
    18ba:	b3 e0       	ldi	r27, 0x03	; 3
    18bc:	ed 91       	ld	r30, X+
    18be:	fc 91       	ld	r31, X
    18c0:	11 97       	sbiw	r26, 0x01	; 1
    18c2:	80 81       	ld	r24, Z
    18c4:	89 17       	cp	r24, r25
    18c6:	29 f1       	breq	.+74     	; 0x1912 <new_msg+0x86>
          return;
    18c8:	12 96       	adiw	r26, 0x02	; 2
    // pokud jsou v seznamu zpravy, strc ji na konec.
    else{
      int i = 0;

      // testujeme, zda uz zprava neni v seznamu
      for (i = 0; i < LenOfMsgBuffer; i++){
    18ca:	83 e0       	ldi	r24, 0x03	; 3
    18cc:	a1 34       	cpi	r26, 0x41	; 65
    18ce:	b8 07       	cpc	r27, r24
    18d0:	a9 f7       	brne	.-22     	; 0x18bc <new_msg+0x30>
          return;
        }
      }
     
      // nastavime pocitadlo na prvek za aktualnim prvkem
      if (msg_buffer_counter != (LenOfMsgBuffer - 1))
    18d2:	44 30       	cpi	r20, 0x04	; 4
    18d4:	51 05       	cpc	r21, r1
    18d6:	71 f0       	breq	.+28     	; 0x18f4 <new_msg+0x68>
        i = msg_buffer_counter + 1;
    18d8:	9a 01       	movw	r18, r20
    18da:	0f c0       	rjmp	.+30     	; 0x18fa <new_msg+0x6e>
      else
        i = 0;
    
      while(i != msg_buffer_counter){
        // kdyz najdeme ukazatel NULL, tak vyskocime z cyklu
        if (msg_buffer[i] == NULL)
    18dc:	f9 01       	movw	r30, r18
    18de:	ee 0f       	add	r30, r30
    18e0:	ff 1f       	adc	r31, r31
    18e2:	e9 5c       	subi	r30, 0xC9	; 201
    18e4:	fc 4f       	sbci	r31, 0xFC	; 252
    18e6:	80 81       	ld	r24, Z
    18e8:	91 81       	ldd	r25, Z+1	; 0x01
    18ea:	89 2b       	or	r24, r25
    18ec:	61 f0       	breq	.+24     	; 0x1906 <new_msg+0x7a>
          break;

        // jesli nejsme na konci, inkrementujem, jinak na nulu.
        if (i != (LenOfMsgBuffer - 1)) 
    18ee:	24 30       	cpi	r18, 0x04	; 4
    18f0:	31 05       	cpc	r19, r1
    18f2:	19 f4       	brne	.+6      	; 0x18fa <new_msg+0x6e>
    18f4:	20 e0       	ldi	r18, 0x00	; 0
    18f6:	30 e0       	ldi	r19, 0x00	; 0
    18f8:	02 c0       	rjmp	.+4      	; 0x18fe <new_msg+0x72>
          i++;
    18fa:	2f 5f       	subi	r18, 0xFF	; 255
    18fc:	3f 4f       	sbci	r19, 0xFF	; 255
      if (msg_buffer_counter != (LenOfMsgBuffer - 1))
        i = msg_buffer_counter + 1;
      else
        i = 0;
    
      while(i != msg_buffer_counter){
    18fe:	24 17       	cp	r18, r20
    1900:	35 07       	cpc	r19, r21
    1902:	61 f7       	brne	.-40     	; 0x18dc <new_msg+0x50>
    1904:	03 c0       	rjmp	.+6      	; 0x190c <new_msg+0x80>
        else 
          i = 0;
      }
      
      if (i != msg_buffer_counter){
        msg_buffer[i] = msg;
    1906:	d1 83       	std	Z+1, r29	; 0x01
    1908:	c0 83       	st	Z, r28
    190a:	03 c0       	rjmp	.+6      	; 0x1912 <new_msg+0x86>
      }
      else{
        new_error(96);
    190c:	80 e6       	ldi	r24, 0x60	; 96
    190e:	0e 94 4e 19 	call	0x329c	; 0x329c <new_error>
      }
    
    }
  }
  
}
    1912:	df 91       	pop	r29
    1914:	cf 91       	pop	r28
    1916:	08 95       	ret

00001918 <serial_msg_ack_timer>:
/// Funkce zobsluhuje ËÌtaË doby Ëek·nÌ na odezvu zpr·vy a
/// ËÌtaË poËtu pokus˘ o odesl·nÌ. Na odpovÏÔ na kaûdou potvrzovanou zpr·vu se Ëek·
/// MAX_MSG_ACK_DELAY cykl˘. Po uplynutÌ tÈto doby je zpr·va zopakov·na. Po
/// MAX_MSG_ACK_REPEATS - tÈm opakov·nÌ je vytvo¯en error.
void serial_msg_ack_timer(void){
  if (p_ack_fcn != NULL){
    1918:	80 91 78 01 	lds	r24, 0x0178
    191c:	90 91 79 01 	lds	r25, 0x0179
    1920:	89 2b       	or	r24, r25
    1922:	a9 f1       	breq	.+106    	; 0x198e <serial_msg_ack_timer+0x76>
    msg_ack_timer++;
    1924:	80 91 7a 01 	lds	r24, 0x017A
    1928:	90 91 7b 01 	lds	r25, 0x017B
    192c:	01 96       	adiw	r24, 0x01	; 1
    192e:	90 93 7b 01 	sts	0x017B, r25
    1932:	80 93 7a 01 	sts	0x017A, r24
    if (msg_ack_timer > MAX_MSG_ACK_DELAY){
    1936:	89 58       	subi	r24, 0x89	; 137
    1938:	93 41       	sbci	r25, 0x13	; 19
    193a:	48 f1       	brcs	.+82     	; 0x198e <serial_msg_ack_timer+0x76>
      if (msg_ack_repeats > 0){
    193c:	80 91 7c 01 	lds	r24, 0x017C
    1940:	88 23       	and	r24, r24
    1942:	19 f1       	breq	.+70     	; 0x198a <serial_msg_ack_timer+0x72>
        char * opakovana_zprava;
        int i = 0;
        
        opakovana_zprava = (char *) mmalloc(LenOfMsg);
    1944:	8b e0       	ldi	r24, 0x0B	; 11
    1946:	90 e0       	ldi	r25, 0x00	; 0
    1948:	0e 94 c1 06 	call	0xd82	; 0xd82 <mmalloc>
    194c:	ac 01       	movw	r20, r24
    194e:	68 2f       	mov	r22, r24
    1950:	95 2f       	mov	r25, r21
    1952:	20 e0       	ldi	r18, 0x00	; 0
    1954:	30 e0       	ldi	r19, 0x00	; 0
        for (i = 0; i < LenOfMsg; i++){
          opakovana_zprava[i] = last_msg_ack[i];
    1956:	fa 01       	movw	r30, r20
    1958:	e2 0f       	add	r30, r18
    195a:	f3 1f       	adc	r31, r19
    195c:	d9 01       	movw	r26, r18
    195e:	a0 58       	subi	r26, 0x80	; 128
    1960:	be 4f       	sbci	r27, 0xFE	; 254
    1962:	8c 91       	ld	r24, X
    1964:	80 83       	st	Z, r24
      if (msg_ack_repeats > 0){
        char * opakovana_zprava;
        int i = 0;
        
        opakovana_zprava = (char *) mmalloc(LenOfMsg);
        for (i = 0; i < LenOfMsg; i++){
    1966:	2f 5f       	subi	r18, 0xFF	; 255
    1968:	3f 4f       	sbci	r19, 0xFF	; 255
    196a:	2b 30       	cpi	r18, 0x0B	; 11
    196c:	31 05       	cpc	r19, r1
    196e:	99 f7       	brne	.-26     	; 0x1956 <serial_msg_ack_timer+0x3e>
          opakovana_zprava[i] = last_msg_ack[i];
        }
        
        new_msg(opakovana_zprava);
    1970:	86 2f       	mov	r24, r22
    1972:	0e 94 46 0c 	call	0x188c	; 0x188c <new_msg>
        msg_ack_repeats--;
    1976:	80 91 7c 01 	lds	r24, 0x017C
    197a:	81 50       	subi	r24, 0x01	; 1
    197c:	80 93 7c 01 	sts	0x017C, r24
        msg_ack_timer = 0;
    1980:	10 92 7b 01 	sts	0x017B, r1
    1984:	10 92 7a 01 	sts	0x017A, r1
    1988:	08 95       	ret
      }
      else{
        msg_nack_fcn();
    198a:	0e 94 2d 0c 	call	0x185a	; 0x185a <msg_nack_fcn>
    198e:	08 95       	ret

00001990 <new_ack_msg>:
 * doch·zÌ k uvolnÏnÌ pamÏti po ¯etÏzci msg, p¯i dalöÌm odesÌl·nÌ se
 * vöak odesÌlajÌ data opÏt z ukazatele msg, kter· jsou vöak jiû
 * uvolnÏn·. 
 * 
 * */
void new_ack_msg(char * msg, unsigned char repeats, void (*p_fcn)(char*s),void (*p_fcn_nresponse)(void)){
    1990:	df 92       	push	r13
    1992:	ef 92       	push	r14
    1994:	ff 92       	push	r15
    1996:	0f 93       	push	r16
    1998:	1f 93       	push	r17
    199a:	cf 93       	push	r28
    199c:	df 93       	push	r29
    199e:	ec 01       	movw	r28, r24
    19a0:	d6 2e       	mov	r13, r22
    19a2:	8a 01       	movw	r16, r20
    19a4:	79 01       	movw	r14, r18
  int i = 0;

  assert(msg != NULL);
    19a6:	00 97       	sbiw	r24, 0x00	; 0
    19a8:	31 f4       	brne	.+12     	; 0x19b6 <new_ack_msg+0x26>
    19aa:	84 e6       	ldi	r24, 0x64	; 100
    19ac:	90 e0       	ldi	r25, 0x00	; 0
    19ae:	62 ee       	ldi	r22, 0xE2	; 226
    19b0:	71 e0       	ldi	r23, 0x01	; 1
    19b2:	0e 94 6e 19 	call	0x32dc	; 0x32dc <err_assert>
  assert(repeats > 0);
    19b6:	dd 20       	and	r13, r13
    19b8:	31 f4       	brne	.+12     	; 0x19c6 <new_ack_msg+0x36>
    19ba:	84 e6       	ldi	r24, 0x64	; 100
    19bc:	90 e0       	ldi	r25, 0x00	; 0
    19be:	63 ee       	ldi	r22, 0xE3	; 227
    19c0:	71 e0       	ldi	r23, 0x01	; 1
    19c2:	0e 94 6e 19 	call	0x32dc	; 0x32dc <err_assert>
    19c6:	20 e0       	ldi	r18, 0x00	; 0
    19c8:	30 e0       	ldi	r19, 0x00	; 0
  for(i =0; i < LenOfMsg; i++){
    last_msg_ack[i] = msg[i];
    19ca:	f9 01       	movw	r30, r18
    19cc:	e0 58       	subi	r30, 0x80	; 128
    19ce:	fe 4f       	sbci	r31, 0xFE	; 254
    19d0:	de 01       	movw	r26, r28
    19d2:	a2 0f       	add	r26, r18
    19d4:	b3 1f       	adc	r27, r19
    19d6:	8c 91       	ld	r24, X
    19d8:	80 83       	st	Z, r24
void new_ack_msg(char * msg, unsigned char repeats, void (*p_fcn)(char*s),void (*p_fcn_nresponse)(void)){
  int i = 0;

  assert(msg != NULL);
  assert(repeats > 0);
  for(i =0; i < LenOfMsg; i++){
    19da:	2f 5f       	subi	r18, 0xFF	; 255
    19dc:	3f 4f       	sbci	r19, 0xFF	; 255
    19de:	2b 30       	cpi	r18, 0x0B	; 11
    19e0:	31 05       	cpc	r19, r1
    19e2:	99 f7       	brne	.-26     	; 0x19ca <new_ack_msg+0x3a>
    last_msg_ack[i] = msg[i];
  }
  msg_ack_timer = 0;
    19e4:	10 92 7b 01 	sts	0x017B, r1
    19e8:	10 92 7a 01 	sts	0x017A, r1
  msg_ack_repeats = repeats;
    19ec:	d0 92 7c 01 	sts	0x017C, r13
  p_ack_fcn = p_fcn;
    19f0:	10 93 79 01 	sts	0x0179, r17
    19f4:	00 93 78 01 	sts	0x0178, r16
  p_nack_fcn = p_fcn_nresponse;
    19f8:	f0 92 7e 01 	sts	0x017E, r15
    19fc:	e0 92 7d 01 	sts	0x017D, r14
  assert(p_ack_fcn != NULL);
    1a00:	01 2b       	or	r16, r17
    1a02:	31 f4       	brne	.+12     	; 0x1a10 <new_ack_msg+0x80>
    1a04:	84 e6       	ldi	r24, 0x64	; 100
    1a06:	90 e0       	ldi	r25, 0x00	; 0
    1a08:	6b ee       	ldi	r22, 0xEB	; 235
    1a0a:	71 e0       	ldi	r23, 0x01	; 1
    1a0c:	0e 94 6e 19 	call	0x32dc	; 0x32dc <err_assert>
  assert(p_nack_fcn != NULL);
    1a10:	80 91 7d 01 	lds	r24, 0x017D
    1a14:	90 91 7e 01 	lds	r25, 0x017E
    1a18:	89 2b       	or	r24, r25
    1a1a:	31 f4       	brne	.+12     	; 0x1a28 <new_ack_msg+0x98>
    1a1c:	84 e6       	ldi	r24, 0x64	; 100
    1a1e:	90 e0       	ldi	r25, 0x00	; 0
    1a20:	6c ee       	ldi	r22, 0xEC	; 236
    1a22:	71 e0       	ldi	r23, 0x01	; 1
    1a24:	0e 94 6e 19 	call	0x32dc	; 0x32dc <err_assert>
  new_msg(msg);
    1a28:	ce 01       	movw	r24, r28
    1a2a:	0e 94 46 0c 	call	0x188c	; 0x188c <new_msg>
/*  */
}
    1a2e:	df 91       	pop	r29
    1a30:	cf 91       	pop	r28
    1a32:	1f 91       	pop	r17
    1a34:	0f 91       	pop	r16
    1a36:	ff 90       	pop	r15
    1a38:	ef 90       	pop	r14
    1a3a:	df 90       	pop	r13
    1a3c:	08 95       	ret

00001a3e <new_msg_P>:
 * Funkce naalokuje pamÏù pro uloûenÌ ¯etÏzce do SRAM, ¯etÏzec tam zkopÌruje
 * a zpr·vu odeöle
 * @param s_p Ukazatel do programovÈ pamÏti.
 * @return Ukazatel v pamÏti SRAM, kam je zkopÌrov·n ¯etÏzec z \a s_p
 **/
void new_msg_P( PGM_P s_p){
    1a3e:	0f 93       	push	r16
    1a40:	1f 93       	push	r17
    1a42:	cf 93       	push	r28
    1a44:	df 93       	push	r29
    1a46:	8c 01       	movw	r16, r24
  char * p_pom;

  p_pom = (char *) malloc(LenOfMsg);
    1a48:	8b e0       	ldi	r24, 0x0B	; 11
    1a4a:	90 e0       	ldi	r25, 0x00	; 0
    1a4c:	0e 94 19 32 	call	0x6432	; 0x6432 <malloc>
    1a50:	ec 01       	movw	r28, r24
  if(p_pom == NULL){
    1a52:	00 97       	sbiw	r24, 0x00	; 0
    1a54:	21 f4       	brne	.+8      	; 0x1a5e <new_msg_P+0x20>
    new_error(88); //Doöla pamÏù
    1a56:	88 e5       	ldi	r24, 0x58	; 88
    1a58:	0e 94 4e 19 	call	0x329c	; 0x329c <new_error>
    1a5c:	08 c0       	rjmp	.+16     	; 0x1a6e <new_msg_P+0x30>
    return ;
  }
  else{
    memcpy_P(p_pom, s_p,LenOfMsg);
    1a5e:	b8 01       	movw	r22, r16
    1a60:	4b e0       	ldi	r20, 0x0B	; 11
    1a62:	50 e0       	ldi	r21, 0x00	; 0
    1a64:	0e 94 1e 33 	call	0x663c	; 0x663c <memcpy_P>
    new_msg(p_pom);
    1a68:	ce 01       	movw	r24, r28
    1a6a:	0e 94 46 0c 	call	0x188c	; 0x188c <new_msg>
  }

  return;
}
    1a6e:	df 91       	pop	r29
    1a70:	cf 91       	pop	r28
    1a72:	1f 91       	pop	r17
    1a74:	0f 91       	pop	r16
    1a76:	08 95       	ret

00001a78 <process_recived_msg>:
  }
  
}

/// V tÏle tÈto funkce je ¯eöeno zpracov·nÌ p¯ijatÈ zpr·vy.
void process_recived_msg(){
    1a78:	20 e0       	ldi	r18, 0x00	; 0
    1a7a:	30 e0       	ldi	r19, 0x00	; 0
  int i = 0;
  
  //zkopirovani zpravy a tim uvoneni prijimaciho bufferu
  for (i = 0; i < LenOfMsg; i++){
    recived_msg[i] = usart_recv_buff[i + 1];
    1a7c:	2f 5f       	subi	r18, 0xFF	; 255
    1a7e:	3f 4f       	sbci	r19, 0xFF	; 255
    1a80:	f9 01       	movw	r30, r18
    1a82:	e0 5c       	subi	r30, 0xC0	; 192
    1a84:	fc 4f       	sbci	r31, 0xFC	; 252
    1a86:	d9 01       	movw	r26, r18
    1a88:	a4 5b       	subi	r26, 0xB4	; 180
    1a8a:	bc 4f       	sbci	r27, 0xFC	; 252
    1a8c:	8c 91       	ld	r24, X
    1a8e:	80 83       	st	Z, r24
/// V tÏle tÈto funkce je ¯eöeno zpracov·nÌ p¯ijatÈ zpr·vy.
void process_recived_msg(){
  int i = 0;
  
  //zkopirovani zpravy a tim uvoneni prijimaciho bufferu
  for (i = 0; i < LenOfMsg; i++){
    1a90:	2b 30       	cpi	r18, 0x0B	; 11
    1a92:	31 05       	cpc	r19, r1
    1a94:	99 f7       	brne	.-26     	; 0x1a7c <process_recived_msg+0x4>
    recived_msg[i] = usart_recv_buff[i + 1];
  }
  recv_msg(recived_msg);
    1a96:	81 e4       	ldi	r24, 0x41	; 65
    1a98:	93 e0       	ldi	r25, 0x03	; 3
    1a9a:	0e 94 78 0e 	call	0x1cf0	; 0x1cf0 <recv_msg>
}
    1a9e:	08 95       	ret

00001aa0 <__vector_13>:
    

}

/// Tahle Ë·st se spouötÌ vûdy kdyû p¯ijmeme nÏjak˝ byte po sÈriovÈm kan·le.
SIGNAL(SIG_UART_RECV){
    1aa0:	1f 92       	push	r1
    1aa2:	0f 92       	push	r0
    1aa4:	0f b6       	in	r0, 0x3f	; 63
    1aa6:	0f 92       	push	r0
    1aa8:	11 24       	eor	r1, r1
    1aaa:	2f 93       	push	r18
    1aac:	3f 93       	push	r19
    1aae:	4f 93       	push	r20
    1ab0:	5f 93       	push	r21
    1ab2:	6f 93       	push	r22
    1ab4:	7f 93       	push	r23
    1ab6:	8f 93       	push	r24
    1ab8:	9f 93       	push	r25
    1aba:	af 93       	push	r26
    1abc:	bf 93       	push	r27
    1abe:	cf 93       	push	r28
    1ac0:	df 93       	push	r29
    1ac2:	ef 93       	push	r30
    1ac4:	ff 93       	push	r31
void read_port(){
  static unsigned char byte_counter = 0;
//  unsigned char c;
//  unsigned char typ=0;

  into_buffer(UDR);
    1ac6:	9c b1       	in	r25, 0x0c	; 12
    1ac8:	ec e4       	ldi	r30, 0x4C	; 76
    1aca:	f3 e0       	ldi	r31, 0x03	; 3
 * Funkce je zaloûen· na stejnÈ implementaci jako na serveru.
 */
void into_buffer(unsigned char c){
  int i=0;
  for (i=0;i < LenOfRecvBuff - 1;i++){
    usart_recv_buff[i]=usart_recv_buff[i+1];
    1acc:	81 81       	ldd	r24, Z+1	; 0x01
    1ace:	81 93       	st	Z+, r24
 * Funkce vkl√°d√° data do bufferu.
 * Funkce je zaloûen· na stejnÈ implementaci jako na serveru.
 */
void into_buffer(unsigned char c){
  int i=0;
  for (i=0;i < LenOfRecvBuff - 1;i++){
    1ad0:	83 e0       	ldi	r24, 0x03	; 3
    1ad2:	ed 35       	cpi	r30, 0x5D	; 93
    1ad4:	f8 07       	cpc	r31, r24
    1ad6:	d1 f7       	brne	.-12     	; 0x1acc <__vector_13+0x2c>
    usart_recv_buff[i]=usart_recv_buff[i+1];
  }
  usart_recv_buff[i]=c;
    1ad8:	90 83       	st	Z, r25
  static unsigned char byte_counter = 0;
//  unsigned char c;
//  unsigned char typ=0;

  into_buffer(UDR);
  byte_counter++;
    1ada:	80 91 7f 01 	lds	r24, 0x017F
    1ade:	8f 5f       	subi	r24, 0xFF	; 255
    1ae0:	80 93 7f 01 	sts	0x017F, r24

  if (test_message(usart_recv_buff) == 1){
    1ae4:	ef 01       	movw	r28, r30
    1ae6:	61 97       	sbiw	r28, 0x11	; 17
    1ae8:	ce 01       	movw	r24, r28
    1aea:	0e 94 f0 0b 	call	0x17e0	; 0x17e0 <test_message>
    1aee:	01 97       	sbiw	r24, 0x01	; 1
    1af0:	51 f4       	brne	.+20     	; 0x1b06 <__vector_13+0x66>
    process_recived_msg();
    1af2:	0e 94 3c 0d 	call	0x1a78	; 0x1a78 <process_recived_msg>
    1af6:	fe 01       	movw	r30, r28

/// Funkce vynuluje p¯ijÌmacÌ buffer
void reset_buffer(void){
  int i=0;
  for (i=0; i < LenOfRecvBuff; i++){
    usart_recv_buff[i]=0;
    1af8:	11 92       	st	Z+, r1


/// Funkce vynuluje p¯ijÌmacÌ buffer
void reset_buffer(void){
  int i=0;
  for (i=0; i < LenOfRecvBuff; i++){
    1afa:	83 e0       	ldi	r24, 0x03	; 3
    1afc:	ee 35       	cpi	r30, 0x5E	; 94
    1afe:	f8 07       	cpc	r31, r24
    1b00:	d9 f7       	brne	.-10     	; 0x1af8 <__vector_13+0x58>
  byte_counter++;

  if (test_message(usart_recv_buff) == 1){
    process_recived_msg();
    reset_buffer();
    byte_counter = 0;
    1b02:	10 92 7f 01 	sts	0x017F, r1
//    zpracuj_zpravu();
//dorazilo
  }
  if ((usart_recv_buff[0] == 255) && (byte_counter > LenOfRecvBuff)){
    1b06:	80 91 4c 03 	lds	r24, 0x034C
    1b0a:	8f 3f       	cpi	r24, 0xFF	; 255
    1b0c:	39 f4       	brne	.+14     	; 0x1b1c <__vector_13+0x7c>
    1b0e:	80 91 7f 01 	lds	r24, 0x017F
    1b12:	83 31       	cpi	r24, 0x13	; 19
    1b14:	18 f0       	brcs	.+6      	; 0x1b1c <__vector_13+0x7c>
    // chyba prenosu - neshoda v kontrolnim souctu
    new_error(86);
    1b16:	86 e5       	ldi	r24, 0x56	; 86
    1b18:	0e 94 4e 19 	call	0x329c	; 0x329c <new_error>
SIGNAL(SIG_UART_RECV){
  read_port();

  
  //zarad_tri_zpravy();
}
    1b1c:	ff 91       	pop	r31
    1b1e:	ef 91       	pop	r30
    1b20:	df 91       	pop	r29
    1b22:	cf 91       	pop	r28
    1b24:	bf 91       	pop	r27
    1b26:	af 91       	pop	r26
    1b28:	9f 91       	pop	r25
    1b2a:	8f 91       	pop	r24
    1b2c:	7f 91       	pop	r23
    1b2e:	6f 91       	pop	r22
    1b30:	5f 91       	pop	r21
    1b32:	4f 91       	pop	r20
    1b34:	3f 91       	pop	r19
    1b36:	2f 91       	pop	r18
    1b38:	0f 90       	pop	r0
    1b3a:	0f be       	out	0x3f, r0	; 63
    1b3c:	0f 90       	pop	r0
    1b3e:	1f 90       	pop	r1
    1b40:	18 95       	reti

00001b42 <to_transmitt_buffer>:


/// Tato funkce obaluje zpravu kodem pouzivanym pro prenos po seriovem kanale.
/// Zde je provedeno uvolnÏnÌ pamÏti zpr·vy. Je tak uËinÏno po nakopÌrov·nÌ
/// zpr·vy do odesÌlacÌho bufferu.
void to_transmitt_buffer(char *msg){
    1b42:	cf 93       	push	r28
    1b44:	df 93       	push	r29
    1b46:	ac 01       	movw	r20, r24
  int i = 0;
  
  usart_trans_buff[0] = 255;
    1b48:	8f ef       	ldi	r24, 0xFF	; 255
    1b4a:	80 93 25 03 	sts	0x0325, r24
    1b4e:	ea 01       	movw	r28, r20
    1b50:	e6 e2       	ldi	r30, 0x26	; 38
    1b52:	f3 e0       	ldi	r31, 0x03	; 3
    1b54:	da 01       	movw	r26, r20
  
  for (i = 0; i < LenOfMsg; i++){
    usart_trans_buff[i + 1] = msg[i];
    1b56:	8d 91       	ld	r24, X+
    1b58:	81 93       	st	Z+, r24
void to_transmitt_buffer(char *msg){
  int i = 0;
  
  usart_trans_buff[0] = 255;
  
  for (i = 0; i < LenOfMsg; i++){
    1b5a:	83 e0       	ldi	r24, 0x03	; 3
    1b5c:	e1 33       	cpi	r30, 0x31	; 49
    1b5e:	f8 07       	cpc	r31, r24
    1b60:	d1 f7       	brne	.-12     	; 0x1b56 <to_transmitt_buffer+0x14>
    usart_trans_buff[i + 1] = msg[i];
  }
  usart_trans_buff[LenOfMsg + 1] = usart_trans_buff[0] ^ msg[0];  
    1b62:	da 01       	movw	r26, r20
    1b64:	8c 91       	ld	r24, X
    1b66:	90 91 25 03 	lds	r25, 0x0325
    1b6a:	89 27       	eor	r24, r25
    1b6c:	80 83       	st	Z, r24
    1b6e:	20 e0       	ldi	r18, 0x00	; 0
    1b70:	30 e0       	ldi	r19, 0x00	; 0

  for(i=0; i < DATASIZE; i = i + 2){
      usart_trans_buff[DATASIZE + 3 + (i/2)] = msg[i+1]^msg[i+2];
    1b72:	f9 01       	movw	r30, r18
    1b74:	f5 95       	asr	r31
    1b76:	e7 95       	ror	r30
    1b78:	eb 5d       	subi	r30, 0xDB	; 219
    1b7a:	fc 4f       	sbci	r31, 0xFC	; 252
    1b7c:	8a 81       	ldd	r24, Y+2	; 0x02
    1b7e:	99 81       	ldd	r25, Y+1	; 0x01
    1b80:	89 27       	eor	r24, r25
    1b82:	85 87       	std	Z+13, r24	; 0x0d
  for (i = 0; i < LenOfMsg; i++){
    usart_trans_buff[i + 1] = msg[i];
  }
  usart_trans_buff[LenOfMsg + 1] = usart_trans_buff[0] ^ msg[0];  

  for(i=0; i < DATASIZE; i = i + 2){
    1b84:	2e 5f       	subi	r18, 0xFE	; 254
    1b86:	3f 4f       	sbci	r19, 0xFF	; 255
    1b88:	22 96       	adiw	r28, 0x02	; 2
    1b8a:	2a 30       	cpi	r18, 0x0A	; 10
    1b8c:	31 05       	cpc	r19, r1
    1b8e:	89 f7       	brne	.-30     	; 0x1b72 <to_transmitt_buffer+0x30>
      usart_trans_buff[DATASIZE + 3 + (i/2)] = msg[i+1]^msg[i+2];
  }

  free((void *)msg);
    1b90:	ca 01       	movw	r24, r20
    1b92:	0e 94 c6 32 	call	0x658c	; 0x658c <free>
  msg = NULL;
}
    1b96:	df 91       	pop	r29
    1b98:	cf 91       	pop	r28
    1b9a:	08 95       	ret

00001b9c <send_msg>:

/// Funkce po svem zavolani projde seznam zprav. Jestli je nejaka zprava k
/// odeslani, zkopiruje ji do odesilaciho bufferu a nastavi usart_trans_count=0;
/// Tim se zahaji odesilani.
void send_msg (void){
  if (msg_buffer_counter != -1){
    1b9c:	e0 91 70 00 	lds	r30, 0x0070
    1ba0:	f0 91 71 00 	lds	r31, 0x0071
    1ba4:	8f ef       	ldi	r24, 0xFF	; 255
    1ba6:	ef 3f       	cpi	r30, 0xFF	; 255
    1ba8:	f8 07       	cpc	r31, r24
    1baa:	b1 f1       	breq	.+108    	; 0x1c18 <send_msg+0x7c>
    char *poiter_to_msg;

    // zkopirujeme obsah do bufferu
    poiter_to_msg = msg_buffer[msg_buffer_counter];

    to_transmitt_buffer(poiter_to_msg);
    1bac:	ee 0f       	add	r30, r30
    1bae:	ff 1f       	adc	r31, r31
    1bb0:	e9 5c       	subi	r30, 0xC9	; 201
    1bb2:	fc 4f       	sbci	r31, 0xFC	; 252
    1bb4:	80 81       	ld	r24, Z
    1bb6:	91 81       	ldd	r25, Z+1	; 0x01
    1bb8:	0e 94 a1 0d 	call	0x1b42	; 0x1b42 <to_transmitt_buffer>
    for (i = 0; i < LenOfTransBuff; i++){
      usart_trans_buff[i] = poiter_to_msg[i];
    }
    */
    // 
    msg_buffer[msg_buffer_counter] = NULL;
    1bbc:	80 91 70 00 	lds	r24, 0x0070
    1bc0:	90 91 71 00 	lds	r25, 0x0071
    1bc4:	fc 01       	movw	r30, r24
    1bc6:	ee 0f       	add	r30, r30
    1bc8:	ff 1f       	adc	r31, r31
    1bca:	e9 5c       	subi	r30, 0xC9	; 201
    1bcc:	fc 4f       	sbci	r31, 0xFC	; 252
    1bce:	11 82       	std	Z+1, r1	; 0x01
    1bd0:	10 82       	st	Z, r1

    // zahajime odesilani
    usart_trans_count = 0;
    1bd2:	10 92 6f 00 	sts	0x006F, r1
    1bd6:	10 92 6e 00 	sts	0x006E, r1

    // Pokusime se nalezt dalsi zpravu
    if (msg_buffer_counter == (LenOfMsgBuffer - 1)){
    1bda:	84 30       	cpi	r24, 0x04	; 4
    1bdc:	91 05       	cpc	r25, r1
    1bde:	29 f4       	brne	.+10     	; 0x1bea <send_msg+0x4e>
      msg_buffer_counter = 0;
    1be0:	10 92 71 00 	sts	0x0071, r1
    1be4:	10 92 70 00 	sts	0x0070, r1
    1be8:	05 c0       	rjmp	.+10     	; 0x1bf4 <send_msg+0x58>
    }
    else{
      msg_buffer_counter++;
    1bea:	01 96       	adiw	r24, 0x01	; 1
    1bec:	90 93 71 00 	sts	0x0071, r25
    1bf0:	80 93 70 00 	sts	0x0070, r24
    }

    // Pokud zprava neexistuje, nastavime pocitadlo na -1;
    if (msg_buffer[msg_buffer_counter] == NULL){
    1bf4:	e0 91 70 00 	lds	r30, 0x0070
    1bf8:	f0 91 71 00 	lds	r31, 0x0071
    1bfc:	ee 0f       	add	r30, r30
    1bfe:	ff 1f       	adc	r31, r31
    1c00:	e9 5c       	subi	r30, 0xC9	; 201
    1c02:	fc 4f       	sbci	r31, 0xFC	; 252
    1c04:	80 81       	ld	r24, Z
    1c06:	91 81       	ldd	r25, Z+1	; 0x01
    1c08:	89 2b       	or	r24, r25
    1c0a:	31 f4       	brne	.+12     	; 0x1c18 <send_msg+0x7c>
      msg_buffer_counter = -1; 
    1c0c:	8f ef       	ldi	r24, 0xFF	; 255
    1c0e:	9f ef       	ldi	r25, 0xFF	; 255
    1c10:	90 93 71 00 	sts	0x0071, r25
    1c14:	80 93 70 00 	sts	0x0070, r24
    1c18:	08 95       	ret

00001c1a <__vector_14>:

/// Tohle se spouötÌ kdyû je pr·zdn˝ odesÌlacÌ buffer.
/// Kdyû je zapot¯ebÌ vysÌlat, staËÌ, kdyû nastavÌ usart_trans_count = 0 .
/// OdesÌl· to po bytech vÏci z usart_trans_bufferu az do konce
/// na konci je malÈ odmlËenÌ, kv˘li lepöÌ synchronizaci
SIGNAL(SIG_UART_DATA){
    1c1a:	1f 92       	push	r1
    1c1c:	0f 92       	push	r0
    1c1e:	0f b6       	in	r0, 0x3f	; 63
    1c20:	0f 92       	push	r0
    1c22:	11 24       	eor	r1, r1
    1c24:	2f 93       	push	r18
    1c26:	3f 93       	push	r19
    1c28:	4f 93       	push	r20
    1c2a:	5f 93       	push	r21
    1c2c:	6f 93       	push	r22
    1c2e:	7f 93       	push	r23
    1c30:	8f 93       	push	r24
    1c32:	9f 93       	push	r25
    1c34:	af 93       	push	r26
    1c36:	bf 93       	push	r27
    1c38:	ef 93       	push	r30
    1c3a:	ff 93       	push	r31
  // Pokud neni co odesilat, tak se mrnkni jestli neco nema send_msg
  if (usart_trans_count == -1){
    1c3c:	80 91 6e 00 	lds	r24, 0x006E
    1c40:	90 91 6f 00 	lds	r25, 0x006F
    1c44:	8f 5f       	subi	r24, 0xFF	; 255
    1c46:	9f 4f       	sbci	r25, 0xFF	; 255
    1c48:	11 f4       	brne	.+4      	; 0x1c4e <__vector_14+0x34>
    send_msg();
    1c4a:	0e 94 ce 0d 	call	0x1b9c	; 0x1b9c <send_msg>
    
  }
  // pokud je neco v bufferu, tak makej
  if (usart_trans_count != -1){
    1c4e:	20 91 6e 00 	lds	r18, 0x006E
    1c52:	30 91 6f 00 	lds	r19, 0x006F
    1c56:	8f ef       	ldi	r24, 0xFF	; 255
    1c58:	2f 3f       	cpi	r18, 0xFF	; 255
    1c5a:	38 07       	cpc	r19, r24
    1c5c:	69 f1       	breq	.+90     	; 0x1cb8 <__vector_14+0x9e>
    
    if (usart_trans_count != LenOfTransBuff){ // zde je odesÌl·n byte po bytu
    1c5e:	22 31       	cpi	r18, 0x12	; 18
    1c60:	31 05       	cpc	r19, r1
    1c62:	59 f0       	breq	.+22     	; 0x1c7a <__vector_14+0x60>
      UDR = usart_trans_buff[usart_trans_count];
    1c64:	f9 01       	movw	r30, r18
    1c66:	eb 5d       	subi	r30, 0xDB	; 219
    1c68:	fc 4f       	sbci	r31, 0xFC	; 252
    1c6a:	80 81       	ld	r24, Z
    1c6c:	8c b9       	out	0x0c, r24	; 12
    
      usart_trans_count++;
    1c6e:	2f 5f       	subi	r18, 0xFF	; 255
    1c70:	3f 4f       	sbci	r19, 0xFF	; 255
    1c72:	30 93 6f 00 	sts	0x006F, r19
    1c76:	20 93 6e 00 	sts	0x006E, r18

    // teÔ se po kaûd˝m odesl·nÌ udÏl· pauza
    // dela se to tak, ûe se vûdycky snÌûÌ counter a kdyû je nula, tak se vöe
    // nastavÌ a ukonËÌ
    //*
    if (usart_trans_count == LenOfTransBuff){
    1c7a:	80 91 6e 00 	lds	r24, 0x006E
    1c7e:	90 91 6f 00 	lds	r25, 0x006F
    1c82:	42 97       	sbiw	r24, 0x12	; 18
    1c84:	d1 f4       	brne	.+52     	; 0x1cba <__vector_14+0xa0>
      if (after_trans_delay_counter != 0){
    1c86:	80 91 72 00 	lds	r24, 0x0072
    1c8a:	90 91 73 00 	lds	r25, 0x0073
    1c8e:	00 97       	sbiw	r24, 0x00	; 0
    1c90:	31 f0       	breq	.+12     	; 0x1c9e <__vector_14+0x84>
        after_trans_delay_counter--;
    1c92:	01 97       	sbiw	r24, 0x01	; 1
    1c94:	90 93 73 00 	sts	0x0073, r25
    1c98:	80 93 72 00 	sts	0x0072, r24
    1c9c:	0e c0       	rjmp	.+28     	; 0x1cba <__vector_14+0xa0>
      

      }
      else{
        after_trans_delay_counter = Delay;
    1c9e:	84 ef       	ldi	r24, 0xF4	; 244
    1ca0:	91 e0       	ldi	r25, 0x01	; 1
    1ca2:	90 93 73 00 	sts	0x0073, r25
    1ca6:	80 93 72 00 	sts	0x0072, r24
        usart_trans_count = -1;
    1caa:	8f ef       	ldi	r24, 0xFF	; 255
    1cac:	9f ef       	ldi	r25, 0xFF	; 255
    1cae:	90 93 6f 00 	sts	0x006F, r25
    1cb2:	80 93 6e 00 	sts	0x006E, r24
    1cb6:	01 c0       	rjmp	.+2      	; 0x1cba <__vector_14+0xa0>
    }
    //*/
    
  }
  else{
    UCSRB = UCSRB & (~(1 << UDRIE));
    1cb8:	55 98       	cbi	0x0a, 5	; 10
  }
}
    1cba:	ff 91       	pop	r31
    1cbc:	ef 91       	pop	r30
    1cbe:	bf 91       	pop	r27
    1cc0:	af 91       	pop	r26
    1cc2:	9f 91       	pop	r25
    1cc4:	8f 91       	pop	r24
    1cc6:	7f 91       	pop	r23
    1cc8:	6f 91       	pop	r22
    1cca:	5f 91       	pop	r21
    1ccc:	4f 91       	pop	r20
    1cce:	3f 91       	pop	r19
    1cd0:	2f 91       	pop	r18
    1cd2:	0f 90       	pop	r0
    1cd4:	0f be       	out	0x3f, r0	; 63
    1cd6:	0f 90       	pop	r0
    1cd8:	1f 90       	pop	r1
    1cda:	18 95       	reti

00001cdc <msg_14>:

/** 
 * Funkce odeöle zpr·vu s p¯Ìsluön˝m kÛdem.
 */
void msg_14 (void){
  new_msg_P(msg14);
    1cdc:	8b e7       	ldi	r24, 0x7B	; 123
    1cde:	92 e0       	ldi	r25, 0x02	; 2
    1ce0:	0e 94 1f 0d 	call	0x1a3e	; 0x1a3e <new_msg_P>
}
    1ce4:	08 95       	ret

00001ce6 <msg_0A>:

/** 
 * Funkce odeöle zpr·vu s p¯Ìsluön˝m kÛdem.
 */
void msg_0A (void){
  new_msg_P(msg0A);
    1ce6:	87 e8       	ldi	r24, 0x87	; 135
    1ce8:	92 e0       	ldi	r25, 0x02	; 2
    1cea:	0e 94 1f 0d 	call	0x1a3e	; 0x1a3e <new_msg_P>
}
    1cee:	08 95       	ret

00001cf0 <recv_msg>:


/**
 * Funkce je spouötÏna po p¯ijetÌ zpr·vy. Rozhoduje o tom, co bude po p¯ijetÌ uËinÏno.
 */
void recv_msg(char * recived_msg){
    1cf0:	cf 93       	push	r28
    1cf2:	df 93       	push	r29
    1cf4:	ec 01       	movw	r28, r24
  
  switch (recived_msg[0]){
    1cf6:	88 81       	ld	r24, Y
    1cf8:	80 31       	cpi	r24, 0x10	; 16
    1cfa:	09 f4       	brne	.+2      	; 0x1cfe <recv_msg+0xe>
    1cfc:	5f c0       	rjmp	.+190    	; 0x1dbc <recv_msg+0xcc>
    1cfe:	81 31       	cpi	r24, 0x11	; 17
    1d00:	80 f4       	brcc	.+32     	; 0x1d22 <recv_msg+0x32>
    1d02:	8a 30       	cpi	r24, 0x0A	; 10
    1d04:	39 f1       	breq	.+78     	; 0x1d54 <recv_msg+0x64>
    1d06:	8b 30       	cpi	r24, 0x0B	; 11
    1d08:	30 f4       	brcc	.+12     	; 0x1d16 <recv_msg+0x26>
    1d0a:	84 30       	cpi	r24, 0x04	; 4
    1d0c:	e9 f0       	breq	.+58     	; 0x1d48 <recv_msg+0x58>
    1d0e:	87 30       	cpi	r24, 0x07	; 7
    1d10:	09 f0       	breq	.+2      	; 0x1d14 <recv_msg+0x24>
    1d12:	94 c0       	rjmp	.+296    	; 0x1e3c <recv_msg+0x14c>
    1d14:	1b c0       	rjmp	.+54     	; 0x1d4c <recv_msg+0x5c>
    1d16:	8e 30       	cpi	r24, 0x0E	; 14
    1d18:	21 f1       	breq	.+72     	; 0x1d62 <recv_msg+0x72>
    1d1a:	8f 30       	cpi	r24, 0x0F	; 15
    1d1c:	09 f0       	breq	.+2      	; 0x1d20 <recv_msg+0x30>
    1d1e:	8e c0       	rjmp	.+284    	; 0x1e3c <recv_msg+0x14c>
    1d20:	33 c0       	rjmp	.+102    	; 0x1d88 <recv_msg+0x98>
    1d22:	8a 31       	cpi	r24, 0x1A	; 26
    1d24:	09 f4       	brne	.+2      	; 0x1d28 <recv_msg+0x38>
    1d26:	6b c0       	rjmp	.+214    	; 0x1dfe <recv_msg+0x10e>
    1d28:	8b 31       	cpi	r24, 0x1B	; 27
    1d2a:	38 f4       	brcc	.+14     	; 0x1d3a <recv_msg+0x4a>
    1d2c:	81 31       	cpi	r24, 0x11	; 17
    1d2e:	09 f4       	brne	.+2      	; 0x1d32 <recv_msg+0x42>
    1d30:	52 c0       	rjmp	.+164    	; 0x1dd6 <recv_msg+0xe6>
    1d32:	84 31       	cpi	r24, 0x14	; 20
    1d34:	09 f0       	breq	.+2      	; 0x1d38 <recv_msg+0x48>
    1d36:	82 c0       	rjmp	.+260    	; 0x1e3c <recv_msg+0x14c>
    1d38:	5e c0       	rjmp	.+188    	; 0x1df6 <recv_msg+0x106>
    1d3a:	80 34       	cpi	r24, 0x40	; 64
    1d3c:	09 f4       	brne	.+2      	; 0x1d40 <recv_msg+0x50>
    1d3e:	63 c0       	rjmp	.+198    	; 0x1e06 <recv_msg+0x116>
    1d40:	88 34       	cpi	r24, 0x48	; 72
    1d42:	09 f0       	breq	.+2      	; 0x1d46 <recv_msg+0x56>
    1d44:	7b c0       	rjmp	.+246    	; 0x1e3c <recv_msg+0x14c>
    1d46:	6d c0       	rjmp	.+218    	; 0x1e22 <recv_msg+0x132>
   
  case '\x04':
    new_error(4);
    1d48:	84 e0       	ldi	r24, 0x04	; 4
    1d4a:	01 c0       	rjmp	.+2      	; 0x1d4e <recv_msg+0x5e>
    break;
  case '\x07':
    new_error(7);
    1d4c:	87 e0       	ldi	r24, 0x07	; 7
    1d4e:	0e 94 4e 19 	call	0x329c	; 0x329c <new_error>
    1d52:	74 c0       	rjmp	.+232    	; 0x1e3c <recv_msg+0x14c>
    break;

  case '\x0A':{
    eeprom_save();
    1d54:	0e 94 d9 10 	call	0x21b2	; 0x21b2 <eeprom_save>
    
    new_msg_P(msg0A); 	/* p¯epoöle zpr·vu na katr */
    1d58:	87 e8       	ldi	r24, 0x87	; 135
    1d5a:	92 e0       	ldi	r25, 0x02	; 2
    1d5c:	0e 94 1f 0d 	call	0x1a3e	; 0x1a3e <new_msg_P>
    1d60:	0e c0       	rjmp	.+28     	; 0x1d7e <recv_msg+0x8e>
  }
    break;
    
  case '\x0E':
    //nastavenÌ p¯en·sobovacÌ konstanty
    set_irc_k((uint16_t)((uint16_t)(recived_msg[1] * 256) + recived_msg[2]));
    1d62:	99 81       	ldd	r25, Y+1	; 0x01
    1d64:	80 e0       	ldi	r24, 0x00	; 0
    1d66:	2a 81       	ldd	r18, Y+2	; 0x02
    1d68:	82 0f       	add	r24, r18
    1d6a:	91 1d       	adc	r25, r1
    1d6c:	0e 94 43 10 	call	0x2086	; 0x2086 <set_irc_k>
    
    //uloûenÌ do eeprom
    eeprom_w16((void *)ee_irc_k, (uint16_t)irc_get_k());
    1d70:	0e 94 21 0f 	call	0x1e42	; 0x1e42 <irc_get_k>
    1d74:	bc 01       	movw	r22, r24
    1d76:	84 e0       	ldi	r24, 0x04	; 4
    1d78:	90 e0       	ldi	r25, 0x00	; 0
    1d7a:	0e 94 cd 10 	call	0x219a	; 0x219a <eeprom_w16>
    new_msg_P(msg14);
    1d7e:	8b e7       	ldi	r24, 0x7B	; 123
    1d80:	92 e0       	ldi	r25, 0x02	; 2
    1d82:	0e 94 1f 0d 	call	0x1a3e	; 0x1a3e <new_msg_P>
    1d86:	5a c0       	rjmp	.+180    	; 0x1e3c <recv_msg+0x14c>
    break;
    
  case '\x0F':
    set_irc_set_on_value((uint32_t)((uint32_t)(recived_msg[1] * 256) + recived_msg[2]));
    1d88:	79 81       	ldd	r23, Y+1	; 0x01
    1d8a:	60 e0       	ldi	r22, 0x00	; 0
    1d8c:	88 27       	eor	r24, r24
    1d8e:	77 fd       	sbrc	r23, 7
    1d90:	80 95       	com	r24
    1d92:	98 2f       	mov	r25, r24
    1d94:	2a 81       	ldd	r18, Y+2	; 0x02
    1d96:	62 0f       	add	r22, r18
    1d98:	71 1d       	adc	r23, r1
    1d9a:	81 1d       	adc	r24, r1
    1d9c:	91 1d       	adc	r25, r1
    1d9e:	0e 94 10 10 	call	0x2020	; 0x2020 <set_irc_set_on_value>
    eeprom_w32((void *)ee_irc_set_on_value,(uint32_t) irc_set_on_value);
    1da2:	40 91 74 00 	lds	r20, 0x0074
    1da6:	50 91 75 00 	lds	r21, 0x0075
    1daa:	60 91 76 00 	lds	r22, 0x0076
    1dae:	70 91 77 00 	lds	r23, 0x0077
    1db2:	86 e0       	ldi	r24, 0x06	; 6
    1db4:	90 e0       	ldi	r25, 0x00	; 0
    1db6:	0e 94 ac 10 	call	0x2158	; 0x2158 <eeprom_w32>
    1dba:	e1 cf       	rjmp	.-62     	; 0x1d7e <recv_msg+0x8e>
    new_msg_P(msg14);
    break;
  case '\x10':{
    char * msg;
    msg = (char*)malloc(LenOfMsg);
    1dbc:	8b e0       	ldi	r24, 0x0B	; 11
    1dbe:	90 e0       	ldi	r25, 0x00	; 0
    1dc0:	0e 94 19 32 	call	0x6432	; 0x6432 <malloc>
    1dc4:	ac 01       	movw	r20, r24
    memcpy(msg,recived_msg,LenOfMsg);
    1dc6:	dc 01       	movw	r26, r24
    1dc8:	fe 01       	movw	r30, r28
    1dca:	8b e0       	ldi	r24, 0x0B	; 11
    1dcc:	01 90       	ld	r0, Z+
    1dce:	0d 92       	st	X+, r0
    1dd0:	81 50       	subi	r24, 0x01	; 1
    1dd2:	e1 f7       	brne	.-8      	; 0x1dcc <recv_msg+0xdc>
    1dd4:	0c c0       	rjmp	.+24     	; 0x1dee <recv_msg+0xfe>
    new_msg_P(msg14);
    break;
  }
  case '\x11':{
    char * msg;
    msg = (char*)malloc(LenOfMsg);
    1dd6:	8b e0       	ldi	r24, 0x0B	; 11
    1dd8:	90 e0       	ldi	r25, 0x00	; 0
    1dda:	0e 94 19 32 	call	0x6432	; 0x6432 <malloc>
    1dde:	ac 01       	movw	r20, r24
    memcpy(msg,recived_msg,LenOfMsg);
    1de0:	dc 01       	movw	r26, r24
    1de2:	fe 01       	movw	r30, r28
    1de4:	8b e0       	ldi	r24, 0x0B	; 11
    1de6:	01 90       	ld	r0, Z+
    1de8:	0d 92       	st	X+, r0
    1dea:	81 50       	subi	r24, 0x01	; 1
    1dec:	e1 f7       	brne	.-8      	; 0x1de6 <recv_msg+0xf6>
    new_msg(msg);
    1dee:	ca 01       	movw	r24, r20
    1df0:	0e 94 46 0c 	call	0x188c	; 0x188c <new_msg>
    1df4:	c4 cf       	rjmp	.-120    	; 0x1d7e <recv_msg+0x8e>
    new_msg_P(msg14);
    break;
  }
  case '\x14':
    msg_ack_fcn(recived_msg);
    1df6:	ce 01       	movw	r24, r28
    1df8:	0e 94 19 0c 	call	0x1832	; 0x1832 <msg_ack_fcn>
    1dfc:	1f c0       	rjmp	.+62     	; 0x1e3c <recv_msg+0x14c>
      new_msg(s);
      }
      break;
    */
  case '\x1A':
    width_src = recived_msg[1];
    1dfe:	89 81       	ldd	r24, Y+1	; 0x01
    1e00:	80 93 60 00 	sts	0x0060, r24
    1e04:	1b c0       	rjmp	.+54     	; 0x1e3c <recv_msg+0x14c>
    break;

  case '\x40':
    
    prumer_v = (recived_msg[2]*256)+recived_msg[1];
    1e06:	9a 81       	ldd	r25, Y+2	; 0x02
    1e08:	80 e0       	ldi	r24, 0x00	; 0
    1e0a:	29 81       	ldd	r18, Y+1	; 0x01
    1e0c:	82 0f       	add	r24, r18
    1e0e:	91 1d       	adc	r25, r1
    1e10:	90 93 17 03 	sts	0x0317, r25
    1e14:	80 93 16 03 	sts	0x0316, r24
    if (width_src == 1){
    1e18:	80 91 60 00 	lds	r24, 0x0060
    1e1c:	81 30       	cpi	r24, 0x01	; 1
    1e1e:	71 f4       	brne	.+28     	; 0x1e3c <recv_msg+0x14c>
    1e20:	04 c0       	rjmp	.+8      	; 0x1e2a <recv_msg+0x13a>
      prumer_h = (recived_msg[4]*256)+recived_msg[3];
    }
    break;
  case '\x48': // data ze serveru
    if (width_src == 2){
    1e22:	80 91 60 00 	lds	r24, 0x0060
    1e26:	82 30       	cpi	r24, 0x02	; 2
    1e28:	49 f4       	brne	.+18     	; 0x1e3c <recv_msg+0x14c>
      prumer_h = (recived_msg[4]*256)+recived_msg[3];
    1e2a:	9c 81       	ldd	r25, Y+4	; 0x04
    1e2c:	80 e0       	ldi	r24, 0x00	; 0
    1e2e:	2b 81       	ldd	r18, Y+3	; 0x03
    1e30:	82 0f       	add	r24, r18
    1e32:	91 1d       	adc	r25, r1
    1e34:	90 93 51 02 	sts	0x0251, r25
    1e38:	80 93 50 02 	sts	0x0250, r24
    break;
  default:
    break;
    
  }
}
    1e3c:	df 91       	pop	r29
    1e3e:	cf 91       	pop	r28
    1e40:	08 95       	ret

00001e42 <irc_get_k>:
  eeprom_w16((void *)ee_irc_k,irc_k);
}

uint16_t irc_get_k(void){
  return irc_k;
}
    1e42:	80 91 78 00 	lds	r24, 0x0078
    1e46:	90 91 79 00 	lds	r25, 0x0079
    1e4a:	08 95       	ret

00001e4c <irc_init>:

/**
 * Inicializace IRC.
 */
void irc_init(void){
  PORTD = PORTD | (1 << 5) | (1 << 6) | (1 << 7);
    1e4c:	82 b3       	in	r24, 0x12	; 18
    1e4e:	80 6e       	ori	r24, 0xE0	; 224
    1e50:	82 bb       	out	0x12, r24	; 18
  // aby nedoch·zelo k vyhl·öenÌ erroru p¯i prvnÌm zavol·nÌ funkce irc_watch
  prev_state = ((PIND) >> 5) & 0x07; 
    1e52:	80 b3       	in	r24, 0x10	; 16
    1e54:	82 95       	swap	r24
    1e56:	86 95       	lsr	r24
    1e58:	87 70       	andi	r24, 0x07	; 7
    1e5a:	80 93 5e 03 	sts	0x035E, r24
}
    1e5e:	08 95       	ret

00001e60 <irc_get_l>:
}




uint16_t irc_get_l(void){
    1e60:	ef 92       	push	r14
    1e62:	ff 92       	push	r15
    1e64:	0f 93       	push	r16
    1e66:	1f 93       	push	r17
    1e68:	60 91 92 01 	lds	r22, 0x0192
    1e6c:	70 91 93 01 	lds	r23, 0x0193
    1e70:	80 91 94 01 	lds	r24, 0x0194
    1e74:	90 91 95 01 	lds	r25, 0x0195
    1e78:	97 ff       	sbrs	r25, 7
    1e7a:	04 c0       	rjmp	.+8      	; 0x1e84 <irc_get_l+0x24>
    1e7c:	60 e0       	ldi	r22, 0x00	; 0
    1e7e:	70 e0       	ldi	r23, 0x00	; 0
    1e80:	80 e0       	ldi	r24, 0x00	; 0
    1e82:	90 e0       	ldi	r25, 0x00	; 0
    1e84:	0e 94 6b 3a 	call	0x74d6	; 0x74d6 <__floatsisf>
    1e88:	27 e1       	ldi	r18, 0x17	; 23
    1e8a:	37 eb       	ldi	r19, 0xB7	; 183
    1e8c:	41 ed       	ldi	r20, 0xD1	; 209
    1e8e:	58 e3       	ldi	r21, 0x38	; 56
    1e90:	0e 94 1f 3b 	call	0x763e	; 0x763e <__mulsf3>
    1e94:	7b 01       	movw	r14, r22
    1e96:	8c 01       	movw	r16, r24
    1e98:	60 91 78 00 	lds	r22, 0x0078
    1e9c:	70 91 79 00 	lds	r23, 0x0079
    1ea0:	80 e0       	ldi	r24, 0x00	; 0
    1ea2:	90 e0       	ldi	r25, 0x00	; 0
    1ea4:	0e 94 69 3a 	call	0x74d2	; 0x74d2 <__floatunsisf>
    1ea8:	9b 01       	movw	r18, r22
    1eaa:	ac 01       	movw	r20, r24
    1eac:	c8 01       	movw	r24, r16
    1eae:	b7 01       	movw	r22, r14
    1eb0:	0e 94 1f 3b 	call	0x763e	; 0x763e <__mulsf3>
    1eb4:	0e 94 3d 3a 	call	0x747a	; 0x747a <__fixunssfsi>
  //out = (uint16_t) (count * (0.0001 * irc_k));

  out = count * 0.0001 * irc_k;
  return out;

}
    1eb8:	cb 01       	movw	r24, r22
    1eba:	1f 91       	pop	r17
    1ebc:	0f 91       	pop	r16
    1ebe:	ff 90       	pop	r15
    1ec0:	ef 90       	pop	r14
    1ec2:	08 95       	ret

00001ec4 <irc_watch>:
/// funkce zavolana, je zkontrolovano, zda nedoslo okd minuleho zavolani ke
/// zmene na vstupech irc. Pokud ano, jsou provedeny prislusne korky - zvyseni
/// nebo snizeni citace irc a pripadne odeslani namerene hodnoty. Namerena
/// hodnota je dana jako hodnota irc cidla krat
/// konstanta (obvykle mensi nez jedna). 
void irc_watch(void){
    1ec4:	df 92       	push	r13
    1ec6:	ef 92       	push	r14
    1ec8:	ff 92       	push	r15
    1eca:	0f 93       	push	r16
    1ecc:	1f 93       	push	r17
  unsigned char zmena_stavu;
  unsigned char ruzne;

  // vstupy jsou invertovany
  //stav = ((~PINC) >> 3) & 0x07;
  stav = ((PIND) >> 5) & 0x07;
    1ece:	d0 b2       	in	r13, 0x10	; 16
    1ed0:	d2 94       	swap	r13
    1ed2:	d6 94       	lsr	r13
    1ed4:	87 e0       	ldi	r24, 0x07	; 7
    1ed6:	d8 22       	and	r13, r24
  zmena_stavu = stav ^ prev_state;
    1ed8:	e0 90 5e 03 	lds	r14, 0x035E
    1edc:	ed 24       	eor	r14, r13
  ruzne = (((stav >> 0) ^ (stav >> 1)) & 0x01);
    1ede:	2d 2d       	mov	r18, r13
    1ee0:	26 95       	lsr	r18
    1ee2:	2d 25       	eor	r18, r13
    1ee4:	21 70       	andi	r18, 0x01	; 1

  // zde se resi pricitani a odecitani pri zmenach vstupu A a B Jestlize dojde
  // ke zmene nektereho vstupu, pak se porovna zda jsou oba bity stejne, ci ne
  // a podle toho se citac bud inkrementuje nebo dekrementuje.
  // Rovnez je zde resen erroru pri soucasne zmene obou vstupu.
  switch ((zmena_stavu >> 0) & 0x03){
    1ee6:	8e 2d       	mov	r24, r14
    1ee8:	90 e0       	ldi	r25, 0x00	; 0
    1eea:	83 70       	andi	r24, 0x03	; 3
    1eec:	90 70       	andi	r25, 0x00	; 0
    1eee:	82 30       	cpi	r24, 0x02	; 2
    1ef0:	91 05       	cpc	r25, r1
    1ef2:	81 f0       	breq	.+32     	; 0x1f14 <irc_watch+0x50>
    1ef4:	83 30       	cpi	r24, 0x03	; 3
    1ef6:	91 05       	cpc	r25, r1
    1ef8:	a1 f1       	breq	.+104    	; 0x1f62 <irc_watch+0x9e>
    1efa:	01 97       	sbiw	r24, 0x01	; 1
    1efc:	a9 f5       	brne	.+106    	; 0x1f68 <irc_watch+0xa4>
    1efe:	80 91 92 01 	lds	r24, 0x0192
    1f02:	90 91 93 01 	lds	r25, 0x0193
    1f06:	a0 91 94 01 	lds	r26, 0x0194
    1f0a:	b0 91 95 01 	lds	r27, 0x0195
    case 1 : 
      // zmenaA
      if (ruzne == 0){
    1f0e:	22 23       	and	r18, r18
    1f10:	59 f4       	brne	.+22     	; 0x1f28 <irc_watch+0x64>
    1f12:	18 c0       	rjmp	.+48     	; 0x1f44 <irc_watch+0x80>
    1f14:	80 91 92 01 	lds	r24, 0x0192
    1f18:	90 91 93 01 	lds	r25, 0x0193
    1f1c:	a0 91 94 01 	lds	r26, 0x0194
    1f20:	b0 91 95 01 	lds	r27, 0x0195
        //irc_send_msg();
      }
      break;
    case 2 :
      // zmenaB
      if (ruzne == 0){
    1f24:	22 23       	and	r18, r18
    1f26:	71 f4       	brne	.+28     	; 0x1f44 <irc_watch+0x80>
        irc_counter--;
    1f28:	01 97       	sbiw	r24, 0x01	; 1
    1f2a:	a1 09       	sbc	r26, r1
    1f2c:	b1 09       	sbc	r27, r1
    1f2e:	80 93 92 01 	sts	0x0192, r24
    1f32:	90 93 93 01 	sts	0x0193, r25
    1f36:	a0 93 94 01 	sts	0x0194, r26
    1f3a:	b0 93 95 01 	sts	0x0195, r27
        last_oper_with_irc_counter = 0;
    1f3e:	10 92 96 01 	sts	0x0196, r1
    1f42:	12 c0       	rjmp	.+36     	; 0x1f68 <irc_watch+0xa4>
        //irc_send_msg();
      }
      else{
        irc_counter++;
    1f44:	01 96       	adiw	r24, 0x01	; 1
    1f46:	a1 1d       	adc	r26, r1
    1f48:	b1 1d       	adc	r27, r1
    1f4a:	80 93 92 01 	sts	0x0192, r24
    1f4e:	90 93 93 01 	sts	0x0193, r25
    1f52:	a0 93 94 01 	sts	0x0194, r26
    1f56:	b0 93 95 01 	sts	0x0195, r27
        last_oper_with_irc_counter = 1;
    1f5a:	81 e0       	ldi	r24, 0x01	; 1
    1f5c:	80 93 96 01 	sts	0x0196, r24
    1f60:	03 c0       	rjmp	.+6      	; 0x1f68 <irc_watch+0xa4>
      }
      break;
    case 3 :
      // oba
      // error
      new_error(6);
    1f62:	86 e0       	ldi	r24, 0x06	; 6
    1f64:	0e 94 4e 19 	call	0x329c	; 0x329c <new_error>
  // zde je reseno nastavovani irc citace
  // pokud se objevi jednicka na pinc.6 a pohybujeme se nahoru (nula je tam
  // pri obraceni vstupu)
  // 
  
  if ((((zmena_stavu >> 2) & 0x01 ) == 1) && (last_oper_with_irc_counter == 1) && (((stav >> 2 ) & 1) == 0)){
    1f68:	8e 2d       	mov	r24, r14
    1f6a:	86 95       	lsr	r24
    1f6c:	86 95       	lsr	r24
    1f6e:	80 ff       	sbrs	r24, 0
    1f70:	4f c0       	rjmp	.+158    	; 0x2010 <irc_watch+0x14c>
    1f72:	80 91 96 01 	lds	r24, 0x0196
    1f76:	81 30       	cpi	r24, 0x01	; 1
    1f78:	09 f0       	breq	.+2      	; 0x1f7c <irc_watch+0xb8>
    1f7a:	4a c0       	rjmp	.+148    	; 0x2010 <irc_watch+0x14c>
    1f7c:	8d 2d       	mov	r24, r13
    1f7e:	86 95       	lsr	r24
    1f80:	86 95       	lsr	r24
    1f82:	09 f0       	breq	.+2      	; 0x1f86 <irc_watch+0xc2>
    1f84:	45 c0       	rjmp	.+138    	; 0x2010 <irc_watch+0x14c>
    int dif = 0;

    dif = irc_set_on_value - irc_counter;
    1f86:	80 91 74 00 	lds	r24, 0x0074
    1f8a:	90 91 75 00 	lds	r25, 0x0075
    1f8e:	a0 91 76 00 	lds	r26, 0x0076
    1f92:	b0 91 77 00 	lds	r27, 0x0077
    1f96:	20 91 92 01 	lds	r18, 0x0192
    1f9a:	30 91 93 01 	lds	r19, 0x0193
    1f9e:	ac 01       	movw	r20, r24
    1fa0:	42 1b       	sub	r20, r18
    1fa2:	53 0b       	sbc	r21, r19
    1fa4:	9a 01       	movw	r18, r20
//    irc_dif_msg[1] = dif;
//    irc_dif_msg[2] = 0;
//    irc_dif_msg[3] = 0;
//    irc_dif_msg[4] = 0;

    irc_counter = irc_set_on_value;
    1fa6:	80 93 92 01 	sts	0x0192, r24
    1faa:	90 93 93 01 	sts	0x0193, r25
    1fae:	a0 93 94 01 	sts	0x0194, r26
    1fb2:	b0 93 95 01 	sts	0x0195, r27


    //irc_send_msg();
    // tady by ölo tröku nahnat
    if ((dif * 0.0001 * irc_k) > 10){
    1fb6:	57 ff       	sbrs	r21, 7
    1fb8:	03 c0       	rjmp	.+6      	; 0x1fc0 <irc_watch+0xfc>
    1fba:	30 95       	com	r19
    1fbc:	21 95       	neg	r18
    1fbe:	3f 4f       	sbci	r19, 0xFF	; 255
    1fc0:	b9 01       	movw	r22, r18
    1fc2:	88 27       	eor	r24, r24
    1fc4:	77 fd       	sbrc	r23, 7
    1fc6:	80 95       	com	r24
    1fc8:	98 2f       	mov	r25, r24
    1fca:	0e 94 6b 3a 	call	0x74d6	; 0x74d6 <__floatsisf>
    1fce:	27 e1       	ldi	r18, 0x17	; 23
    1fd0:	37 eb       	ldi	r19, 0xB7	; 183
    1fd2:	41 ed       	ldi	r20, 0xD1	; 209
    1fd4:	58 e3       	ldi	r21, 0x38	; 56
    1fd6:	0e 94 1f 3b 	call	0x763e	; 0x763e <__mulsf3>
    1fda:	7b 01       	movw	r14, r22
    1fdc:	8c 01       	movw	r16, r24
    1fde:	60 91 78 00 	lds	r22, 0x0078
    1fe2:	70 91 79 00 	lds	r23, 0x0079
    1fe6:	80 e0       	ldi	r24, 0x00	; 0
    1fe8:	90 e0       	ldi	r25, 0x00	; 0
    1fea:	0e 94 69 3a 	call	0x74d2	; 0x74d2 <__floatunsisf>
    1fee:	9b 01       	movw	r18, r22
    1ff0:	ac 01       	movw	r20, r24
    1ff2:	c8 01       	movw	r24, r16
    1ff4:	b7 01       	movw	r22, r14
    1ff6:	0e 94 1f 3b 	call	0x763e	; 0x763e <__mulsf3>
    1ffa:	20 e0       	ldi	r18, 0x00	; 0
    1ffc:	30 e0       	ldi	r19, 0x00	; 0
    1ffe:	40 e2       	ldi	r20, 0x20	; 32
    2000:	51 e4       	ldi	r21, 0x41	; 65
    2002:	0e 94 1b 3b 	call	0x7636	; 0x7636 <__gesf2>
    2006:	18 16       	cp	r1, r24
    2008:	1c f4       	brge	.+6      	; 0x2010 <irc_watch+0x14c>
      new_error(83);
    200a:	83 e5       	ldi	r24, 0x53	; 83
    200c:	0e 94 4e 19 	call	0x329c	; 0x329c <new_error>
    
  }
  

    
  prev_state = stav;
    2010:	d0 92 5e 03 	sts	0x035E, r13
  
}
    2014:	1f 91       	pop	r17
    2016:	0f 91       	pop	r16
    2018:	ff 90       	pop	r15
    201a:	ef 90       	pop	r14
    201c:	df 90       	pop	r13
    201e:	08 95       	ret

00002020 <set_irc_set_on_value>:
}

/// NastavenÌ hodnoty.
/// Vstupem je vzd·lenost nastavovacÌhoo bodu od poË·tku v centimetrech vyn·soben· deseti.
/// tj 65 cm je 650
void set_irc_set_on_value(int32_t q){
    2020:	ef 92       	push	r14
    2022:	ff 92       	push	r15
    2024:	0f 93       	push	r16
    2026:	1f 93       	push	r17
  // je tu jen 1000 mÌsto 10000. Je to protoûe ta vstupnÌ hodnota je p¯en·soben· deseti, tak je
  // t¯eba jÌ vydÏlit
  irc_set_on_value = (int32_t)(q * (1000.0 /(irc_k)));
    2028:	0e 94 6b 3a 	call	0x74d6	; 0x74d6 <__floatsisf>
    202c:	7b 01       	movw	r14, r22
    202e:	8c 01       	movw	r16, r24
    2030:	60 91 78 00 	lds	r22, 0x0078
    2034:	70 91 79 00 	lds	r23, 0x0079
    2038:	80 e0       	ldi	r24, 0x00	; 0
    203a:	90 e0       	ldi	r25, 0x00	; 0
    203c:	0e 94 69 3a 	call	0x74d2	; 0x74d2 <__floatunsisf>
    2040:	9b 01       	movw	r18, r22
    2042:	ac 01       	movw	r20, r24
    2044:	60 e0       	ldi	r22, 0x00	; 0
    2046:	70 e0       	ldi	r23, 0x00	; 0
    2048:	8a e7       	ldi	r24, 0x7A	; 122
    204a:	94 e4       	ldi	r25, 0x44	; 68
    204c:	0e 94 d0 39 	call	0x73a0	; 0x73a0 <__divsf3>
    2050:	9b 01       	movw	r18, r22
    2052:	ac 01       	movw	r20, r24
    2054:	c8 01       	movw	r24, r16
    2056:	b7 01       	movw	r22, r14
    2058:	0e 94 1f 3b 	call	0x763e	; 0x763e <__mulsf3>
    205c:	0e 94 38 3a 	call	0x7470	; 0x7470 <__fixsfsi>
    2060:	ab 01       	movw	r20, r22
    2062:	bc 01       	movw	r22, r24
    2064:	40 93 74 00 	sts	0x0074, r20
    2068:	50 93 75 00 	sts	0x0075, r21
    206c:	60 93 76 00 	sts	0x0076, r22
    2070:	70 93 77 00 	sts	0x0077, r23
  eeprom_w32((void *)ee_irc_k,irc_set_on_value);
    2074:	84 e0       	ldi	r24, 0x04	; 4
    2076:	90 e0       	ldi	r25, 0x00	; 0
    2078:	0e 94 ac 10 	call	0x2158	; 0x2158 <eeprom_w32>
}
    207c:	1f 91       	pop	r17
    207e:	0f 91       	pop	r16
    2080:	ff 90       	pop	r15
    2082:	ef 90       	pop	r14
    2084:	08 95       	ret

00002086 <set_irc_k>:
/// Vstupem je ËÌslo, kterÈ odpodvÌd· kolik milimetr˘ je na jednu ot·Ëku.
void set_irc_k (uint16_t i) {

  //10000/480 = 125/6, 120 pulz˘ * 4 hrany  = 480
  // irc_k = (i * 125) / (60); // 125/60 = 25/12 
  irc_k = (i * 25) / (12);
    2086:	29 e1       	ldi	r18, 0x19	; 25
    2088:	30 e0       	ldi	r19, 0x00	; 0
    208a:	ac 01       	movw	r20, r24
    208c:	42 9f       	mul	r20, r18
    208e:	c0 01       	movw	r24, r0
    2090:	43 9f       	mul	r20, r19
    2092:	90 0d       	add	r25, r0
    2094:	52 9f       	mul	r21, r18
    2096:	90 0d       	add	r25, r0
    2098:	11 24       	eor	r1, r1
    209a:	6c e0       	ldi	r22, 0x0C	; 12
    209c:	70 e0       	ldi	r23, 0x00	; 0
    209e:	0e 94 82 3b 	call	0x7704	; 0x7704 <__udivmodhi4>
    20a2:	60 93 78 00 	sts	0x0078, r22
    20a6:	70 93 79 00 	sts	0x0079, r23
  eeprom_w16((void *)ee_irc_k,irc_k);
    20aa:	84 e0       	ldi	r24, 0x04	; 4
    20ac:	90 e0       	ldi	r25, 0x00	; 0
    20ae:	0e 94 cd 10 	call	0x219a	; 0x219a <eeprom_w16>
}
    20b2:	08 95       	ret

000020b4 <eeprom_read_byte>:

/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    20b4:	9c 01       	movw	r18, r24
    do {} while (!eeprom_is_ready ());
    20b6:	e1 99       	sbic	0x1c, 1	; 28
    20b8:	fe cf       	rjmp	.-4      	; 0x20b6 <eeprom_read_byte+0x2>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    20ba:	3f bb       	out	0x1f, r19	; 31
    20bc:	2e bb       	out	0x1e, r18	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    20be:	e0 9a       	sbi	0x1c, 0	; 28
    20c0:	8d b3       	in	r24, 0x1d	; 29
        : "i" (_SFR_IO_ADDR(EECR)),
          "i" (EERE),
          "i" (_SFR_IO_ADDR(EEDR))
    );
    return __result;
}
    20c2:	08 95       	ret

000020c4 <eeprom_write_byte>:

/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    20c4:	9c 01       	movw	r18, r24
    do {} while (!eeprom_is_ready ());
    20c6:	e1 99       	sbic	0x1c, 1	; 28
    20c8:	fe cf       	rjmp	.-4      	; 0x20c6 <eeprom_write_byte+0x2>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    20ca:	3f bb       	out	0x1f, r19	; 31
    20cc:	2e bb       	out	0x1e, r18	; 30
#endif
    EEDR = __value;
    20ce:	6d bb       	out	0x1d, r22	; 29

    __asm__ __volatile__ (
    20d0:	0f b6       	in	r0, 0x3f	; 63
    20d2:	f8 94       	cli
    20d4:	e2 9a       	sbi	0x1c, 2	; 28
    20d6:	e1 9a       	sbi	0x1c, 1	; 28
    20d8:	0f be       	out	0x3f, r0	; 63
          [__sreg]  "i" (_SFR_IO_ADDR(SREG)),
          [__eemwe] "i" (EEMWE),
          [__eewe]  "i" (EEWE)
        : "r0"
    );
}
    20da:	08 95       	ret

000020dc <eeprom_w8>:
  wtch_enable2();
  wtch_reset2();
}

//8 bit
void eeprom_w8(void *uiAddress, uint8_t c){
    20dc:	9c 01       	movw	r18, r24
  //cekame dokud neni volno
  wtch_reset2();
    20de:	10 92 18 02 	sts	0x0218, r1
    20e2:	10 92 17 02 	sts	0x0217, r1
    20e6:	a8 95       	wdr
  eeprom_busy_wait();
    20e8:	e1 99       	sbic	0x1c, 1	; 28
    20ea:	fe cf       	rjmp	.-4      	; 0x20e8 <eeprom_w8+0xc>
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    20ec:	e1 99       	sbic	0x1c, 1	; 28
    20ee:	fe cf       	rjmp	.-4      	; 0x20ec <eeprom_w8+0x10>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    20f0:	3f bb       	out	0x1f, r19	; 31
    20f2:	2e bb       	out	0x1e, r18	; 30
#endif
    EEDR = __value;
    20f4:	6d bb       	out	0x1d, r22	; 29

    __asm__ __volatile__ (
    20f6:	0f b6       	in	r0, 0x3f	; 63
    20f8:	f8 94       	cli
    20fa:	e2 9a       	sbi	0x1c, 2	; 28
    20fc:	e1 9a       	sbi	0x1c, 1	; 28
    20fe:	0f be       	out	0x3f, r0	; 63
  eeprom_write_byte(uiAddress, c);
  
}
    2100:	08 95       	ret

00002102 <eeprom_r8>:

char eeprom_r8(void *uiAddress){
    2102:	9c 01       	movw	r18, r24
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    2104:	e1 99       	sbic	0x1c, 1	; 28
    2106:	fe cf       	rjmp	.-4      	; 0x2104 <eeprom_r8+0x2>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    2108:	3f bb       	out	0x1f, r19	; 31
    210a:	2e bb       	out	0x1e, r18	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    210c:	e0 9a       	sbi	0x1c, 0	; 28
    210e:	8d b3       	in	r24, 0x1d	; 29
  return eeprom_read_byte(uiAddress);
}
    2110:	08 95       	ret

00002112 <eeprom_r32>:
  //cekame dokud neni volno
  eeprom_busy_wait();
  eeprom_write_block( (void *)&data, uiAddress, 4);
}

uint32_t eeprom_r32(void *uiAddress){
    2112:	df 93       	push	r29
    2114:	cf 93       	push	r28
    2116:	00 d0       	rcall	.+0      	; 0x2118 <eeprom_r32+0x6>
    2118:	00 d0       	rcall	.+0      	; 0x211a <eeprom_r32+0x8>
    211a:	cd b7       	in	r28, 0x3d	; 61
    211c:	de b7       	in	r29, 0x3e	; 62
    211e:	bc 01       	movw	r22, r24
  wtch_reset2();
    2120:	10 92 18 02 	sts	0x0218, r1
    2124:	10 92 17 02 	sts	0x0217, r1
    2128:	a8 95       	wdr
  uint32_t out = 0;
    212a:	19 82       	std	Y+1, r1	; 0x01
    212c:	1a 82       	std	Y+2, r1	; 0x02
    212e:	1b 82       	std	Y+3, r1	; 0x03
    2130:	1c 82       	std	Y+4, r1	; 0x04
 */
static __inline__ void
eeprom_read_block (void *__dst, const void *__src, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eerd_block (__dst, __src, __n, eeprom_read_byte);
    2132:	ce 01       	movw	r24, r28
    2134:	01 96       	adiw	r24, 0x01	; 1
    2136:	44 e0       	ldi	r20, 0x04	; 4
    2138:	50 e0       	ldi	r21, 0x00	; 0
    213a:	2a e5       	ldi	r18, 0x5A	; 90
    213c:	30 e1       	ldi	r19, 0x10	; 16
    213e:	0e 94 4d 33 	call	0x669a	; 0x669a <__eerd_block>
    2142:	69 81       	ldd	r22, Y+1	; 0x01
    2144:	7a 81       	ldd	r23, Y+2	; 0x02
  eeprom_read_block( (void *)&out, uiAddress, 4);
  
  return out;
}
    2146:	8b 81       	ldd	r24, Y+3	; 0x03
    2148:	9c 81       	ldd	r25, Y+4	; 0x04
    214a:	0f 90       	pop	r0
    214c:	0f 90       	pop	r0
    214e:	0f 90       	pop	r0
    2150:	0f 90       	pop	r0
    2152:	cf 91       	pop	r28
    2154:	df 91       	pop	r29
    2156:	08 95       	ret

00002158 <eeprom_w32>:
uint16_t eeprom_r16(void *uiAddress){
  return eeprom_read_word(uiAddress);
}

//32bit
void eeprom_w32(void *uiAddress, uint32_t data){
    2158:	df 93       	push	r29
    215a:	cf 93       	push	r28
    215c:	00 d0       	rcall	.+0      	; 0x215e <eeprom_w32+0x6>
    215e:	00 d0       	rcall	.+0      	; 0x2160 <eeprom_w32+0x8>
    2160:	cd b7       	in	r28, 0x3d	; 61
    2162:	de b7       	in	r29, 0x3e	; 62
    2164:	49 83       	std	Y+1, r20	; 0x01
    2166:	5a 83       	std	Y+2, r21	; 0x02
    2168:	6b 83       	std	Y+3, r22	; 0x03
    216a:	7c 83       	std	Y+4, r23	; 0x04
  //cekame dokud neni volno
  eeprom_busy_wait();
    216c:	e1 99       	sbic	0x1c, 1	; 28
    216e:	fe cf       	rjmp	.-4      	; 0x216c <eeprom_w32+0x14>
 */
static __inline__ void
eeprom_write_block (const void *__src, void *__dst, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eewr_block (__dst, __src, __n, eeprom_write_byte);
    2170:	be 01       	movw	r22, r28
    2172:	6f 5f       	subi	r22, 0xFF	; 255
    2174:	7f 4f       	sbci	r23, 0xFF	; 255
    2176:	44 e0       	ldi	r20, 0x04	; 4
    2178:	50 e0       	ldi	r21, 0x00	; 0
    217a:	22 e6       	ldi	r18, 0x62	; 98
    217c:	30 e1       	ldi	r19, 0x10	; 16
    217e:	0e 94 7f 33 	call	0x66fe	; 0x66fe <__eewr_block>
  eeprom_write_block( (void *)&data, uiAddress, 4);
}
    2182:	0f 90       	pop	r0
    2184:	0f 90       	pop	r0
    2186:	0f 90       	pop	r0
    2188:	0f 90       	pop	r0
    218a:	cf 91       	pop	r28
    218c:	df 91       	pop	r29
    218e:	08 95       	ret

00002190 <eeprom_r16>:
    Read one 16-bit word (little endian) from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint16_t eeprom_read_word (const uint16_t *__p)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    return __eerd_word (__p, eeprom_read_byte);
    2190:	6a e5       	ldi	r22, 0x5A	; 90
    2192:	70 e1       	ldi	r23, 0x10	; 16
    2194:	0e 94 69 33 	call	0x66d2	; 0x66d2 <__eerd_word>
  
}

uint16_t eeprom_r16(void *uiAddress){
  return eeprom_read_word(uiAddress);
}
    2198:	08 95       	ret

0000219a <eeprom_w16>:
}

//16bit
void eeprom_w16(void *uiAddress, uint16_t word){
  //cekame dokud neni volno
  wtch_reset2();
    219a:	10 92 18 02 	sts	0x0218, r1
    219e:	10 92 17 02 	sts	0x0217, r1
    21a2:	a8 95       	wdr
  eeprom_busy_wait();
    21a4:	e1 99       	sbic	0x1c, 1	; 28
    21a6:	fe cf       	rjmp	.-4      	; 0x21a4 <eeprom_w16+0xa>
    Write a word \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_word (uint16_t *__p, uint16_t __value)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eewr_word (__p, __value, eeprom_write_byte);
    21a8:	42 e6       	ldi	r20, 0x62	; 98
    21aa:	50 e1       	ldi	r21, 0x10	; 16
    21ac:	0e 94 9b 33 	call	0x6736	; 0x6736 <__eewr_word>
  eeprom_write_word(uiAddress, word);
  
}
    21b0:	08 95       	ret

000021b2 <eeprom_save>:
}

void eeprom_save(void){
  void * p_eeprom;
  
  wtch_reset2();
    21b2:	a8 95       	wdr
  wtch_disable2();
    21b4:	8f ef       	ldi	r24, 0xFF	; 255
    21b6:	9f ef       	ldi	r25, 0xFF	; 255
    21b8:	90 93 18 02 	sts	0x0218, r25
    21bc:	80 93 17 02 	sts	0x0217, r24
    21c0:	88 e1       	ldi	r24, 0x18	; 24
    21c2:	0f b6       	in	r0, 0x3f	; 63
    21c4:	f8 94       	cli
    21c6:	81 bd       	out	0x21, r24	; 33
    21c8:	11 bc       	out	0x21, r1	; 33
    21ca:	0f be       	out	0x3f, r0	; 63
  eeprom_w32((void *)ee_irc_counter, irc_counter);
    21cc:	40 91 92 01 	lds	r20, 0x0192
    21d0:	50 91 93 01 	lds	r21, 0x0193
    21d4:	60 91 94 01 	lds	r22, 0x0194
    21d8:	70 91 95 01 	lds	r23, 0x0195
    21dc:	80 e0       	ldi	r24, 0x00	; 0
    21de:	90 e0       	ldi	r25, 0x00	; 0
    21e0:	0e 94 ac 10 	call	0x2158	; 0x2158 <eeprom_w32>
  eeprom_w8((void *)ee_width_src,width_src);
    21e4:	20 91 60 00 	lds	r18, 0x0060
}

//8 bit
void eeprom_w8(void *uiAddress, uint8_t c){
  //cekame dokud neni volno
  wtch_reset2();
    21e8:	a8 95       	wdr
  eeprom_busy_wait();
    21ea:	e1 99       	sbic	0x1c, 1	; 28
    21ec:	fe cf       	rjmp	.-4      	; 0x21ea <eeprom_save+0x38>
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    21ee:	e1 99       	sbic	0x1c, 1	; 28
    21f0:	fe cf       	rjmp	.-4      	; 0x21ee <eeprom_save+0x3c>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    21f2:	8a e0       	ldi	r24, 0x0A	; 10
    21f4:	90 e0       	ldi	r25, 0x00	; 0
    21f6:	9f bb       	out	0x1f, r25	; 31
    21f8:	8e bb       	out	0x1e, r24	; 30
#endif
    EEDR = __value;
    21fa:	2d bb       	out	0x1d, r18	; 29

    __asm__ __volatile__ (
    21fc:	0f b6       	in	r0, 0x3f	; 63
    21fe:	f8 94       	cli
    2200:	e2 9a       	sbi	0x1c, 2	; 28
    2202:	e1 9a       	sbi	0x1c, 1	; 28
    2204:	0f be       	out	0x3f, r0	; 63
}

//8 bit
void eeprom_w8(void *uiAddress, uint8_t c){
  //cekame dokud neni volno
  wtch_reset2();
    2206:	10 92 18 02 	sts	0x0218, r1
    220a:	10 92 17 02 	sts	0x0217, r1
    220e:	a8 95       	wdr
  eeprom_busy_wait();
    2210:	e1 99       	sbic	0x1c, 1	; 28
    2212:	fe cf       	rjmp	.-4      	; 0x2210 <eeprom_save+0x5e>
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    2214:	e1 99       	sbic	0x1c, 1	; 28
    2216:	fe cf       	rjmp	.-4      	; 0x2214 <eeprom_save+0x62>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    2218:	8b e0       	ldi	r24, 0x0B	; 11
    221a:	90 e0       	ldi	r25, 0x00	; 0
    221c:	9f bb       	out	0x1f, r25	; 31
    221e:	8e bb       	out	0x1e, r24	; 30
#endif
    EEDR = __value;
    2220:	8f e3       	ldi	r24, 0x3F	; 63
    2222:	8d bb       	out	0x1d, r24	; 29

    __asm__ __volatile__ (
    2224:	0f b6       	in	r0, 0x3f	; 63
    2226:	f8 94       	cli
    2228:	e2 9a       	sbi	0x1c, 2	; 28
    222a:	e1 9a       	sbi	0x1c, 1	; 28
    222c:	0f be       	out	0x3f, r0	; 63
  wtch_reset2();
  wtch_disable2();
  eeprom_w32((void *)ee_irc_counter, irc_counter);
  eeprom_w8((void *)ee_width_src,width_src);
  eeprom_w8((void *)ee_flag,63);
  uloz_posledni_data();
    222e:	0e 94 17 21 	call	0x422e	; 0x422e <uloz_posledni_data>
  //lst_write_eeprom((void *) ee_lst);
  p_eeprom = dat_zak_write_eeprom((void *)ee_lst);
    2232:	8c e0       	ldi	r24, 0x0C	; 12
    2234:	90 e0       	ldi	r25, 0x00	; 0
    2236:	0e 94 df 17 	call	0x2fbe	; 0x2fbe <dat_zak_write_eeprom>
  p_eeprom = dat_write_eeprom((void *)ee_data);
    223a:	8c e9       	ldi	r24, 0x9C	; 156
    223c:	90 e0       	ldi	r25, 0x00	; 0
    223e:	0e 94 42 18 	call	0x3084	; 0x3084 <dat_write_eeprom>

  wtch_enable2();
    2242:	2f e0       	ldi	r18, 0x0F	; 15
    2244:	88 e1       	ldi	r24, 0x18	; 24
    2246:	90 e0       	ldi	r25, 0x00	; 0
    2248:	0f b6       	in	r0, 0x3f	; 63
    224a:	f8 94       	cli
    224c:	a8 95       	wdr
    224e:	81 bd       	out	0x21, r24	; 33
    2250:	0f be       	out	0x3f, r0	; 63
    2252:	21 bd       	out	0x21, r18	; 33
  wtch_reset2();
    2254:	10 92 18 02 	sts	0x0218, r1
    2258:	10 92 17 02 	sts	0x0217, r1
    225c:	a8 95       	wdr
}
    225e:	08 95       	ret

00002260 <eeprom_load>:

//kods
void eeprom_load(void){
  char flag; // ukazuje, zda doölo k uloûenÌ dat
  void * p_eeprom;
  irc_counter = (int32_t)eeprom_r32((void *)ee_irc_counter);
    2260:	80 e0       	ldi	r24, 0x00	; 0
    2262:	90 e0       	ldi	r25, 0x00	; 0
    2264:	0e 94 89 10 	call	0x2112	; 0x2112 <eeprom_r32>
    2268:	60 93 92 01 	sts	0x0192, r22
    226c:	70 93 93 01 	sts	0x0193, r23
    2270:	80 93 94 01 	sts	0x0194, r24
    2274:	90 93 95 01 	sts	0x0195, r25
    Read one 16-bit word (little endian) from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint16_t eeprom_read_word (const uint16_t *__p)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    return __eerd_word (__p, eeprom_read_byte);
    2278:	84 e0       	ldi	r24, 0x04	; 4
    227a:	90 e0       	ldi	r25, 0x00	; 0
    227c:	6a e5       	ldi	r22, 0x5A	; 90
    227e:	70 e1       	ldi	r23, 0x10	; 16
    2280:	0e 94 69 33 	call	0x66d2	; 0x66d2 <__eerd_word>
  irc_k = (uint16_t)eeprom_r16((void *)ee_irc_k);
    2284:	90 93 79 00 	sts	0x0079, r25
    2288:	80 93 78 00 	sts	0x0078, r24
  irc_set_on_value = (int32_t)eeprom_r32((void *)ee_irc_set_on_value);
    228c:	86 e0       	ldi	r24, 0x06	; 6
    228e:	90 e0       	ldi	r25, 0x00	; 0
    2290:	0e 94 89 10 	call	0x2112	; 0x2112 <eeprom_r32>
    2294:	60 93 74 00 	sts	0x0074, r22
    2298:	70 93 75 00 	sts	0x0075, r23
    229c:	80 93 76 00 	sts	0x0076, r24
    22a0:	90 93 77 00 	sts	0x0077, r25
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    22a4:	e1 99       	sbic	0x1c, 1	; 28
    22a6:	fe cf       	rjmp	.-4      	; 0x22a4 <eeprom_load+0x44>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    22a8:	8a e0       	ldi	r24, 0x0A	; 10
    22aa:	90 e0       	ldi	r25, 0x00	; 0
    22ac:	9f bb       	out	0x1f, r25	; 31
    22ae:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    22b0:	e0 9a       	sbi	0x1c, 0	; 28
    22b2:	8d b3       	in	r24, 0x1d	; 29
  width_src = (unsigned char) eeprom_r8((void *)ee_width_src);
  width_src = width_src < 3?width_src:1;
    22b4:	83 30       	cpi	r24, 0x03	; 3
    22b6:	08 f0       	brcs	.+2      	; 0x22ba <eeprom_load+0x5a>
    22b8:	81 e0       	ldi	r24, 0x01	; 1
    22ba:	80 93 60 00 	sts	0x0060, r24
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    22be:	e1 99       	sbic	0x1c, 1	; 28
    22c0:	fe cf       	rjmp	.-4      	; 0x22be <eeprom_load+0x5e>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    22c2:	8b e0       	ldi	r24, 0x0B	; 11
    22c4:	90 e0       	ldi	r25, 0x00	; 0
    22c6:	9f bb       	out	0x1f, r25	; 31
    22c8:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    22ca:	e0 9a       	sbi	0x1c, 0	; 28
    22cc:	8d b3       	in	r24, 0x1d	; 29
  
  flag = eeprom_r8((void *)ee_flag);
  if (flag == 63){
    22ce:	8f 33       	cpi	r24, 0x3F	; 63
    22d0:	99 f4       	brne	.+38     	; 0x22f8 <eeprom_load+0x98>
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    22d2:	e1 99       	sbic	0x1c, 1	; 28
    22d4:	fe cf       	rjmp	.-4      	; 0x22d2 <eeprom_load+0x72>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    22d6:	8a e0       	ldi	r24, 0x0A	; 10
    22d8:	90 e0       	ldi	r25, 0x00	; 0
    22da:	9f bb       	out	0x1f, r25	; 31
    22dc:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    22de:	e0 9a       	sbi	0x1c, 0	; 28
    22e0:	8d b3       	in	r24, 0x1d	; 29
    width_src = eeprom_r8((void *)ee_width_src);
    22e2:	80 93 60 00 	sts	0x0060, r24
    //lst_read_eeprom((void *)ee_lst);
    p_eeprom = dat_zak_read_eeprom((void *)ee_lst);
    22e6:	8c e0       	ldi	r24, 0x0C	; 12
    22e8:	90 e0       	ldi	r25, 0x00	; 0
    22ea:	0e 94 75 17 	call	0x2eea	; 0x2eea <dat_zak_read_eeprom>
    p_eeprom = dat_read_eeprom((void *)ee_data);
    22ee:	8c e9       	ldi	r24, 0x9C	; 156
    22f0:	90 e0       	ldi	r25, 0x00	; 0
    22f2:	0e 94 27 18 	call	0x304e	; 0x304e <dat_read_eeprom>
    22f6:	08 95       	ret

  }
  else{
    set_irc_k(DEFAULT_irc_k);
    22f8:	80 e5       	ldi	r24, 0x50	; 80
    22fa:	91 e0       	ldi	r25, 0x01	; 1
    22fc:	0e 94 43 10 	call	0x2086	; 0x2086 <set_irc_k>
    set_irc_set_on_value(DEFAULT_irc_set_on_value);
    2300:	6c ec       	ldi	r22, 0xCC	; 204
    2302:	70 e1       	ldi	r23, 0x10	; 16
    2304:	80 e0       	ldi	r24, 0x00	; 0
    2306:	90 e0       	ldi	r25, 0x00	; 0
    2308:	0e 94 10 10 	call	0x2020	; 0x2020 <set_irc_set_on_value>
    dat_free_m_jmena();
    230c:	0e 94 76 16 	call	0x2cec	; 0x2cec <dat_free_m_jmena>
    2310:	08 95       	ret

00002312 <lcd_new_frame>:
int lcd_ctrl_y = LCD_Y_MAX ;

/// @returns
/// Funkce vr·tÌ 1 pokud se p¯i dalöÌm zavol·nÌ lcd_control zaËne vykreslovat nov˝ frame
/// jinak vr·tÌ nula
char lcd_new_frame(void){
    2312:	20 e0       	ldi	r18, 0x00	; 0
    2314:	80 91 7f 00 	lds	r24, 0x007F
    2318:	90 91 80 00 	lds	r25, 0x0080
    231c:	04 97       	sbiw	r24, 0x04	; 4
    231e:	09 f4       	brne	.+2      	; 0x2322 <lcd_new_frame+0x10>
    2320:	21 e0       	ldi	r18, 0x01	; 1
  if (lcd_ctrl_y == LCD_Y_MAX)
    return 1;
  else
    return 0;
}
    2322:	82 2f       	mov	r24, r18
    2324:	08 95       	ret

00002326 <d10>:


/// Jen takov· zdrûovacÌ funkce pro odlazov·nÌ
void d10(void){
    2326:	80 e0       	ldi	r24, 0x00	; 0
    2328:	90 e0       	ldi	r25, 0x00	; 0
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    232a:	32 e0       	ldi	r19, 0x02	; 2
    232c:	23 2f       	mov	r18, r19
    232e:	2a 95       	dec	r18
    2330:	f1 f7       	brne	.-4      	; 0x232e <d10+0x8>
  int i;
  for (i=0; i< 250; i++){
    2332:	01 96       	adiw	r24, 0x01	; 1
    2334:	8a 3f       	cpi	r24, 0xFA	; 250
    2336:	91 05       	cpc	r25, r1
    2338:	c9 f7       	brne	.-14     	; 0x232c <d10+0x6>
    _delay_us(1);
  }
}
    233a:	08 95       	ret

0000233c <clear_dscreen>:

/// Vymaûe default screen.
void clear_dscreen(void){
    233c:	e4 e5       	ldi	r30, 0x54	; 84
    233e:	f2 e0       	ldi	r31, 0x02	; 2
void clear_screen(char (*screen)[LCD_X_MAX]){
  int i,j;

  for (i=0; i < LCD_X_MAX; i++){
    for (j = 0; j < LCD_Y_MAX; j++){
      screen[j][i] = ' ';
    2340:	80 e2       	ldi	r24, 0x20	; 32
    2342:	80 83       	st	Z, r24
    2344:	80 a7       	std	Z+40, r24	; 0x28
    2346:	e0 5b       	subi	r30, 0xB0	; 176
    2348:	ff 4f       	sbci	r31, 0xFF	; 255
    234a:	80 83       	st	Z, r24
    234c:	b8 96       	adiw	r30, 0x28	; 40
    234e:	80 83       	st	Z, r24
    2350:	e7 57       	subi	r30, 0x77	; 119
    2352:	f0 40       	sbci	r31, 0x00	; 0

// Vymaûe obsah lcd_data
void clear_screen(char (*screen)[LCD_X_MAX]){
  int i,j;

  for (i=0; i < LCD_X_MAX; i++){
    2354:	92 e0       	ldi	r25, 0x02	; 2
    2356:	ec 37       	cpi	r30, 0x7C	; 124
    2358:	f9 07       	cpc	r31, r25
    235a:	99 f7       	brne	.-26     	; 0x2342 <clear_dscreen+0x6>
}

/// Vymaûe default screen.
void clear_dscreen(void){
  clear_screen(default_screen);
}
    235c:	08 95       	ret

0000235e <clear_screen>:


// Vymaûe obsah lcd_data
void clear_screen(char (*screen)[LCD_X_MAX]){
    235e:	fc 01       	movw	r30, r24
  int i,j;

  for (i=0; i < LCD_X_MAX; i++){
    for (j = 0; j < LCD_Y_MAX; j++){
      screen[j][i] = ' ';
    2360:	80 e2       	ldi	r24, 0x20	; 32

// Vymaûe obsah lcd_data
void clear_screen(char (*screen)[LCD_X_MAX]){
  int i,j;

  for (i=0; i < LCD_X_MAX; i++){
    2362:	9f 01       	movw	r18, r30
    2364:	28 5d       	subi	r18, 0xD8	; 216
    2366:	3f 4f       	sbci	r19, 0xFF	; 255
    for (j = 0; j < LCD_Y_MAX; j++){
      screen[j][i] = ' ';
    2368:	80 83       	st	Z, r24
    236a:	80 a7       	std	Z+40, r24	; 0x28
    236c:	e0 5b       	subi	r30, 0xB0	; 176
    236e:	ff 4f       	sbci	r31, 0xFF	; 255
    2370:	80 83       	st	Z, r24
    2372:	b8 96       	adiw	r30, 0x28	; 40
    2374:	80 83       	st	Z, r24
    2376:	e7 57       	subi	r30, 0x77	; 119
    2378:	f0 40       	sbci	r31, 0x00	; 0

// Vymaûe obsah lcd_data
void clear_screen(char (*screen)[LCD_X_MAX]){
  int i,j;

  for (i=0; i < LCD_X_MAX; i++){
    237a:	e2 17       	cp	r30, r18
    237c:	f3 07       	cpc	r31, r19
    237e:	a1 f7       	brne	.-24     	; 0x2368 <clear_screen+0xa>
    for (j = 0; j < LCD_Y_MAX; j++){
      screen[j][i] = ' ';
    }
  }
}
    2380:	08 95       	ret

00002382 <printc>:

/**
 * Funkce vytiskne znak na mÌsto kurzoru. Funkce nenÌ prov·dÏna ve "vl·knÏ".
 */
void printc(char c){
    2382:	20 e0       	ldi	r18, 0x00	; 0
    2384:	30 e0       	ldi	r19, 0x00	; 0
    2386:	42 e0       	ldi	r20, 0x02	; 2
    2388:	94 2f       	mov	r25, r20
    238a:	9a 95       	dec	r25
    238c:	f1 f7       	brne	.-4      	; 0x238a <printc+0x8>


/// Jen takov· zdrûovacÌ funkce pro odlazov·nÌ
void d10(void){
  int i;
  for (i=0; i< 250; i++){
    238e:	2f 5f       	subi	r18, 0xFF	; 255
    2390:	3f 4f       	sbci	r19, 0xFF	; 255
    2392:	2a 3f       	cpi	r18, 0xFA	; 250
    2394:	31 05       	cpc	r19, r1
    2396:	c1 f7       	brne	.-16     	; 0x2388 <printc+0x6>
/**
 * Funkce vytiskne znak na mÌsto kurzoru. Funkce nenÌ prov·dÏna ve "vl·knÏ".
 */
void printc(char c){
  d10();
  PORTA = c;
    2398:	8b bb       	out	0x1b, r24	; 27
  PORTB = ((PORTB & 0xf8) | (5 & 0x07));
    239a:	88 b3       	in	r24, 0x18	; 24
    239c:	88 7f       	andi	r24, 0xF8	; 248
    239e:	85 60       	ori	r24, 0x05	; 5
    23a0:	88 bb       	out	0x18, r24	; 24
    23a2:	80 e0       	ldi	r24, 0x00	; 0
    23a4:	90 e0       	ldi	r25, 0x00	; 0
    23a6:	32 e0       	ldi	r19, 0x02	; 2
    23a8:	23 2f       	mov	r18, r19
    23aa:	2a 95       	dec	r18
    23ac:	f1 f7       	brne	.-4      	; 0x23aa <printc+0x28>


/// Jen takov· zdrûovacÌ funkce pro odlazov·nÌ
void d10(void){
  int i;
  for (i=0; i< 250; i++){
    23ae:	01 96       	adiw	r24, 0x01	; 1
    23b0:	8a 3f       	cpi	r24, 0xFA	; 250
    23b2:	91 05       	cpc	r25, r1
    23b4:	c9 f7       	brne	.-14     	; 0x23a8 <printc+0x26>
void printc(char c){
  d10();
  PORTA = c;
  PORTB = ((PORTB & 0xf8) | (5 & 0x07));
  d10();
  PORTB = ((PORTB & 0xf8) | (1 & 0x07));
    23b6:	88 b3       	in	r24, 0x18	; 24
    23b8:	88 7f       	andi	r24, 0xF8	; 248
    23ba:	81 60       	ori	r24, 0x01	; 1
    23bc:	88 bb       	out	0x18, r24	; 24
    23be:	80 e0       	ldi	r24, 0x00	; 0
    23c0:	90 e0       	ldi	r25, 0x00	; 0
    23c2:	32 e0       	ldi	r19, 0x02	; 2
    23c4:	23 2f       	mov	r18, r19
    23c6:	2a 95       	dec	r18
    23c8:	f1 f7       	brne	.-4      	; 0x23c6 <printc+0x44>


/// Jen takov· zdrûovacÌ funkce pro odlazov·nÌ
void d10(void){
  int i;
  for (i=0; i< 250; i++){
    23ca:	01 96       	adiw	r24, 0x01	; 1
    23cc:	8a 3f       	cpi	r24, 0xFA	; 250
    23ce:	91 05       	cpc	r25, r1
    23d0:	c9 f7       	brne	.-14     	; 0x23c4 <printc+0x42>
  PORTA = c;
  PORTB = ((PORTB & 0xf8) | (5 & 0x07));
  d10();
  PORTB = ((PORTB & 0xf8) | (1 & 0x07));
  d10();
  PORTB = ((PORTB & 0xf8) | (5 & 0x07));
    23d2:	88 b3       	in	r24, 0x18	; 24
    23d4:	88 7f       	andi	r24, 0xF8	; 248
    23d6:	85 60       	ori	r24, 0x05	; 5
    23d8:	88 bb       	out	0x18, r24	; 24
}
    23da:	08 95       	ret

000023dc <printnt_P>:

/**
 * Funkce vypÌöe na souËasnou pozici kurzoru text z programovÈ pamÏti.
 * Funkce nenÌ naps·na do "vl·kna".
 */
void printnt_P(char * s){
    23dc:	cf 93       	push	r28
    23de:	df 93       	push	r29
    23e0:	ec 01       	movw	r28, r24
    23e2:	02 c0       	rjmp	.+4      	; 0x23e8 <printnt_P+0xc>
  int i=0;
  char c;
  while ((c = pgm_read_byte_near(s+i)) != '\0'){
    printc(c);
    23e4:	0e 94 c1 11 	call	0x2382	; 0x2382 <printc>
 * Funkce nenÌ naps·na do "vl·kna".
 */
void printnt_P(char * s){
  int i=0;
  char c;
  while ((c = pgm_read_byte_near(s+i)) != '\0'){
    23e8:	fe 01       	movw	r30, r28
    23ea:	84 91       	lpm	r24, Z+
    23ec:	21 96       	adiw	r28, 0x01	; 1
    23ee:	88 23       	and	r24, r24
    23f0:	c9 f7       	brne	.-14     	; 0x23e4 <printnt_P+0x8>
    printc(c);
    i++;
  }
}
    23f2:	df 91       	pop	r29
    23f4:	cf 91       	pop	r28
    23f6:	08 95       	ret

000023f8 <printcxyd>:
void print(char * s){
  printxy(default_screen,0,0,s);
}

/// Vytiskne znak do defaultscreenu na sou¯adnici x,y.
void printcxyd(int y, int x, char c){
    23f8:	9c 01       	movw	r18, r24
  if ((x < LCD_X_MAX)&&(y < LCD_Y_MAX)){
    23fa:	68 32       	cpi	r22, 0x28	; 40
    23fc:	71 05       	cpc	r23, r1
    23fe:	8c f4       	brge	.+34     	; 0x2422 <printcxyd+0x2a>
    2400:	84 30       	cpi	r24, 0x04	; 4
    2402:	91 05       	cpc	r25, r1
    2404:	74 f4       	brge	.+28     	; 0x2422 <printcxyd+0x2a>
    default_screen[y][x] = c;
    2406:	88 e2       	ldi	r24, 0x28	; 40
    2408:	90 e0       	ldi	r25, 0x00	; 0
    240a:	28 9f       	mul	r18, r24
    240c:	f0 01       	movw	r30, r0
    240e:	29 9f       	mul	r18, r25
    2410:	f0 0d       	add	r31, r0
    2412:	38 9f       	mul	r19, r24
    2414:	f0 0d       	add	r31, r0
    2416:	11 24       	eor	r1, r1
    2418:	e6 0f       	add	r30, r22
    241a:	f7 1f       	adc	r31, r23
    241c:	ec 5a       	subi	r30, 0xAC	; 172
    241e:	fd 4f       	sbci	r31, 0xFD	; 253
    2420:	40 83       	st	Z, r20
    2422:	08 95       	ret

00002424 <lcd_w_inst>:


/// Zapiö instrukci.
void lcd_w_inst(char c){
#ifdef DVA_E
  PORTA = c;
    2424:	8b bb       	out	0x1b, r24	; 27
  PORTB = ((PORTB & 0xf8) | (6 & 0x07));
    2426:	88 b3       	in	r24, 0x18	; 24
    2428:	88 7f       	andi	r24, 0xF8	; 248
    242a:	86 60       	ori	r24, 0x06	; 6
    242c:	88 bb       	out	0x18, r24	; 24
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    242e:	20 e2       	ldi	r18, 0x20	; 32
    2430:	3e e4       	ldi	r19, 0x4E	; 78
    2432:	c9 01       	movw	r24, r18
    2434:	01 97       	sbiw	r24, 0x01	; 1
    2436:	f1 f7       	brne	.-4      	; 0x2434 <lcd_w_inst+0x10>
   _delay_ms(10);
  PORTB = ((PORTB & 0xf8) | (0 & 0x07));
    2438:	88 b3       	in	r24, 0x18	; 24
    243a:	88 7f       	andi	r24, 0xF8	; 248
    243c:	88 bb       	out	0x18, r24	; 24
    243e:	c9 01       	movw	r24, r18
    2440:	01 97       	sbiw	r24, 0x01	; 1
    2442:	f1 f7       	brne	.-4      	; 0x2440 <lcd_w_inst+0x1c>
   _delay_ms(10);
  PORTB = ((PORTB & 0xf8) | (6 & 0x07));
    2444:	88 b3       	in	r24, 0x18	; 24
    2446:	88 7f       	andi	r24, 0xF8	; 248
    2448:	86 60       	ori	r24, 0x06	; 6
    244a:	88 bb       	out	0x18, r24	; 24
    244c:	c9 01       	movw	r24, r18
    244e:	01 97       	sbiw	r24, 0x01	; 1
    2450:	f1 f7       	brne	.-4      	; 0x244e <lcd_w_inst+0x2a>
  PORTB = ((PORTB & 0xf8) | (0 & 0x07));
   _delay_ms(10);
  PORTB = ((PORTB & 0xf8) | (4 & 0x07));
   _delay_ms(10);
#endif
}
    2452:	08 95       	ret

00002454 <lcd_init>:

void lcd_init(void){
  p_akt_screen = default_screen;
    2454:	44 e5       	ldi	r20, 0x54	; 84
    2456:	52 e0       	ldi	r21, 0x02	; 2
    2458:	50 93 4f 02 	sts	0x024F, r21
    245c:	40 93 4e 02 	sts	0x024E, r20

  int i;
  //cekej 15ms od n·bÏhu Vcc nad 4,5V
  DDRB = (DDRB & 0xf8)|(7 & 0x07);
    2460:	87 b3       	in	r24, 0x17	; 23
    2462:	87 60       	ori	r24, 0x07	; 7
    2464:	87 bb       	out	0x17, r24	; 23
  DDRA = 255;
    2466:	8f ef       	ldi	r24, 0xFF	; 255
    2468:	8a bb       	out	0x1a, r24	; 26
    246a:	20 e2       	ldi	r18, 0x20	; 32
    246c:	3e e4       	ldi	r19, 0x4E	; 78
    246e:	c9 01       	movw	r24, r18
    2470:	01 97       	sbiw	r24, 0x01	; 1
    2472:	f1 f7       	brne	.-4      	; 0x2470 <lcd_init+0x1c>
    2474:	c9 01       	movw	r24, r18
    2476:	01 97       	sbiw	r24, 0x01	; 1
    2478:	f1 f7       	brne	.-4      	; 0x2476 <lcd_init+0x22>
    247a:	c9 01       	movw	r24, r18
    247c:	01 97       	sbiw	r24, 0x01	; 1
    247e:	f1 f7       	brne	.-4      	; 0x247c <lcd_init+0x28>

  for (i = 0; i < 3; i++){
    _delay_ms(10);
  }
  PORTB = ((PORTB & 0xf8) | (0 & 0x07));
    2480:	88 b3       	in	r24, 0x18	; 24
    2482:	88 7f       	andi	r24, 0xF8	; 248
    2484:	88 bb       	out	0x18, r24	; 24
    2486:	c9 01       	movw	r24, r18
    2488:	01 97       	sbiw	r24, 0x01	; 1
    248a:	f1 f7       	brne	.-4      	; 0x2488 <lcd_init+0x34>
  _delay_ms(10);
  PORTB = ((PORTB & 0xf8) | (4 & 0x07));
    248c:	88 b3       	in	r24, 0x18	; 24
    248e:	88 7f       	andi	r24, 0xF8	; 248
    2490:	84 60       	ori	r24, 0x04	; 4
    2492:	88 bb       	out	0x18, r24	; 24
    2494:	c9 01       	movw	r24, r18
    2496:	01 97       	sbiw	r24, 0x01	; 1
    2498:	f1 f7       	brne	.-4      	; 0x2496 <lcd_init+0x42>


/// Zapiö instrukci.
void lcd_w_inst(char c){
#ifdef DVA_E
  PORTA = c;
    249a:	88 e3       	ldi	r24, 0x38	; 56
    249c:	8b bb       	out	0x1b, r24	; 27
  PORTB = ((PORTB & 0xf8) | (6 & 0x07));
    249e:	88 b3       	in	r24, 0x18	; 24
    24a0:	88 7f       	andi	r24, 0xF8	; 248
    24a2:	86 60       	ori	r24, 0x06	; 6
    24a4:	88 bb       	out	0x18, r24	; 24
    24a6:	c9 01       	movw	r24, r18
    24a8:	01 97       	sbiw	r24, 0x01	; 1
    24aa:	f1 f7       	brne	.-4      	; 0x24a8 <lcd_init+0x54>
   _delay_ms(10);
  PORTB = ((PORTB & 0xf8) | (0 & 0x07));
    24ac:	88 b3       	in	r24, 0x18	; 24
    24ae:	88 7f       	andi	r24, 0xF8	; 248
    24b0:	88 bb       	out	0x18, r24	; 24
    24b2:	c9 01       	movw	r24, r18
    24b4:	01 97       	sbiw	r24, 0x01	; 1
    24b6:	f1 f7       	brne	.-4      	; 0x24b4 <lcd_init+0x60>
   _delay_ms(10);
  PORTB = ((PORTB & 0xf8) | (6 & 0x07));
    24b8:	88 b3       	in	r24, 0x18	; 24
    24ba:	88 7f       	andi	r24, 0xF8	; 248
    24bc:	86 60       	ori	r24, 0x06	; 6
    24be:	88 bb       	out	0x18, r24	; 24
    24c0:	c9 01       	movw	r24, r18
    24c2:	01 97       	sbiw	r24, 0x01	; 1
    24c4:	f1 f7       	brne	.-4      	; 0x24c2 <lcd_init+0x6e>


/// Zapiö instrukci.
void lcd_w_inst(char c){
#ifdef DVA_E
  PORTA = c;
    24c6:	8c e0       	ldi	r24, 0x0C	; 12
    24c8:	8b bb       	out	0x1b, r24	; 27
  PORTB = ((PORTB & 0xf8) | (6 & 0x07));
    24ca:	88 b3       	in	r24, 0x18	; 24
    24cc:	88 7f       	andi	r24, 0xF8	; 248
    24ce:	86 60       	ori	r24, 0x06	; 6
    24d0:	88 bb       	out	0x18, r24	; 24
    24d2:	c9 01       	movw	r24, r18
    24d4:	01 97       	sbiw	r24, 0x01	; 1
    24d6:	f1 f7       	brne	.-4      	; 0x24d4 <lcd_init+0x80>
   _delay_ms(10);
  PORTB = ((PORTB & 0xf8) | (0 & 0x07));
    24d8:	88 b3       	in	r24, 0x18	; 24
    24da:	88 7f       	andi	r24, 0xF8	; 248
    24dc:	88 bb       	out	0x18, r24	; 24
    24de:	c9 01       	movw	r24, r18
    24e0:	01 97       	sbiw	r24, 0x01	; 1
    24e2:	f1 f7       	brne	.-4      	; 0x24e0 <lcd_init+0x8c>
   _delay_ms(10);
  PORTB = ((PORTB & 0xf8) | (6 & 0x07));
    24e4:	88 b3       	in	r24, 0x18	; 24
    24e6:	88 7f       	andi	r24, 0xF8	; 248
    24e8:	86 60       	ori	r24, 0x06	; 6
    24ea:	88 bb       	out	0x18, r24	; 24
    24ec:	c9 01       	movw	r24, r18
    24ee:	01 97       	sbiw	r24, 0x01	; 1
    24f0:	f1 f7       	brne	.-4      	; 0x24ee <lcd_init+0x9a>


/// Zapiö instrukci.
void lcd_w_inst(char c){
#ifdef DVA_E
  PORTA = c;
    24f2:	86 e0       	ldi	r24, 0x06	; 6
    24f4:	8b bb       	out	0x1b, r24	; 27
  PORTB = ((PORTB & 0xf8) | (6 & 0x07));
    24f6:	88 b3       	in	r24, 0x18	; 24
    24f8:	88 7f       	andi	r24, 0xF8	; 248
    24fa:	86 60       	ori	r24, 0x06	; 6
    24fc:	88 bb       	out	0x18, r24	; 24
    24fe:	c9 01       	movw	r24, r18
    2500:	01 97       	sbiw	r24, 0x01	; 1
    2502:	f1 f7       	brne	.-4      	; 0x2500 <lcd_init+0xac>
   _delay_ms(10);
  PORTB = ((PORTB & 0xf8) | (0 & 0x07));
    2504:	88 b3       	in	r24, 0x18	; 24
    2506:	88 7f       	andi	r24, 0xF8	; 248
    2508:	88 bb       	out	0x18, r24	; 24
    250a:	c9 01       	movw	r24, r18
    250c:	01 97       	sbiw	r24, 0x01	; 1
    250e:	f1 f7       	brne	.-4      	; 0x250c <lcd_init+0xb8>
   _delay_ms(10);
  PORTB = ((PORTB & 0xf8) | (6 & 0x07));
    2510:	88 b3       	in	r24, 0x18	; 24
    2512:	88 7f       	andi	r24, 0xF8	; 248
    2514:	86 60       	ori	r24, 0x06	; 6
    2516:	88 bb       	out	0x18, r24	; 24
    2518:	c9 01       	movw	r24, r18
    251a:	01 97       	sbiw	r24, 0x01	; 1
    251c:	f1 f7       	brne	.-4      	; 0x251a <lcd_init+0xc6>


/// Zapiö instrukci.
void lcd_w_inst(char c){
#ifdef DVA_E
  PORTA = c;
    251e:	81 e0       	ldi	r24, 0x01	; 1
    2520:	8b bb       	out	0x1b, r24	; 27
  PORTB = ((PORTB & 0xf8) | (6 & 0x07));
    2522:	88 b3       	in	r24, 0x18	; 24
    2524:	88 7f       	andi	r24, 0xF8	; 248
    2526:	86 60       	ori	r24, 0x06	; 6
    2528:	88 bb       	out	0x18, r24	; 24
    252a:	c9 01       	movw	r24, r18
    252c:	01 97       	sbiw	r24, 0x01	; 1
    252e:	f1 f7       	brne	.-4      	; 0x252c <lcd_init+0xd8>
   _delay_ms(10);
  PORTB = ((PORTB & 0xf8) | (0 & 0x07));
    2530:	88 b3       	in	r24, 0x18	; 24
    2532:	88 7f       	andi	r24, 0xF8	; 248
    2534:	88 bb       	out	0x18, r24	; 24
    2536:	c9 01       	movw	r24, r18
    2538:	01 97       	sbiw	r24, 0x01	; 1
    253a:	f1 f7       	brne	.-4      	; 0x2538 <lcd_init+0xe4>
   _delay_ms(10);
  PORTB = ((PORTB & 0xf8) | (6 & 0x07));
    253c:	88 b3       	in	r24, 0x18	; 24
    253e:	88 7f       	andi	r24, 0xF8	; 248
    2540:	86 60       	ori	r24, 0x06	; 6
    2542:	88 bb       	out	0x18, r24	; 24
    2544:	c9 01       	movw	r24, r18
    2546:	01 97       	sbiw	r24, 0x01	; 1
    2548:	f1 f7       	brne	.-4      	; 0x2546 <lcd_init+0xf2>
  lcd_w_inst(0x38);
  lcd_w_inst(0x0c); //0x0e; //-kurzor zapnut˝  //0x0c //vypne kurzor
  lcd_w_inst(0x06);
  lcd_w_inst(0x01); //vymaûe display a posune kurzor na zaË·tek.

  PORTB = ((PORTB & 0xf8) | (5 & 0x07)); //p¯iprravÌ na odesÌl·nÌ dat
    254a:	88 b3       	in	r24, 0x18	; 24
    254c:	88 7f       	andi	r24, 0xF8	; 248
    254e:	85 60       	ori	r24, 0x05	; 5
    2550:	88 bb       	out	0x18, r24	; 24
    2552:	fa 01       	movw	r30, r20
void clear_screen(char (*screen)[LCD_X_MAX]){
  int i,j;

  for (i=0; i < LCD_X_MAX; i++){
    for (j = 0; j < LCD_Y_MAX; j++){
      screen[j][i] = ' ';
    2554:	80 e2       	ldi	r24, 0x20	; 32
    2556:	80 83       	st	Z, r24
    2558:	80 a7       	std	Z+40, r24	; 0x28
    255a:	e0 5b       	subi	r30, 0xB0	; 176
    255c:	ff 4f       	sbci	r31, 0xFF	; 255
    255e:	80 83       	st	Z, r24
    2560:	b8 96       	adiw	r30, 0x28	; 40
    2562:	80 83       	st	Z, r24
    2564:	e7 57       	subi	r30, 0x77	; 119
    2566:	f0 40       	sbci	r31, 0x00	; 0

// Vymaûe obsah lcd_data
void clear_screen(char (*screen)[LCD_X_MAX]){
  int i,j;

  for (i=0; i < LCD_X_MAX; i++){
    2568:	92 e0       	ldi	r25, 0x02	; 2
    256a:	ec 37       	cpi	r30, 0x7C	; 124
    256c:	f9 07       	cpc	r31, r25
    256e:	99 f7       	brne	.-26     	; 0x2556 <lcd_init+0x102>

*/
 // printxy(default_screen,0,10,int2string("  ",0));
  //lcd_print();

}
    2570:	08 95       	ret

00002572 <lcd_control>:
 */
void lcd_control(void){
  // Jde to po ¯·dku a vypisuje to znak po znaku, na konci ¯·dku 
  // to skoËÌ na dalöÌ. na poslednÌm ¯·dku to p¯id· k poËÌtadlu
  // jeötÏ jedniËku a pak zafunguje prvnÌ if. Ten nastavÌ displej na zaË·tek.
  if (lcd_ctrl_y == (LCD_Y_MAX -1 + 1 )){
    2572:	40 91 7f 00 	lds	r20, 0x007F
    2576:	50 91 80 00 	lds	r21, 0x0080
    257a:	20 91 97 01 	lds	r18, 0x0197
    257e:	30 91 98 01 	lds	r19, 0x0198
    2582:	44 30       	cpi	r20, 0x04	; 4
    2584:	51 05       	cpc	r21, r1
    2586:	19 f5       	brne	.+70     	; 0x25ce <lcd_control+0x5c>
  
    switch (lcd_ctrl_count){
    2588:	21 30       	cpi	r18, 0x01	; 1
    258a:	31 05       	cpc	r19, r1
    258c:	61 f0       	breq	.+24     	; 0x25a6 <lcd_control+0x34>
    258e:	22 30       	cpi	r18, 0x02	; 2
    2590:	31 05       	cpc	r19, r1
    2592:	69 f0       	breq	.+26     	; 0x25ae <lcd_control+0x3c>
    2594:	21 15       	cp	r18, r1
    2596:	31 05       	cpc	r19, r1
    2598:	71 f4       	brne	.+28     	; 0x25b6 <lcd_control+0x44>
        PORTB = ((PORTB & 0xf8) | (5 & 0x07));
        break;
#else
      case 0:  // pripravime na vynulovani a nastaveni na zacatek 
        //TODO mozna by stacilo presunuti na zacatek
        PORTA = 2;
    259a:	82 e0       	ldi	r24, 0x02	; 2
    259c:	8b bb       	out	0x1b, r24	; 27
        PORTB = ((PORTB & 0xf8) | (6 & 0x07));
    259e:	88 b3       	in	r24, 0x18	; 24
    25a0:	88 7f       	andi	r24, 0xF8	; 248
    25a2:	86 60       	ori	r24, 0x06	; 6
    25a4:	02 c0       	rjmp	.+4      	; 0x25aa <lcd_control+0x38>
        break;
      case 1:  //zapisem
        PORTB = ((PORTB & 0xf8) | (0 & 0x07));
    25a6:	88 b3       	in	r24, 0x18	; 24
    25a8:	88 7f       	andi	r24, 0xF8	; 248
    25aa:	88 bb       	out	0x18, r24	; 24
    25ac:	45 c0       	rjmp	.+138    	; 0x2638 <lcd_control+0xc6>
        break;
      case 2:  //zase nahodime ecko a p¯ipravÌme na z·pis dat
        PORTB = ((PORTB & 0xf8) | (7 & 0x07));
    25ae:	88 b3       	in	r24, 0x18	; 24
    25b0:	87 60       	ori	r24, 0x07	; 7
    25b2:	88 bb       	out	0x18, r24	; 24
    25b4:	03 c0       	rjmp	.+6      	; 0x25bc <lcd_control+0x4a>
        break;
#endif
    }
    if (lcd_ctrl_count != 2)
    25b6:	22 30       	cpi	r18, 0x02	; 2
    25b8:	31 05       	cpc	r19, r1
    25ba:	f1 f5       	brne	.+124    	; 0x2638 <lcd_control+0xc6>
      lcd_ctrl_count++;
    else{
      lcd_ctrl_count = 0;
    25bc:	10 92 98 01 	sts	0x0198, r1
    25c0:	10 92 97 01 	sts	0x0197, r1
      lcd_ctrl_x = 0;
    25c4:	10 92 9a 01 	sts	0x019A, r1
    25c8:	10 92 99 01 	sts	0x0199, r1
    25cc:	5b c0       	rjmp	.+182    	; 0x2684 <lcd_control+0x112>
      lcd_ctrl_y = 0;
    }
  }
  else{
    switch (lcd_ctrl_count){
    25ce:	21 30       	cpi	r18, 0x01	; 1
    25d0:	31 05       	cpc	r19, r1
    25d2:	f9 f0       	breq	.+62     	; 0x2612 <lcd_control+0xa0>
    25d4:	22 30       	cpi	r18, 0x02	; 2
    25d6:	31 05       	cpc	r19, r1
    25d8:	49 f1       	breq	.+82     	; 0x262c <lcd_control+0xba>
    25da:	21 15       	cp	r18, r1
    25dc:	31 05       	cpc	r19, r1
    25de:	49 f5       	brne	.+82     	; 0x2632 <lcd_control+0xc0>
          lcd_ctrl_y_prohod = 2;
        PORTA = p_akt_screen[lcd_ctrl_y_prohod][lcd_ctrl_x];
        PORTB = ((PORTB & 0xf8) | (5 & 0x07));
        }
#else
        PORTA = p_akt_screen[lcd_ctrl_y][lcd_ctrl_x];
    25e0:	88 e2       	ldi	r24, 0x28	; 40
    25e2:	90 e0       	ldi	r25, 0x00	; 0
    25e4:	bc 01       	movw	r22, r24
    25e6:	46 9f       	mul	r20, r22
    25e8:	c0 01       	movw	r24, r0
    25ea:	47 9f       	mul	r20, r23
    25ec:	90 0d       	add	r25, r0
    25ee:	56 9f       	mul	r21, r22
    25f0:	90 0d       	add	r25, r0
    25f2:	11 24       	eor	r1, r1
    25f4:	e0 91 4e 02 	lds	r30, 0x024E
    25f8:	f0 91 4f 02 	lds	r31, 0x024F
    25fc:	e8 0f       	add	r30, r24
    25fe:	f9 1f       	adc	r31, r25
    2600:	80 91 99 01 	lds	r24, 0x0199
    2604:	90 91 9a 01 	lds	r25, 0x019A
    2608:	e8 0f       	add	r30, r24
    260a:	f9 1f       	adc	r31, r25
    260c:	80 81       	ld	r24, Z
    260e:	8b bb       	out	0x1b, r24	; 27
    2610:	0d c0       	rjmp	.+26     	; 0x262c <lcd_control+0xba>
        break;
      case 1:  //zapisem
#ifndef DVA_E
        PORTB = ((PORTB & 0xf8) | (1 & 0x07));
#else
        if (lcd_ctrl_y < 2)
    2612:	42 30       	cpi	r20, 0x02	; 2
    2614:	51 05       	cpc	r21, r1
    2616:	2c f4       	brge	.+10     	; 0x2622 <lcd_control+0xb0>
          PORTB = ((PORTB & 0xf8) | (3 & 0x07));
    2618:	88 b3       	in	r24, 0x18	; 24
    261a:	88 7f       	andi	r24, 0xF8	; 248
    261c:	83 60       	ori	r24, 0x03	; 3
    261e:	88 bb       	out	0x18, r24	; 24
    2620:	12 c0       	rjmp	.+36     	; 0x2646 <lcd_control+0xd4>
        else
          PORTB = ((PORTB & 0xf8) | (5 & 0x07));
    2622:	88 b3       	in	r24, 0x18	; 24
    2624:	88 7f       	andi	r24, 0xF8	; 248
    2626:	85 60       	ori	r24, 0x05	; 5
    2628:	88 bb       	out	0x18, r24	; 24
    262a:	03 c0       	rjmp	.+6      	; 0x2632 <lcd_control+0xc0>
        break;
      case 2:  //zase nahodime ecko a p¯ipravÌme na z·pis dat
#ifndef DVA_E
        PORTB = ((PORTB & 0xf8) | (5 & 0x07));
#else
        PORTB = ((PORTB & 0xf8) | (7 & 0x07));
    262c:	88 b3       	in	r24, 0x18	; 24
    262e:	87 60       	ori	r24, 0x07	; 7
    2630:	bc cf       	rjmp	.-136    	; 0x25aa <lcd_control+0x38>
#endif
        break;
    }

    if (lcd_ctrl_count != 1)
    2632:	21 30       	cpi	r18, 0x01	; 1
    2634:	31 05       	cpc	r19, r1
    2636:	39 f0       	breq	.+14     	; 0x2646 <lcd_control+0xd4>
      lcd_ctrl_count++;
    2638:	2f 5f       	subi	r18, 0xFF	; 255
    263a:	3f 4f       	sbci	r19, 0xFF	; 255
    263c:	30 93 98 01 	sts	0x0198, r19
    2640:	20 93 97 01 	sts	0x0197, r18
    2644:	08 95       	ret
    else{
      // Tady se ¯eöÌ spr·vnÈ ËÌt·nÌ. P¯i dosaûenÌ meznÌch hodnot pole dojde k nastavenÌ sou¯adnic na dalöÌ ¯·dek...
      // sem se to dostane vûdy po dokonËenÌ z·pisu znaku (instrukce).
      lcd_ctrl_count = 0;
    2646:	10 92 98 01 	sts	0x0198, r1
    264a:	10 92 97 01 	sts	0x0197, r1
      if (lcd_ctrl_x < (LCD_X_MAX - 1)){
    264e:	80 91 99 01 	lds	r24, 0x0199
    2652:	90 91 9a 01 	lds	r25, 0x019A
    2656:	87 32       	cpi	r24, 0x27	; 39
    2658:	91 05       	cpc	r25, r1
    265a:	34 f4       	brge	.+12     	; 0x2668 <lcd_control+0xf6>
        //pokud jsme nedos·hli koncce ¯·dku, zvyöujeme jeho sou¯adnici
        lcd_ctrl_x++;
    265c:	01 96       	adiw	r24, 0x01	; 1
    265e:	90 93 9a 01 	sts	0x019A, r25
    2662:	80 93 99 01 	sts	0x0199, r24
    2666:	08 95       	ret
      }
      else{
        // kdyû jsme na konci ¯·dku, nastavÌme sou¯adnici na nulu a zv˝öÌme poËÌtadlo ¯·dk˘.
        lcd_ctrl_x = 0;
    2668:	10 92 9a 01 	sts	0x019A, r1
    266c:	10 92 99 01 	sts	0x0199, r1

        if(lcd_ctrl_y < (LCD_Y_MAX -1 + 1)){
    2670:	44 30       	cpi	r20, 0x04	; 4
    2672:	51 05       	cpc	r21, r1
    2674:	3c f4       	brge	.+14     	; 0x2684 <lcd_control+0x112>
          lcd_ctrl_y++;
    2676:	4f 5f       	subi	r20, 0xFF	; 255
    2678:	5f 4f       	sbci	r21, 0xFF	; 255
    267a:	50 93 80 00 	sts	0x0080, r21
    267e:	40 93 7f 00 	sts	0x007F, r20
    2682:	08 95       	ret
        }
        else{
          //pokud jsme se dostali na poslednÌ ¯·dek displaye + 1 , je nÏco divnÏ
          // tenhle p¯Ìpad by totiû mÏla chytit prvnÌ podmÌnka. MÌsto poslenÌho ¯·dku + 1 se zpracov·v· instrukce pro 
          // nastavenÌ displeje na nulu.
          lcd_ctrl_y = 0;
    2684:	10 92 80 00 	sts	0x0080, r1
    2688:	10 92 7f 00 	sts	0x007F, r1
    268c:	08 95       	ret

0000268e <printxyd_P>:
    new_error(82);
  }
}

/// Funkce vloûÌ na danou pozici ¯etÏzec @a s
void printxyd_P(int y,int x,void * s){
    268e:	af 92       	push	r10
    2690:	bf 92       	push	r11
    2692:	cf 92       	push	r12
    2694:	df 92       	push	r13
    2696:	ef 92       	push	r14
    2698:	ff 92       	push	r15
    269a:	1f 93       	push	r17
    269c:	cf 93       	push	r28
    269e:	df 93       	push	r29
    26a0:	dc 01       	movw	r26, r24
    26a2:	eb 01       	movw	r28, r22
    26a4:	7a 01       	movw	r14, r20
  int n = 0;
  int n_x = 0;
  char c;

  if ((x < LCD_X_MAX)&&(y < LCD_Y_MAX)){
    26a6:	68 32       	cpi	r22, 0x28	; 40
    26a8:	71 05       	cpc	r23, r1
    26aa:	0c f0       	brlt	.+2      	; 0x26ae <printxyd_P+0x20>
    26ac:	50 c0       	rjmp	.+160    	; 0x274e <printxyd_P+0xc0>
    26ae:	84 30       	cpi	r24, 0x04	; 4
    26b0:	91 05       	cpc	r25, r1
    26b2:	0c f0       	brlt	.+2      	; 0x26b6 <printxyd_P+0x28>
    26b4:	4c c0       	rjmp	.+152    	; 0x274e <printxyd_P+0xc0>
    //KopÌruj do pole lcd
    c = pgm_read_byte_near(s);
    26b6:	fa 01       	movw	r30, r20
    26b8:	14 91       	lpm	r17, Z+
    26ba:	40 e0       	ldi	r20, 0x00	; 0
    26bc:	50 e0       	ldi	r21, 0x00	; 0
        n_x = 0;
        n++;
        c = pgm_read_byte_near(s+n);
        if (y >= LCD_Y_MAX){
          new_error(80);
          break;
    26be:	88 e2       	ldi	r24, 0x28	; 40
    26c0:	c8 2e       	mov	r12, r24
    26c2:	d1 2c       	mov	r13, r1
    26c4:	1f c0       	rjmp	.+62     	; 0x2704 <printxyd_P+0x76>
  if ((x < LCD_X_MAX)&&(y < LCD_Y_MAX)){
    //KopÌruj do pole lcd
    c = pgm_read_byte_near(s);
    while ((c != '\0') && ( (x + n_x) < LCD_X_MAX)){
      //screen[y][x+n_x]=c;
      default_screen[y][x+n_x] = c;
    26c6:	f5 01       	movw	r30, r10
    26c8:	11 93       	st	Z+, r17
    26ca:	5f 01       	movw	r10, r30

      n++;
    26cc:	4f 5f       	subi	r20, 0xFF	; 255
    26ce:	5f 4f       	sbci	r21, 0xFF	; 255
      n_x++;
      c = pgm_read_byte_near(s+n);
    26d0:	fb 01       	movw	r30, r22
    26d2:	84 91       	lpm	r24, Z+
    26d4:	6f 5f       	subi	r22, 0xFF	; 255
    26d6:	7f 4f       	sbci	r23, 0xFF	; 255
      if(c == '\n'){
    26d8:	8a 30       	cpi	r24, 0x0A	; 10
    26da:	21 f0       	breq	.+8      	; 0x26e4 <printxyd_P+0x56>
    while ((c != '\0') && ( (x + n_x) < LCD_X_MAX)){
      //screen[y][x+n_x]=c;
      default_screen[y][x+n_x] = c;

      n++;
      n_x++;
    26dc:	2f 5f       	subi	r18, 0xFF	; 255
    26de:	3f 4f       	sbci	r19, 0xFF	; 255
    26e0:	18 2f       	mov	r17, r24
    26e2:	26 c0       	rjmp	.+76     	; 0x2730 <printxyd_P+0xa2>
      c = pgm_read_byte_near(s+n);
      if(c == '\n'){
        y++;
    26e4:	11 96       	adiw	r26, 0x01	; 1
        n_x = 0;
        n++;
    26e6:	4f 5f       	subi	r20, 0xFF	; 255
    26e8:	5f 4f       	sbci	r21, 0xFF	; 255
        c = pgm_read_byte_near(s+n);
    26ea:	f7 01       	movw	r30, r14
    26ec:	e4 0f       	add	r30, r20
    26ee:	f5 1f       	adc	r31, r21
    26f0:	14 91       	lpm	r17, Z+
        if (y >= LCD_Y_MAX){
    26f2:	a4 30       	cpi	r26, 0x04	; 4
    26f4:	b1 05       	cpc	r27, r1
    26f6:	34 f0       	brlt	.+12     	; 0x2704 <printxyd_P+0x76>
          new_error(80);
    26f8:	80 e5       	ldi	r24, 0x50	; 80
    26fa:	0e 94 4e 19 	call	0x329c	; 0x329c <new_error>
    26fe:	20 e0       	ldi	r18, 0x00	; 0
    2700:	30 e0       	ldi	r19, 0x00	; 0
    2702:	1e c0       	rjmp	.+60     	; 0x2740 <printxyd_P+0xb2>
          break;
    2704:	ac 9d       	mul	r26, r12
    2706:	50 01       	movw	r10, r0
    2708:	ad 9d       	mul	r26, r13
    270a:	b0 0c       	add	r11, r0
    270c:	bc 9d       	mul	r27, r12
    270e:	b0 0c       	add	r11, r0
    2710:	11 24       	eor	r1, r1
    2712:	ac 0e       	add	r10, r28
    2714:	bd 1e       	adc	r11, r29
    2716:	84 e5       	ldi	r24, 0x54	; 84
    2718:	92 e0       	ldi	r25, 0x02	; 2
    271a:	a8 0e       	add	r10, r24
    271c:	b9 1e       	adc	r11, r25
    271e:	4f 5f       	subi	r20, 0xFF	; 255
    2720:	5f 4f       	sbci	r21, 0xFF	; 255
    2722:	b7 01       	movw	r22, r14
    2724:	64 0f       	add	r22, r20
    2726:	75 1f       	adc	r23, r21
    2728:	41 50       	subi	r20, 0x01	; 1
    272a:	50 40       	sbci	r21, 0x00	; 0
    272c:	20 e0       	ldi	r18, 0x00	; 0
    272e:	30 e0       	ldi	r19, 0x00	; 0
  char c;

  if ((x < LCD_X_MAX)&&(y < LCD_Y_MAX)){
    //KopÌruj do pole lcd
    c = pgm_read_byte_near(s);
    while ((c != '\0') && ( (x + n_x) < LCD_X_MAX)){
    2730:	11 23       	and	r17, r17
    2732:	31 f0       	breq	.+12     	; 0x2740 <printxyd_P+0xb2>
    2734:	c9 01       	movw	r24, r18
    2736:	8c 0f       	add	r24, r28
    2738:	9d 1f       	adc	r25, r29
    273a:	88 97       	sbiw	r24, 0x28	; 40
    273c:	0c f4       	brge	.+2      	; 0x2740 <printxyd_P+0xb2>
    273e:	c3 cf       	rjmp	.-122    	; 0x26c6 <printxyd_P+0x38>
          break;
        }
        
      }
    }
    if ((x+n_x) > LCD_X_MAX){
    2740:	2c 0f       	add	r18, r28
    2742:	3d 1f       	adc	r19, r29
    2744:	29 32       	cpi	r18, 0x29	; 41
    2746:	31 05       	cpc	r19, r1
    2748:	2c f0       	brlt	.+10     	; 0x2754 <printxyd_P+0xc6>
      new_error(81);
    274a:	81 e5       	ldi	r24, 0x51	; 81
    274c:	01 c0       	rjmp	.+2      	; 0x2750 <printxyd_P+0xc2>
    }
  }
  else{
    new_error(82);
    274e:	82 e5       	ldi	r24, 0x52	; 82
    2750:	0e 94 4e 19 	call	0x329c	; 0x329c <new_error>
  }
}
    2754:	df 91       	pop	r29
    2756:	cf 91       	pop	r28
    2758:	1f 91       	pop	r17
    275a:	ff 90       	pop	r15
    275c:	ef 90       	pop	r14
    275e:	df 90       	pop	r13
    2760:	cf 90       	pop	r12
    2762:	bf 90       	pop	r11
    2764:	af 90       	pop	r10
    2766:	08 95       	ret

00002768 <printxy>:
void printxyd(int y, int x, char * s){
  printxy(default_screen, y, x, s);
}

/// Funkce vloûÌ na danou pozici ¯etÏzec @a s
void printxy(char (*screen)[LCD_X_MAX],int y,int x,char * s){
    2768:	af 92       	push	r10
    276a:	bf 92       	push	r11
    276c:	cf 92       	push	r12
    276e:	df 92       	push	r13
    2770:	ef 92       	push	r14
    2772:	ff 92       	push	r15
    2774:	0f 93       	push	r16
    2776:	1f 93       	push	r17
    2778:	cf 93       	push	r28
    277a:	df 93       	push	r29
    277c:	dc 01       	movw	r26, r24
    277e:	8b 01       	movw	r16, r22
    2780:	7a 01       	movw	r14, r20
    2782:	e9 01       	movw	r28, r18
  int n = 0;
  int n_x = 0;
  char c;
  if (s == NULL){
    2784:	21 15       	cp	r18, r1
    2786:	31 05       	cpc	r19, r1
    2788:	11 f4       	brne	.+4      	; 0x278e <printxy+0x26>
    278a:	ca e7       	ldi	r28, 0x7A	; 122
    278c:	d0 e0       	ldi	r29, 0x00	; 0
    s = "NULL";
  }

  if ((x < LCD_X_MAX)&&(y < LCD_Y_MAX)){
    278e:	88 e2       	ldi	r24, 0x28	; 40
    2790:	e8 16       	cp	r14, r24
    2792:	f1 04       	cpc	r15, r1
    2794:	0c f0       	brlt	.+2      	; 0x2798 <printxy+0x30>
    2796:	4c c0       	rjmp	.+152    	; 0x2830 <printxy+0xc8>
    2798:	04 30       	cpi	r16, 0x04	; 4
    279a:	11 05       	cpc	r17, r1
    279c:	0c f0       	brlt	.+2      	; 0x27a0 <printxy+0x38>
    279e:	48 c0       	rjmp	.+144    	; 0x2830 <printxy+0xc8>
    //KopÌruj do pole lcd
    c = s[0];
    27a0:	e8 81       	ld	r30, Y
    27a2:	88 e2       	ldi	r24, 0x28	; 40
    27a4:	90 e0       	ldi	r25, 0x00	; 0
    27a6:	08 9f       	mul	r16, r24
    27a8:	b0 01       	movw	r22, r0
    27aa:	09 9f       	mul	r16, r25
    27ac:	70 0d       	add	r23, r0
    27ae:	18 9f       	mul	r17, r24
    27b0:	70 0d       	add	r23, r0
    27b2:	11 24       	eor	r1, r1
    27b4:	6a 0f       	add	r22, r26
    27b6:	7b 1f       	adc	r23, r27
    27b8:	40 e0       	ldi	r20, 0x00	; 0
    27ba:	50 e0       	ldi	r21, 0x00	; 0
    27bc:	23 c0       	rjmp	.+70     	; 0x2804 <printxy+0x9c>
    while ((c != '\0') && ( (x + n_x) < LCD_X_MAX)){
      screen[y][x+n_x]=c;
    27be:	d6 01       	movw	r26, r12
    27c0:	ed 93       	st	X+, r30
    27c2:	6d 01       	movw	r12, r26
      //default_screen[y][x+n_x] = c;

      n++;
    27c4:	4f 5f       	subi	r20, 0xFF	; 255
    27c6:	5f 4f       	sbci	r21, 0xFF	; 255
      n_x++;
      c = s[n];
    27c8:	d5 01       	movw	r26, r10
    27ca:	11 96       	adiw	r26, 0x01	; 1
    27cc:	ec 91       	ld	r30, X
    27ce:	08 94       	sec
    27d0:	a1 1c       	adc	r10, r1
    27d2:	b1 1c       	adc	r11, r1
      if(c == '\n'){
    27d4:	ea 30       	cpi	r30, 0x0A	; 10
    27d6:	19 f0       	breq	.+6      	; 0x27de <printxy+0x76>
    while ((c != '\0') && ( (x + n_x) < LCD_X_MAX)){
      screen[y][x+n_x]=c;
      //default_screen[y][x+n_x] = c;

      n++;
      n_x++;
    27d8:	2f 5f       	subi	r18, 0xFF	; 255
    27da:	3f 4f       	sbci	r19, 0xFF	; 255
    27dc:	1b c0       	rjmp	.+54     	; 0x2814 <printxy+0xac>
      c = s[n];
      if(c == '\n'){
        y++;
    27de:	0f 5f       	subi	r16, 0xFF	; 255
    27e0:	1f 4f       	sbci	r17, 0xFF	; 255
        n_x = 0;
        n++;
    27e2:	4f 5f       	subi	r20, 0xFF	; 255
    27e4:	5f 4f       	sbci	r21, 0xFF	; 255
        c = s[n];
    27e6:	fe 01       	movw	r30, r28
    27e8:	e4 0f       	add	r30, r20
    27ea:	f5 1f       	adc	r31, r21
    27ec:	e0 81       	ld	r30, Z
    27ee:	68 5d       	subi	r22, 0xD8	; 216
    27f0:	7f 4f       	sbci	r23, 0xFF	; 255
        if (y >= LCD_Y_MAX){
    27f2:	04 30       	cpi	r16, 0x04	; 4
    27f4:	11 05       	cpc	r17, r1
    27f6:	34 f0       	brlt	.+12     	; 0x2804 <printxy+0x9c>
          new_error(80);
    27f8:	80 e5       	ldi	r24, 0x50	; 80
    27fa:	0e 94 4e 19 	call	0x329c	; 0x329c <new_error>
    27fe:	20 e0       	ldi	r18, 0x00	; 0
    2800:	30 e0       	ldi	r19, 0x00	; 0
    2802:	0f c0       	rjmp	.+30     	; 0x2822 <printxy+0xba>
          break;
    2804:	6b 01       	movw	r12, r22
    2806:	ce 0c       	add	r12, r14
    2808:	df 1c       	adc	r13, r15
    280a:	5e 01       	movw	r10, r28
    280c:	a4 0e       	add	r10, r20
    280e:	b5 1e       	adc	r11, r21
    2810:	20 e0       	ldi	r18, 0x00	; 0
    2812:	30 e0       	ldi	r19, 0x00	; 0
  }

  if ((x < LCD_X_MAX)&&(y < LCD_Y_MAX)){
    //KopÌruj do pole lcd
    c = s[0];
    while ((c != '\0') && ( (x + n_x) < LCD_X_MAX)){
    2814:	ee 23       	and	r30, r30
    2816:	29 f0       	breq	.+10     	; 0x2822 <printxy+0xba>
    2818:	c9 01       	movw	r24, r18
    281a:	8e 0d       	add	r24, r14
    281c:	9f 1d       	adc	r25, r15
    281e:	88 97       	sbiw	r24, 0x28	; 40
    2820:	74 f2       	brlt	.-100    	; 0x27be <printxy+0x56>
          break;
        }
        
      }
    }
    if ((x+n_x) > LCD_X_MAX){
    2822:	2e 0d       	add	r18, r14
    2824:	3f 1d       	adc	r19, r15
    2826:	29 32       	cpi	r18, 0x29	; 41
    2828:	31 05       	cpc	r19, r1
    282a:	2c f0       	brlt	.+10     	; 0x2836 <printxy+0xce>
      new_error(81);
    282c:	81 e5       	ldi	r24, 0x51	; 81
    282e:	01 c0       	rjmp	.+2      	; 0x2832 <printxy+0xca>
    }
  }
  else{
    new_error(82);
    2830:	82 e5       	ldi	r24, 0x52	; 82
    2832:	0e 94 4e 19 	call	0x329c	; 0x329c <new_error>
  }
}
    2836:	df 91       	pop	r29
    2838:	cf 91       	pop	r28
    283a:	1f 91       	pop	r17
    283c:	0f 91       	pop	r16
    283e:	ff 90       	pop	r15
    2840:	ef 90       	pop	r14
    2842:	df 90       	pop	r13
    2844:	cf 90       	pop	r12
    2846:	bf 90       	pop	r11
    2848:	af 90       	pop	r10
    284a:	08 95       	ret

0000284c <printxyd>:
}



/// Tiskne do default_screenu
void printxyd(int y, int x, char * s){
    284c:	fc 01       	movw	r30, r24
    284e:	db 01       	movw	r26, r22
    2850:	9a 01       	movw	r18, r20
  printxy(default_screen, y, x, s);
    2852:	84 e5       	ldi	r24, 0x54	; 84
    2854:	92 e0       	ldi	r25, 0x02	; 2
    2856:	bf 01       	movw	r22, r30
    2858:	ad 01       	movw	r20, r26
    285a:	0e 94 b4 13 	call	0x2768	; 0x2768 <printxy>
}
    285e:	08 95       	ret

00002860 <print>:
    i++;
  }
}

///vytiskne text do default_screenu.
void print(char * s){
    2860:	9c 01       	movw	r18, r24
  printxy(default_screen,0,0,s);
    2862:	84 e5       	ldi	r24, 0x54	; 84
    2864:	92 e0       	ldi	r25, 0x02	; 2
    2866:	60 e0       	ldi	r22, 0x00	; 0
    2868:	70 e0       	ldi	r23, 0x00	; 0
    286a:	40 e0       	ldi	r20, 0x00	; 0
    286c:	50 e0       	ldi	r21, 0x00	; 0
    286e:	0e 94 b4 13 	call	0x2768	; 0x2768 <printxy>
}
    2872:	08 95       	ret

00002874 <mezery>:

/**
 * Funkce vyplnÌ dan˝ ¯etÏzec mezerami. PoËet mezer je urËen argumentem len. Za mezery je umÌstÏn
 * znak '\0'.
 */
char * mezery(char *s,char len){
    2874:	ac 01       	movw	r20, r24
    2876:	20 e0       	ldi	r18, 0x00	; 0
    2878:	30 e0       	ldi	r19, 0x00	; 0
  int i;
  for (i = 0; i < len; i++){
    287a:	a6 2f       	mov	r26, r22
    287c:	b0 e0       	ldi	r27, 0x00	; 0
    s[i] = ' ';
    287e:	80 e2       	ldi	r24, 0x20	; 32
    2880:	06 c0       	rjmp	.+12     	; 0x288e <mezery+0x1a>
    2882:	fa 01       	movw	r30, r20
    2884:	e2 0f       	add	r30, r18
    2886:	f3 1f       	adc	r31, r19
    2888:	80 83       	st	Z, r24
 * Funkce vyplnÌ dan˝ ¯etÏzec mezerami. PoËet mezer je urËen argumentem len. Za mezery je umÌstÏn
 * znak '\0'.
 */
char * mezery(char *s,char len){
  int i;
  for (i = 0; i < len; i++){
    288a:	2f 5f       	subi	r18, 0xFF	; 255
    288c:	3f 4f       	sbci	r19, 0xFF	; 255
    288e:	2a 17       	cp	r18, r26
    2890:	3b 07       	cpc	r19, r27
    2892:	bc f3       	brlt	.-18     	; 0x2882 <mezery+0xe>
    s[i] = ' ';
  }
  s[(int)len]='\0';
    2894:	a4 0f       	add	r26, r20
    2896:	b5 1f       	adc	r27, r21
    2898:	1c 92       	st	X, r1
  return s;
}
    289a:	ca 01       	movw	r24, r20
    289c:	08 95       	ret

0000289e <strlen>:

/// Funkce vracÌ dÈlku ¯etÏzce.
int strlen(char * s){
  int i = 0;
  while (s[i] != '\0'){
    i++;
    289e:	ac 01       	movw	r20, r24
    28a0:	20 e0       	ldi	r18, 0x00	; 0
    28a2:	30 e0       	ldi	r19, 0x00	; 0
    28a4:	02 c0       	rjmp	.+4      	; 0x28aa <strlen+0xc>
    28a6:	2f 5f       	subi	r18, 0xFF	; 255
    28a8:	3f 4f       	sbci	r19, 0xFF	; 255


/// Funkce vracÌ dÈlku ¯etÏzce.
int strlen(char * s){
  int i = 0;
  while (s[i] != '\0'){
    28aa:	fa 01       	movw	r30, r20
    28ac:	e2 0f       	add	r30, r18
    28ae:	f3 1f       	adc	r31, r19
    28b0:	80 81       	ld	r24, Z
    28b2:	88 23       	and	r24, r24
    28b4:	c1 f7       	brne	.-16     	; 0x28a6 <strlen+0x8>
    i++;
  }
  return i;
}
    28b6:	c9 01       	movw	r24, r18
    28b8:	08 95       	ret

000028ba <int2strn>:
}

/**
 * Funkce p¯ev·dÌ ËÌslo na ¯etÏzec
 */
char * int2strn(char * s, int len, uint16_t cislo){
    28ba:	8f 92       	push	r8
    28bc:	9f 92       	push	r9
    28be:	af 92       	push	r10
    28c0:	bf 92       	push	r11
    28c2:	cf 92       	push	r12
    28c4:	df 92       	push	r13
    28c6:	ef 92       	push	r14
    28c8:	ff 92       	push	r15
    28ca:	0f 93       	push	r16
    28cc:	1f 93       	push	r17
    28ce:	df 93       	push	r29
    28d0:	cf 93       	push	r28
    28d2:	cd b7       	in	r28, 0x3d	; 61
    28d4:	de b7       	in	r29, 0x3e	; 62
    28d6:	2a 97       	sbiw	r28, 0x0a	; 10
    28d8:	0f b6       	in	r0, 0x3f	; 63
    28da:	f8 94       	cli
    28dc:	de bf       	out	0x3e, r29	; 62
    28de:	0f be       	out	0x3f, r0	; 63
    28e0:	cd bf       	out	0x3d, r28	; 61
    28e2:	4c 01       	movw	r8, r24
    28e4:	7b 01       	movw	r14, r22
    28e6:	b4 2e       	mov	r11, r20
    28e8:	45 2f       	mov	r20, r21
//  char s[6]= "     \0";
  //uint16_t zaklad;
  int nenula = 0;
  int i;
  uint16_t zaklady [5] = {1,10,100,1000,10000};
    28ea:	de 01       	movw	r26, r28
    28ec:	11 96       	adiw	r26, 0x01	; 1
    28ee:	e1 e8       	ldi	r30, 0x81	; 129
    28f0:	f0 e0       	ldi	r31, 0x00	; 0
    28f2:	8a e0       	ldi	r24, 0x0A	; 10
    28f4:	01 90       	ld	r0, Z+
    28f6:	0d 92       	st	X+, r0
    28f8:	81 50       	subi	r24, 0x01	; 1
    28fa:	e1 f7       	brne	.-8      	; 0x28f4 <int2strn+0x3a>
  
  s[len] = '\0';
    28fc:	f4 01       	movw	r30, r8
    28fe:	ee 0d       	add	r30, r14
    2900:	ff 1d       	adc	r31, r15
    2902:	10 82       	st	Z, r1
  if (s[0] == '0'){
    2904:	d4 01       	movw	r26, r8
    2906:	ac 90       	ld	r10, X
/*
  for (int i=0; i < (len - 1);i++){
    zaklad = zaklad * 10;
  }
*/
  if (len < 5){
    2908:	b5 e0       	ldi	r27, 0x05	; 5
    290a:	eb 16       	cp	r14, r27
    290c:	f1 04       	cpc	r15, r1
    290e:	1c f0       	brlt	.+6      	; 0x2916 <int2strn+0x5c>
    2910:	04 e0       	ldi	r16, 0x04	; 4
    2912:	10 e0       	ldi	r17, 0x00	; 0
    2914:	03 c0       	rjmp	.+6      	; 0x291c <int2strn+0x62>
    i = len - 1;
    2916:	87 01       	movw	r16, r14
    2918:	01 50       	subi	r16, 0x01	; 1
    291a:	10 40       	sbci	r17, 0x00	; 0
    i = 4;
  }
  
  //zaklad = zaklady[i];

  if ((cislo/zaklady[i]) >= 10){ //tohle testuje jestli neni ËÌslo na vÌc mÌst neû je moûn˝ zobrazit
    291c:	f8 01       	movw	r30, r16
    291e:	ee 0f       	add	r30, r30
    2920:	ff 1f       	adc	r31, r31
    2922:	9e 01       	movw	r18, r28
    2924:	2f 5f       	subi	r18, 0xFF	; 255
    2926:	3f 4f       	sbci	r19, 0xFF	; 255
    2928:	e2 0f       	add	r30, r18
    292a:	f3 1f       	adc	r31, r19
    292c:	60 81       	ld	r22, Z
    292e:	71 81       	ldd	r23, Z+1	; 0x01
    2930:	8b 2d       	mov	r24, r11
    2932:	94 2f       	mov	r25, r20
    2934:	0e 94 82 3b 	call	0x7704	; 0x7704 <__udivmodhi4>
    2938:	6a 30       	cpi	r22, 0x0A	; 10
    293a:	71 05       	cpc	r23, r1
    293c:	90 f4       	brcc	.+36     	; 0x2962 <int2strn+0xa8>
    //new_error(85);
  }
  else{
    if (i < 4)
    293e:	04 30       	cpi	r16, 0x04	; 4
    2940:	11 05       	cpc	r17, r1
    2942:	49 f1       	breq	.+82     	; 0x2996 <int2strn+0xdc>
      cislo = cislo % (zaklady[i+1] );
    2944:	c8 01       	movw	r24, r16
    2946:	01 96       	adiw	r24, 0x01	; 1
    2948:	88 0f       	add	r24, r24
    294a:	99 1f       	adc	r25, r25
    294c:	28 0f       	add	r18, r24
    294e:	39 1f       	adc	r19, r25
    2950:	f9 01       	movw	r30, r18
    2952:	60 81       	ld	r22, Z
    2954:	71 81       	ldd	r23, Z+1	; 0x01
    2956:	8b 2d       	mov	r24, r11
    2958:	94 2f       	mov	r25, r20
    295a:	0e 94 82 3b 	call	0x7704	; 0x7704 <__udivmodhi4>
    295e:	b8 2e       	mov	r11, r24
    2960:	49 2f       	mov	r20, r25
    2962:	cc 24       	eor	r12, r12
    2964:	dd 24       	eor	r13, r13
    2966:	f0 e3       	ldi	r31, 0x30	; 48
    2968:	af 16       	cp	r10, r31
    296a:	19 f4       	brne	.+6      	; 0x2972 <int2strn+0xb8>
    296c:	31 e0       	ldi	r19, 0x01	; 1
    296e:	c3 2e       	mov	r12, r19
    2970:	d1 2c       	mov	r13, r1
    2972:	f7 01       	movw	r30, r14
    2974:	e0 1b       	sub	r30, r16
    2976:	f1 0b       	sbc	r31, r17
    2978:	31 97       	sbiw	r30, 0x01	; 1
    297a:	e8 0d       	add	r30, r8
    297c:	f9 1d       	adc	r31, r9
    297e:	c8 01       	movw	r24, r16
    2980:	88 0f       	add	r24, r24
    2982:	99 1f       	adc	r25, r25
    2984:	7e 01       	movw	r14, r28
    2986:	08 94       	sec
    2988:	e1 1c       	adc	r14, r1
    298a:	f1 1c       	adc	r15, r1
    298c:	e8 0e       	add	r14, r24
    298e:	f9 1e       	adc	r15, r25
  }
  while (i >= 0){ //zaklad >= 1){//i < len){
    int mezi;
    mezi = (cislo / zaklady[i]);
    if ((mezi == 0)&&(nenula == 0)&&(zaklady[i] > 1)){
      s[len - i - 1] = ' '; 
    2990:	90 e2       	ldi	r25, 0x20	; 32
    2992:	a9 2e       	mov	r10, r25
    2994:	2a c0       	rjmp	.+84     	; 0x29ea <int2strn+0x130>
  }
  else{
    if (i < 4)
      cislo = cislo % (zaklady[i+1] );
    else
      cislo = cislo % (zaklady[4]);
    2996:	69 85       	ldd	r22, Y+9	; 0x09
    2998:	7a 85       	ldd	r23, Y+10	; 0x0a
    299a:	dd cf       	rjmp	.-70     	; 0x2956 <int2strn+0x9c>
  }
  while (i >= 0){ //zaklad >= 1){//i < len){
    int mezi;
    mezi = (cislo / zaklady[i]);
    299c:	d7 01       	movw	r26, r14
    299e:	2d 91       	ld	r18, X+
    29a0:	3c 91       	ld	r19, X
    29a2:	8b 2d       	mov	r24, r11
    29a4:	94 2f       	mov	r25, r20
    29a6:	b9 01       	movw	r22, r18
    29a8:	0e 94 82 3b 	call	0x7704	; 0x7704 <__udivmodhi4>
    29ac:	cb 01       	movw	r24, r22
    if ((mezi == 0)&&(nenula == 0)&&(zaklady[i] > 1)){
    29ae:	61 15       	cp	r22, r1
    29b0:	71 05       	cpc	r23, r1
    29b2:	41 f4       	brne	.+16     	; 0x29c4 <int2strn+0x10a>
    29b4:	c1 14       	cp	r12, r1
    29b6:	d1 04       	cpc	r13, r1
    29b8:	29 f4       	brne	.+10     	; 0x29c4 <int2strn+0x10a>
    29ba:	22 30       	cpi	r18, 0x02	; 2
    29bc:	31 05       	cpc	r19, r1
    29be:	10 f0       	brcs	.+4      	; 0x29c4 <int2strn+0x10a>
      s[len - i - 1] = ' '; 
    29c0:	a0 82       	st	Z, r10
    29c2:	05 c0       	rjmp	.+10     	; 0x29ce <int2strn+0x114>
    }
    else{
      s[len - i - 1] = 48 + mezi;
    29c4:	80 5d       	subi	r24, 0xD0	; 208
    29c6:	80 83       	st	Z, r24
    29c8:	81 e0       	ldi	r24, 0x01	; 1
    29ca:	c8 2e       	mov	r12, r24
    29cc:	d1 2c       	mov	r13, r1
      if (nenula == 0){
        nenula = 1;
      }
    }
    cislo = cislo - ((cislo/zaklady[i]) * zaklady[i]);
    29ce:	8b 2d       	mov	r24, r11
    29d0:	94 2f       	mov	r25, r20
    29d2:	b9 01       	movw	r22, r18
    29d4:	0e 94 82 3b 	call	0x7704	; 0x7704 <__udivmodhi4>
    29d8:	b8 2e       	mov	r11, r24
    29da:	49 2f       	mov	r20, r25
    //cislo = cislo % zaklady[i];
    i--;
    29dc:	01 50       	subi	r16, 0x01	; 1
    29de:	10 40       	sbci	r17, 0x00	; 0
    29e0:	31 96       	adiw	r30, 0x01	; 1
    29e2:	8e ef       	ldi	r24, 0xFE	; 254
    29e4:	9f ef       	ldi	r25, 0xFF	; 255
    29e6:	e8 0e       	add	r14, r24
    29e8:	f9 1e       	adc	r15, r25
    if (i < 4)
      cislo = cislo % (zaklady[i+1] );
    else
      cislo = cislo % (zaklady[4]);
  }
  while (i >= 0){ //zaklad >= 1){//i < len){
    29ea:	17 ff       	sbrs	r17, 7
    29ec:	d7 cf       	rjmp	.-82     	; 0x299c <int2strn+0xe2>
    //cislo = cislo % zaklady[i];
    i--;
  }
  
  return s;
}
    29ee:	c4 01       	movw	r24, r8
    29f0:	2a 96       	adiw	r28, 0x0a	; 10
    29f2:	0f b6       	in	r0, 0x3f	; 63
    29f4:	f8 94       	cli
    29f6:	de bf       	out	0x3e, r29	; 62
    29f8:	0f be       	out	0x3f, r0	; 63
    29fa:	cd bf       	out	0x3d, r28	; 61
    29fc:	cf 91       	pop	r28
    29fe:	df 91       	pop	r29
    2a00:	1f 91       	pop	r17
    2a02:	0f 91       	pop	r16
    2a04:	ff 90       	pop	r15
    2a06:	ef 90       	pop	r14
    2a08:	df 90       	pop	r13
    2a0a:	cf 90       	pop	r12
    2a0c:	bf 90       	pop	r11
    2a0e:	af 90       	pop	r10
    2a10:	9f 90       	pop	r9
    2a12:	8f 90       	pop	r8
    2a14:	08 95       	ret

00002a16 <int2str>:
 * Funkce p¯ev·dÌ ËÌslo na ¯etÏzec. Vstupem je ¯etÏzec. ZmÏ¯Ì se jeho dÈlka a na takovou dÈlku se p¯evede 
 * ËÌslo. Pokud je ¯etÏzec p¯Ìliö kr·tk˝, dojde k vyps·nÌ chybovÈ zpr·vy. Zarovn·v· se vpravo.
 * Pokud je prvnÌ znak vstupnÌho ¯etÏzce roven '0', vypisujÌ se i poË·teËnÌ nuly
 * nap¯ 0056
 */
char * int2str(char *s, uint16_t cislo){
    2a16:	9c 01       	movw	r18, r24
    2a18:	ab 01       	movw	r20, r22
    2a1a:	60 e0       	ldi	r22, 0x00	; 0
    2a1c:	70 e0       	ldi	r23, 0x00	; 0
    2a1e:	02 c0       	rjmp	.+4      	; 0x2a24 <int2str+0xe>

/// Funkce vracÌ dÈlku ¯etÏzce.
int strlen(char * s){
  int i = 0;
  while (s[i] != '\0'){
    i++;
    2a20:	6f 5f       	subi	r22, 0xFF	; 255
    2a22:	7f 4f       	sbci	r23, 0xFF	; 255


/// Funkce vracÌ dÈlku ¯etÏzce.
int strlen(char * s){
  int i = 0;
  while (s[i] != '\0'){
    2a24:	f9 01       	movw	r30, r18
    2a26:	e6 0f       	add	r30, r22
    2a28:	f7 1f       	adc	r31, r23
    2a2a:	80 81       	ld	r24, Z
    2a2c:	88 23       	and	r24, r24
    2a2e:	c1 f7       	brne	.-16     	; 0x2a20 <int2str+0xa>
 * Pokud je prvnÌ znak vstupnÌho ¯etÏzce roven '0', vypisujÌ se i poË·teËnÌ nuly
 * nap¯ 0056
 */
char * int2str(char *s, uint16_t cislo){
  
  return int2strn(s,strlen(s), cislo);
    2a30:	c9 01       	movw	r24, r18
    2a32:	0e 94 5d 14 	call	0x28ba	; 0x28ba <int2strn>
}
    2a36:	08 95       	ret

00002a38 <eeprom_read_byte>:

/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    2a38:	9c 01       	movw	r18, r24
    do {} while (!eeprom_is_ready ());
    2a3a:	e1 99       	sbic	0x1c, 1	; 28
    2a3c:	fe cf       	rjmp	.-4      	; 0x2a3a <eeprom_read_byte+0x2>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    2a3e:	3f bb       	out	0x1f, r19	; 31
    2a40:	2e bb       	out	0x1e, r18	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    2a42:	e0 9a       	sbi	0x1c, 0	; 28
    2a44:	8d b3       	in	r24, 0x1d	; 29
        : "i" (_SFR_IO_ADDR(EECR)),
          "i" (EERE),
          "i" (_SFR_IO_ADDR(EEDR))
    );
    return __result;
}
    2a46:	08 95       	ret

00002a48 <eeprom_write_byte>:

/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    2a48:	9c 01       	movw	r18, r24
    do {} while (!eeprom_is_ready ());
    2a4a:	e1 99       	sbic	0x1c, 1	; 28
    2a4c:	fe cf       	rjmp	.-4      	; 0x2a4a <eeprom_write_byte+0x2>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    2a4e:	3f bb       	out	0x1f, r19	; 31
    2a50:	2e bb       	out	0x1e, r18	; 30
#endif
    EEDR = __value;
    2a52:	6d bb       	out	0x1d, r22	; 29

    __asm__ __volatile__ (
    2a54:	0f b6       	in	r0, 0x3f	; 63
    2a56:	f8 94       	cli
    2a58:	e2 9a       	sbi	0x1c, 2	; 28
    2a5a:	e1 9a       	sbi	0x1c, 1	; 28
    2a5c:	0f be       	out	0x3f, r0	; 63
          [__sreg]  "i" (_SFR_IO_ADDR(SREG)),
          [__eemwe] "i" (EEMWE),
          [__eewe]  "i" (EEWE)
        : "r0"
    );
}
    2a5e:	08 95       	ret

00002a60 <r_record>:
/**
 * Funkce naËte z·znam s id @a zaznam. Data tohoto z·znamu jsou naËteny do
 * glob·lnÌch promÏnn˝ch data_prumer , data_delka , data_zakaznik
 * data_druh_dreva , data_operace.
 */
void r_record(uint16_t zaznam){
    2a60:	0f 93       	push	r16
    2a62:	1f 93       	push	r17
  char posun = ((zaznam & 0x01) * 4) ; // pokud je cislo zaznamu sudÈ bude to nula, pokud lichÈ, bude to Ëty¯i
  //char a , b;
  zaznam = zaznam >> 1;
    2a64:	9c 01       	movw	r18, r24
    2a66:	36 95       	lsr	r19
    2a68:	27 95       	ror	r18
  
 // b = data[zaznam][1 + posun];

  data_prumer = (data[zaznam][0 + posun] >> 1) * 5;
    2a6a:	81 70       	andi	r24, 0x01	; 1
    2a6c:	90 70       	andi	r25, 0x00	; 0
    2a6e:	88 0f       	add	r24, r24
    2a70:	88 0f       	add	r24, r24
    2a72:	08 2f       	mov	r16, r24
    2a74:	10 e0       	ldi	r17, 0x00	; 0
    2a76:	af e5       	ldi	r26, 0x5F	; 95
    2a78:	b3 e0       	ldi	r27, 0x03	; 3
    2a7a:	b9 01       	movw	r22, r18
    2a7c:	e3 e0       	ldi	r30, 0x03	; 3
    2a7e:	66 0f       	add	r22, r22
    2a80:	77 1f       	adc	r23, r23
    2a82:	ea 95       	dec	r30
    2a84:	e1 f7       	brne	.-8      	; 0x2a7e <r_record+0x1e>
    2a86:	62 1b       	sub	r22, r18
    2a88:	73 0b       	sbc	r23, r19
    2a8a:	fb 01       	movw	r30, r22
    2a8c:	e0 0f       	add	r30, r16
    2a8e:	f1 1f       	adc	r31, r17
    2a90:	ea 0f       	add	r30, r26
    2a92:	fb 1f       	adc	r31, r27
    2a94:	20 81       	ld	r18, Z
    2a96:	82 2f       	mov	r24, r18
    2a98:	86 95       	lsr	r24
    2a9a:	45 e0       	ldi	r20, 0x05	; 5
    2a9c:	84 9f       	mul	r24, r20
    2a9e:	c0 01       	movw	r24, r0
    2aa0:	11 24       	eor	r1, r1
    2aa2:	90 93 a2 01 	sts	0x01A2, r25
    2aa6:	80 93 a1 01 	sts	0x01A1, r24
  data_delka = (((data[zaznam][0 + posun] & 1) * 256) + data[zaznam][1 + posun]) * 5; 
    2aaa:	30 e0       	ldi	r19, 0x00	; 0
    2aac:	21 70       	andi	r18, 0x01	; 1
    2aae:	30 70       	andi	r19, 0x00	; 0
    2ab0:	32 2f       	mov	r19, r18
    2ab2:	22 27       	eor	r18, r18
    2ab4:	a6 0f       	add	r26, r22
    2ab6:	b7 1f       	adc	r27, r23
    2ab8:	fd 01       	movw	r30, r26
    2aba:	e0 0f       	add	r30, r16
    2abc:	f1 1f       	adc	r31, r17
    2abe:	81 81       	ldd	r24, Z+1	; 0x01
    2ac0:	28 0f       	add	r18, r24
    2ac2:	31 1d       	adc	r19, r1
    2ac4:	c9 01       	movw	r24, r18
    2ac6:	88 0f       	add	r24, r24
    2ac8:	99 1f       	adc	r25, r25
    2aca:	88 0f       	add	r24, r24
    2acc:	99 1f       	adc	r25, r25
    2ace:	82 0f       	add	r24, r18
    2ad0:	93 1f       	adc	r25, r19
    2ad2:	90 93 9f 01 	sts	0x019F, r25
    2ad6:	80 93 9e 01 	sts	0x019E, r24
  
  data_zakaznik = (data[zaznam][2 + posun] >> 3);
    2ada:	82 81       	ldd	r24, Z+2	; 0x02
    2adc:	98 2f       	mov	r25, r24
    2ade:	96 95       	lsr	r25
    2ae0:	96 95       	lsr	r25
    2ae2:	96 95       	lsr	r25
    2ae4:	90 93 a0 01 	sts	0x01A0, r25
  data_druh_dreva = data[zaznam][2 + posun] & 0x07;
    2ae8:	87 70       	andi	r24, 0x07	; 7
    2aea:	80 93 a3 01 	sts	0x01A3, r24
  data_operace = (data[zaznam][3] >> posun) & 0x0f;
    2aee:	13 96       	adiw	r26, 0x03	; 3
    2af0:	8c 91       	ld	r24, X
    2af2:	90 e0       	ldi	r25, 0x00	; 0
    2af4:	02 c0       	rjmp	.+4      	; 0x2afa <r_record+0x9a>
    2af6:	95 95       	asr	r25
    2af8:	87 95       	ror	r24
    2afa:	0a 95       	dec	r16
    2afc:	e2 f7       	brpl	.-8      	; 0x2af6 <r_record+0x96>
    2afe:	8f 70       	andi	r24, 0x0F	; 15
    2b00:	80 93 a4 01 	sts	0x01A4, r24
  
}
    2b04:	1f 91       	pop	r17
    2b06:	0f 91       	pop	r16
    2b08:	08 95       	ret

00002b0a <r_rec_delka>:
/// @param zaznam ID z·znamu.
/// @return VracÌ dÈlku.
uint16_t r_rec_delka(uint16_t zaznam) {
  char posun = ((zaznam & 0x01) * 4) ;  // pokud je cislo zaznamu sudÈ bude to nula, 
                                        // pokud lichÈ, bude to Ëty¯i
  zaznam = zaznam >> 1;
    2b0a:	ac 01       	movw	r20, r24
    2b0c:	56 95       	lsr	r21
    2b0e:	47 95       	ror	r20
  
  return (((data[zaznam][0 + posun] & 1) * 256) + data[zaznam][1 + posun]) * 5; 
    2b10:	81 70       	andi	r24, 0x01	; 1
    2b12:	90 70       	andi	r25, 0x00	; 0
    2b14:	88 0f       	add	r24, r24
    2b16:	88 0f       	add	r24, r24
    2b18:	68 2f       	mov	r22, r24
    2b1a:	70 e0       	ldi	r23, 0x00	; 0
    2b1c:	af e5       	ldi	r26, 0x5F	; 95
    2b1e:	b3 e0       	ldi	r27, 0x03	; 3
    2b20:	9a 01       	movw	r18, r20
    2b22:	e3 e0       	ldi	r30, 0x03	; 3
    2b24:	22 0f       	add	r18, r18
    2b26:	33 1f       	adc	r19, r19
    2b28:	ea 95       	dec	r30
    2b2a:	e1 f7       	brne	.-8      	; 0x2b24 <r_rec_delka+0x1a>
    2b2c:	24 1b       	sub	r18, r20
    2b2e:	35 0b       	sbc	r19, r21
    2b30:	f9 01       	movw	r30, r18
    2b32:	e6 0f       	add	r30, r22
    2b34:	f7 1f       	adc	r31, r23
    2b36:	ea 0f       	add	r30, r26
    2b38:	fb 1f       	adc	r31, r27
    2b3a:	80 81       	ld	r24, Z
    2b3c:	90 e0       	ldi	r25, 0x00	; 0
    2b3e:	81 70       	andi	r24, 0x01	; 1
    2b40:	90 70       	andi	r25, 0x00	; 0
    2b42:	98 2f       	mov	r25, r24
    2b44:	88 27       	eor	r24, r24
    2b46:	a2 0f       	add	r26, r18
    2b48:	b3 1f       	adc	r27, r19
    2b4a:	a6 0f       	add	r26, r22
    2b4c:	b7 1f       	adc	r27, r23
    2b4e:	11 96       	adiw	r26, 0x01	; 1
    2b50:	2c 91       	ld	r18, X
    2b52:	82 0f       	add	r24, r18
    2b54:	91 1d       	adc	r25, r1
    2b56:	9c 01       	movw	r18, r24
    2b58:	22 0f       	add	r18, r18
    2b5a:	33 1f       	adc	r19, r19
    2b5c:	22 0f       	add	r18, r18
    2b5e:	33 1f       	adc	r19, r19
    2b60:	28 0f       	add	r18, r24
    2b62:	39 1f       	adc	r19, r25
  
}
    2b64:	c9 01       	movw	r24, r18
    2b66:	08 95       	ret

00002b68 <r_rec_prumer>:

/// Funkce vracÌ pr˘mÏr.
uint16_t r_rec_prumer(uint16_t zaznam){
    2b68:	9c 01       	movw	r18, r24
    2b6a:	21 70       	andi	r18, 0x01	; 1
    2b6c:	30 70       	andi	r19, 0x00	; 0
    2b6e:	22 0f       	add	r18, r18
    2b70:	22 0f       	add	r18, r18
    2b72:	96 95       	lsr	r25
    2b74:	87 95       	ror	r24
    2b76:	fc 01       	movw	r30, r24
    2b78:	a3 e0       	ldi	r26, 0x03	; 3
    2b7a:	ee 0f       	add	r30, r30
    2b7c:	ff 1f       	adc	r31, r31
    2b7e:	aa 95       	dec	r26
    2b80:	e1 f7       	brne	.-8      	; 0x2b7a <r_rec_prumer+0x12>
    2b82:	e8 1b       	sub	r30, r24
    2b84:	f9 0b       	sbc	r31, r25
    2b86:	e2 0f       	add	r30, r18
    2b88:	f1 1d       	adc	r31, r1
    2b8a:	e1 5a       	subi	r30, 0xA1	; 161
    2b8c:	fc 4f       	sbci	r31, 0xFC	; 252
    2b8e:	20 81       	ld	r18, Z
    2b90:	26 95       	lsr	r18
    2b92:	85 e0       	ldi	r24, 0x05	; 5
    2b94:	28 9f       	mul	r18, r24
    2b96:	90 01       	movw	r18, r0
    2b98:	11 24       	eor	r1, r1
  char posun = ((zaznam & 0x01) * 4) ;  // pokud je cislo zaznamu sudÈ bude to nula, 
                                        // pokud lichÈ, bude to Ëty¯i
  zaznam = zaznam >> 1;

  return (data[zaznam][0 + posun] >> 1) * 5;
}
    2b9a:	c9 01       	movw	r24, r18
    2b9c:	08 95       	ret

00002b9e <r_rec_zakaznik>:

/// VracÌ id z·kaznÌka.
char r_rec_zakaznik(uint16_t zaznam){
    2b9e:	9c 01       	movw	r18, r24
    2ba0:	21 70       	andi	r18, 0x01	; 1
    2ba2:	30 70       	andi	r19, 0x00	; 0
    2ba4:	22 0f       	add	r18, r18
    2ba6:	22 0f       	add	r18, r18
    2ba8:	96 95       	lsr	r25
    2baa:	87 95       	ror	r24
    2bac:	fc 01       	movw	r30, r24
    2bae:	33 e0       	ldi	r19, 0x03	; 3
    2bb0:	ee 0f       	add	r30, r30
    2bb2:	ff 1f       	adc	r31, r31
    2bb4:	3a 95       	dec	r19
    2bb6:	e1 f7       	brne	.-8      	; 0x2bb0 <r_rec_zakaznik+0x12>
    2bb8:	e8 1b       	sub	r30, r24
    2bba:	f9 0b       	sbc	r31, r25
    2bbc:	e1 5a       	subi	r30, 0xA1	; 161
    2bbe:	fc 4f       	sbci	r31, 0xFC	; 252
    2bc0:	e2 0f       	add	r30, r18
    2bc2:	f1 1d       	adc	r31, r1
    2bc4:	82 81       	ldd	r24, Z+2	; 0x02
  char posun = ((zaznam & 0x01) * 4) ;  // pokud je cislo zaznamu sudÈ bude to nula, 
                                        // pokud lichÈ, bude to Ëty¯i
  zaznam = zaznam >> 1;

  return (data[zaznam][2 + posun] >> 3);
}
    2bc6:	86 95       	lsr	r24
    2bc8:	86 95       	lsr	r24
    2bca:	86 95       	lsr	r24
    2bcc:	08 95       	ret

00002bce <r_rec_druh_dreva>:


/// Funkce vracÌ druh d¯eva.
char r_rec_druh_dreva(uint16_t zaznam){
    2bce:	9c 01       	movw	r18, r24
    2bd0:	21 70       	andi	r18, 0x01	; 1
    2bd2:	30 70       	andi	r19, 0x00	; 0
    2bd4:	22 0f       	add	r18, r18
    2bd6:	22 0f       	add	r18, r18
    2bd8:	96 95       	lsr	r25
    2bda:	87 95       	ror	r24
    2bdc:	fc 01       	movw	r30, r24
    2bde:	53 e0       	ldi	r21, 0x03	; 3
    2be0:	ee 0f       	add	r30, r30
    2be2:	ff 1f       	adc	r31, r31
    2be4:	5a 95       	dec	r21
    2be6:	e1 f7       	brne	.-8      	; 0x2be0 <r_rec_druh_dreva+0x12>
    2be8:	e8 1b       	sub	r30, r24
    2bea:	f9 0b       	sbc	r31, r25
    2bec:	e1 5a       	subi	r30, 0xA1	; 161
    2bee:	fc 4f       	sbci	r31, 0xFC	; 252
    2bf0:	e2 0f       	add	r30, r18
    2bf2:	f1 1d       	adc	r31, r1
    2bf4:	82 81       	ldd	r24, Z+2	; 0x02
  char posun = ((zaznam & 0x01) * 4) ;  // pokud je cislo zaznamu sudÈ bude to nula, 
                                        // pokud lichÈ, bude to Ëty¯i
  zaznam = zaznam >> 1;

  return  data[zaznam][2 + posun] & 0x07;
}
    2bf6:	87 70       	andi	r24, 0x07	; 7
    2bf8:	08 95       	ret

00002bfa <r_rec_operace>:

/// Funkce vracÌ operaci. Je zde zakÛdov·n druh dalöÌ operace, manipulace.
char r_rec_operace(uint16_t zaznam){
    2bfa:	9c 01       	movw	r18, r24
    2bfc:	96 95       	lsr	r25
    2bfe:	87 95       	ror	r24
    2c00:	fc 01       	movw	r30, r24
    2c02:	73 e0       	ldi	r23, 0x03	; 3
    2c04:	ee 0f       	add	r30, r30
    2c06:	ff 1f       	adc	r31, r31
    2c08:	7a 95       	dec	r23
    2c0a:	e1 f7       	brne	.-8      	; 0x2c04 <r_rec_operace+0xa>
    2c0c:	e8 1b       	sub	r30, r24
    2c0e:	f9 0b       	sbc	r31, r25
    2c10:	e1 5a       	subi	r30, 0xA1	; 161
    2c12:	fc 4f       	sbci	r31, 0xFC	; 252
    2c14:	83 81       	ldd	r24, Z+3	; 0x03
    2c16:	90 e0       	ldi	r25, 0x00	; 0
    2c18:	21 70       	andi	r18, 0x01	; 1
    2c1a:	30 70       	andi	r19, 0x00	; 0
    2c1c:	22 0f       	add	r18, r18
    2c1e:	22 0f       	add	r18, r18
    2c20:	02 c0       	rjmp	.+4      	; 0x2c26 <r_rec_operace+0x2c>
    2c22:	95 95       	asr	r25
    2c24:	87 95       	ror	r24
    2c26:	2a 95       	dec	r18
    2c28:	e2 f7       	brpl	.-8      	; 0x2c22 <r_rec_operace+0x28>
  char posun = ((zaznam & 0x01) * 4) ;  // pokud je cislo zaznamu sudÈ bude to nula, 
                                        // pokud lichÈ, bude to Ëty¯i
  zaznam = zaznam >> 1;

  return  (data[zaznam][3] >> posun) & 0x0f;
}
    2c2a:	8f 70       	andi	r24, 0x0F	; 15
    2c2c:	08 95       	ret

00002c2e <find_last_record_of_zakaznik>:
/// z·znamu.
/// @param zakaznik Vstupem je ËÌslo z·kaznÌka.
/// @return V˝stupem je ËÌslo mÏ¯enÌ.
///
/// @return V p¯ÌpadÏ, ûe û·dn˝ z·znam nebyl nalezen, vracÌ -1
int16_t find_last_record_of_zakaznik(char zakaznik){
    2c2e:	cf 93       	push	r28
    2c30:	df 93       	push	r29
    2c32:	48 2f       	mov	r20, r24
  int16_t zaznam = data_top - 1;
    2c34:	c0 91 9b 01 	lds	r28, 0x019B
    2c38:	d0 91 9c 01 	lds	r29, 0x019C
    2c3c:	1e c0       	rjmp	.+60     	; 0x2c7a <find_last_record_of_zakaznik+0x4c>

  while (zaznam >= 0){
    if(r_rec_zakaznik(zaznam) == zakaznik){
    2c3e:	9e 01       	movw	r18, r28
    2c40:	21 70       	andi	r18, 0x01	; 1
    2c42:	30 70       	andi	r19, 0x00	; 0
    2c44:	22 0f       	add	r18, r18
    2c46:	22 0f       	add	r18, r18
    2c48:	ce 01       	movw	r24, r28
    2c4a:	96 95       	lsr	r25
    2c4c:	87 95       	ror	r24
    2c4e:	fc 01       	movw	r30, r24
    2c50:	a3 e0       	ldi	r26, 0x03	; 3
    2c52:	ee 0f       	add	r30, r30
    2c54:	ff 1f       	adc	r31, r31
    2c56:	aa 95       	dec	r26
    2c58:	e1 f7       	brne	.-8      	; 0x2c52 <find_last_record_of_zakaznik+0x24>
    2c5a:	e8 1b       	sub	r30, r24
    2c5c:	f9 0b       	sbc	r31, r25
    2c5e:	e1 5a       	subi	r30, 0xA1	; 161
    2c60:	fc 4f       	sbci	r31, 0xFC	; 252
    2c62:	e2 0f       	add	r30, r18
    2c64:	f1 1d       	adc	r31, r1
    2c66:	82 81       	ldd	r24, Z+2	; 0x02
    2c68:	86 95       	lsr	r24
    2c6a:	86 95       	lsr	r24
    2c6c:	86 95       	lsr	r24
    2c6e:	84 17       	cp	r24, r20
    2c70:	21 f4       	brne	.+8      	; 0x2c7a <find_last_record_of_zakaznik+0x4c>
      r_record((uint16_t) zaznam);
    2c72:	ce 01       	movw	r24, r28
    2c74:	0e 94 30 15 	call	0x2a60	; 0x2a60 <r_record>
    2c78:	05 c0       	rjmp	.+10     	; 0x2c84 <find_last_record_of_zakaznik+0x56>
      return zaznam;
    }
    zaznam--;
    2c7a:	21 97       	sbiw	r28, 0x01	; 1
///
/// @return V p¯ÌpadÏ, ûe û·dn˝ z·znam nebyl nalezen, vracÌ -1
int16_t find_last_record_of_zakaznik(char zakaznik){
  int16_t zaznam = data_top - 1;

  while (zaznam >= 0){
    2c7c:	d7 ff       	sbrs	r29, 7
    2c7e:	df cf       	rjmp	.-66     	; 0x2c3e <find_last_record_of_zakaznik+0x10>
    2c80:	cf ef       	ldi	r28, 0xFF	; 255
    2c82:	df ef       	ldi	r29, 0xFF	; 255
    }
    zaznam--;
    
  }
  return -1;
}
    2c84:	ce 01       	movw	r24, r28
    2c86:	df 91       	pop	r29
    2c88:	cf 91       	pop	r28
    2c8a:	08 95       	ret

00002c8c <dat_add_zakaznik>:
  free((void *)m_jmena[cislo]);
  m_jmena[cislo] = NULL;
}

/// P¯id· do seznamu z·kaznÌk˘ novÈho z·kaznÌka.
char dat_add_zakaznik(char * jmeno){
    2c8c:	ac 01       	movw	r20, r24
    2c8e:	e4 ef       	ldi	r30, 0xF4	; 244
    2c90:	f2 e0       	ldi	r31, 0x02	; 2
    2c92:	20 e0       	ldi	r18, 0x00	; 0
    2c94:	30 e0       	ldi	r19, 0x00	; 0
    2c96:	02 c0       	rjmp	.+4      	; 0x2c9c <dat_add_zakaznik+0x10>
  //int len = menu[0] -> len;
  int i=0;

  while ((m_jmena[i] != NULL) && (i < (MAX_ZAKAZNIK - 1))){
    i++;
    2c98:	2f 5f       	subi	r18, 0xFF	; 255
    2c9a:	3f 4f       	sbci	r19, 0xFF	; 255
/// P¯id· do seznamu z·kaznÌk˘ novÈho z·kaznÌka.
char dat_add_zakaznik(char * jmeno){
  //int len = menu[0] -> len;
  int i=0;

  while ((m_jmena[i] != NULL) && (i < (MAX_ZAKAZNIK - 1))){
    2c9c:	80 81       	ld	r24, Z
    2c9e:	91 81       	ldd	r25, Z+1	; 0x01
    2ca0:	89 2b       	or	r24, r25
    2ca2:	21 f0       	breq	.+8      	; 0x2cac <dat_add_zakaznik+0x20>
    2ca4:	32 96       	adiw	r30, 0x02	; 2
    2ca6:	2f 30       	cpi	r18, 0x0F	; 15
    2ca8:	31 05       	cpc	r19, r1
    2caa:	b1 f7       	brne	.-20     	; 0x2c98 <dat_add_zakaznik+0xc>
    i++;
  }

  m_jmena[i] = jmeno; // pokud nebude venku oöet¯eno maxim·lnÌ p¯id·nÌ,                     
    2cac:	f9 01       	movw	r30, r18
    2cae:	ee 0f       	add	r30, r30
    2cb0:	ff 1f       	adc	r31, r31
    2cb2:	ec 50       	subi	r30, 0x0C	; 12
    2cb4:	fd 4f       	sbci	r31, 0xFD	; 253
    2cb6:	51 83       	std	Z+1, r21	; 0x01
    2cb8:	40 83       	st	Z, r20
                      // bude se p¯episovat poslednÌ hodnota

  if (i == (MAX_ZAKAZNIK - 1)){// poslednÌ a m·me plno
    2cba:	2f 30       	cpi	r18, 0x0F	; 15
    2cbc:	31 05       	cpc	r19, r1
    2cbe:	11 f4       	brne	.+4      	; 0x2cc4 <dat_add_zakaznik+0x38>
    2cc0:	8f e0       	ldi	r24, 0x0F	; 15
    2cc2:	08 95       	ret
  //  m_jmena[MAX_ZAKAZNIK - 1] = jmeno;//menu_pridat;
  return MAX_ZAKAZNIK - 1;
  }
  return (char)i;
    2cc4:	82 2f       	mov	r24, r18
}
    2cc6:	08 95       	ret

00002cc8 <dat_odstran_zakaznika>:
}


// pozor venku musÌ b˝t oöet¯eno, zda je nenÌ na danÈ jmÈno 
// odkaz od namÏ¯en˝ch hodnot
void dat_odstran_zakaznika(int cislo){
    2cc8:	0f 93       	push	r16
    2cca:	1f 93       	push	r17
  //int i;
//  char *c = ;
  free((void *)m_jmena[cislo]);
    2ccc:	8c 01       	movw	r16, r24
    2cce:	00 0f       	add	r16, r16
    2cd0:	11 1f       	adc	r17, r17
    2cd2:	0c 50       	subi	r16, 0x0C	; 12
    2cd4:	1d 4f       	sbci	r17, 0xFD	; 253
    2cd6:	f8 01       	movw	r30, r16
    2cd8:	80 81       	ld	r24, Z
    2cda:	91 81       	ldd	r25, Z+1	; 0x01
    2cdc:	0e 94 c6 32 	call	0x658c	; 0x658c <free>
  m_jmena[cislo] = NULL;
    2ce0:	f8 01       	movw	r30, r16
    2ce2:	11 82       	std	Z+1, r1	; 0x01
    2ce4:	10 82       	st	Z, r1
}
    2ce6:	1f 91       	pop	r17
    2ce8:	0f 91       	pop	r16
    2cea:	08 95       	ret

00002cec <dat_free_m_jmena>:
  return -1;
}

/*----------------------------------*/

void dat_free_m_jmena(void){
    2cec:	cf 93       	push	r28
    2cee:	df 93       	push	r29
    2cf0:	c4 ef       	ldi	r28, 0xF4	; 244
    2cf2:	d2 e0       	ldi	r29, 0x02	; 2
  int i;
  for (i = 0 ; i < MAX_ZAKAZNIK; i++){
    if (m_jmena[i] != NULL){
    2cf4:	88 81       	ld	r24, Y
    2cf6:	99 81       	ldd	r25, Y+1	; 0x01
    2cf8:	00 97       	sbiw	r24, 0x00	; 0
    2cfa:	21 f0       	breq	.+8      	; 0x2d04 <dat_free_m_jmena+0x18>
      free((void *) m_jmena[i]);
    2cfc:	0e 94 c6 32 	call	0x658c	; 0x658c <free>
      m_jmena[i] = NULL;
    2d00:	19 82       	std	Y+1, r1	; 0x01
    2d02:	18 82       	st	Y, r1
    2d04:	22 96       	adiw	r28, 0x02	; 2

/*----------------------------------*/

void dat_free_m_jmena(void){
  int i;
  for (i = 0 ; i < MAX_ZAKAZNIK; i++){
    2d06:	83 e0       	ldi	r24, 0x03	; 3
    2d08:	c4 31       	cpi	r28, 0x14	; 20
    2d0a:	d8 07       	cpc	r29, r24
    2d0c:	99 f7       	brne	.-26     	; 0x2cf4 <dat_free_m_jmena+0x8>
    if (m_jmena[i] != NULL){
      free((void *) m_jmena[i]);
      m_jmena[i] = NULL;
    }
  }
  m_jmena[MAX_ZAKAZNIK] = menu_pridat;
    2d0e:	80 91 93 00 	lds	r24, 0x0093
    2d12:	90 91 94 00 	lds	r25, 0x0094
    2d16:	99 83       	std	Y+1, r25	; 0x01
    2d18:	88 83       	st	Y, r24
}
    2d1a:	df 91       	pop	r29
    2d1c:	cf 91       	pop	r28
    2d1e:	08 95       	ret

00002d20 <dat_del_all>:

/**
 * Funkce odstanÌ vöechny z·znamy dat a jmÈna z·kaznÌk˘. 
 */
void dat_del_all(void){
  data_top = 0;
    2d20:	10 92 9c 01 	sts	0x019C, r1
    2d24:	10 92 9b 01 	sts	0x019B, r1
  dat_free_m_jmena();
    2d28:	0e 94 76 16 	call	0x2cec	; 0x2cec <dat_free_m_jmena>
  dat_free_m_jmena();
    2d2c:	0e 94 76 16 	call	0x2cec	; 0x2cec <dat_free_m_jmena>
}
    2d30:	08 95       	ret

00002d32 <w_record>:

/**
 * Funkce ukl·d· do datovÈho pole z·znam. Z·znam je uloûen na 3.5 bytech.
 * P˘lbajty z posobÏ jsoucÌch z·znam˘ jsou uloûeny do jednoho bytu.
 */
void w_record(uint16_t zaznam, char zakaznik, char druh_dreva, char operace, uint16_t delka, uint16_t prumer){
    2d32:	9f 92       	push	r9
    2d34:	af 92       	push	r10
    2d36:	bf 92       	push	r11
    2d38:	cf 92       	push	r12
    2d3a:	df 92       	push	r13
    2d3c:	ef 92       	push	r14
    2d3e:	ff 92       	push	r15
    2d40:	0f 93       	push	r16
    2d42:	1f 93       	push	r17
    2d44:	cf 93       	push	r28
    2d46:	df 93       	push	r29
    2d48:	ec 01       	movw	r28, r24
    2d4a:	d6 2e       	mov	r13, r22
    2d4c:	c4 2e       	mov	r12, r20
    2d4e:	92 2e       	mov	r9, r18
    2d50:	c8 01       	movw	r24, r16
  char posun = ((zaznam & 0x01) * 4) ; // pokud je cislo zaznamu sudÈ bude to nula, pokud lichÈ, bude to Ëty¯i
  zaznam = zaznam >> 1;
    2d52:	5e 01       	movw	r10, r28
    2d54:	b6 94       	lsr	r11
    2d56:	a7 94       	ror	r10



  // p¯epoËet - ukl·d· zaokrouhlenÈ na 5 cm
  delka = (delka + 2) / 5; // ta plus trojka je tam aby to zaokrouhlovalo
    2d58:	02 96       	adiw	r24, 0x02	; 2
    2d5a:	65 e0       	ldi	r22, 0x05	; 5
    2d5c:	70 e0       	ldi	r23, 0x00	; 0
    2d5e:	0e 94 82 3b 	call	0x7704	; 0x7704 <__udivmodhi4>
    2d62:	8b 01       	movw	r16, r22
  if (delka > 511){
    2d64:	22 e0       	ldi	r18, 0x02	; 2
    2d66:	60 30       	cpi	r22, 0x00	; 0
    2d68:	72 07       	cpc	r23, r18
    2d6a:	28 f0       	brcs	.+10     	; 0x2d76 <w_record+0x44>
    new_error(89); //prekrocen rozsah delky
    2d6c:	89 e5       	ldi	r24, 0x59	; 89
    2d6e:	0e 94 4e 19 	call	0x329c	; 0x329c <new_error>
    2d72:	0f ef       	ldi	r16, 0xFF	; 255
    2d74:	11 e0       	ldi	r17, 0x01	; 1
    delka = 511;
  }
  // ukl·d· zaokrouhlenÈ na 5 mm
  prumer = (prumer + 2) / 5;
    2d76:	c7 01       	movw	r24, r14
    2d78:	02 96       	adiw	r24, 0x02	; 2
    2d7a:	65 e0       	ldi	r22, 0x05	; 5
    2d7c:	70 e0       	ldi	r23, 0x00	; 0
    2d7e:	0e 94 82 3b 	call	0x7704	; 0x7704 <__udivmodhi4>
    2d82:	cb 01       	movw	r24, r22
  if (prumer > 127){
    2d84:	60 38       	cpi	r22, 0x80	; 128
    2d86:	71 05       	cpc	r23, r1
    2d88:	28 f0       	brcs	.+10     	; 0x2d94 <w_record+0x62>
    new_error(90); //prekrocen rozsah prumeru
    2d8a:	8a e5       	ldi	r24, 0x5A	; 90
    2d8c:	0e 94 4e 19 	call	0x329c	; 0x329c <new_error>
    2d90:	8f e7       	ldi	r24, 0x7F	; 127
    2d92:	90 e0       	ldi	r25, 0x00	; 0
    prumer = 127;
  }

  //pozor pokud bude dÈlka vÏtöÌ neû 512, bude doch·zet k p¯episov·nÌ ˙daje o pr˘mÏru
  data[zaznam][0 + posun] = (prumer << 1) | ((delka >> 8)&1); //prvnich 7 bit˘ je pr˘mÏr, poslenÌ bit(0) pat¯Ì k dÈlce
    2d94:	c1 70       	andi	r28, 0x01	; 1
    2d96:	d0 70       	andi	r29, 0x00	; 0
    2d98:	9e 01       	movw	r18, r28
    2d9a:	22 0f       	add	r18, r18
    2d9c:	22 0f       	add	r18, r18
    2d9e:	42 2f       	mov	r20, r18
    2da0:	50 e0       	ldi	r21, 0x00	; 0
    2da2:	d5 01       	movw	r26, r10
    2da4:	23 e0       	ldi	r18, 0x03	; 3
    2da6:	aa 0f       	add	r26, r26
    2da8:	bb 1f       	adc	r27, r27
    2daa:	2a 95       	dec	r18
    2dac:	e1 f7       	brne	.-8      	; 0x2da6 <w_record+0x74>
    2dae:	aa 19       	sub	r26, r10
    2db0:	bb 09       	sbc	r27, r11
    2db2:	fd 01       	movw	r30, r26
    2db4:	e4 0f       	add	r30, r20
    2db6:	f5 1f       	adc	r31, r21
    2db8:	e1 5a       	subi	r30, 0xA1	; 161
    2dba:	fc 4f       	sbci	r31, 0xFC	; 252
    2dbc:	88 0f       	add	r24, r24
    2dbe:	91 2f       	mov	r25, r17
    2dc0:	91 70       	andi	r25, 0x01	; 1
    2dc2:	89 2b       	or	r24, r25
    2dc4:	80 83       	st	Z, r24
  data[zaznam][1 + posun] = (255 & delka);
    2dc6:	a1 5a       	subi	r26, 0xA1	; 161
    2dc8:	bc 4f       	sbci	r27, 0xFC	; 252
    2dca:	fd 01       	movw	r30, r26
    2dcc:	e4 0f       	add	r30, r20
    2dce:	f5 1f       	adc	r31, r21
    2dd0:	01 83       	std	Z+1, r16	; 0x01
  data[zaznam][2 + posun] = (zakaznik << 3)|(druh_dreva);
    2dd2:	dd 0c       	add	r13, r13
    2dd4:	dd 0c       	add	r13, r13
    2dd6:	dd 0c       	add	r13, r13
    2dd8:	dc 28       	or	r13, r12
    2dda:	d2 82       	std	Z+2, r13	; 0x02
  data[zaznam][3] = (data[zaznam][3] & (0xf0 >> posun)) | (operace << posun);
    2ddc:	80 ef       	ldi	r24, 0xF0	; 240
    2dde:	90 e0       	ldi	r25, 0x00	; 0
    2de0:	04 2e       	mov	r0, r20
    2de2:	02 c0       	rjmp	.+4      	; 0x2de8 <w_record+0xb6>
    2de4:	95 95       	asr	r25
    2de6:	87 95       	ror	r24
    2de8:	0a 94       	dec	r0
    2dea:	e2 f7       	brpl	.-8      	; 0x2de4 <w_record+0xb2>
    2dec:	13 96       	adiw	r26, 0x03	; 3
    2dee:	2c 91       	ld	r18, X
    2df0:	13 97       	sbiw	r26, 0x03	; 3
    2df2:	28 23       	and	r18, r24
    2df4:	89 2d       	mov	r24, r9
    2df6:	90 e0       	ldi	r25, 0x00	; 0
    2df8:	02 c0       	rjmp	.+4      	; 0x2dfe <w_record+0xcc>
    2dfa:	88 0f       	add	r24, r24
    2dfc:	99 1f       	adc	r25, r25
    2dfe:	4a 95       	dec	r20
    2e00:	e2 f7       	brpl	.-8      	; 0x2dfa <w_record+0xc8>
    2e02:	28 2b       	or	r18, r24
    2e04:	13 96       	adiw	r26, 0x03	; 3
    2e06:	2c 93       	st	X, r18
  
}
    2e08:	df 91       	pop	r29
    2e0a:	cf 91       	pop	r28
    2e0c:	1f 91       	pop	r17
    2e0e:	0f 91       	pop	r16
    2e10:	ff 90       	pop	r15
    2e12:	ef 90       	pop	r14
    2e14:	df 90       	pop	r13
    2e16:	cf 90       	pop	r12
    2e18:	bf 90       	pop	r11
    2e1a:	af 90       	pop	r10
    2e1c:	9f 90       	pop	r9
    2e1e:	08 95       	ret

00002e20 <new_record>:
  data_top = eeprom_r16(odkud + 1 + (7 * DELKA_POLE_DAT));
  return (void *)odkud + 1 + (7 * DELKA_POLE_DAT) + 2;
}

/// UloûÌ z·znam do pamÏti. 
void new_record(char zakaznik,char druh_dreva,char operace,uint16_t delka, uint16_t prumer){
    2e20:	ef 92       	push	r14
    2e22:	ff 92       	push	r15
    2e24:	0f 93       	push	r16
    2e26:	1f 93       	push	r17
    2e28:	58 2f       	mov	r21, r24
    2e2a:	76 2f       	mov	r23, r22
    2e2c:	a4 2f       	mov	r26, r20
    2e2e:	f9 01       	movw	r30, r18
    2e30:	78 01       	movw	r14, r16
  w_record(data_top,zakaznik,druh_dreva,operace,delka, prumer);
    2e32:	80 91 9b 01 	lds	r24, 0x019B
    2e36:	90 91 9c 01 	lds	r25, 0x019C
    2e3a:	65 2f       	mov	r22, r21
    2e3c:	47 2f       	mov	r20, r23
    2e3e:	2a 2f       	mov	r18, r26
    2e40:	8f 01       	movw	r16, r30
    2e42:	0e 94 99 16 	call	0x2d32	; 0x2d32 <w_record>
  data_top++;
    2e46:	80 91 9b 01 	lds	r24, 0x019B
    2e4a:	90 91 9c 01 	lds	r25, 0x019C
    2e4e:	01 96       	adiw	r24, 0x01	; 1
    2e50:	90 93 9c 01 	sts	0x019C, r25
    2e54:	80 93 9b 01 	sts	0x019B, r24
}
    2e58:	1f 91       	pop	r17
    2e5a:	0f 91       	pop	r16
    2e5c:	ff 90       	pop	r15
    2e5e:	ef 90       	pop	r14
    2e60:	08 95       	ret

00002e62 <dat_del_record>:
  dat_free_m_jmena();
}


/// Funkce smaûe z·znam @a id
void dat_del_record(uint16_t id){
    2e62:	cf 92       	push	r12
    2e64:	df 92       	push	r13
    2e66:	ef 92       	push	r14
    2e68:	ff 92       	push	r15
    2e6a:	0f 93       	push	r16
    2e6c:	1f 93       	push	r17
    2e6e:	cf 93       	push	r28
    2e70:	df 93       	push	r29
    2e72:	9c 01       	movw	r18, r24
  uint16_t i = 0;

  if (id >= data_top){
    2e74:	80 91 9b 01 	lds	r24, 0x019B
    2e78:	90 91 9c 01 	lds	r25, 0x019C
    2e7c:	28 17       	cp	r18, r24
    2e7e:	39 07       	cpc	r19, r25
    2e80:	10 f4       	brcc	.+4      	; 0x2e86 <dat_del_record+0x24>
    2e82:	e9 01       	movw	r28, r18
    2e84:	1d c0       	rjmp	.+58     	; 0x2ec0 <dat_del_record+0x5e>
    new_error(10);
    2e86:	8a e0       	ldi	r24, 0x0A	; 10
    2e88:	0e 94 4e 19 	call	0x329c	; 0x329c <new_error>
    2e8c:	25 c0       	rjmp	.+74     	; 0x2ed8 <dat_del_record+0x76>
    return;
  }

  for (i = id; i < (data_top - 1); i++){
    r_record(i + 1);
    2e8e:	6e 01       	movw	r12, r28
    2e90:	08 94       	sec
    2e92:	c1 1c       	adc	r12, r1
    2e94:	d1 1c       	adc	r13, r1
    2e96:	c6 01       	movw	r24, r12
    2e98:	0e 94 30 15 	call	0x2a60	; 0x2a60 <r_record>
    w_record((unsigned int) i ,data_zakaznik, data_druh_dreva, data_operace, data_delka, data_prumer);
    2e9c:	00 91 9e 01 	lds	r16, 0x019E
    2ea0:	10 91 9f 01 	lds	r17, 0x019F
    2ea4:	e0 90 a1 01 	lds	r14, 0x01A1
    2ea8:	f0 90 a2 01 	lds	r15, 0x01A2
    2eac:	ce 01       	movw	r24, r28
    2eae:	60 91 a0 01 	lds	r22, 0x01A0
    2eb2:	40 91 a3 01 	lds	r20, 0x01A3
    2eb6:	20 91 a4 01 	lds	r18, 0x01A4
    2eba:	0e 94 99 16 	call	0x2d32	; 0x2d32 <w_record>
    2ebe:	e6 01       	movw	r28, r12
  if (id >= data_top){
    new_error(10);
    return;
  }

  for (i = id; i < (data_top - 1); i++){
    2ec0:	80 91 9b 01 	lds	r24, 0x019B
    2ec4:	90 91 9c 01 	lds	r25, 0x019C
    2ec8:	01 97       	sbiw	r24, 0x01	; 1
    2eca:	c8 17       	cp	r28, r24
    2ecc:	d9 07       	cpc	r29, r25
    2ece:	f8 f2       	brcs	.-66     	; 0x2e8e <dat_del_record+0x2c>
    r_record(i + 1);
    w_record((unsigned int) i ,data_zakaznik, data_druh_dreva, data_operace, data_delka, data_prumer);
  }
  data_top--;
    2ed0:	90 93 9c 01 	sts	0x019C, r25
    2ed4:	80 93 9b 01 	sts	0x019B, r24
}
    2ed8:	df 91       	pop	r29
    2eda:	cf 91       	pop	r28
    2edc:	1f 91       	pop	r17
    2ede:	0f 91       	pop	r16
    2ee0:	ff 90       	pop	r15
    2ee2:	ef 90       	pop	r14
    2ee4:	df 90       	pop	r13
    2ee6:	cf 90       	pop	r12
    2ee8:	08 95       	ret

00002eea <dat_zak_read_eeprom>:
  return (void *)kam + prirustek;

}


void *dat_zak_read_eeprom(void *kam){
    2eea:	af 92       	push	r10
    2eec:	bf 92       	push	r11
    2eee:	cf 92       	push	r12
    2ef0:	df 92       	push	r13
    2ef2:	ef 92       	push	r14
    2ef4:	ff 92       	push	r15
    2ef6:	0f 93       	push	r16
    2ef8:	1f 93       	push	r17
    2efa:	cf 93       	push	r28
    2efc:	df 93       	push	r29
    2efe:	18 2f       	mov	r17, r24
    2f00:	09 2f       	mov	r16, r25
  int i = 0;
  uint16_t prirustek = 0;
  int j = 0;


  dat_free_m_jmena();
    2f02:	0e 94 76 16 	call	0x2cec	; 0x2cec <dat_free_m_jmena>
    2f06:	21 2f       	mov	r18, r17
    2f08:	30 2f       	mov	r19, r16
    2f0a:	c9 01       	movw	r24, r18
    2f0c:	ec 01       	movw	r28, r24
    2f0e:	ee 24       	eor	r14, r14
    2f10:	ff 24       	eor	r15, r15
    2f12:	00 e0       	ldi	r16, 0x00	; 0
    2f14:	10 e0       	ldi	r17, 0x00	; 0

  while (1){  
    str_buf[j] = eeprom_r8(kam + prirustek);
    2f16:	65 e2       	ldi	r22, 0x25	; 37
    2f18:	a6 2e       	mov	r10, r22
    2f1a:	62 e0       	ldi	r22, 0x02	; 2
    2f1c:	b6 2e       	mov	r11, r22
  int i = 0;
  uint16_t prirustek = 0;
  int j = 0;


  dat_free_m_jmena();
    2f1e:	dc 2e       	mov	r13, r28
    2f20:	cd 2e       	mov	r12, r29

  while (1){  
    str_buf[j] = eeprom_r8(kam + prirustek);
    2f22:	ce 01       	movw	r24, r28
    2f24:	0e 94 81 10 	call	0x2102	; 0x2102 <eeprom_r8>
    2f28:	f8 01       	movw	r30, r16
    2f2a:	eb 5d       	subi	r30, 0xDB	; 219
    2f2c:	fd 4f       	sbci	r31, 0xFD	; 253
    2f2e:	80 83       	st	Z, r24
    //printc(str_buf[j]);                              /// @todo
    //for(q=0; q < 500; q++){  /// @todo
    //  _delay_ms(1);
    //}

    if(str_buf[j] == '\0') {
    2f30:	88 23       	and	r24, r24
    2f32:	89 f5       	brne	.+98     	; 0x2f96 <dat_zak_read_eeprom+0xac>
      char *s;
      char len = strlen(str_buf);
    2f34:	f5 01       	movw	r30, r10
    2f36:	01 90       	ld	r0, Z+
    2f38:	00 20       	and	r0, r0
    2f3a:	e9 f7       	brne	.-6      	; 0x2f36 <dat_zak_read_eeprom+0x4c>
    2f3c:	31 97       	sbiw	r30, 0x01	; 1
    2f3e:	e5 52       	subi	r30, 0x25	; 37
    2f40:	f2 40       	sbci	r31, 0x02	; 2
    2f42:	8e 2f       	mov	r24, r30
      if (len == 0 ){
    2f44:	ee 23       	and	r30, r30
    2f46:	41 f4       	brne	.+16     	; 0x2f58 <dat_zak_read_eeprom+0x6e>
        m_jmena[i] = NULL;
    2f48:	f7 01       	movw	r30, r14
    2f4a:	ee 0f       	add	r30, r30
    2f4c:	ff 1f       	adc	r31, r31
    2f4e:	ec 50       	subi	r30, 0x0C	; 12
    2f50:	fd 4f       	sbci	r31, 0xFD	; 253
    2f52:	11 82       	std	Z+1, r1	; 0x01
    2f54:	10 82       	st	Z, r1
    2f56:	16 c0       	rjmp	.+44     	; 0x2f84 <dat_zak_read_eeprom+0x9a>
      }
      else{
        s = (char *)malloc(len + 1);
    2f58:	90 e0       	ldi	r25, 0x00	; 0
    2f5a:	01 96       	adiw	r24, 0x01	; 1
    2f5c:	0e 94 19 32 	call	0x6432	; 0x6432 <malloc>
    2f60:	8c 01       	movw	r16, r24
        if (s == NULL){
    2f62:	00 97       	sbiw	r24, 0x00	; 0
    2f64:	21 f4       	brne	.+8      	; 0x2f6e <dat_zak_read_eeprom+0x84>
	  // printc('E');    /// @todo
          new_error(88);
    2f66:	88 e5       	ldi	r24, 0x58	; 88
    2f68:	0e 94 4e 19 	call	0x329c	; 0x329c <new_error>
    2f6c:	0b c0       	rjmp	.+22     	; 0x2f84 <dat_zak_read_eeprom+0x9a>
	}
	else{
	  //printc('-');
	  strcpy(s,str_buf);
    2f6e:	65 e2       	ldi	r22, 0x25	; 37
    2f70:	72 e0       	ldi	r23, 0x02	; 2
    2f72:	0e 94 37 33 	call	0x666e	; 0x666e <strcpy>
	  m_jmena[i] = s;
    2f76:	f7 01       	movw	r30, r14
    2f78:	ee 0f       	add	r30, r30
    2f7a:	ff 1f       	adc	r31, r31
    2f7c:	ec 50       	subi	r30, 0x0C	; 12
    2f7e:	fd 4f       	sbci	r31, 0xFD	; 253
    2f80:	11 83       	std	Z+1, r17	; 0x01
    2f82:	00 83       	st	Z, r16
	}
      }
        //msr_scr_add_zakaznik(s);
      j = -1;
      i++;
    2f84:	08 94       	sec
    2f86:	e1 1c       	adc	r14, r1
    2f88:	f1 1c       	adc	r15, r1
      if (i >= MAX_ZAKAZNIK){
    2f8a:	80 e1       	ldi	r24, 0x10	; 16
    2f8c:	e8 16       	cp	r14, r24
    2f8e:	f1 04       	cpc	r15, r1
    2f90:	4c f4       	brge	.+18     	; 0x2fa4 <dat_zak_read_eeprom+0xba>
        break;
    2f92:	0f ef       	ldi	r16, 0xFF	; 255
    2f94:	1f ef       	ldi	r17, 0xFF	; 255
      }
    }
    j++;
    2f96:	0f 5f       	subi	r16, 0xFF	; 255
    2f98:	1f 4f       	sbci	r17, 0xFF	; 255
    2f9a:	21 96       	adiw	r28, 0x01	; 1
    if (j > 12)
    2f9c:	0d 30       	cpi	r16, 0x0D	; 13
    2f9e:	11 05       	cpc	r17, r1
    2fa0:	0c f4       	brge	.+2      	; 0x2fa4 <dat_zak_read_eeprom+0xba>
    2fa2:	bd cf       	rjmp	.-134    	; 0x2f1e <dat_zak_read_eeprom+0x34>
      break;
    prirustek++;
  }
  return (void *) kam + prirustek;
}
    2fa4:	8d 2d       	mov	r24, r13
    2fa6:	9c 2d       	mov	r25, r12
    2fa8:	df 91       	pop	r29
    2faa:	cf 91       	pop	r28
    2fac:	1f 91       	pop	r17
    2fae:	0f 91       	pop	r16
    2fb0:	ff 90       	pop	r15
    2fb2:	ef 90       	pop	r14
    2fb4:	df 90       	pop	r13
    2fb6:	cf 90       	pop	r12
    2fb8:	bf 90       	pop	r11
    2fba:	af 90       	pop	r10
    2fbc:	08 95       	ret

00002fbe <dat_zak_write_eeprom>:
  m_jmena[MAX_ZAKAZNIK] = menu_pridat;
}

// Funkce uloûÌ daata do eeprom
//ukl·d· do pevnÈ dÈlky, //TODO ölo by p¯epsat na ukl·d·nÌ do promÏnnÈ dÈlky
void *dat_zak_write_eeprom(void *kam){
    2fbe:	cf 92       	push	r12
    2fc0:	df 92       	push	r13
    2fc2:	ef 92       	push	r14
    2fc4:	ff 92       	push	r15
    2fc6:	0f 93       	push	r16
    2fc8:	1f 93       	push	r17
    2fca:	cf 93       	push	r28
    2fcc:	df 93       	push	r29
    2fce:	6c 01       	movw	r12, r24
    2fd0:	74 ef       	ldi	r23, 0xF4	; 244
    2fd2:	e7 2e       	mov	r14, r23
    2fd4:	72 e0       	ldi	r23, 0x02	; 2
    2fd6:	f7 2e       	mov	r15, r23
    2fd8:	c0 e0       	ldi	r28, 0x00	; 0
    2fda:	d0 e0       	ldi	r29, 0x00	; 0
  int i;
  uint16_t prirustek = 0;
  
  for (i = 0; i < MAX_ZAKAZNIK; i++){
    eeprom_busy_wait();
    2fdc:	e1 99       	sbic	0x1c, 1	; 28
    2fde:	fe cf       	rjmp	.-4      	; 0x2fdc <dat_zak_write_eeprom+0x1e>
    if (m_jmena[i] != NULL){
    2fe0:	f7 01       	movw	r30, r14
    2fe2:	60 81       	ld	r22, Z
    2fe4:	71 81       	ldd	r23, Z+1	; 0x01
    2fe6:	c6 01       	movw	r24, r12
    2fe8:	8c 0f       	add	r24, r28
    2fea:	9d 1f       	adc	r25, r29
    2fec:	61 15       	cp	r22, r1
    2fee:	71 05       	cpc	r23, r1
    2ff0:	79 f0       	breq	.+30     	; 0x3010 <dat_zak_write_eeprom+0x52>
      char len = 1 + strlen(m_jmena[i]);
    2ff2:	db 01       	movw	r26, r22
    2ff4:	0d 90       	ld	r0, X+
    2ff6:	00 20       	and	r0, r0
    2ff8:	e9 f7       	brne	.-6      	; 0x2ff4 <dat_zak_write_eeprom+0x36>
      eeprom_write_block(m_jmena[i], kam + prirustek ,len);
    2ffa:	a6 1b       	sub	r26, r22
    2ffc:	0a 2f       	mov	r16, r26
    2ffe:	10 e0       	ldi	r17, 0x00	; 0
 */
static __inline__ void
eeprom_write_block (const void *__src, void *__dst, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eewr_block (__dst, __src, __n, eeprom_write_byte);
    3000:	a8 01       	movw	r20, r16
    3002:	24 e2       	ldi	r18, 0x24	; 36
    3004:	35 e1       	ldi	r19, 0x15	; 21
    3006:	0e 94 7f 33 	call	0x66fe	; 0x66fe <__eewr_block>
      prirustek += len;
    300a:	c0 0f       	add	r28, r16
    300c:	d1 1f       	adc	r29, r17
    300e:	09 c0       	rjmp	.+18     	; 0x3022 <dat_zak_write_eeprom+0x64>
    3010:	6b e8       	ldi	r22, 0x8B	; 139
    3012:	70 e0       	ldi	r23, 0x00	; 0
    3014:	41 e0       	ldi	r20, 0x01	; 1
    3016:	50 e0       	ldi	r21, 0x00	; 0
    3018:	24 e2       	ldi	r18, 0x24	; 36
    301a:	35 e1       	ldi	r19, 0x15	; 21
    301c:	0e 94 7f 33 	call	0x66fe	; 0x66fe <__eewr_block>
    }
    else{
      eeprom_write_block("",kam + prirustek,1);
      prirustek += 1;
    3020:	21 96       	adiw	r28, 0x01	; 1
    3022:	82 e0       	ldi	r24, 0x02	; 2
    3024:	90 e0       	ldi	r25, 0x00	; 0
    3026:	e8 0e       	add	r14, r24
    3028:	f9 1e       	adc	r15, r25
//ukl·d· do pevnÈ dÈlky, //TODO ölo by p¯epsat na ukl·d·nÌ do promÏnnÈ dÈlky
void *dat_zak_write_eeprom(void *kam){
  int i;
  uint16_t prirustek = 0;
  
  for (i = 0; i < MAX_ZAKAZNIK; i++){
    302a:	94 e1       	ldi	r25, 0x14	; 20
    302c:	e9 16       	cp	r14, r25
    302e:	93 e0       	ldi	r25, 0x03	; 3
    3030:	f9 06       	cpc	r15, r25
    3032:	a1 f6       	brne	.-88     	; 0x2fdc <dat_zak_write_eeprom+0x1e>
    3034:	96 01       	movw	r18, r12
    3036:	2c 0f       	add	r18, r28
    3038:	3d 1f       	adc	r19, r29
      prirustek += 1;
    }
  }
  return (void *)kam + prirustek;

}
    303a:	c9 01       	movw	r24, r18
    303c:	df 91       	pop	r29
    303e:	cf 91       	pop	r28
    3040:	1f 91       	pop	r17
    3042:	0f 91       	pop	r16
    3044:	ff 90       	pop	r15
    3046:	ef 90       	pop	r14
    3048:	df 90       	pop	r13
    304a:	cf 90       	pop	r12
    304c:	08 95       	ret

0000304e <dat_read_eeprom>:

  return (void *) kam + 1 + (7 * DELKA_POLE_DAT) + 2;
}

/// NaËte data z EEPROM.
void *dat_read_eeprom(void * odkud){
    304e:	0f 93       	push	r16
    3050:	1f 93       	push	r17
    3052:	8c 01       	movw	r16, r24
 */
static __inline__ void
eeprom_read_block (void *__dst, const void *__src, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eerd_block (__dst, __src, __n, eeprom_read_byte);
    3054:	8f e5       	ldi	r24, 0x5F	; 95
    3056:	93 e0       	ldi	r25, 0x03	; 3
    3058:	b8 01       	movw	r22, r16
    305a:	4f ed       	ldi	r20, 0xDF	; 223
    305c:	52 e0       	ldi	r21, 0x02	; 2
    305e:	2c e1       	ldi	r18, 0x1C	; 28
    3060:	35 e1       	ldi	r19, 0x15	; 21
    3062:	0e 94 4d 33 	call	0x669a	; 0x669a <__eerd_block>
  eeprom_read_block((void *)&(data[0]),odkud , DELKA_POLE_DAT * 7);
  data_top = eeprom_r16(odkud + 1 + (7 * DELKA_POLE_DAT));
    3066:	c8 01       	movw	r24, r16
    3068:	80 52       	subi	r24, 0x20	; 32
    306a:	9d 4f       	sbci	r25, 0xFD	; 253
    306c:	0e 94 c8 10 	call	0x2190	; 0x2190 <eeprom_r16>
    3070:	90 93 9c 01 	sts	0x019C, r25
    3074:	80 93 9b 01 	sts	0x019B, r24
    3078:	0e 51       	subi	r16, 0x1E	; 30
    307a:	1d 4f       	sbci	r17, 0xFD	; 253
  return (void *)odkud + 1 + (7 * DELKA_POLE_DAT) + 2;
}
    307c:	c8 01       	movw	r24, r16
    307e:	1f 91       	pop	r17
    3080:	0f 91       	pop	r16
    3082:	08 95       	ret

00003084 <dat_write_eeprom>:
  }
  data_top--;
}

/// Funkce uloûÌ data do eeprom a na v˝stupu se objevÌ prvnÌ voln· adresa v eprom za uk·dan˝mi daty.
void *dat_write_eeprom(void *kam){
    3084:	cf 93       	push	r28
    3086:	df 93       	push	r29
    3088:	ec 01       	movw	r28, r24
  eeprom_busy_wait();
    308a:	e1 99       	sbic	0x1c, 1	; 28
    308c:	fe cf       	rjmp	.-4      	; 0x308a <dat_write_eeprom+0x6>
 */
static __inline__ void
eeprom_write_block (const void *__src, void *__dst, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eewr_block (__dst, __src, __n, eeprom_write_byte);
    308e:	ce 01       	movw	r24, r28
    3090:	6f e5       	ldi	r22, 0x5F	; 95
    3092:	73 e0       	ldi	r23, 0x03	; 3
    3094:	4f ed       	ldi	r20, 0xDF	; 223
    3096:	52 e0       	ldi	r21, 0x02	; 2
    3098:	24 e2       	ldi	r18, 0x24	; 36
    309a:	35 e1       	ldi	r19, 0x15	; 21
    309c:	0e 94 7f 33 	call	0x66fe	; 0x66fe <__eewr_block>
  eeprom_write_block((void *)&(data[0]),kam, DELKA_POLE_DAT * 7);
  eeprom_busy_wait();
    30a0:	e1 99       	sbic	0x1c, 1	; 28
    30a2:	fe cf       	rjmp	.-4      	; 0x30a0 <dat_write_eeprom+0x1c>
  eeprom_w16((void *) kam + 1 + (7 * DELKA_POLE_DAT), data_top);
    30a4:	60 91 9b 01 	lds	r22, 0x019B
    30a8:	70 91 9c 01 	lds	r23, 0x019C
    30ac:	ce 01       	movw	r24, r28
    30ae:	80 52       	subi	r24, 0x20	; 32
    30b0:	9d 4f       	sbci	r25, 0xFD	; 253
    30b2:	0e 94 cd 10 	call	0x219a	; 0x219a <eeprom_w16>
    30b6:	9e 01       	movw	r18, r28
    30b8:	2e 51       	subi	r18, 0x1E	; 30
    30ba:	3d 4f       	sbci	r19, 0xFD	; 253

  return (void *) kam + 1 + (7 * DELKA_POLE_DAT) + 2;
}
    30bc:	c9 01       	movw	r24, r18
    30be:	df 91       	pop	r29
    30c0:	cf 91       	pop	r28
    30c2:	08 95       	ret

000030c4 <scr_close>:
    break;
  }
}

void scr_close(char scr){
  switch (scr){
    30c4:	84 30       	cpi	r24, 0x04	; 4
    30c6:	81 f0       	breq	.+32     	; 0x30e8 <scr_close+0x24>
    30c8:	85 30       	cpi	r24, 0x05	; 5
    30ca:	18 f4       	brcc	.+6      	; 0x30d2 <scr_close+0xe>
    30cc:	88 23       	and	r24, r24
    30ce:	31 f0       	breq	.+12     	; 0x30dc <scr_close+0x18>
    30d0:	08 95       	ret
    30d2:	85 30       	cpi	r24, 0x05	; 5
    30d4:	31 f0       	breq	.+12     	; 0x30e2 <scr_close+0x1e>
    30d6:	88 30       	cpi	r24, 0x08	; 8
    30d8:	61 f4       	brne	.+24     	; 0x30f2 <scr_close+0x2e>
    30da:	09 c0       	rjmp	.+18     	; 0x30ee <scr_close+0x2a>
//  case LST_SCR:
//    list_scr_open();
//    break;
  case MSR_SCR:
    measure_scr_close();
    30dc:	0e 94 52 21 	call	0x42a4	; 0x42a4 <measure_scr_close>
    30e0:	08 95       	ret
    break;
  case DLST_SCR:
    dlst_scr_close();
    30e2:	0e 94 79 2c 	call	0x58f2	; 0x58f2 <dlst_scr_close>
    30e6:	08 95       	ret
    break;
  case DAT_SCR:
    data_scr_close();
    30e8:	0e 94 8f 26 	call	0x4d1e	; 0x4d1e <data_scr_close>
    30ec:	08 95       	ret
    break;
  case STP_SCR:
    stp_scr_close();
    30ee:	0e 94 43 30 	call	0x6086	; 0x6086 <stp_scr_close>
    30f2:	08 95       	ret

000030f4 <scr_open>:
  }
}


void scr_open(char scr){
  switch(scr){
    30f4:	84 30       	cpi	r24, 0x04	; 4
    30f6:	b1 f0       	breq	.+44     	; 0x3124 <scr_open+0x30>
    30f8:	85 30       	cpi	r24, 0x05	; 5
    30fa:	38 f4       	brcc	.+14     	; 0x310a <scr_open+0x16>
    30fc:	82 30       	cpi	r24, 0x02	; 2
    30fe:	c1 f0       	breq	.+48     	; 0x3130 <scr_open+0x3c>
    3100:	83 30       	cpi	r24, 0x03	; 3
    3102:	c8 f4       	brcc	.+50     	; 0x3136 <scr_open+0x42>
    3104:	88 23       	and	r24, r24
    3106:	41 f0       	breq	.+16     	; 0x3118 <scr_open+0x24>
    3108:	08 95       	ret
    310a:	87 30       	cpi	r24, 0x07	; 7
    310c:	71 f0       	breq	.+28     	; 0x312a <scr_open+0x36>
    310e:	88 30       	cpi	r24, 0x08	; 8
    3110:	a9 f0       	breq	.+42     	; 0x313c <scr_open+0x48>
    3112:	85 30       	cpi	r24, 0x05	; 5
    3114:	a9 f4       	brne	.+42     	; 0x3140 <scr_open+0x4c>
    3116:	03 c0       	rjmp	.+6      	; 0x311e <scr_open+0x2a>
//  case LST_SCR:
//    list_scr_open();
//    break;
  case MSR_SCR:
    measure_scr_open();
    3118:	0e 94 d2 24 	call	0x49a4	; 0x49a4 <measure_scr_open>
    311c:	08 95       	ret
    break;
  case DLST_SCR:
    dlst_scr_open();
    311e:	0e 94 8e 2c 	call	0x591c	; 0x591c <dlst_scr_open>
    3122:	08 95       	ret
    break;
  case DAT_SCR:
    data_scr_open();
    3124:	0e 94 ed 26 	call	0x4dda	; 0x4dda <data_scr_open>
    3128:	08 95       	ret
    break;
  case SER_SCR:
    ser_scr_open();
    312a:	0e 94 b3 2f 	call	0x5f66	; 0x5f66 <ser_scr_open>
    312e:	08 95       	ret
    break;
  case HLP_SCR:
    hlp_scr_open();
    3130:	0e 94 84 25 	call	0x4b08	; 0x4b08 <hlp_scr_open>
    3134:	08 95       	ret
    break;
  case ERR_SCR:
    err_scr_open();
    3136:	0e 94 49 19 	call	0x3292	; 0x3292 <err_scr_open>
    313a:	08 95       	ret
    break;
  case STP_SCR:
    stp_scr_open();
    313c:	0e 94 af 31 	call	0x635e	; 0x635e <stp_scr_open>
    3140:	08 95       	ret

00003142 <scr_draw>:
}


///Funkce vykreslÌ obrazovku. PoËÌt· se s p¯edchozÌ alokacÌ.
void scr_draw(char scr){
  switch(scr){
    3142:	83 30       	cpi	r24, 0x03	; 3
    3144:	b9 f0       	breq	.+46     	; 0x3174 <scr_draw+0x32>
    3146:	84 30       	cpi	r24, 0x04	; 4
    3148:	28 f4       	brcc	.+10     	; 0x3154 <scr_draw+0x12>
    314a:	88 23       	and	r24, r24
    314c:	51 f0       	breq	.+20     	; 0x3162 <scr_draw+0x20>
    314e:	82 30       	cpi	r24, 0x02	; 2
    3150:	c9 f4       	brne	.+50     	; 0x3184 <scr_draw+0x42>
    3152:	0d c0       	rjmp	.+26     	; 0x316e <scr_draw+0x2c>
    3154:	85 30       	cpi	r24, 0x05	; 5
    3156:	89 f0       	breq	.+34     	; 0x317a <scr_draw+0x38>
    3158:	85 30       	cpi	r24, 0x05	; 5
    315a:	30 f0       	brcs	.+12     	; 0x3168 <scr_draw+0x26>
    315c:	88 30       	cpi	r24, 0x08	; 8
    315e:	91 f4       	brne	.+36     	; 0x3184 <scr_draw+0x42>
    3160:	0f c0       	rjmp	.+30     	; 0x3180 <scr_draw+0x3e>
    case MSR_SCR:
      measure_scr_draw();
    3162:	0e 94 86 21 	call	0x430c	; 0x430c <measure_scr_draw>
    3166:	08 95       	ret
      break;
//    case LST_SCR:
//      list_scr_draw();
//      break;
    case DAT_SCR:
      data_scr_draw();
    3168:	0e 94 98 28 	call	0x5130	; 0x5130 <data_scr_draw>
    316c:	08 95       	ret
      break;
    case HLP_SCR:
      help_scr_draw();
    316e:	0e 94 a3 25 	call	0x4b46	; 0x4b46 <help_scr_draw>
    3172:	08 95       	ret
      break;
    case ERR_SCR:
      error_scr_draw();
    3174:	0e 94 0c 1b 	call	0x3618	; 0x3618 <error_scr_draw>
    3178:	08 95       	ret
      break;
    case DLST_SCR:
      dlst_scr_draw();
    317a:	0e 94 fd 2c 	call	0x59fa	; 0x59fa <dlst_scr_draw>
    317e:	08 95       	ret
      break;
    case STP_SCR:
      stp_scr_draw();
    3180:	0e 94 a4 31 	call	0x6348	; 0x6348 <stp_scr_draw>
    3184:	08 95       	ret

00003186 <scr_ch>:
  }
}

/// Funkce p¯epne na jinou obrazovku. ZajistÌ p¯itom vöechny pot¯ebnÈ 
/// zavedenÌ promÏnnn˝ch
void scr_ch(char scr){
    3186:	1f 93       	push	r17
    3188:	18 2f       	mov	r17, r24
  if (akt_scr == scr){ // nem· smysl alokovat
    318a:	80 91 a5 01 	lds	r24, 0x01A5
    318e:	81 17       	cp	r24, r17
    3190:	41 f0       	breq	.+16     	; 0x31a2 <scr_ch+0x1c>
    scr_draw(scr); // dojde jen k p¯ekreslenÌ
  }
  else{
    scr_close(akt_scr);
    3192:	0e 94 62 18 	call	0x30c4	; 0x30c4 <scr_close>
    scr_open(scr);
    3196:	81 2f       	mov	r24, r17
    3198:	0e 94 7a 18 	call	0x30f4	; 0x30f4 <scr_open>
    akt_scr = scr;
    319c:	10 93 a5 01 	sts	0x01A5, r17
    scr_draw(scr);
    31a0:	81 2f       	mov	r24, r17
    31a2:	0e 94 a1 18 	call	0x3142	; 0x3142 <scr_draw>
  }
}
    31a6:	1f 91       	pop	r17
    31a8:	08 95       	ret

000031aa <gui_control>:


}
/*  */
void gui_control(void){
  if (lcd_new_frame()){
    31aa:	0e 94 89 11 	call	0x2312	; 0x2312 <lcd_new_frame>
    31ae:	88 23       	and	r24, r24
    31b0:	41 f1       	breq	.+80     	; 0x3202 <gui_control+0x58>
  
    switch (akt_scr){
    31b2:	80 91 a5 01 	lds	r24, 0x01A5
    31b6:	84 30       	cpi	r24, 0x04	; 4
    31b8:	c9 f0       	breq	.+50     	; 0x31ec <gui_control+0x42>
    31ba:	85 30       	cpi	r24, 0x05	; 5
    31bc:	38 f4       	brcc	.+14     	; 0x31cc <gui_control+0x22>
    31be:	82 30       	cpi	r24, 0x02	; 2
    31c0:	79 f0       	breq	.+30     	; 0x31e0 <gui_control+0x36>
    31c2:	83 30       	cpi	r24, 0x03	; 3
    31c4:	80 f4       	brcc	.+32     	; 0x31e6 <gui_control+0x3c>
    31c6:	88 23       	and	r24, r24
    31c8:	41 f0       	breq	.+16     	; 0x31da <gui_control+0x30>
    31ca:	08 95       	ret
    31cc:	87 30       	cpi	r24, 0x07	; 7
    31ce:	a1 f0       	breq	.+40     	; 0x31f8 <gui_control+0x4e>
    31d0:	88 30       	cpi	r24, 0x08	; 8
    31d2:	a9 f0       	breq	.+42     	; 0x31fe <gui_control+0x54>
    31d4:	85 30       	cpi	r24, 0x05	; 5
    31d6:	a9 f4       	brne	.+42     	; 0x3202 <gui_control+0x58>
    31d8:	0c c0       	rjmp	.+24     	; 0x31f2 <gui_control+0x48>
    case MSR_SCR:
      measure_scr_control();
    31da:	0e 94 01 22 	call	0x4402	; 0x4402 <measure_scr_control>
    31de:	08 95       	ret
      break;
//    case LST_SCR:
//      list_scr_control();
//      break;
    case HLP_SCR:
      help_scr_control();
    31e0:	0e 94 8e 25 	call	0x4b1c	; 0x4b1c <help_scr_control>
    31e4:	08 95       	ret
      break;
    case ERR_SCR:
      error_scr_control();
    31e6:	0e 94 bd 19 	call	0x337a	; 0x337a <error_scr_control>
    31ea:	08 95       	ret
      break;
    case DAT_SCR:
      data_scr_control();
    31ec:	0e 94 1c 29 	call	0x5238	; 0x5238 <data_scr_control>
    31f0:	08 95       	ret
      break;
    case DLST_SCR:
      dlst_scr_control();
    31f2:	0e 94 0b 2d 	call	0x5a16	; 0x5a16 <dlst_scr_control>
    31f6:	08 95       	ret
      break;
    case SER_SCR:
      ser_scr_control();
    31f8:	0e 94 f7 2f 	call	0x5fee	; 0x5fee <ser_scr_control>
    31fc:	08 95       	ret
      break;
    case STP_SCR:
      stp_scr_control();
    31fe:	0e 94 c5 30 	call	0x618a	; 0x618a <stp_scr_control>
    3202:	08 95       	ret

00003204 <gui_init>:


void gui_init(void){

//  list_scr_init();
  data_scr_init();
    3204:	0e 94 f6 25 	call	0x4bec	; 0x4bec <data_scr_init>
  measure_scr_init();
    3208:	0e 94 f8 20 	call	0x41f0	; 0x41f0 <measure_scr_init>
 // je treba nastartovat uvodni obrazovku
  measure_scr_open();
    320c:	0e 94 d2 24 	call	0x49a4	; 0x49a4 <measure_scr_open>
  measure_scr_draw();
    3210:	0e 94 86 21 	call	0x430c	; 0x430c <measure_scr_draw>


}
    3214:	08 95       	ret

00003216 <ok_scr>:
}

int ok_scr(void){
  char c;

  if ((c = get_spec()) != 0){
    3216:	0e 94 f2 1c 	call	0x39e4	; 0x39e4 <get_spec>
    321a:	88 23       	and	r24, r24
    321c:	b9 f0       	breq	.+46     	; 0x324c <ok_scr+0x36>
    switch(c){
    321e:	85 30       	cpi	r24, 0x05	; 5
    3220:	51 f0       	breq	.+20     	; 0x3236 <ok_scr+0x20>
    3222:	86 30       	cpi	r24, 0x06	; 6
    3224:	18 f4       	brcc	.+6      	; 0x322c <ok_scr+0x16>
    3226:	84 30       	cpi	r24, 0x04	; 4
    3228:	89 f4       	brne	.+34     	; 0x324c <ok_scr+0x36>
    322a:	08 c0       	rjmp	.+16     	; 0x323c <ok_scr+0x26>
    322c:	85 31       	cpi	r24, 0x15	; 21
    322e:	49 f0       	breq	.+18     	; 0x3242 <ok_scr+0x2c>
    3230:	86 31       	cpi	r24, 0x16	; 22
    3232:	61 f4       	brne	.+24     	; 0x324c <ok_scr+0x36>
    3234:	09 c0       	rjmp	.+18     	; 0x3248 <ok_scr+0x32>
    3236:	2f ef       	ldi	r18, 0xFF	; 255
    3238:	3f ef       	ldi	r19, 0xFF	; 255
    323a:	0a c0       	rjmp	.+20     	; 0x3250 <ok_scr+0x3a>
    323c:	21 e0       	ldi	r18, 0x01	; 1
    323e:	30 e0       	ldi	r19, 0x00	; 0
    3240:	07 c0       	rjmp	.+14     	; 0x3250 <ok_scr+0x3a>
      break;
    case 5: //Esc
      return -1;
      break;
    case 21: // F11 - Strorno mÏ¯enÌ
      kf_zrusit();
    3242:	0e 94 09 32 	call	0x6412	; 0x6412 <kf_zrusit>
    3246:	02 c0       	rjmp	.+4      	; 0x324c <ok_scr+0x36>
      break;
    case 22: //F12
      // Odesl·nÌ dat.
      send_data();
    3248:	0e 94 3c 2f 	call	0x5e78	; 0x5e78 <send_data>
    324c:	20 e0       	ldi	r18, 0x00	; 0
    324e:	30 e0       	ldi	r19, 0x00	; 0
      break;
    }
    
  }
  return 0;
}
    3250:	c9 01       	movw	r24, r18
    3252:	08 95       	ret

00003254 <ok_scr_init>:

void scr_open(char scr);
void scr_close(char scr);


void ok_scr_init(char *str){
    3254:	0f 93       	push	r16
    3256:	1f 93       	push	r17
    3258:	8c 01       	movw	r16, r24
  clear_dscreen();
    325a:	0e 94 9e 11 	call	0x233c	; 0x233c <clear_dscreen>
  printxyd_P(0,0,(void *)str);
    325e:	80 e0       	ldi	r24, 0x00	; 0
    3260:	90 e0       	ldi	r25, 0x00	; 0
    3262:	60 e0       	ldi	r22, 0x00	; 0
    3264:	70 e0       	ldi	r23, 0x00	; 0
    3266:	a8 01       	movw	r20, r16
    3268:	0e 94 47 13 	call	0x268e	; 0x268e <printxyd_P>

  printxyd_P(3,4,(void *)s_ok);
    326c:	83 e0       	ldi	r24, 0x03	; 3
    326e:	90 e0       	ldi	r25, 0x00	; 0
    3270:	64 e0       	ldi	r22, 0x04	; 4
    3272:	70 e0       	ldi	r23, 0x00	; 0
    3274:	43 e9       	ldi	r20, 0x93	; 147
    3276:	52 e0       	ldi	r21, 0x02	; 2
    3278:	0e 94 47 13 	call	0x268e	; 0x268e <printxyd_P>
  printxyd_P(3,24,(void *)s_storno);
    327c:	83 e0       	ldi	r24, 0x03	; 3
    327e:	90 e0       	ldi	r25, 0x00	; 0
    3280:	68 e1       	ldi	r22, 0x18	; 24
    3282:	70 e0       	ldi	r23, 0x00	; 0
    3284:	4e e9       	ldi	r20, 0x9E	; 158
    3286:	52 e0       	ldi	r21, 0x02	; 2
    3288:	0e 94 47 13 	call	0x268e	; 0x268e <printxyd_P>
}
    328c:	1f 91       	pop	r17
    328e:	0f 91       	pop	r16
    3290:	08 95       	ret

00003292 <err_scr_open>:
    new_err = 0;
  }
}

void err_scr_open(void){
   prev_scr = akt_scr;
    3292:	80 91 a5 01 	lds	r24, 0x01A5
    3296:	80 93 a6 01 	sts	0x01A6, r24
}
    329a:	08 95       	ret

0000329c <new_error>:

/// Funkce vytv·¯Ì novou chybu. Dojde k p¯epnutÌ na
/// "error screen" a k v˝pisu textu popisujÌcÌho tuto chybu.
/// @param err_num Identifikuje ËÌslem chybovou hl·öku.
void new_error(uint8_t err_num){
  last_err = err_num;
    329c:	80 93 b7 00 	sts	0x00B7, r24
  new_err = 1;
    32a0:	81 e0       	ldi	r24, 0x01	; 1
    32a2:	80 93 a9 01 	sts	0x01A9, r24
  //prev_scr = akt_scr;
  //scr_ch(ERR_SCR);
 
}
    32a6:	08 95       	ret

000032a8 <new_str_error>:


/**
 * Funkce vytvo¯Ì nov˝ error. Jeho text je zad·n v parametru s.
 */
void new_str_error(uint8_t err_num, char * s){
    32a8:	1f 93       	push	r17
    32aa:	cf 93       	push	r28
    32ac:	df 93       	push	r29
    32ae:	18 2f       	mov	r17, r24
    32b0:	eb 01       	movw	r28, r22
  assert(err_num >= 150);
    32b2:	86 39       	cpi	r24, 0x96	; 150
    32b4:	30 f4       	brcc	.+12     	; 0x32c2 <new_str_error+0x1a>
    32b6:	85 e9       	ldi	r24, 0x95	; 149
    32b8:	90 e0       	ldi	r25, 0x00	; 0
    32ba:	66 e7       	ldi	r22, 0x76	; 118
    32bc:	70 e0       	ldi	r23, 0x00	; 0
    32be:	0e 94 6e 19 	call	0x32dc	; 0x32dc <err_assert>
  last_err = err_num;
    32c2:	10 93 b7 00 	sts	0x00B7, r17
  err_str = s;
    32c6:	d0 93 a8 01 	sts	0x01A8, r29
    32ca:	c0 93 a7 01 	sts	0x01A7, r28
  scr_ch(ERR_SCR);
    32ce:	83 e0       	ldi	r24, 0x03	; 3
    32d0:	0e 94 c3 18 	call	0x3186	; 0x3186 <scr_ch>

}
    32d4:	df 91       	pop	r29
    32d6:	cf 91       	pop	r28
    32d8:	1f 91       	pop	r17
    32da:	08 95       	ret

000032dc <err_assert>:
/**
 * Funkce je vol·na v p¯ÌpadÏ ûe makro assert() nalezlo nÏjakou chybu.
 * Funkce vyvto¯Ì ¯eùÏzec, v nÏm°û je pops·no jmÈno funkce, jmÈno
 * souboru a ¯·dek, z nÏhoû je makro spouötÏno.
 */
void err_assert(char * soubor, int radek){
    32dc:	cf 92       	push	r12
    32de:	df 92       	push	r13
    32e0:	ef 92       	push	r14
    32e2:	ff 92       	push	r15
    32e4:	0f 93       	push	r16
    32e6:	1f 93       	push	r17
    32e8:	d8 2e       	mov	r13, r24
    32ea:	c9 2e       	mov	r12, r25
    32ec:	8b 01       	movw	r16, r22
  char * str = (char *)mmalloc(strlen(soubor) + 20 + 4 + 3);
    32ee:	a8 2f       	mov	r26, r24
    32f0:	b9 2f       	mov	r27, r25
    32f2:	fd 01       	movw	r30, r26
    32f4:	01 90       	ld	r0, Z+
    32f6:	00 20       	and	r0, r0
    32f8:	e9 f7       	brne	.-6      	; 0x32f4 <err_assert+0x18>
    32fa:	ea 1b       	sub	r30, r26
    32fc:	fb 0b       	sbc	r31, r27
    32fe:	cf 01       	movw	r24, r30
    3300:	4a 96       	adiw	r24, 0x1a	; 26
    3302:	0e 94 c1 06 	call	0xd82	; 0xd82 <mmalloc>
    3306:	f8 2e       	mov	r15, r24
    3308:	e9 2e       	mov	r14, r25
  
  sprintf(str,"Error 150: assert()\n%s\n%i",soubor,radek);
    330a:	8d b7       	in	r24, 0x3d	; 61
    330c:	9e b7       	in	r25, 0x3e	; 62
    330e:	08 97       	sbiw	r24, 0x08	; 8
    3310:	0f b6       	in	r0, 0x3f	; 63
    3312:	f8 94       	cli
    3314:	9e bf       	out	0x3e, r25	; 62
    3316:	0f be       	out	0x3f, r0	; 63
    3318:	8d bf       	out	0x3d, r24	; 61
    331a:	ed b7       	in	r30, 0x3d	; 61
    331c:	fe b7       	in	r31, 0x3e	; 62
    331e:	31 96       	adiw	r30, 0x01	; 1
    3320:	ad b7       	in	r26, 0x3d	; 61
    3322:	be b7       	in	r27, 0x3e	; 62
    3324:	11 96       	adiw	r26, 0x01	; 1
    3326:	fc 92       	st	X, r15
    3328:	e1 82       	std	Z+1, r14	; 0x01
    332a:	8d e9       	ldi	r24, 0x9D	; 157
    332c:	90 e0       	ldi	r25, 0x00	; 0
    332e:	93 83       	std	Z+3, r25	; 0x03
    3330:	82 83       	std	Z+2, r24	; 0x02
    3332:	d4 82       	std	Z+4, r13	; 0x04
    3334:	c5 82       	std	Z+5, r12	; 0x05
    3336:	17 83       	std	Z+7, r17	; 0x07
    3338:	06 83       	std	Z+6, r16	; 0x06
    333a:	0e 94 b0 33 	call	0x6760	; 0x6760 <sprintf>
  new_str_error(150,str);
    333e:	8d b7       	in	r24, 0x3d	; 61
    3340:	9e b7       	in	r25, 0x3e	; 62
    3342:	08 96       	adiw	r24, 0x08	; 8
    3344:	0f b6       	in	r0, 0x3f	; 63
    3346:	f8 94       	cli
    3348:	9e bf       	out	0x3e, r25	; 62
    334a:	0f be       	out	0x3f, r0	; 63
    334c:	8d bf       	out	0x3d, r24	; 61
    334e:	86 e9       	ldi	r24, 0x96	; 150
    3350:	6f 2d       	mov	r22, r15
    3352:	7e 2d       	mov	r23, r14
    3354:	0e 94 54 19 	call	0x32a8	; 0x32a8 <new_str_error>
}
    3358:	1f 91       	pop	r17
    335a:	0f 91       	pop	r16
    335c:	ff 90       	pop	r15
    335e:	ef 90       	pop	r14
    3360:	df 90       	pop	r13
    3362:	cf 90       	pop	r12
    3364:	08 95       	ret

00003366 <err_control>:
 * Funkce, kter· zajiöùuje asynchronÌ vypisov·nÌ error˘. D¯Ìve totiû mohlo dojÌt k
 * p¯eruöenÌ bÏhu programu uprost¯ed vykon·v·nÌ nÏkterÈ funkce a to vedlo k potÌûÌm s
 * korektnÌm navracenÌm systÈmov˝ch prost¯edk˘.
 */
void err_control(void){
  if (new_err == 1){
    3366:	80 91 a9 01 	lds	r24, 0x01A9
    336a:	81 30       	cpi	r24, 0x01	; 1
    336c:	29 f4       	brne	.+10     	; 0x3378 <err_control+0x12>
    scr_ch(ERR_SCR);
    336e:	83 e0       	ldi	r24, 0x03	; 3
    3370:	0e 94 c3 18 	call	0x3186	; 0x3186 <scr_ch>
    new_err = 0;
    3374:	10 92 a9 01 	sts	0x01A9, r1
    3378:	08 95       	ret

0000337a <error_scr_control>:
    pocitadlo_1 = 0;
    scr_ch(prev_scr);
  }
  */

  if ((c = get_spec()) != 0){
    337a:	0e 94 f2 1c 	call	0x39e4	; 0x39e4 <get_spec>
    337e:	88 23       	and	r24, r24
    3380:	a9 f0       	breq	.+42     	; 0x33ac <error_scr_control+0x32>
    switch (c){
    3382:	85 31       	cpi	r24, 0x15	; 21
    3384:	71 f0       	breq	.+28     	; 0x33a2 <error_scr_control+0x28>
    3386:	86 31       	cpi	r24, 0x16	; 22
    3388:	20 f4       	brcc	.+8      	; 0x3392 <error_scr_control+0x18>
    338a:	84 50       	subi	r24, 0x04	; 4
    338c:	82 30       	cpi	r24, 0x02	; 2
    338e:	70 f4       	brcc	.+28     	; 0x33ac <error_scr_control+0x32>
    3390:	03 c0       	rjmp	.+6      	; 0x3398 <error_scr_control+0x1e>
    3392:	86 31       	cpi	r24, 0x16	; 22
    3394:	59 f4       	brne	.+22     	; 0x33ac <error_scr_control+0x32>
    3396:	08 c0       	rjmp	.+16     	; 0x33a8 <error_scr_control+0x2e>
    case 4: //Enter
    case 5: //Esc
      scr_ch(prev_scr);
    3398:	80 91 a6 01 	lds	r24, 0x01A6
    339c:	0e 94 c3 18 	call	0x3186	; 0x3186 <scr_ch>
    33a0:	08 95       	ret
      //measure_scr_draw();
      break;
    case 21: // F11 - Strorno mÏ¯enÌ
      kf_zrusit();
    33a2:	0e 94 09 32 	call	0x6412	; 0x6412 <kf_zrusit>
    33a6:	08 95       	ret
      break;
    case 22: //F12
      // Odesl·nÌ dat.
      send_data();
    33a8:	0e 94 3c 2f 	call	0x5e78	; 0x5e78 <send_data>
    33ac:	08 95       	ret

000033ae <print_err>:
}

void print_err(void){
  
  //error_scr_draw();
  switch(last_err){
    33ae:	80 91 b7 00 	lds	r24, 0x00B7
    33b2:	88 35       	cpi	r24, 0x58	; 88
    33b4:	09 f4       	brne	.+2      	; 0x33b8 <print_err+0xa>
    33b6:	c3 c0       	rjmp	.+390    	; 0x353e <print_err+0x190>
    33b8:	89 35       	cpi	r24, 0x59	; 89
    33ba:	70 f5       	brcc	.+92     	; 0x3418 <print_err+0x6a>
    33bc:	80 35       	cpi	r24, 0x50	; 80
    33be:	09 f4       	brne	.+2      	; 0x33c2 <print_err+0x14>
    33c0:	86 c0       	rjmp	.+268    	; 0x34ce <print_err+0x120>
    33c2:	81 35       	cpi	r24, 0x51	; 81
    33c4:	b0 f4       	brcc	.+44     	; 0x33f2 <print_err+0x44>
    33c6:	86 30       	cpi	r24, 0x06	; 6
    33c8:	09 f4       	brne	.+2      	; 0x33cc <print_err+0x1e>
    33ca:	65 c0       	rjmp	.+202    	; 0x3496 <print_err+0xe8>
    33cc:	87 30       	cpi	r24, 0x07	; 7
    33ce:	38 f4       	brcc	.+14     	; 0x33de <print_err+0x30>
    33d0:	81 30       	cpi	r24, 0x01	; 1
    33d2:	09 f4       	brne	.+2      	; 0x33d6 <print_err+0x28>
    33d4:	52 c0       	rjmp	.+164    	; 0x347a <print_err+0xcc>
    33d6:	84 30       	cpi	r24, 0x04	; 4
    33d8:	09 f0       	breq	.+2      	; 0x33dc <print_err+0x2e>
    33da:	1d c1       	rjmp	.+570    	; 0x3616 <print_err+0x268>
    33dc:	55 c0       	rjmp	.+170    	; 0x3488 <print_err+0xda>
    33de:	8a 30       	cpi	r24, 0x0A	; 10
    33e0:	09 f4       	brne	.+2      	; 0x33e4 <print_err+0x36>
    33e2:	67 c0       	rjmp	.+206    	; 0x34b2 <print_err+0x104>
    33e4:	8b 30       	cpi	r24, 0x0B	; 11
    33e6:	09 f4       	brne	.+2      	; 0x33ea <print_err+0x3c>
    33e8:	6b c0       	rjmp	.+214    	; 0x34c0 <print_err+0x112>
    33ea:	87 30       	cpi	r24, 0x07	; 7
    33ec:	09 f0       	breq	.+2      	; 0x33f0 <print_err+0x42>
    33ee:	13 c1       	rjmp	.+550    	; 0x3616 <print_err+0x268>
    33f0:	59 c0       	rjmp	.+178    	; 0x34a4 <print_err+0xf6>
    33f2:	84 35       	cpi	r24, 0x54	; 84
    33f4:	09 f4       	brne	.+2      	; 0x33f8 <print_err+0x4a>
    33f6:	87 c0       	rjmp	.+270    	; 0x3506 <print_err+0x158>
    33f8:	85 35       	cpi	r24, 0x55	; 85
    33fa:	38 f4       	brcc	.+14     	; 0x340a <print_err+0x5c>
    33fc:	82 35       	cpi	r24, 0x52	; 82
    33fe:	09 f4       	brne	.+2      	; 0x3402 <print_err+0x54>
    3400:	74 c0       	rjmp	.+232    	; 0x34ea <print_err+0x13c>
    3402:	83 35       	cpi	r24, 0x53	; 83
    3404:	08 f0       	brcs	.+2      	; 0x3408 <print_err+0x5a>
    3406:	78 c0       	rjmp	.+240    	; 0x34f8 <print_err+0x14a>
    3408:	69 c0       	rjmp	.+210    	; 0x34dc <print_err+0x12e>
    340a:	86 35       	cpi	r24, 0x56	; 86
    340c:	09 f4       	brne	.+2      	; 0x3410 <print_err+0x62>
    340e:	89 c0       	rjmp	.+274    	; 0x3522 <print_err+0x174>
    3410:	87 35       	cpi	r24, 0x57	; 87
    3412:	08 f0       	brcs	.+2      	; 0x3416 <print_err+0x68>
    3414:	8d c0       	rjmp	.+282    	; 0x3530 <print_err+0x182>
    3416:	7e c0       	rjmp	.+252    	; 0x3514 <print_err+0x166>
    3418:	8f 35       	cpi	r24, 0x5F	; 95
    341a:	09 f4       	brne	.+2      	; 0x341e <print_err+0x70>
    341c:	c1 c0       	rjmp	.+386    	; 0x35a0 <print_err+0x1f2>
    341e:	80 36       	cpi	r24, 0x60	; 96
    3420:	98 f4       	brcc	.+38     	; 0x3448 <print_err+0x9a>
    3422:	8b 35       	cpi	r24, 0x5B	; 91
    3424:	09 f4       	brne	.+2      	; 0x3428 <print_err+0x7a>
    3426:	a0 c0       	rjmp	.+320    	; 0x3568 <print_err+0x1ba>
    3428:	8c 35       	cpi	r24, 0x5C	; 92
    342a:	38 f4       	brcc	.+14     	; 0x343a <print_err+0x8c>
    342c:	89 35       	cpi	r24, 0x59	; 89
    342e:	09 f4       	brne	.+2      	; 0x3432 <print_err+0x84>
    3430:	8d c0       	rjmp	.+282    	; 0x354c <print_err+0x19e>
    3432:	8a 35       	cpi	r24, 0x5A	; 90
    3434:	09 f0       	breq	.+2      	; 0x3438 <print_err+0x8a>
    3436:	ef c0       	rjmp	.+478    	; 0x3616 <print_err+0x268>
    3438:	90 c0       	rjmp	.+288    	; 0x355a <print_err+0x1ac>
    343a:	8d 35       	cpi	r24, 0x5D	; 93
    343c:	09 f4       	brne	.+2      	; 0x3440 <print_err+0x92>
    343e:	a2 c0       	rjmp	.+324    	; 0x3584 <print_err+0x1d6>
    3440:	8e 35       	cpi	r24, 0x5E	; 94
    3442:	08 f0       	brcs	.+2      	; 0x3446 <print_err+0x98>
    3444:	a6 c0       	rjmp	.+332    	; 0x3592 <print_err+0x1e4>
    3446:	97 c0       	rjmp	.+302    	; 0x3576 <print_err+0x1c8>
    3448:	85 36       	cpi	r24, 0x65	; 101
    344a:	09 f4       	brne	.+2      	; 0x344e <print_err+0xa0>
    344c:	c5 c0       	rjmp	.+394    	; 0x35d8 <print_err+0x22a>
    344e:	86 36       	cpi	r24, 0x66	; 102
    3450:	50 f4       	brcc	.+20     	; 0x3466 <print_err+0xb8>
    3452:	83 36       	cpi	r24, 0x63	; 99
    3454:	09 f4       	brne	.+2      	; 0x3458 <print_err+0xaa>
    3456:	b2 c0       	rjmp	.+356    	; 0x35bc <print_err+0x20e>
    3458:	84 36       	cpi	r24, 0x64	; 100
    345a:	08 f0       	brcs	.+2      	; 0x345e <print_err+0xb0>
    345c:	b6 c0       	rjmp	.+364    	; 0x35ca <print_err+0x21c>
    345e:	80 36       	cpi	r24, 0x60	; 96
    3460:	09 f0       	breq	.+2      	; 0x3464 <print_err+0xb6>
    3462:	d9 c0       	rjmp	.+434    	; 0x3616 <print_err+0x268>
    3464:	a4 c0       	rjmp	.+328    	; 0x35ae <print_err+0x200>
    3466:	88 3c       	cpi	r24, 0xC8	; 200
    3468:	09 f4       	brne	.+2      	; 0x346c <print_err+0xbe>
    346a:	c4 c0       	rjmp	.+392    	; 0x35f4 <print_err+0x246>
    346c:	89 3c       	cpi	r24, 0xC9	; 201
    346e:	09 f4       	brne	.+2      	; 0x3472 <print_err+0xc4>
    3470:	ca c0       	rjmp	.+404    	; 0x3606 <print_err+0x258>
    3472:	86 36       	cpi	r24, 0x66	; 102
    3474:	09 f0       	breq	.+2      	; 0x3478 <print_err+0xca>
    3476:	cf c0       	rjmp	.+414    	; 0x3616 <print_err+0x268>
    3478:	b6 c0       	rjmp	.+364    	; 0x35e6 <print_err+0x238>
    case 1: 
      printxyd_P(0,0,(void *)err1);
    347a:	80 e0       	ldi	r24, 0x00	; 0
    347c:	90 e0       	ldi	r25, 0x00	; 0
    347e:	60 e0       	ldi	r22, 0x00	; 0
    3480:	70 e0       	ldi	r23, 0x00	; 0
    3482:	4b ea       	ldi	r20, 0xAB	; 171
    3484:	52 e0       	ldi	r21, 0x02	; 2
    3486:	bc c0       	rjmp	.+376    	; 0x3600 <print_err+0x252>
      break;
    case 4:
      printxyd_P(0,0,(void *)err4);
    3488:	80 e0       	ldi	r24, 0x00	; 0
    348a:	90 e0       	ldi	r25, 0x00	; 0
    348c:	60 e0       	ldi	r22, 0x00	; 0
    348e:	70 e0       	ldi	r23, 0x00	; 0
    3490:	44 e1       	ldi	r20, 0x14	; 20
    3492:	53 e0       	ldi	r21, 0x03	; 3
    3494:	b5 c0       	rjmp	.+362    	; 0x3600 <print_err+0x252>
      break;
    case 6:
      printxyd_P(0,0,(void *)err6);
    3496:	80 e0       	ldi	r24, 0x00	; 0
    3498:	90 e0       	ldi	r25, 0x00	; 0
    349a:	60 e0       	ldi	r22, 0x00	; 0
    349c:	70 e0       	ldi	r23, 0x00	; 0
    349e:	43 e4       	ldi	r20, 0x43	; 67
    34a0:	53 e0       	ldi	r21, 0x03	; 3
    34a2:	ae c0       	rjmp	.+348    	; 0x3600 <print_err+0x252>
      break;
    case 7:
      printxyd_P(0,0,(void *)err7);
    34a4:	80 e0       	ldi	r24, 0x00	; 0
    34a6:	90 e0       	ldi	r25, 0x00	; 0
    34a8:	60 e0       	ldi	r22, 0x00	; 0
    34aa:	70 e0       	ldi	r23, 0x00	; 0
    34ac:	43 e7       	ldi	r20, 0x73	; 115
    34ae:	53 e0       	ldi	r21, 0x03	; 3
    34b0:	a7 c0       	rjmp	.+334    	; 0x3600 <print_err+0x252>
      break;
    case 10:
      printxyd_P(0,0,(void *)err10);
    34b2:	80 e0       	ldi	r24, 0x00	; 0
    34b4:	90 e0       	ldi	r25, 0x00	; 0
    34b6:	60 e0       	ldi	r22, 0x00	; 0
    34b8:	70 e0       	ldi	r23, 0x00	; 0
    34ba:	4e eb       	ldi	r20, 0xBE	; 190
    34bc:	53 e0       	ldi	r21, 0x03	; 3
    34be:	a0 c0       	rjmp	.+320    	; 0x3600 <print_err+0x252>
      break;
    case 11:
      printxyd_P(0,0,(void *)err11);
    34c0:	80 e0       	ldi	r24, 0x00	; 0
    34c2:	90 e0       	ldi	r25, 0x00	; 0
    34c4:	60 e0       	ldi	r22, 0x00	; 0
    34c6:	70 e0       	ldi	r23, 0x00	; 0
    34c8:	40 ed       	ldi	r20, 0xD0	; 208
    34ca:	53 e0       	ldi	r21, 0x03	; 3
    34cc:	99 c0       	rjmp	.+306    	; 0x3600 <print_err+0x252>
      break;
    case 80: // lcd.c chyba LCD - p¯ekroËenÌ rozsahu displeje po od¯·dkov·nÌ
      printxyd_P(0,0,(void *)err80);
    34ce:	80 e0       	ldi	r24, 0x00	; 0
    34d0:	90 e0       	ldi	r25, 0x00	; 0
    34d2:	60 e0       	ldi	r22, 0x00	; 0
    34d4:	70 e0       	ldi	r23, 0x00	; 0
    34d6:	44 ee       	ldi	r20, 0xE4	; 228
    34d8:	53 e0       	ldi	r21, 0x03	; 3
    34da:	92 c0       	rjmp	.+292    	; 0x3600 <print_err+0x252>
      break;
    case 81: // lcd.c
      printxyd_P(0,0,(void *)err81);
    34dc:	80 e0       	ldi	r24, 0x00	; 0
    34de:	90 e0       	ldi	r25, 0x00	; 0
    34e0:	60 e0       	ldi	r22, 0x00	; 0
    34e2:	70 e0       	ldi	r23, 0x00	; 0
    34e4:	4e e1       	ldi	r20, 0x1E	; 30
    34e6:	54 e0       	ldi	r21, 0x04	; 4
    34e8:	8b c0       	rjmp	.+278    	; 0x3600 <print_err+0x252>
      break;
    case 82: // lcd.c
      printxyd_P(0,0,(void *)err82);
    34ea:	80 e0       	ldi	r24, 0x00	; 0
    34ec:	90 e0       	ldi	r25, 0x00	; 0
    34ee:	60 e0       	ldi	r22, 0x00	; 0
    34f0:	70 e0       	ldi	r23, 0x00	; 0
    34f2:	4b e4       	ldi	r20, 0x4B	; 75
    34f4:	54 e0       	ldi	r21, 0x04	; 4
    34f6:	84 c0       	rjmp	.+264    	; 0x3600 <print_err+0x252>
      break;
    case 83: // irc.c
      printxyd_P(0,0,(void *)err83);
    34f8:	80 e0       	ldi	r24, 0x00	; 0
    34fa:	90 e0       	ldi	r25, 0x00	; 0
    34fc:	60 e0       	ldi	r22, 0x00	; 0
    34fe:	70 e0       	ldi	r23, 0x00	; 0
    3500:	4a e7       	ldi	r20, 0x7A	; 122
    3502:	54 e0       	ldi	r21, 0x04	; 4
    3504:	7d c0       	rjmp	.+250    	; 0x3600 <print_err+0x252>
      break;
    case 84: // measure.c
      printxyd_P(0,0,(void *)err84);
    3506:	80 e0       	ldi	r24, 0x00	; 0
    3508:	90 e0       	ldi	r25, 0x00	; 0
    350a:	60 e0       	ldi	r22, 0x00	; 0
    350c:	70 e0       	ldi	r23, 0x00	; 0
    350e:	48 eb       	ldi	r20, 0xB8	; 184
    3510:	54 e0       	ldi	r21, 0x04	; 4
    3512:	76 c0       	rjmp	.+236    	; 0x3600 <print_err+0x252>
      break;
    case 85:
      printxyd_P(0,0,(void *)err85);
    3514:	80 e0       	ldi	r24, 0x00	; 0
    3516:	90 e0       	ldi	r25, 0x00	; 0
    3518:	60 e0       	ldi	r22, 0x00	; 0
    351a:	70 e0       	ldi	r23, 0x00	; 0
    351c:	47 ef       	ldi	r20, 0xF7	; 247
    351e:	54 e0       	ldi	r21, 0x04	; 4
    3520:	6f c0       	rjmp	.+222    	; 0x3600 <print_err+0x252>
      break;
    case 86:
      printxyd_P(0,0,(void *)err86);
    3522:	80 e0       	ldi	r24, 0x00	; 0
    3524:	90 e0       	ldi	r25, 0x00	; 0
    3526:	60 e0       	ldi	r22, 0x00	; 0
    3528:	70 e0       	ldi	r23, 0x00	; 0
    352a:	4d e5       	ldi	r20, 0x5D	; 93
    352c:	55 e0       	ldi	r21, 0x05	; 5
    352e:	68 c0       	rjmp	.+208    	; 0x3600 <print_err+0x252>
      break;
    case 87:
      printxyd_P(0,0,(void *)err87);
    3530:	80 e0       	ldi	r24, 0x00	; 0
    3532:	90 e0       	ldi	r25, 0x00	; 0
    3534:	60 e0       	ldi	r22, 0x00	; 0
    3536:	70 e0       	ldi	r23, 0x00	; 0
    3538:	47 ec       	ldi	r20, 0xC7	; 199
    353a:	55 e0       	ldi	r21, 0x05	; 5
    353c:	61 c0       	rjmp	.+194    	; 0x3600 <print_err+0x252>
      break;
    case 88:
      printxyd_P(0,0,(void *)err88);
    353e:	80 e0       	ldi	r24, 0x00	; 0
    3540:	90 e0       	ldi	r25, 0x00	; 0
    3542:	60 e0       	ldi	r22, 0x00	; 0
    3544:	70 e0       	ldi	r23, 0x00	; 0
    3546:	47 e1       	ldi	r20, 0x17	; 23
    3548:	56 e0       	ldi	r21, 0x06	; 6
    354a:	5a c0       	rjmp	.+180    	; 0x3600 <print_err+0x252>
      break;
    case 89:
      printxyd_P(0,0,(void *)err89);
    354c:	80 e0       	ldi	r24, 0x00	; 0
    354e:	90 e0       	ldi	r25, 0x00	; 0
    3550:	60 e0       	ldi	r22, 0x00	; 0
    3552:	70 e0       	ldi	r23, 0x00	; 0
    3554:	43 e3       	ldi	r20, 0x33	; 51
    3556:	56 e0       	ldi	r21, 0x06	; 6
    3558:	53 c0       	rjmp	.+166    	; 0x3600 <print_err+0x252>
      break;
    case 90:
      printxyd_P(0,0,(void *)err90);
    355a:	80 e0       	ldi	r24, 0x00	; 0
    355c:	90 e0       	ldi	r25, 0x00	; 0
    355e:	60 e0       	ldi	r22, 0x00	; 0
    3560:	70 e0       	ldi	r23, 0x00	; 0
    3562:	46 e8       	ldi	r20, 0x86	; 134
    3564:	56 e0       	ldi	r21, 0x06	; 6
    3566:	4c c0       	rjmp	.+152    	; 0x3600 <print_err+0x252>
      break;
    case 91:
      printxyd_P(0,0,(void *)err91);
    3568:	80 e0       	ldi	r24, 0x00	; 0
    356a:	90 e0       	ldi	r25, 0x00	; 0
    356c:	60 e0       	ldi	r22, 0x00	; 0
    356e:	70 e0       	ldi	r23, 0x00	; 0
    3570:	4f ed       	ldi	r20, 0xDF	; 223
    3572:	56 e0       	ldi	r21, 0x06	; 6
    3574:	45 c0       	rjmp	.+138    	; 0x3600 <print_err+0x252>
      break;
    case 92:
      printxyd_P(0,0,(void *)err92);
    3576:	80 e0       	ldi	r24, 0x00	; 0
    3578:	90 e0       	ldi	r25, 0x00	; 0
    357a:	60 e0       	ldi	r22, 0x00	; 0
    357c:	70 e0       	ldi	r23, 0x00	; 0
    357e:	47 e1       	ldi	r20, 0x17	; 23
    3580:	57 e0       	ldi	r21, 0x07	; 7
    3582:	3e c0       	rjmp	.+124    	; 0x3600 <print_err+0x252>
      break;
    case 93:
      printxyd_P(0,0,(void *)err93);
    3584:	80 e0       	ldi	r24, 0x00	; 0
    3586:	90 e0       	ldi	r25, 0x00	; 0
    3588:	60 e0       	ldi	r22, 0x00	; 0
    358a:	70 e0       	ldi	r23, 0x00	; 0
    358c:	4f e8       	ldi	r20, 0x8F	; 143
    358e:	57 e0       	ldi	r21, 0x07	; 7
    3590:	37 c0       	rjmp	.+110    	; 0x3600 <print_err+0x252>
      break;
    case 94:
      printxyd_P(0,0,(void *)err94);
    3592:	80 e0       	ldi	r24, 0x00	; 0
    3594:	90 e0       	ldi	r25, 0x00	; 0
    3596:	60 e0       	ldi	r22, 0x00	; 0
    3598:	70 e0       	ldi	r23, 0x00	; 0
    359a:	41 ef       	ldi	r20, 0xF1	; 241
    359c:	57 e0       	ldi	r21, 0x07	; 7
    359e:	30 c0       	rjmp	.+96     	; 0x3600 <print_err+0x252>
      break;
    case 95:
      printxyd_P(0,0,(void *)err95);
    35a0:	80 e0       	ldi	r24, 0x00	; 0
    35a2:	90 e0       	ldi	r25, 0x00	; 0
    35a4:	60 e0       	ldi	r22, 0x00	; 0
    35a6:	70 e0       	ldi	r23, 0x00	; 0
    35a8:	45 e2       	ldi	r20, 0x25	; 37
    35aa:	58 e0       	ldi	r21, 0x08	; 8
    35ac:	29 c0       	rjmp	.+82     	; 0x3600 <print_err+0x252>
      break;
    case 96:
      printxyd_P(0,0,(void *)err96);
    35ae:	80 e0       	ldi	r24, 0x00	; 0
    35b0:	90 e0       	ldi	r25, 0x00	; 0
    35b2:	60 e0       	ldi	r22, 0x00	; 0
    35b4:	70 e0       	ldi	r23, 0x00	; 0
    35b6:	42 ea       	ldi	r20, 0xA2	; 162
    35b8:	58 e0       	ldi	r21, 0x08	; 8
    35ba:	22 c0       	rjmp	.+68     	; 0x3600 <print_err+0x252>
      break;
    case 99:
      printxyd_P(0,0,(void *)err99);
    35bc:	80 e0       	ldi	r24, 0x00	; 0
    35be:	90 e0       	ldi	r25, 0x00	; 0
    35c0:	60 e0       	ldi	r22, 0x00	; 0
    35c2:	70 e0       	ldi	r23, 0x00	; 0
    35c4:	41 e1       	ldi	r20, 0x11	; 17
    35c6:	59 e0       	ldi	r21, 0x09	; 9
    35c8:	1b c0       	rjmp	.+54     	; 0x3600 <print_err+0x252>
      break;
    case 100:
      printxyd_P(0,0,(void *)err100);
    35ca:	80 e0       	ldi	r24, 0x00	; 0
    35cc:	90 e0       	ldi	r25, 0x00	; 0
    35ce:	60 e0       	ldi	r22, 0x00	; 0
    35d0:	70 e0       	ldi	r23, 0x00	; 0
    35d2:	42 e6       	ldi	r20, 0x62	; 98
    35d4:	59 e0       	ldi	r21, 0x09	; 9
    35d6:	14 c0       	rjmp	.+40     	; 0x3600 <print_err+0x252>
      break;
    case 101:
      printxyd_P(0,0,(void *)err101);
    35d8:	80 e0       	ldi	r24, 0x00	; 0
    35da:	90 e0       	ldi	r25, 0x00	; 0
    35dc:	60 e0       	ldi	r22, 0x00	; 0
    35de:	70 e0       	ldi	r23, 0x00	; 0
    35e0:	46 e8       	ldi	r20, 0x86	; 134
    35e2:	59 e0       	ldi	r21, 0x09	; 9
    35e4:	0d c0       	rjmp	.+26     	; 0x3600 <print_err+0x252>
      break;
    case 102:
      printxyd_P(0,0,(void *)err102);
    35e6:	80 e0       	ldi	r24, 0x00	; 0
    35e8:	90 e0       	ldi	r25, 0x00	; 0
    35ea:	60 e0       	ldi	r22, 0x00	; 0
    35ec:	70 e0       	ldi	r23, 0x00	; 0
    35ee:	4f ed       	ldi	r20, 0xDF	; 223
    35f0:	59 e0       	ldi	r21, 0x09	; 9
    35f2:	06 c0       	rjmp	.+12     	; 0x3600 <print_err+0x252>
      break;
    case 200:
      printxyd_P(0,0,(void *)err200);
    35f4:	80 e0       	ldi	r24, 0x00	; 0
    35f6:	90 e0       	ldi	r25, 0x00	; 0
    35f8:	60 e0       	ldi	r22, 0x00	; 0
    35fa:	70 e0       	ldi	r23, 0x00	; 0
    35fc:	4d e0       	ldi	r20, 0x0D	; 13
    35fe:	5a e0       	ldi	r21, 0x0A	; 10
    3600:	0e 94 47 13 	call	0x268e	; 0x268e <printxyd_P>
    3604:	08 95       	ret
      break;
    case 201:
      printxyd_P(0,0,(void *)err201);
    3606:	80 e0       	ldi	r24, 0x00	; 0
    3608:	90 e0       	ldi	r25, 0x00	; 0
    360a:	60 e0       	ldi	r22, 0x00	; 0
    360c:	70 e0       	ldi	r23, 0x00	; 0
    360e:	4a e2       	ldi	r20, 0x2A	; 42
    3610:	5a e0       	ldi	r21, 0x0A	; 10
    3612:	0e 94 47 13 	call	0x268e	; 0x268e <printxyd_P>
    3616:	08 95       	ret

00003618 <error_scr_draw>:
  }
}


void error_scr_draw(void){
  if (prev_scr == ERR_SCR){
    3618:	80 91 a6 01 	lds	r24, 0x01A6
    361c:	83 30       	cpi	r24, 0x03	; 3
    361e:	11 f4       	brne	.+4      	; 0x3624 <error_scr_draw+0xc>
    prev_scr = MSR_SCR;
    3620:	10 92 a6 01 	sts	0x01A6, r1
  }

  clear_dscreen();
    3624:	0e 94 9e 11 	call	0x233c	; 0x233c <clear_dscreen>
  //akt_scr = ERR_SCR;
  if ((last_err >= 150)&&(last_err < 200)){
    3628:	80 91 b7 00 	lds	r24, 0x00B7
    362c:	86 59       	subi	r24, 0x96	; 150
    362e:	82 33       	cpi	r24, 0x32	; 50
    3630:	a8 f4       	brcc	.+42     	; 0x365c <error_scr_draw+0x44>
    printxyd(0,0,err_str);
    3632:	40 91 a7 01 	lds	r20, 0x01A7
    3636:	50 91 a8 01 	lds	r21, 0x01A8
    363a:	80 e0       	ldi	r24, 0x00	; 0
    363c:	90 e0       	ldi	r25, 0x00	; 0
    363e:	60 e0       	ldi	r22, 0x00	; 0
    3640:	70 e0       	ldi	r23, 0x00	; 0
    3642:	0e 94 26 14 	call	0x284c	; 0x284c <printxyd>
    free((void*)err_str);
    3646:	80 91 a7 01 	lds	r24, 0x01A7
    364a:	90 91 a8 01 	lds	r25, 0x01A8
    364e:	0e 94 c6 32 	call	0x658c	; 0x658c <free>
    err_str = NULL;
    3652:	10 92 a8 01 	sts	0x01A8, r1
    3656:	10 92 a7 01 	sts	0x01A7, r1
    365a:	08 95       	ret
  }
  else{
    print_err();
    365c:	0e 94 d7 19 	call	0x33ae	; 0x33ae <print_err>
    3660:	08 95       	ret

00003662 <keyb_in_buff>:
/// - 0 : nic
/// - 1 : p¯ijat char
/// - 2 : efko, öipka
///
/// @param kod VlastnÌ kÛd kl·vesy.
void keyb_in_buff(char flag, char kod){
    3662:	28 2f       	mov	r18, r24
  int i = 0;

  if (flag == 0)
    3664:	88 23       	and	r24, r24
    3666:	21 f1       	breq	.+72     	; 0x36b0 <keyb_in_buff+0x4e>
    return;
  
  for (i = 0; i < (KEYB_BUFF_SIZE - 1); i++){
    if ((keyb_buff[i+1].flag) != 0){
    3668:	90 91 b1 01 	lds	r25, 0x01B1
    366c:	99 23       	and	r25, r25
    366e:	19 f4       	brne	.+6      	; 0x3676 <keyb_in_buff+0x14>
    3670:	e0 e0       	ldi	r30, 0x00	; 0
    3672:	f0 e0       	ldi	r31, 0x00	; 0
    3674:	17 c0       	rjmp	.+46     	; 0x36a4 <keyb_in_buff+0x42>
      keyb_buff[i] = keyb_buff[i+1];
    3676:	80 91 b2 01 	lds	r24, 0x01B2
    367a:	80 93 b0 01 	sts	0x01B0, r24
    367e:	90 93 af 01 	sts	0x01AF, r25

  if (flag == 0)
    return;
  
  for (i = 0; i < (KEYB_BUFF_SIZE - 1); i++){
    if ((keyb_buff[i+1].flag) != 0){
    3682:	90 91 b3 01 	lds	r25, 0x01B3
    3686:	99 23       	and	r25, r25
    3688:	59 f0       	breq	.+22     	; 0x36a0 <keyb_in_buff+0x3e>
      keyb_buff[i] = keyb_buff[i+1];
    368a:	80 91 b4 01 	lds	r24, 0x01B4
    368e:	80 93 b2 01 	sts	0x01B2, r24
    3692:	90 93 b1 01 	sts	0x01B1, r25
      keyb_buff[i].flag = flag;
      keyb_buff[i].kod = kod;
      return;
    }
  }
  keyb_buff[KEYB_BUFF_SIZE - 1].flag = flag;
    3696:	20 93 b3 01 	sts	0x01B3, r18
  keyb_buff[KEYB_BUFF_SIZE - 1].kod = kod;
    369a:	60 93 b4 01 	sts	0x01B4, r22
    369e:	08 95       	ret
    36a0:	e1 e0       	ldi	r30, 0x01	; 1
    36a2:	f0 e0       	ldi	r31, 0x00	; 0
  for (i = 0; i < (KEYB_BUFF_SIZE - 1); i++){
    if ((keyb_buff[i+1].flag) != 0){
      keyb_buff[i] = keyb_buff[i+1];
    }
    else{
      keyb_buff[i].flag = flag;
    36a4:	ee 0f       	add	r30, r30
    36a6:	ff 1f       	adc	r31, r31
    36a8:	e1 55       	subi	r30, 0x51	; 81
    36aa:	fe 4f       	sbci	r31, 0xFE	; 254
    36ac:	20 83       	st	Z, r18
      keyb_buff[i].kod = kod;
    36ae:	61 83       	std	Z+1, r22	; 0x01
    36b0:	08 95       	ret

000036b2 <zpracuj_kod>:
/// pracuje zbytek programu. V p¯ÌpadÏ, ûe je stisknuta kl·vesa tisknutelnÈho znaku,
/// je ËtecÌm funkcÌm poskytnuta jeho jeho ASCII hodnota. V p¯ÌpadÏ stiskutÌ kl·vesy
/// jinÈho typu je nastaven recive_flag a funkce pro ËtenÌ bÏûn˝ch znak˘ ( get_char() )
/// nic nevr·tÌ. Pro naËtenÌ kÛdu speci·lnÌ kl·vesy je nutno pouûÌt funkci get_spec().
void zpracuj_kod(char c){
  if (minuly_kod == 0){
    36b2:	90 91 ae 01 	lds	r25, 0x01AE
    36b6:	99 23       	and	r25, r25
    36b8:	09 f0       	breq	.+2      	; 0x36bc <zpracuj_kod+0xa>
    36ba:	d3 c0       	rjmp	.+422    	; 0x3862 <zpracuj_kod+0x1b0>
    switch (c){
    36bc:	90 e0       	ldi	r25, 0x00	; 0
    36be:	fc 01       	movw	r30, r24
    36c0:	31 97       	sbiw	r30, 0x01	; 1
    36c2:	e0 3f       	cpi	r30, 0xF0	; 240
    36c4:	f1 05       	cpc	r31, r1
    36c6:	08 f0       	brcs	.+2      	; 0x36ca <zpracuj_kod+0x18>
    36c8:	06 c1       	rjmp	.+524    	; 0x38d6 <zpracuj_kod+0x224>
    36ca:	e6 5d       	subi	r30, 0xD6	; 214
    36cc:	ff 4f       	sbci	r31, 0xFF	; 255
    36ce:	ee 0f       	add	r30, r30
    36d0:	ff 1f       	adc	r31, r31
    36d2:	05 90       	lpm	r0, Z+
    36d4:	f4 91       	lpm	r31, Z+
    36d6:	e0 2d       	mov	r30, r0
    36d8:	09 94       	ijmp
      break;
    case (0x4e):
      keyb_in_buff(1,'-');
      break;
    case (0x55):
      keyb_in_buff(1,'=');
    36da:	81 e0       	ldi	r24, 0x01	; 1
    36dc:	6d e3       	ldi	r22, 0x3D	; 61
    36de:	f3 c0       	rjmp	.+486    	; 0x38c6 <zpracuj_kod+0x214>
      break;
    case (0x66):  //Backspace 1
      keyb_in_buff(2,1);
    36e0:	82 e0       	ldi	r24, 0x02	; 2
    36e2:	61 e0       	ldi	r22, 0x01	; 1
    36e4:	f0 c0       	rjmp	.+480    	; 0x38c6 <zpracuj_kod+0x214>
      break;
      
    case (0x0d): //Ta 2
      keyb_in_buff(2,2);
    36e6:	82 e0       	ldi	r24, 0x02	; 2
    36e8:	62 e0       	ldi	r22, 0x02	; 2
    36ea:	ed c0       	rjmp	.+474    	; 0x38c6 <zpracuj_kod+0x214>
      break;
    case (0x15):
      keyb_in_buff(1,'Q');
    36ec:	81 e0       	ldi	r24, 0x01	; 1
    36ee:	61 e5       	ldi	r22, 0x51	; 81
    36f0:	ea c0       	rjmp	.+468    	; 0x38c6 <zpracuj_kod+0x214>
      break;
    case (0x1d):
      keyb_in_buff(1,'W');
    36f2:	81 e0       	ldi	r24, 0x01	; 1
    36f4:	67 e5       	ldi	r22, 0x57	; 87
    36f6:	e7 c0       	rjmp	.+462    	; 0x38c6 <zpracuj_kod+0x214>
      break;
    case (0x24):
      keyb_in_buff(1,'E');
    36f8:	81 e0       	ldi	r24, 0x01	; 1
    36fa:	65 e4       	ldi	r22, 0x45	; 69
    36fc:	e4 c0       	rjmp	.+456    	; 0x38c6 <zpracuj_kod+0x214>
      break;
    case (0x2d):
      keyb_in_buff(1,'R');
    36fe:	81 e0       	ldi	r24, 0x01	; 1
    3700:	62 e5       	ldi	r22, 0x52	; 82
    3702:	e1 c0       	rjmp	.+450    	; 0x38c6 <zpracuj_kod+0x214>
      break;
    case (0x2c):
      keyb_in_buff(1,'T');
    3704:	81 e0       	ldi	r24, 0x01	; 1
    3706:	64 e5       	ldi	r22, 0x54	; 84
    3708:	de c0       	rjmp	.+444    	; 0x38c6 <zpracuj_kod+0x214>
      break;
    case (0x35):
      keyb_in_buff(1,'Y');
    370a:	81 e0       	ldi	r24, 0x01	; 1
    370c:	69 e5       	ldi	r22, 0x59	; 89
    370e:	db c0       	rjmp	.+438    	; 0x38c6 <zpracuj_kod+0x214>
      break;
    case (0x3c):
      keyb_in_buff(1,'U');
    3710:	81 e0       	ldi	r24, 0x01	; 1
    3712:	65 e5       	ldi	r22, 0x55	; 85
    3714:	d8 c0       	rjmp	.+432    	; 0x38c6 <zpracuj_kod+0x214>
      break;
    case (0x43):
      keyb_in_buff(1,'I');
    3716:	81 e0       	ldi	r24, 0x01	; 1
    3718:	69 e4       	ldi	r22, 0x49	; 73
    371a:	d5 c0       	rjmp	.+426    	; 0x38c6 <zpracuj_kod+0x214>
      break;
    case (0x44):
      keyb_in_buff(1,'O');
    371c:	81 e0       	ldi	r24, 0x01	; 1
    371e:	6f e4       	ldi	r22, 0x4F	; 79
    3720:	d2 c0       	rjmp	.+420    	; 0x38c6 <zpracuj_kod+0x214>
      break;
    case (0x4d):
      keyb_in_buff(1,'P');
    3722:	81 e0       	ldi	r24, 0x01	; 1
    3724:	60 e5       	ldi	r22, 0x50	; 80
    3726:	cf c0       	rjmp	.+414    	; 0x38c6 <zpracuj_kod+0x214>
      break;
    case (0x54):
      keyb_in_buff(1,'[');
    3728:	81 e0       	ldi	r24, 0x01	; 1
    372a:	6b e5       	ldi	r22, 0x5B	; 91
    372c:	cc c0       	rjmp	.+408    	; 0x38c6 <zpracuj_kod+0x214>
      break;
    case (0x5b):
      keyb_in_buff(1,']');
    372e:	81 e0       	ldi	r24, 0x01	; 1
    3730:	6d e5       	ldi	r22, 0x5D	; 93
    3732:	c9 c0       	rjmp	.+402    	; 0x38c6 <zpracuj_kod+0x214>
      break;
    case (0x5d):
      keyb_in_buff(1,'\\');
    3734:	81 e0       	ldi	r24, 0x01	; 1
    3736:	6c e5       	ldi	r22, 0x5C	; 92
    3738:	c6 c0       	rjmp	.+396    	; 0x38c6 <zpracuj_kod+0x214>
      break;
      
    case (0x58): //Caps Lock
      keyb_in_buff(2,3);
    373a:	82 e0       	ldi	r24, 0x02	; 2
    373c:	63 e0       	ldi	r22, 0x03	; 3
    373e:	c3 c0       	rjmp	.+390    	; 0x38c6 <zpracuj_kod+0x214>
      break;
    case (0x1c):
      keyb_in_buff(1,'A');
    3740:	81 e0       	ldi	r24, 0x01	; 1
    3742:	61 e4       	ldi	r22, 0x41	; 65
    3744:	c0 c0       	rjmp	.+384    	; 0x38c6 <zpracuj_kod+0x214>
      break;
    case (0x1b):
      keyb_in_buff(1,'S');
    3746:	81 e0       	ldi	r24, 0x01	; 1
    3748:	63 e5       	ldi	r22, 0x53	; 83
    374a:	bd c0       	rjmp	.+378    	; 0x38c6 <zpracuj_kod+0x214>
      break;
    case (0x23):
      keyb_in_buff(1,'D');
    374c:	81 e0       	ldi	r24, 0x01	; 1
    374e:	64 e4       	ldi	r22, 0x44	; 68
    3750:	ba c0       	rjmp	.+372    	; 0x38c6 <zpracuj_kod+0x214>
      break;
    case (0x2b):
      keyb_in_buff(1,'F');
    3752:	81 e0       	ldi	r24, 0x01	; 1
    3754:	66 e4       	ldi	r22, 0x46	; 70
    3756:	b7 c0       	rjmp	.+366    	; 0x38c6 <zpracuj_kod+0x214>
      break;
    case (0x34):
      keyb_in_buff(1,'G');
    3758:	81 e0       	ldi	r24, 0x01	; 1
    375a:	67 e4       	ldi	r22, 0x47	; 71
    375c:	b4 c0       	rjmp	.+360    	; 0x38c6 <zpracuj_kod+0x214>
      break;
    case (0x33):
      keyb_in_buff(1,
    375e:	81 e0       	ldi	r24, 0x01	; 1
    3760:	68 e4       	ldi	r22, 0x48	; 72
    3762:	b1 c0       	rjmp	.+354    	; 0x38c6 <zpracuj_kod+0x214>
'H');
      break;
    case (0x3b):
      keyb_in_buff(1,'J');
    3764:	81 e0       	ldi	r24, 0x01	; 1
    3766:	6a e4       	ldi	r22, 0x4A	; 74
    3768:	ae c0       	rjmp	.+348    	; 0x38c6 <zpracuj_kod+0x214>
      break;
    case (0x42):
      keyb_in_buff(1,'K');
    376a:	81 e0       	ldi	r24, 0x01	; 1
    376c:	6b e4       	ldi	r22, 0x4B	; 75
    376e:	ab c0       	rjmp	.+342    	; 0x38c6 <zpracuj_kod+0x214>
      break;
    case (0x4b):
      keyb_in_buff(1,'L');
    3770:	81 e0       	ldi	r24, 0x01	; 1
    3772:	6c e4       	ldi	r22, 0x4C	; 76
    3774:	a8 c0       	rjmp	.+336    	; 0x38c6 <zpracuj_kod+0x214>
      break;
    case (0x4c):
      keyb_in_buff(1,';');
    3776:	81 e0       	ldi	r24, 0x01	; 1
    3778:	6b e3       	ldi	r22, 0x3B	; 59
    377a:	a5 c0       	rjmp	.+330    	; 0x38c6 <zpracuj_kod+0x214>
      break;
    case (0x52):
      keyb_in_buff(1,'\'');
    377c:	81 e0       	ldi	r24, 0x01	; 1
    377e:	67 e2       	ldi	r22, 0x27	; 39
    3780:	a2 c0       	rjmp	.+324    	; 0x38c6 <zpracuj_kod+0x214>
    case (0x5a): //Enter
      keyb_in_buff(2,4);
      break;
      
    case (0x1a):
      keyb_in_buff(1,'Z');
    3782:	81 e0       	ldi	r24, 0x01	; 1
    3784:	6a e5       	ldi	r22, 0x5A	; 90
    3786:	9f c0       	rjmp	.+318    	; 0x38c6 <zpracuj_kod+0x214>
      break;
    case (0x22):
      keyb_in_buff(1,'X');
    3788:	81 e0       	ldi	r24, 0x01	; 1
    378a:	68 e5       	ldi	r22, 0x58	; 88
    378c:	9c c0       	rjmp	.+312    	; 0x38c6 <zpracuj_kod+0x214>
      break;
    case (0x21):
      keyb_in_buff(1,'C');
    378e:	81 e0       	ldi	r24, 0x01	; 1
    3790:	63 e4       	ldi	r22, 0x43	; 67
    3792:	99 c0       	rjmp	.+306    	; 0x38c6 <zpracuj_kod+0x214>
      break;
    case (0x2a):
      keyb_in_buff(1,'V');
    3794:	81 e0       	ldi	r24, 0x01	; 1
    3796:	66 e5       	ldi	r22, 0x56	; 86
    3798:	96 c0       	rjmp	.+300    	; 0x38c6 <zpracuj_kod+0x214>
      break;
    case (0x32):
      keyb_in_buff(1,'B');
    379a:	81 e0       	ldi	r24, 0x01	; 1
    379c:	62 e4       	ldi	r22, 0x42	; 66
    379e:	93 c0       	rjmp	.+294    	; 0x38c6 <zpracuj_kod+0x214>
      break;
    case (0x31):
      keyb_in_buff(1,'N');
    37a0:	81 e0       	ldi	r24, 0x01	; 1
    37a2:	6e e4       	ldi	r22, 0x4E	; 78
    37a4:	90 c0       	rjmp	.+288    	; 0x38c6 <zpracuj_kod+0x214>
      break;
    case (0x3a):
      keyb_in_buff(1,'M');
    37a6:	81 e0       	ldi	r24, 0x01	; 1
    37a8:	6d e4       	ldi	r22, 0x4D	; 77
    37aa:	8d c0       	rjmp	.+282    	; 0x38c6 <zpracuj_kod+0x214>
      break;
    case (0x41):
      keyb_in_buff(1,',');
    37ac:	81 e0       	ldi	r24, 0x01	; 1
    37ae:	6c e2       	ldi	r22, 0x2C	; 44
    37b0:	8a c0       	rjmp	.+276    	; 0x38c6 <zpracuj_kod+0x214>
    case (0x4a):
      keyb_in_buff(1,'/');
      break;
      
    case (0x29):
      keyb_in_buff(1,' ');
    37b2:	81 e0       	ldi	r24, 0x01	; 1
    37b4:	60 e2       	ldi	r22, 0x20	; 32
    37b6:	87 c0       	rjmp	.+270    	; 0x38c6 <zpracuj_kod+0x214>
      break;
      
    case (0x76): //Esc
      keyb_in_buff(2,5);
    37b8:	82 e0       	ldi	r24, 0x02	; 2
    37ba:	65 e0       	ldi	r22, 0x05	; 5
    37bc:	84 c0       	rjmp	.+264    	; 0x38c6 <zpracuj_kod+0x214>
      break;
      
    case 0x70: // 0_num
      keyb_in_buff(1,'0');
    37be:	81 e0       	ldi	r24, 0x01	; 1
    37c0:	60 e3       	ldi	r22, 0x30	; 48
    37c2:	81 c0       	rjmp	.+258    	; 0x38c6 <zpracuj_kod+0x214>
      break;
    case 0x69: // 1_num
      keyb_in_buff(1,'1');
    37c4:	81 e0       	ldi	r24, 0x01	; 1
    37c6:	61 e3       	ldi	r22, 0x31	; 49
    37c8:	7e c0       	rjmp	.+252    	; 0x38c6 <zpracuj_kod+0x214>
      break;
    case 0x72: // 2_num
      keyb_in_buff(1,'2');
    37ca:	81 e0       	ldi	r24, 0x01	; 1
    37cc:	62 e3       	ldi	r22, 0x32	; 50
    37ce:	7b c0       	rjmp	.+246    	; 0x38c6 <zpracuj_kod+0x214>
      break;
    case 0x7A: // 3_num
      keyb_in_buff(1,'3');
    37d0:	81 e0       	ldi	r24, 0x01	; 1
    37d2:	63 e3       	ldi	r22, 0x33	; 51
    37d4:	78 c0       	rjmp	.+240    	; 0x38c6 <zpracuj_kod+0x214>
      break;
    case 0x6B: // 4_num
      keyb_in_buff(1,'4');
    37d6:	81 e0       	ldi	r24, 0x01	; 1
    37d8:	64 e3       	ldi	r22, 0x34	; 52
    37da:	75 c0       	rjmp	.+234    	; 0x38c6 <zpracuj_kod+0x214>
      break;
    case 0x73: // 5_num
      keyb_in_buff(1,'5');
    37dc:	81 e0       	ldi	r24, 0x01	; 1
    37de:	65 e3       	ldi	r22, 0x35	; 53
    37e0:	72 c0       	rjmp	.+228    	; 0x38c6 <zpracuj_kod+0x214>
      break;
    case 0x74: // 6_num
      keyb_in_buff(1,'6');
    37e2:	81 e0       	ldi	r24, 0x01	; 1
    37e4:	66 e3       	ldi	r22, 0x36	; 54
    37e6:	6f c0       	rjmp	.+222    	; 0x38c6 <zpracuj_kod+0x214>
      break;
    case 0x6C: // 7_num
      keyb_in_buff(1,'7');
    37e8:	81 e0       	ldi	r24, 0x01	; 1
    37ea:	67 e3       	ldi	r22, 0x37	; 55
    37ec:	6c c0       	rjmp	.+216    	; 0x38c6 <zpracuj_kod+0x214>
      break;
    case 0x75: // 8_num
      keyb_in_buff(1,'8');
    37ee:	81 e0       	ldi	r24, 0x01	; 1
    37f0:	68 e3       	ldi	r22, 0x38	; 56
    37f2:	69 c0       	rjmp	.+210    	; 0x38c6 <zpracuj_kod+0x214>
      break;
    case 0x7D: // 9_num
      keyb_in_buff(1,'9');
    37f4:	81 e0       	ldi	r24, 0x01	; 1
    37f6:	69 e3       	ldi	r22, 0x39	; 57
    37f8:	66 c0       	rjmp	.+204    	; 0x38c6 <zpracuj_kod+0x214>
      break;
    case 0x7B: // -_num
      keyb_in_buff(1,'-');
    37fa:	81 e0       	ldi	r24, 0x01	; 1
    37fc:	6d e2       	ldi	r22, 0x2D	; 45
    37fe:	63 c0       	rjmp	.+198    	; 0x38c6 <zpracuj_kod+0x214>
      break;
    case 0x71: // ._num
      keyb_in_buff(1,'.');
    3800:	81 e0       	ldi	r24, 0x01	; 1
    3802:	6e e2       	ldi	r22, 0x2E	; 46
    3804:	60 c0       	rjmp	.+192    	; 0x38c6 <zpracuj_kod+0x214>
      break;
    case 0x7C: // *_num
      keyb_in_buff(1,'*');
    3806:	81 e0       	ldi	r24, 0x01	; 1
    3808:	6a e2       	ldi	r22, 0x2A	; 42
    380a:	5d c0       	rjmp	.+186    	; 0x38c6 <zpracuj_kod+0x214>
      break;
    case 0x79: // +_num
      keyb_in_buff(1,'+');
    380c:	81 e0       	ldi	r24, 0x01	; 1
    380e:	6b e2       	ldi	r22, 0x2B	; 43
    3810:	5a c0       	rjmp	.+180    	; 0x38c6 <zpracuj_kod+0x214>
      break;


      
    case (0x05): //F1
      keyb_in_buff(2,11);
    3812:	82 e0       	ldi	r24, 0x02	; 2
    3814:	6b e0       	ldi	r22, 0x0B	; 11
    3816:	57 c0       	rjmp	.+174    	; 0x38c6 <zpracuj_kod+0x214>
      break;
    case (0x06): //F2
      keyb_in_buff(2,12);
    3818:	82 e0       	ldi	r24, 0x02	; 2
    381a:	6c e0       	ldi	r22, 0x0C	; 12
    381c:	54 c0       	rjmp	.+168    	; 0x38c6 <zpracuj_kod+0x214>
      break;
    case (0x04): //F3
      keyb_in_buff(2,13);
    381e:	82 e0       	ldi	r24, 0x02	; 2
    3820:	6d e0       	ldi	r22, 0x0D	; 13
    3822:	51 c0       	rjmp	.+162    	; 0x38c6 <zpracuj_kod+0x214>
      break;
    case (0x0c): //F4
      keyb_in_buff(2,14);
    3824:	82 e0       	ldi	r24, 0x02	; 2
    3826:	6e e0       	ldi	r22, 0x0E	; 14
    3828:	4e c0       	rjmp	.+156    	; 0x38c6 <zpracuj_kod+0x214>
      break;
    case (0x03): //F5
      keyb_in_buff(2,15);
    382a:	82 e0       	ldi	r24, 0x02	; 2
    382c:	6f e0       	ldi	r22, 0x0F	; 15
    382e:	4b c0       	rjmp	.+150    	; 0x38c6 <zpracuj_kod+0x214>
      break;
    case (0x0b): //F6
      keyb_in_buff(2,16);
    3830:	82 e0       	ldi	r24, 0x02	; 2
    3832:	60 e1       	ldi	r22, 0x10	; 16
    3834:	48 c0       	rjmp	.+144    	; 0x38c6 <zpracuj_kod+0x214>
      break;
    case (0x83): //F7
      keyb_in_buff(2,17);
    3836:	82 e0       	ldi	r24, 0x02	; 2
    3838:	61 e1       	ldi	r22, 0x11	; 17
    383a:	45 c0       	rjmp	.+138    	; 0x38c6 <zpracuj_kod+0x214>
      break;
    case (0x0a): //F8
      keyb_in_buff(2,18);
    383c:	82 e0       	ldi	r24, 0x02	; 2
    383e:	62 e1       	ldi	r22, 0x12	; 18
    3840:	42 c0       	rjmp	.+132    	; 0x38c6 <zpracuj_kod+0x214>
      break;
    case (0x01): //F9
      keyb_in_buff(2,19);
    3842:	82 e0       	ldi	r24, 0x02	; 2
    3844:	63 e1       	ldi	r22, 0x13	; 19
    3846:	3f c0       	rjmp	.+126    	; 0x38c6 <zpracuj_kod+0x214>
      break;
    case (0x09): //F10
      keyb_in_buff(2,20);
    3848:	82 e0       	ldi	r24, 0x02	; 2
    384a:	64 e1       	ldi	r22, 0x14	; 20
    384c:	3c c0       	rjmp	.+120    	; 0x38c6 <zpracuj_kod+0x214>
      break;
    case (0x78): //F11
      keyb_in_buff(2,21);
    384e:	82 e0       	ldi	r24, 0x02	; 2
    3850:	65 e1       	ldi	r22, 0x15	; 21
    3852:	39 c0       	rjmp	.+114    	; 0x38c6 <zpracuj_kod+0x214>
      break;
    case (0x07): //F12
      keyb_in_buff(2,22);
    3854:	82 e0       	ldi	r24, 0x02	; 2
    3856:	66 e1       	ldi	r22, 0x16	; 22
    3858:	36 c0       	rjmp	.+108    	; 0x38c6 <zpracuj_kod+0x214>
      break;
    case (0xe0):
      minuly_kod = 0xe0;
    385a:	80 ee       	ldi	r24, 0xE0	; 224
    385c:	37 c0       	rjmp	.+110    	; 0x38cc <zpracuj_kod+0x21a>
      break;
      
    case (0xf0):
      minuly_kod = 0xf0;
    385e:	80 ef       	ldi	r24, 0xF0	; 240
    3860:	35 c0       	rjmp	.+106    	; 0x38cc <zpracuj_kod+0x21a>
      //rec_buf = 0;
      break;
      
    }
  }
  else if (minuly_kod == 0xe0){
    3862:	90 3e       	cpi	r25, 0xE0	; 224
    3864:	b1 f5       	brne	.+108    	; 0x38d2 <zpracuj_kod+0x220>
    switch (c){
    3866:	82 37       	cpi	r24, 0x72	; 114
    3868:	01 f1       	breq	.+64     	; 0x38aa <zpracuj_kod+0x1f8>
    386a:	83 37       	cpi	r24, 0x73	; 115
    386c:	60 f4       	brcc	.+24     	; 0x3886 <zpracuj_kod+0x1d4>
    386e:	8a 35       	cpi	r24, 0x5A	; 90
    3870:	29 f1       	breq	.+74     	; 0x38bc <zpracuj_kod+0x20a>
    3872:	8b 35       	cpi	r24, 0x5B	; 91
    3874:	18 f4       	brcc	.+6      	; 0x387c <zpracuj_kod+0x1ca>
    3876:	8a 34       	cpi	r24, 0x4A	; 74
    3878:	71 f5       	brne	.+92     	; 0x38d6 <zpracuj_kod+0x224>
    387a:	23 c0       	rjmp	.+70     	; 0x38c2 <zpracuj_kod+0x210>
    387c:	8b 36       	cpi	r24, 0x6B	; 107
    387e:	c1 f0       	breq	.+48     	; 0x38b0 <zpracuj_kod+0x1fe>
    3880:	81 37       	cpi	r24, 0x71	; 113
    3882:	49 f5       	brne	.+82     	; 0x38d6 <zpracuj_kod+0x224>
    3884:	0c c0       	rjmp	.+24     	; 0x389e <zpracuj_kod+0x1ec>
    3886:	85 37       	cpi	r24, 0x75	; 117
    3888:	69 f0       	breq	.+26     	; 0x38a4 <zpracuj_kod+0x1f2>
    388a:	86 37       	cpi	r24, 0x76	; 118
    388c:	18 f4       	brcc	.+6      	; 0x3894 <zpracuj_kod+0x1e2>
    388e:	84 37       	cpi	r24, 0x74	; 116
    3890:	11 f5       	brne	.+68     	; 0x38d6 <zpracuj_kod+0x224>
    3892:	11 c0       	rjmp	.+34     	; 0x38b6 <zpracuj_kod+0x204>
    3894:	80 3e       	cpi	r24, 0xE0	; 224
    3896:	d1 f0       	breq	.+52     	; 0x38cc <zpracuj_kod+0x21a>
    3898:	80 3f       	cpi	r24, 0xF0	; 240
    389a:	e9 f4       	brne	.+58     	; 0x38d6 <zpracuj_kod+0x224>
    389c:	17 c0       	rjmp	.+46     	; 0x38cc <zpracuj_kod+0x21a>
    case 0x71: //Del
      keyb_in_buff(2,6);
    389e:	82 e0       	ldi	r24, 0x02	; 2
    38a0:	66 e0       	ldi	r22, 0x06	; 6
    38a2:	11 c0       	rjmp	.+34     	; 0x38c6 <zpracuj_kod+0x214>
      break;
    case 0x75: // Up
      keyb_in_buff(2,7);
    38a4:	82 e0       	ldi	r24, 0x02	; 2
    38a6:	67 e0       	ldi	r22, 0x07	; 7
    38a8:	0e c0       	rjmp	.+28     	; 0x38c6 <zpracuj_kod+0x214>
      break;
    case 0x72: // Down
      keyb_in_buff(2,8);
    38aa:	82 e0       	ldi	r24, 0x02	; 2
    38ac:	68 e0       	ldi	r22, 0x08	; 8
    38ae:	0b c0       	rjmp	.+22     	; 0x38c6 <zpracuj_kod+0x214>
      break;
    case 0x6B: // Left
      keyb_in_buff(2,9);
    38b0:	82 e0       	ldi	r24, 0x02	; 2
    38b2:	69 e0       	ldi	r22, 0x09	; 9
    38b4:	08 c0       	rjmp	.+16     	; 0x38c6 <zpracuj_kod+0x214>
      break;
    case 0x74: // Right
      keyb_in_buff(2,10);
    38b6:	82 e0       	ldi	r24, 0x02	; 2
    38b8:	6a e0       	ldi	r22, 0x0A	; 10
    38ba:	05 c0       	rjmp	.+10     	; 0x38c6 <zpracuj_kod+0x214>
      break;
    case 0x5A: // Enter_num
      keyb_in_buff(2,4);
    38bc:	82 e0       	ldi	r24, 0x02	; 2
    38be:	64 e0       	ldi	r22, 0x04	; 4
    38c0:	02 c0       	rjmp	.+4      	; 0x38c6 <zpracuj_kod+0x214>
      break;
    case 0x4A: // /_num
      keyb_in_buff(1,'/');
    38c2:	81 e0       	ldi	r24, 0x01	; 1
    38c4:	6f e2       	ldi	r22, 0x2F	; 47
    38c6:	0e 94 31 1b 	call	0x3662	; 0x3662 <keyb_in_buff>
    38ca:	08 95       	ret
      break;
    case 0xF0:
      minuly_kod = 0xF0;
      break;
    case 0xE0:
      minuly_kod = 0xE0;
    38cc:	80 93 ae 01 	sts	0x01AE, r24
    38d0:	08 95       	ret
  else if (minuly_kod == 0xF0 ){
    // napriklad pri pusteni sipky
    minuly_kod = 0;
  }
  else{
    minuly_kod = 0;
    38d2:	10 92 ae 01 	sts	0x01AE, r1
    38d6:	08 95       	ret

000038d8 <__vector_2>:
    




SIGNAL(SIG_INTERRUPT1){
    38d8:	1f 92       	push	r1
    38da:	0f 92       	push	r0
    38dc:	0f b6       	in	r0, 0x3f	; 63
    38de:	0f 92       	push	r0
    38e0:	11 24       	eor	r1, r1
    38e2:	2f 93       	push	r18
    38e4:	3f 93       	push	r19
    38e6:	4f 93       	push	r20
    38e8:	5f 93       	push	r21
    38ea:	6f 93       	push	r22
    38ec:	7f 93       	push	r23
    38ee:	8f 93       	push	r24
    38f0:	9f 93       	push	r25
    38f2:	af 93       	push	r26
    38f4:	bf 93       	push	r27
    38f6:	ef 93       	push	r30
    38f8:	ff 93       	push	r31

  keyb_recv_watchdog = 0;  // 
    38fa:	10 92 ab 01 	sts	0x01AB, r1
    38fe:	10 92 aa 01 	sts	0x01AA, r1
  
  if ((data_counter > 0)&&(data_counter < 9)){
    3902:	20 91 ac 01 	lds	r18, 0x01AC
    3906:	82 2f       	mov	r24, r18
    3908:	81 50       	subi	r24, 0x01	; 1
    390a:	88 30       	cpi	r24, 0x08	; 8
    390c:	a0 f4       	brcc	.+40     	; 0x3936 <__vector_2+0x5e>
    recivedc |= ((PINC & 1) << (data_counter - 1));
    390e:	83 b3       	in	r24, 0x13	; 19
    3910:	90 e0       	ldi	r25, 0x00	; 0
    3912:	81 70       	andi	r24, 0x01	; 1
    3914:	90 70       	andi	r25, 0x00	; 0
    3916:	33 27       	eor	r19, r19
    3918:	27 fd       	sbrc	r18, 7
    391a:	30 95       	com	r19
    391c:	21 50       	subi	r18, 0x01	; 1
    391e:	30 40       	sbci	r19, 0x00	; 0
    3920:	02 c0       	rjmp	.+4      	; 0x3926 <__vector_2+0x4e>
    3922:	88 0f       	add	r24, r24
    3924:	99 1f       	adc	r25, r25
    3926:	2a 95       	dec	r18
    3928:	e2 f7       	brpl	.-8      	; 0x3922 <__vector_2+0x4a>
    392a:	20 91 ad 01 	lds	r18, 0x01AD
    392e:	28 2b       	or	r18, r24
    3930:	20 93 ad 01 	sts	0x01AD, r18
    3934:	0b c0       	rjmp	.+22     	; 0x394c <__vector_2+0x74>
  }
  else if(data_counter == 10) {
    3936:	2a 30       	cpi	r18, 0x0A	; 10
    3938:	49 f4       	brne	.+18     	; 0x394c <__vector_2+0x74>
    data_counter = -1;
    393a:	8f ef       	ldi	r24, 0xFF	; 255
    393c:	80 93 ac 01 	sts	0x01AC, r24
    //printxy(default_screen, 0,0,s);
    //printxy(default_screen, 0,2, int2string("   ",recivedc));
    zpracuj_kod(recivedc);
    3940:	80 91 ad 01 	lds	r24, 0x01AD
    3944:	0e 94 59 1b 	call	0x36b2	; 0x36b2 <zpracuj_kod>
    recivedc = 0;
    3948:	10 92 ad 01 	sts	0x01AD, r1
  }
  //printxy(default_screen, 0,2, int2string("    ",data_counter));
  data_counter++;
    394c:	80 91 ac 01 	lds	r24, 0x01AC
    3950:	8f 5f       	subi	r24, 0xFF	; 255
    3952:	80 93 ac 01 	sts	0x01AC, r24
}
    3956:	ff 91       	pop	r31
    3958:	ef 91       	pop	r30
    395a:	bf 91       	pop	r27
    395c:	af 91       	pop	r26
    395e:	9f 91       	pop	r25
    3960:	8f 91       	pop	r24
    3962:	7f 91       	pop	r23
    3964:	6f 91       	pop	r22
    3966:	5f 91       	pop	r21
    3968:	4f 91       	pop	r20
    396a:	3f 91       	pop	r19
    396c:	2f 91       	pop	r18
    396e:	0f 90       	pop	r0
    3970:	0f be       	out	0x3f, r0	; 63
    3972:	0f 90       	pop	r0
    3974:	1f 90       	pop	r1
    3976:	18 95       	reti

00003978 <get_char>:
  
}
//TODO
/// Funkce vr·tÌ poslednÌ p¯ijat˝ znak .
char get_char(void){
  if (keyb_buff[0].flag == 1){
    3978:	80 91 af 01 	lds	r24, 0x01AF
    397c:	81 30       	cpi	r24, 0x01	; 1
    397e:	11 f0       	breq	.+4      	; 0x3984 <get_char+0xc>
    3980:	20 e0       	ldi	r18, 0x00	; 0
    3982:	2e c0       	rjmp	.+92     	; 0x39e0 <get_char+0x68>
static KEY get_key_from_buff(void){
  int i = 0;
  KEY out;

  out.flag = keyb_buff[0].flag;
  out.kod = keyb_buff[0].kod;
    3984:	20 91 b0 01 	lds	r18, 0x01B0
  if (keyb_buff[0].flag == 0)
    return out;

  for(i = 0; i < (KEYB_BUFF_SIZE - 1); i++){
    if (keyb_buff[i+1].flag != 0){
    3988:	90 91 b1 01 	lds	r25, 0x01B1
    398c:	99 23       	and	r25, r25
    398e:	29 f4       	brne	.+10     	; 0x399a <get_char+0x22>
    3990:	a1 e0       	ldi	r26, 0x01	; 1
    3992:	b0 e0       	ldi	r27, 0x00	; 0
    3994:	e0 e0       	ldi	r30, 0x00	; 0
    3996:	f0 e0       	ldi	r31, 0x00	; 0
    3998:	17 c0       	rjmp	.+46     	; 0x39c8 <get_char+0x50>
      keyb_buff[i] = keyb_buff[i+1];
    399a:	80 91 b2 01 	lds	r24, 0x01B2
    399e:	80 93 b0 01 	sts	0x01B0, r24
    39a2:	90 93 af 01 	sts	0x01AF, r25
  out.kod = keyb_buff[0].kod;
  if (keyb_buff[0].flag == 0)
    return out;

  for(i = 0; i < (KEYB_BUFF_SIZE - 1); i++){
    if (keyb_buff[i+1].flag != 0){
    39a6:	90 91 b3 01 	lds	r25, 0x01B3
    39aa:	99 23       	and	r25, r25
    39ac:	49 f0       	breq	.+18     	; 0x39c0 <get_char+0x48>
      keyb_buff[i] = keyb_buff[i+1];
    39ae:	80 91 b4 01 	lds	r24, 0x01B4
    39b2:	80 93 b2 01 	sts	0x01B2, r24
    39b6:	90 93 b1 01 	sts	0x01B1, r25
    else{
      keyb_buff[i] = keyb_buff[i+1];
      return out;
    }
  }
  keyb_buff[KEYB_BUFF_SIZE - 1].flag = 0;
    39ba:	10 92 b3 01 	sts	0x01B3, r1
    39be:	10 c0       	rjmp	.+32     	; 0x39e0 <get_char+0x68>
    39c0:	a2 e0       	ldi	r26, 0x02	; 2
    39c2:	b0 e0       	ldi	r27, 0x00	; 0
    39c4:	e1 e0       	ldi	r30, 0x01	; 1
    39c6:	f0 e0       	ldi	r31, 0x00	; 0
  for(i = 0; i < (KEYB_BUFF_SIZE - 1); i++){
    if (keyb_buff[i+1].flag != 0){
      keyb_buff[i] = keyb_buff[i+1];
    }
    else{
      keyb_buff[i] = keyb_buff[i+1];
    39c8:	ee 0f       	add	r30, r30
    39ca:	ff 1f       	adc	r31, r31
    39cc:	e1 55       	subi	r30, 0x51	; 81
    39ce:	fe 4f       	sbci	r31, 0xFE	; 254
    39d0:	aa 0f       	add	r26, r26
    39d2:	bb 1f       	adc	r27, r27
    39d4:	a1 55       	subi	r26, 0x51	; 81
    39d6:	be 4f       	sbci	r27, 0xFE	; 254
    39d8:	11 96       	adiw	r26, 0x01	; 1
    39da:	8c 91       	ld	r24, X
    39dc:	81 83       	std	Z+1, r24	; 0x01
    39de:	10 82       	st	Z, r1
  if (keyb_buff[0].flag == 1){
    return get_key_from_buff().kod;
  }
  else
    return 0;
}
    39e0:	82 2f       	mov	r24, r18
    39e2:	08 95       	ret

000039e4 <get_spec>:

/// Funkce vr·tÌ poslednÌ p¯ijat˝ stisk speci·lnÌ kl·vesy.
char get_spec(void){
  if (keyb_buff[0].flag == 2){
    39e4:	80 91 af 01 	lds	r24, 0x01AF
    39e8:	82 30       	cpi	r24, 0x02	; 2
    39ea:	11 f0       	breq	.+4      	; 0x39f0 <get_spec+0xc>
    39ec:	20 e0       	ldi	r18, 0x00	; 0
    39ee:	2e c0       	rjmp	.+92     	; 0x3a4c <get_spec+0x68>
static KEY get_key_from_buff(void){
  int i = 0;
  KEY out;

  out.flag = keyb_buff[0].flag;
  out.kod = keyb_buff[0].kod;
    39f0:	20 91 b0 01 	lds	r18, 0x01B0
  if (keyb_buff[0].flag == 0)
    return out;

  for(i = 0; i < (KEYB_BUFF_SIZE - 1); i++){
    if (keyb_buff[i+1].flag != 0){
    39f4:	90 91 b1 01 	lds	r25, 0x01B1
    39f8:	99 23       	and	r25, r25
    39fa:	29 f4       	brne	.+10     	; 0x3a06 <get_spec+0x22>
    39fc:	a1 e0       	ldi	r26, 0x01	; 1
    39fe:	b0 e0       	ldi	r27, 0x00	; 0
    3a00:	e0 e0       	ldi	r30, 0x00	; 0
    3a02:	f0 e0       	ldi	r31, 0x00	; 0
    3a04:	17 c0       	rjmp	.+46     	; 0x3a34 <get_spec+0x50>
      keyb_buff[i] = keyb_buff[i+1];
    3a06:	80 91 b2 01 	lds	r24, 0x01B2
    3a0a:	80 93 b0 01 	sts	0x01B0, r24
    3a0e:	90 93 af 01 	sts	0x01AF, r25
  out.kod = keyb_buff[0].kod;
  if (keyb_buff[0].flag == 0)
    return out;

  for(i = 0; i < (KEYB_BUFF_SIZE - 1); i++){
    if (keyb_buff[i+1].flag != 0){
    3a12:	90 91 b3 01 	lds	r25, 0x01B3
    3a16:	99 23       	and	r25, r25
    3a18:	49 f0       	breq	.+18     	; 0x3a2c <get_spec+0x48>
      keyb_buff[i] = keyb_buff[i+1];
    3a1a:	80 91 b4 01 	lds	r24, 0x01B4
    3a1e:	80 93 b2 01 	sts	0x01B2, r24
    3a22:	90 93 b1 01 	sts	0x01B1, r25
    else{
      keyb_buff[i] = keyb_buff[i+1];
      return out;
    }
  }
  keyb_buff[KEYB_BUFF_SIZE - 1].flag = 0;
    3a26:	10 92 b3 01 	sts	0x01B3, r1
    3a2a:	10 c0       	rjmp	.+32     	; 0x3a4c <get_spec+0x68>
    3a2c:	a2 e0       	ldi	r26, 0x02	; 2
    3a2e:	b0 e0       	ldi	r27, 0x00	; 0
    3a30:	e1 e0       	ldi	r30, 0x01	; 1
    3a32:	f0 e0       	ldi	r31, 0x00	; 0
  for(i = 0; i < (KEYB_BUFF_SIZE - 1); i++){
    if (keyb_buff[i+1].flag != 0){
      keyb_buff[i] = keyb_buff[i+1];
    }
    else{
      keyb_buff[i] = keyb_buff[i+1];
    3a34:	ee 0f       	add	r30, r30
    3a36:	ff 1f       	adc	r31, r31
    3a38:	e1 55       	subi	r30, 0x51	; 81
    3a3a:	fe 4f       	sbci	r31, 0xFE	; 254
    3a3c:	aa 0f       	add	r26, r26
    3a3e:	bb 1f       	adc	r27, r27
    3a40:	a1 55       	subi	r26, 0x51	; 81
    3a42:	be 4f       	sbci	r27, 0xFE	; 254
    3a44:	11 96       	adiw	r26, 0x01	; 1
    3a46:	8c 91       	ld	r24, X
    3a48:	81 83       	std	Z+1, r24	; 0x01
    3a4a:	10 82       	st	Z, r1
  if (keyb_buff[0].flag == 2){
    return get_key_from_buff().kod;
  }
  else
    return 0;
}
    3a4c:	82 2f       	mov	r24, r18
    3a4e:	08 95       	ret

00003a50 <keyboard_init>:

void keyboard_init(void){
  MCUCR |= (1 << ISC11)|(0 << ISC10); // nastavenÌ p¯eruöenÌ se sestupnou hranou
    3a50:	85 b7       	in	r24, 0x35	; 53
    3a52:	88 60       	ori	r24, 0x08	; 8
    3a54:	85 bf       	out	0x35, r24	; 53
  GICR |= (1 << INT1);
    3a56:	8b b7       	in	r24, 0x3b	; 59
    3a58:	80 68       	ori	r24, 0x80	; 128
    3a5a:	8b bf       	out	0x3b, r24	; 59
  
  // nastavenÌ pull-up odporu na DATA pinu
  PORTC |= 1;
    3a5c:	a8 9a       	sbi	0x15, 0	; 21

  //nastavenÌ pull-up na CLK
  PORTD |= (1 << 3);
    3a5e:	93 9a       	sbi	0x12, 3	; 18
}
    3a60:	08 95       	ret

00003a62 <keyboard_recv_watchdog>:
/// p¯eruöÌ p¯Ìjem poslednÌho sign·lu a nastavÌ data_counter na nulu pouûÌv· se k
/// ¯eöenÌ problÈmu s s nespr·vn˝m p¯ijetÌm zpr·vy a n·sledn˝m posunutÌm p¯ijmu
/// funkce p¯ijme t¯eba jen polovinu bit˘, ale nevÌ ûe uû je konec vysÌl·nÌ a kdyû 
/// dorazÌ prvnÌ polovina dalöÌho kÛdu, zapÌöe je jako druhou Ë·st p¯edchozÌho.
void keyboard_recv_watchdog(void){
  if (keyb_recv_watchdog > KEYB_RECV_WATCH_N ){
    3a62:	80 91 aa 01 	lds	r24, 0x01AA
    3a66:	90 91 ab 01 	lds	r25, 0x01AB
    3a6a:	23 e0       	ldi	r18, 0x03	; 3
    3a6c:	89 3e       	cpi	r24, 0xE9	; 233
    3a6e:	92 07       	cpc	r25, r18
    3a70:	28 f0       	brcs	.+10     	; 0x3a7c <keyboard_recv_watchdog+0x1a>
    data_counter = 0;
    3a72:	10 92 ac 01 	sts	0x01AC, r1
    recivedc = 0;
    3a76:	10 92 ad 01 	sts	0x01AD, r1
    3a7a:	08 95       	ret
  }
  else
    keyb_recv_watchdog++;
    3a7c:	01 96       	adiw	r24, 0x01	; 1
    3a7e:	90 93 ab 01 	sts	0x01AB, r25
    3a82:	80 93 aa 01 	sts	0x01AA, r24
    3a86:	08 95       	ret

00003a88 <menu_prev_item>:
}

/**
 * Funkce posune kurzor na dalöÌ poloûku menu.
 */
char menu_prev_item(MENU_ITEM *menu[], char i, char max_i){
    3a88:	ff 92       	push	r15
    3a8a:	0f 93       	push	r16
    3a8c:	1f 93       	push	r17
    3a8e:	cf 93       	push	r28
    3a90:	df 93       	push	r29
    3a92:	8c 01       	movw	r16, r24
    3a94:	f4 2e       	mov	r15, r20
  int ii = (int) i;
    3a96:	c6 2f       	mov	r28, r22
    3a98:	d0 e0       	ldi	r29, 0x00	; 0
  int max_ii = (int) max_i;

  printcxyd(menu[ii] -> y, ((menu[ii] -> x) - 1), ' ' );
    3a9a:	fe 01       	movw	r30, r28
    3a9c:	ee 0f       	add	r30, r30
    3a9e:	ff 1f       	adc	r31, r31
    3aa0:	e0 0f       	add	r30, r16
    3aa2:	f1 1f       	adc	r31, r17
    3aa4:	01 90       	ld	r0, Z+
    3aa6:	f0 81       	ld	r31, Z
    3aa8:	e0 2d       	mov	r30, r0
    3aaa:	60 81       	ld	r22, Z
    3aac:	70 e0       	ldi	r23, 0x00	; 0
    3aae:	61 50       	subi	r22, 0x01	; 1
    3ab0:	70 40       	sbci	r23, 0x00	; 0
    3ab2:	81 81       	ldd	r24, Z+1	; 0x01
    3ab4:	90 e0       	ldi	r25, 0x00	; 0
    3ab6:	40 e2       	ldi	r20, 0x20	; 32
    3ab8:	0e 94 fc 11 	call	0x23f8	; 0x23f8 <printcxyd>

  if (ii > 0){
    3abc:	20 97       	sbiw	r28, 0x00	; 0
    3abe:	11 f4       	brne	.+4      	; 0x3ac4 <menu_prev_item+0x3c>
    ii--;
  }
  else{
    ii = max_ii - 1;
    3ac0:	cf 2d       	mov	r28, r15
    3ac2:	d0 e0       	ldi	r29, 0x00	; 0
    3ac4:	21 97       	sbiw	r28, 0x01	; 1
  }
  printcxyd(menu[ii] ->y, ((menu[ii] -> x) - 1), 255 );
    3ac6:	fe 01       	movw	r30, r28
    3ac8:	ee 0f       	add	r30, r30
    3aca:	ff 1f       	adc	r31, r31
    3acc:	e0 0f       	add	r30, r16
    3ace:	f1 1f       	adc	r31, r17
    3ad0:	01 90       	ld	r0, Z+
    3ad2:	f0 81       	ld	r31, Z
    3ad4:	e0 2d       	mov	r30, r0
    3ad6:	60 81       	ld	r22, Z
    3ad8:	70 e0       	ldi	r23, 0x00	; 0
    3ada:	61 50       	subi	r22, 0x01	; 1
    3adc:	70 40       	sbci	r23, 0x00	; 0
    3ade:	81 81       	ldd	r24, Z+1	; 0x01
    3ae0:	90 e0       	ldi	r25, 0x00	; 0
    3ae2:	4f ef       	ldi	r20, 0xFF	; 255
    3ae4:	0e 94 fc 11 	call	0x23f8	; 0x23f8 <printcxyd>

  return (char) ii;
}
    3ae8:	8c 2f       	mov	r24, r28
    3aea:	df 91       	pop	r29
    3aec:	cf 91       	pop	r28
    3aee:	1f 91       	pop	r17
    3af0:	0f 91       	pop	r16
    3af2:	ff 90       	pop	r15
    3af4:	08 95       	ret

00003af6 <menu_next_item>:
}

/**
 * Funkce posune kurzor na p¯edchozÌ poloûku menu.
 */
char menu_next_item(MENU_ITEM *menu[], char i, char max_i){
    3af6:	ef 92       	push	r14
    3af8:	ff 92       	push	r15
    3afa:	0f 93       	push	r16
    3afc:	1f 93       	push	r17
    3afe:	cf 93       	push	r28
    3b00:	df 93       	push	r29
    3b02:	7c 01       	movw	r14, r24
    3b04:	04 2f       	mov	r16, r20
  int ii = (int) i;
    3b06:	c6 2f       	mov	r28, r22
    3b08:	d0 e0       	ldi	r29, 0x00	; 0
  int max_ii = (int) max_i;

  printcxyd(menu[ii] -> y, ((menu[ii] -> x) - 1), ' ' );
    3b0a:	fe 01       	movw	r30, r28
    3b0c:	ee 0f       	add	r30, r30
    3b0e:	ff 1f       	adc	r31, r31
    3b10:	e8 0f       	add	r30, r24
    3b12:	f9 1f       	adc	r31, r25
    3b14:	01 90       	ld	r0, Z+
    3b16:	f0 81       	ld	r31, Z
    3b18:	e0 2d       	mov	r30, r0
    3b1a:	60 81       	ld	r22, Z
    3b1c:	70 e0       	ldi	r23, 0x00	; 0
    3b1e:	61 50       	subi	r22, 0x01	; 1
    3b20:	70 40       	sbci	r23, 0x00	; 0
    3b22:	81 81       	ldd	r24, Z+1	; 0x01
    3b24:	90 e0       	ldi	r25, 0x00	; 0
    3b26:	40 e2       	ldi	r20, 0x20	; 32
    3b28:	0e 94 fc 11 	call	0x23f8	; 0x23f8 <printcxyd>

  if (ii < (max_ii - 1)){
    3b2c:	10 e0       	ldi	r17, 0x00	; 0
    3b2e:	01 50       	subi	r16, 0x01	; 1
    3b30:	10 40       	sbci	r17, 0x00	; 0
    3b32:	c0 17       	cp	r28, r16
    3b34:	d1 07       	cpc	r29, r17
    3b36:	1c f0       	brlt	.+6      	; 0x3b3e <menu_next_item+0x48>
    3b38:	c0 e0       	ldi	r28, 0x00	; 0
    3b3a:	d0 e0       	ldi	r29, 0x00	; 0
    3b3c:	01 c0       	rjmp	.+2      	; 0x3b40 <menu_next_item+0x4a>
    ii++;
    3b3e:	21 96       	adiw	r28, 0x01	; 1
  }
  else{
    ii = 0;
  }
  printcxyd(menu[ii] ->y, ((menu[ii] -> x) - 1), 255 );
    3b40:	fe 01       	movw	r30, r28
    3b42:	ee 0f       	add	r30, r30
    3b44:	ff 1f       	adc	r31, r31
    3b46:	ee 0d       	add	r30, r14
    3b48:	ff 1d       	adc	r31, r15
    3b4a:	01 90       	ld	r0, Z+
    3b4c:	f0 81       	ld	r31, Z
    3b4e:	e0 2d       	mov	r30, r0
    3b50:	60 81       	ld	r22, Z
    3b52:	70 e0       	ldi	r23, 0x00	; 0
    3b54:	61 50       	subi	r22, 0x01	; 1
    3b56:	70 40       	sbci	r23, 0x00	; 0
    3b58:	81 81       	ldd	r24, Z+1	; 0x01
    3b5a:	90 e0       	ldi	r25, 0x00	; 0
    3b5c:	4f ef       	ldi	r20, 0xFF	; 255
    3b5e:	0e 94 fc 11 	call	0x23f8	; 0x23f8 <printcxyd>

  return (char) ii;
}
    3b62:	8c 2f       	mov	r24, r28
    3b64:	df 91       	pop	r29
    3b66:	cf 91       	pop	r28
    3b68:	1f 91       	pop	r17
    3b6a:	0f 91       	pop	r16
    3b6c:	ff 90       	pop	r15
    3b6e:	ef 90       	pop	r14
    3b70:	08 95       	ret

00003b72 <menu_next_value>:
}

/**
 * Funkce nastavÌ zvolenou hodnotu na dalöÌ.
 */
void menu_next_value(MENU_ITEM *menu[], char ic){
    3b72:	cf 92       	push	r12
    3b74:	df 92       	push	r13
    3b76:	ef 92       	push	r14
    3b78:	ff 92       	push	r15
    3b7a:	0f 93       	push	r16
    3b7c:	1f 93       	push	r17
    3b7e:	cf 93       	push	r28
    3b80:	df 93       	push	r29
  int i = (int) ic;
  char len_a;
  char len_b;
  char counter = 0;
  
  if (menu[i] -> polozky[menu[i] -> val] != NULL)
    3b82:	06 2f       	mov	r16, r22
    3b84:	10 e0       	ldi	r17, 0x00	; 0
    3b86:	00 0f       	add	r16, r16
    3b88:	11 1f       	adc	r17, r17
    3b8a:	08 0f       	add	r16, r24
    3b8c:	19 1f       	adc	r17, r25
    3b8e:	d8 01       	movw	r26, r16
    3b90:	ed 91       	ld	r30, X+
    3b92:	fc 91       	ld	r31, X
    3b94:	85 81       	ldd	r24, Z+5	; 0x05
    3b96:	90 e0       	ldi	r25, 0x00	; 0
    3b98:	88 0f       	add	r24, r24
    3b9a:	99 1f       	adc	r25, r25
    3b9c:	03 80       	ldd	r0, Z+3	; 0x03
    3b9e:	f4 81       	ldd	r31, Z+4	; 0x04
    3ba0:	e0 2d       	mov	r30, r0
    3ba2:	e8 0f       	add	r30, r24
    3ba4:	f9 1f       	adc	r31, r25
    3ba6:	01 90       	ld	r0, Z+
    3ba8:	f0 81       	ld	r31, Z
    3baa:	e0 2d       	mov	r30, r0
    3bac:	30 97       	sbiw	r30, 0x00	; 0
    3bae:	11 f4       	brne	.+4      	; 0x3bb4 <menu_next_value+0x42>
    3bb0:	68 e0       	ldi	r22, 0x08	; 8
    3bb2:	07 c0       	rjmp	.+14     	; 0x3bc2 <menu_next_value+0x50>
    len_a = strlen(menu[i] -> polozky[menu[i] -> val]);
    3bb4:	df 01       	movw	r26, r30
    3bb6:	01 90       	ld	r0, Z+
    3bb8:	00 20       	and	r0, r0
    3bba:	e9 f7       	brne	.-6      	; 0x3bb6 <menu_next_value+0x44>
    3bbc:	31 97       	sbiw	r30, 0x01	; 1
    3bbe:	6e 2f       	mov	r22, r30
    3bc0:	6a 1b       	sub	r22, r26
    3bc2:	50 e0       	ldi	r21, 0x00	; 0
  else
    len_a = 8;

  do{ // p¯eskakov·nÌ NULL hodnot
    // posouv·nÌ hodnot vp¯ed
    if (menu[i] -> val < (menu[i] -> len - 1)){
    3bc4:	d8 01       	movw	r26, r16
    3bc6:	ed 91       	ld	r30, X+
    3bc8:	fc 91       	ld	r31, X
    3bca:	45 81       	ldd	r20, Z+5	; 0x05
    3bcc:	24 2f       	mov	r18, r20
    3bce:	30 e0       	ldi	r19, 0x00	; 0
    3bd0:	82 81       	ldd	r24, Z+2	; 0x02
    3bd2:	90 e0       	ldi	r25, 0x00	; 0
    3bd4:	01 97       	sbiw	r24, 0x01	; 1
    3bd6:	28 17       	cp	r18, r24
    3bd8:	39 07       	cpc	r19, r25
    3bda:	1c f4       	brge	.+6      	; 0x3be2 <menu_next_value+0x70>
      menu[i] -> val = menu[i] -> val + 1;
    3bdc:	4f 5f       	subi	r20, 0xFF	; 255
    3bde:	45 83       	std	Z+5, r20	; 0x05
    3be0:	01 c0       	rjmp	.+2      	; 0x3be4 <menu_next_value+0x72>
    }
    else 
      menu[i] -> val = 0;
    3be2:	15 82       	std	Z+5, r1	; 0x05

    counter++;
    3be4:	5f 5f       	subi	r21, 0xFF	; 255

    if (counter > menu[i] -> len){
    3be6:	d8 01       	movw	r26, r16
    3be8:	ed 91       	ld	r30, X+
    3bea:	fc 91       	ld	r31, X
    3bec:	82 81       	ldd	r24, Z+2	; 0x02
    3bee:	85 17       	cp	r24, r21
    3bf0:	18 f4       	brcc	.+6      	; 0x3bf8 <menu_next_value+0x86>
      menu[i] -> val = 255;
    3bf2:	8f ef       	ldi	r24, 0xFF	; 255
    3bf4:	85 83       	std	Z+5, r24	; 0x05
    3bf6:	0d c0       	rjmp	.+26     	; 0x3c12 <menu_next_value+0xa0>
      break;
    }
  }while((menu[i] -> polozky[menu[i] -> val]) == NULL);
    3bf8:	85 81       	ldd	r24, Z+5	; 0x05
    3bfa:	90 e0       	ldi	r25, 0x00	; 0
    3bfc:	88 0f       	add	r24, r24
    3bfe:	99 1f       	adc	r25, r25
    3c00:	03 80       	ldd	r0, Z+3	; 0x03
    3c02:	f4 81       	ldd	r31, Z+4	; 0x04
    3c04:	e0 2d       	mov	r30, r0
    3c06:	e8 0f       	add	r30, r24
    3c08:	f9 1f       	adc	r31, r25
    3c0a:	80 81       	ld	r24, Z
    3c0c:	91 81       	ldd	r25, Z+1	; 0x01
    3c0e:	89 2b       	or	r24, r25
    3c10:	c9 f2       	breq	.-78     	; 0x3bc4 <menu_next_value+0x52>
  
  if (menu[i] -> val != 255)
    3c12:	d8 01       	movw	r26, r16
    3c14:	ed 91       	ld	r30, X+
    3c16:	fc 91       	ld	r31, X
    3c18:	85 81       	ldd	r24, Z+5	; 0x05
    3c1a:	8f 3f       	cpi	r24, 0xFF	; 255
    3c1c:	11 f4       	brne	.+4      	; 0x3c22 <menu_next_value+0xb0>
    3c1e:	e0 e0       	ldi	r30, 0x00	; 0
    3c20:	10 c0       	rjmp	.+32     	; 0x3c42 <menu_next_value+0xd0>
    len_b = strlen(menu[i] -> polozky[menu[i] -> val]);
    3c22:	90 e0       	ldi	r25, 0x00	; 0
    3c24:	88 0f       	add	r24, r24
    3c26:	99 1f       	adc	r25, r25
    3c28:	03 80       	ldd	r0, Z+3	; 0x03
    3c2a:	f4 81       	ldd	r31, Z+4	; 0x04
    3c2c:	e0 2d       	mov	r30, r0
    3c2e:	e8 0f       	add	r30, r24
    3c30:	f9 1f       	adc	r31, r25
    3c32:	a0 81       	ld	r26, Z
    3c34:	b1 81       	ldd	r27, Z+1	; 0x01
    3c36:	fd 01       	movw	r30, r26
    3c38:	01 90       	ld	r0, Z+
    3c3a:	00 20       	and	r0, r0
    3c3c:	e9 f7       	brne	.-6      	; 0x3c38 <menu_next_value+0xc6>
    3c3e:	31 97       	sbiw	r30, 0x01	; 1
    3c40:	ea 1b       	sub	r30, r26
  else
    len_b = 0;
  
  // domaz·nÌ konce minlÈho ¯etÏzce
  if (len_a > len_b){
    3c42:	e6 17       	cp	r30, r22
    3c44:	d0 f4       	brcc	.+52     	; 0x3c7a <menu_next_value+0x108>
    int j;
    len_a = len_a - len_b;
    3c46:	6e 1b       	sub	r22, r30
    3c48:	c0 e0       	ldi	r28, 0x00	; 0
    3c4a:	d0 e0       	ldi	r29, 0x00	; 0
    for (j=0; j < len_a; j++){
    3c4c:	c6 2e       	mov	r12, r22
    3c4e:	dd 24       	eor	r13, r13
      printcxyd(menu[i] ->y, menu[i] ->x + len_b + j,' ');
    3c50:	ee 2e       	mov	r14, r30
    3c52:	ff 24       	eor	r15, r15
    3c54:	0f c0       	rjmp	.+30     	; 0x3c74 <menu_next_value+0x102>
    3c56:	d8 01       	movw	r26, r16
    3c58:	ed 91       	ld	r30, X+
    3c5a:	fc 91       	ld	r31, X
    3c5c:	80 81       	ld	r24, Z
    3c5e:	b7 01       	movw	r22, r14
    3c60:	68 0f       	add	r22, r24
    3c62:	71 1d       	adc	r23, r1
    3c64:	6c 0f       	add	r22, r28
    3c66:	7d 1f       	adc	r23, r29
    3c68:	81 81       	ldd	r24, Z+1	; 0x01
    3c6a:	90 e0       	ldi	r25, 0x00	; 0
    3c6c:	40 e2       	ldi	r20, 0x20	; 32
    3c6e:	0e 94 fc 11 	call	0x23f8	; 0x23f8 <printcxyd>
  
  // domaz·nÌ konce minlÈho ¯etÏzce
  if (len_a > len_b){
    int j;
    len_a = len_a - len_b;
    for (j=0; j < len_a; j++){
    3c72:	21 96       	adiw	r28, 0x01	; 1
    3c74:	cc 15       	cp	r28, r12
    3c76:	dd 05       	cpc	r29, r13
    3c78:	74 f3       	brlt	.-36     	; 0x3c56 <menu_next_value+0xe4>
      printcxyd(menu[i] ->y, menu[i] ->x + len_b + j,' ');
    }
  }
  
  if (menu[i] -> val == 255)
    3c7a:	d8 01       	movw	r26, r16
    3c7c:	ed 91       	ld	r30, X+
    3c7e:	fc 91       	ld	r31, X
    3c80:	85 81       	ldd	r24, Z+5	; 0x05
    3c82:	11 81       	ldd	r17, Z+1	; 0x01
    3c84:	00 81       	ld	r16, Z
    3c86:	8f 3f       	cpi	r24, 0xFF	; 255
    3c88:	41 f4       	brne	.+16     	; 0x3c9a <menu_next_value+0x128>
    printxyd(menu[i] ->y, (menu[i] -> x), strcpy_P(str_buf,s_prazdne));
    3c8a:	85 e2       	ldi	r24, 0x25	; 37
    3c8c:	92 e0       	ldi	r25, 0x02	; 2
    3c8e:	6d e6       	ldi	r22, 0x6D	; 109
    3c90:	7a e0       	ldi	r23, 0x0A	; 10
    3c92:	0e 94 27 33 	call	0x664e	; 0x664e <strcpy_P>
    3c96:	ac 01       	movw	r20, r24
    3c98:	0a c0       	rjmp	.+20     	; 0x3cae <menu_next_value+0x13c>
  else
    printxyd(menu[i] ->y, (menu[i] -> x), menu[i] -> polozky[menu[i] -> val] );
    3c9a:	90 e0       	ldi	r25, 0x00	; 0
    3c9c:	88 0f       	add	r24, r24
    3c9e:	99 1f       	adc	r25, r25
    3ca0:	03 80       	ldd	r0, Z+3	; 0x03
    3ca2:	f4 81       	ldd	r31, Z+4	; 0x04
    3ca4:	e0 2d       	mov	r30, r0
    3ca6:	e8 0f       	add	r30, r24
    3ca8:	f9 1f       	adc	r31, r25
    3caa:	40 81       	ld	r20, Z
    3cac:	51 81       	ldd	r21, Z+1	; 0x01
    3cae:	81 2f       	mov	r24, r17
    3cb0:	90 e0       	ldi	r25, 0x00	; 0
    3cb2:	60 2f       	mov	r22, r16
    3cb4:	70 e0       	ldi	r23, 0x00	; 0
    3cb6:	0e 94 26 14 	call	0x284c	; 0x284c <printxyd>
}
    3cba:	df 91       	pop	r29
    3cbc:	cf 91       	pop	r28
    3cbe:	1f 91       	pop	r17
    3cc0:	0f 91       	pop	r16
    3cc2:	ff 90       	pop	r15
    3cc4:	ef 90       	pop	r14
    3cc6:	df 90       	pop	r13
    3cc8:	cf 90       	pop	r12
    3cca:	08 95       	ret

00003ccc <menu_draw>:
 * Funkce vykreslÌ menu.
 * Vykresleny jsou jeho poloûky a kurzor. Je-li hodnota nÏjakÈ poloûky
 * NULL, sk·Ëe se na dalöÌ. Jedinou v˝jimkou je hodnota 255. Pro ty je vyps·na
 * hl·öka "prazdne".
 */
void menu_draw(MENU_ITEM *menu[], uint8_t len, char menu_i){
    3ccc:	9f 92       	push	r9
    3cce:	af 92       	push	r10
    3cd0:	bf 92       	push	r11
    3cd2:	cf 92       	push	r12
    3cd4:	df 92       	push	r13
    3cd6:	ef 92       	push	r14
    3cd8:	ff 92       	push	r15
    3cda:	0f 93       	push	r16
    3cdc:	1f 93       	push	r17
    3cde:	cf 93       	push	r28
    3ce0:	df 93       	push	r29
    3ce2:	6c 01       	movw	r12, r24
    3ce4:	94 2e       	mov	r9, r20
    3ce6:	ec 01       	movw	r28, r24
    3ce8:	ee 24       	eor	r14, r14
    3cea:	ff 24       	eor	r15, r15
  int i;

  for (i =0; i <len ; i++){
    3cec:	a6 2e       	mov	r10, r22
    3cee:	bb 24       	eor	r11, r11
    3cf0:	4e c0       	rjmp	.+156    	; 0x3d8e <menu_draw+0xc2>
    if (menu[i] -> polozky == NULL){
    3cf2:	a8 81       	ld	r26, Y
    3cf4:	b9 81       	ldd	r27, Y+1	; 0x01
    3cf6:	13 96       	adiw	r26, 0x03	; 3
    3cf8:	ed 91       	ld	r30, X+
    3cfa:	fc 91       	ld	r31, X
    3cfc:	14 97       	sbiw	r26, 0x04	; 4
    3cfe:	30 97       	sbiw	r30, 0x00	; 0
    3d00:	09 f4       	brne	.+2      	; 0x3d04 <menu_draw+0x38>
    3d02:	41 c0       	rjmp	.+130    	; 0x3d86 <menu_draw+0xba>
      
    }
    else{
      // pokud je hodnota poloûky NULL a nenÌ 255 pak nevÌme co vypsat. ZkusÌme tedy skoËit
      // na dalöÌ poloûku.
      if ((menu[i] -> polozky[menu[i] -> val] == NULL)&&(menu[i] -> val != 255))
    3d04:	15 96       	adiw	r26, 0x05	; 5
    3d06:	2c 91       	ld	r18, X
    3d08:	82 2f       	mov	r24, r18
    3d0a:	90 e0       	ldi	r25, 0x00	; 0
    3d0c:	88 0f       	add	r24, r24
    3d0e:	99 1f       	adc	r25, r25
    3d10:	e8 0f       	add	r30, r24
    3d12:	f9 1f       	adc	r31, r25
    3d14:	80 81       	ld	r24, Z
    3d16:	91 81       	ldd	r25, Z+1	; 0x01
    3d18:	89 2b       	or	r24, r25
    3d1a:	31 f4       	brne	.+12     	; 0x3d28 <menu_draw+0x5c>
    3d1c:	2f 3f       	cpi	r18, 0xFF	; 255
    3d1e:	21 f0       	breq	.+8      	; 0x3d28 <menu_draw+0x5c>
	menu_next_value(menu, menu_i);
    3d20:	c6 01       	movw	r24, r12
    3d22:	69 2d       	mov	r22, r9
    3d24:	0e 94 b9 1d 	call	0x3b72	; 0x3b72 <menu_next_value>
      
      if ((menu[i] -> polozky[menu[i] -> val] == NULL)&&(menu[i] -> val != 255)){
    3d28:	a8 81       	ld	r26, Y
    3d2a:	b9 81       	ldd	r27, Y+1	; 0x01
    3d2c:	15 96       	adiw	r26, 0x05	; 5
    3d2e:	2c 91       	ld	r18, X
    3d30:	15 97       	sbiw	r26, 0x05	; 5
    3d32:	82 2f       	mov	r24, r18
    3d34:	90 e0       	ldi	r25, 0x00	; 0
    3d36:	88 0f       	add	r24, r24
    3d38:	99 1f       	adc	r25, r25
    3d3a:	13 96       	adiw	r26, 0x03	; 3
    3d3c:	ed 91       	ld	r30, X+
    3d3e:	fc 91       	ld	r31, X
    3d40:	14 97       	sbiw	r26, 0x04	; 4
    3d42:	e8 0f       	add	r30, r24
    3d44:	f9 1f       	adc	r31, r25
    3d46:	40 81       	ld	r20, Z
    3d48:	51 81       	ldd	r21, Z+1	; 0x01
    3d4a:	41 15       	cp	r20, r1
    3d4c:	51 05       	cpc	r21, r1
    3d4e:	19 f4       	brne	.+6      	; 0x3d56 <menu_draw+0x8a>
    3d50:	2f 3f       	cpi	r18, 0xFF	; 255
    3d52:	c9 f4       	brne	.+50     	; 0x3d86 <menu_draw+0xba>
    3d54:	02 c0       	rjmp	.+4      	; 0x3d5a <menu_draw+0x8e>
      }
      //printxyd(menu[i] -> y, menu[i] -> x,"prazdne");
      else{
	// printxyd(menu[i] -> y, menu[i] -> x, menu[i] -> polozky[menu[i] -> val]);
	if (menu[i] -> val == 255)
    3d56:	2f 3f       	cpi	r18, 0xFF	; 255
    3d58:	79 f4       	brne	.+30     	; 0x3d78 <menu_draw+0xac>
	  printxyd(menu[i] ->y, (menu[i] -> x), strcpy_P(str_buf,s_prazdne));
    3d5a:	11 96       	adiw	r26, 0x01	; 1
    3d5c:	1c 91       	ld	r17, X
    3d5e:	11 97       	sbiw	r26, 0x01	; 1
    3d60:	0c 91       	ld	r16, X
    3d62:	85 e2       	ldi	r24, 0x25	; 37
    3d64:	92 e0       	ldi	r25, 0x02	; 2
    3d66:	6d e6       	ldi	r22, 0x6D	; 109
    3d68:	7a e0       	ldi	r23, 0x0A	; 10
    3d6a:	0e 94 27 33 	call	0x664e	; 0x664e <strcpy_P>
    3d6e:	ac 01       	movw	r20, r24
    3d70:	81 2f       	mov	r24, r17
    3d72:	90 e0       	ldi	r25, 0x00	; 0
    3d74:	60 2f       	mov	r22, r16
    3d76:	04 c0       	rjmp	.+8      	; 0x3d80 <menu_draw+0xb4>
	else
	  printxyd(menu[i] ->y, (menu[i] -> x), menu[i] -> polozky[menu[i] -> val] );
    3d78:	6c 91       	ld	r22, X
    3d7a:	11 96       	adiw	r26, 0x01	; 1
    3d7c:	8c 91       	ld	r24, X
    3d7e:	90 e0       	ldi	r25, 0x00	; 0
    3d80:	70 e0       	ldi	r23, 0x00	; 0
    3d82:	0e 94 26 14 	call	0x284c	; 0x284c <printxyd>
 * hl·öka "prazdne".
 */
void menu_draw(MENU_ITEM *menu[], uint8_t len, char menu_i){
  int i;

  for (i =0; i <len ; i++){
    3d86:	08 94       	sec
    3d88:	e1 1c       	adc	r14, r1
    3d8a:	f1 1c       	adc	r15, r1
    3d8c:	22 96       	adiw	r28, 0x02	; 2
    3d8e:	ea 14       	cp	r14, r10
    3d90:	fb 04       	cpc	r15, r11
    3d92:	0c f4       	brge	.+2      	; 0x3d96 <menu_draw+0xca>
    3d94:	ae cf       	rjmp	.-164    	; 0x3cf2 <menu_draw+0x26>
    }
    }
  }

  i = (int) menu_i;
  printcxyd(menu[i] -> y, ((menu[i] -> x) - 1), 255 );
    3d96:	e9 2d       	mov	r30, r9
    3d98:	f0 e0       	ldi	r31, 0x00	; 0
    3d9a:	ee 0f       	add	r30, r30
    3d9c:	ff 1f       	adc	r31, r31
    3d9e:	ec 0d       	add	r30, r12
    3da0:	fd 1d       	adc	r31, r13
    3da2:	01 90       	ld	r0, Z+
    3da4:	f0 81       	ld	r31, Z
    3da6:	e0 2d       	mov	r30, r0
    3da8:	60 81       	ld	r22, Z
    3daa:	70 e0       	ldi	r23, 0x00	; 0
    3dac:	61 50       	subi	r22, 0x01	; 1
    3dae:	70 40       	sbci	r23, 0x00	; 0
    3db0:	81 81       	ldd	r24, Z+1	; 0x01
    3db2:	90 e0       	ldi	r25, 0x00	; 0
    3db4:	4f ef       	ldi	r20, 0xFF	; 255
    3db6:	0e 94 fc 11 	call	0x23f8	; 0x23f8 <printcxyd>
}
    3dba:	df 91       	pop	r29
    3dbc:	cf 91       	pop	r28
    3dbe:	1f 91       	pop	r17
    3dc0:	0f 91       	pop	r16
    3dc2:	ff 90       	pop	r15
    3dc4:	ef 90       	pop	r14
    3dc6:	df 90       	pop	r13
    3dc8:	cf 90       	pop	r12
    3dca:	bf 90       	pop	r11
    3dcc:	af 90       	pop	r10
    3dce:	9f 90       	pop	r9
    3dd0:	08 95       	ret

00003dd2 <read_line_init>:
 * Funkce inicializuje naËÌt·nÌ ¯etÏzce z ¯·dky.
 * @param y Souûadnice poË·tku.
 * @param x Sou¯adnice poË·tku.
 * @param s Ukazatel na string, kam bude ¯etÏzec ukl·d·n.
 */
void read_line_init(int y, int x, char *s){ 
    3dd2:	ef 92       	push	r14
    3dd4:	ff 92       	push	r15
    3dd6:	0f 93       	push	r16
    3dd8:	1f 93       	push	r17
    3dda:	cf 93       	push	r28
    3ddc:	df 93       	push	r29
    3dde:	f8 2e       	mov	r15, r24
    3de0:	e9 2e       	mov	r14, r25
    3de2:	8b 01       	movw	r16, r22
  int i;
  
  char_counter = 0;
    3de4:	10 92 b8 01 	sts	0x01B8, r1
    3de8:	10 92 b7 01 	sts	0x01B7, r1
  max_len = (char) strlen(s);
    3dec:	fa 01       	movw	r30, r20
    3dee:	01 90       	ld	r0, Z+
    3df0:	00 20       	and	r0, r0
    3df2:	e9 f7       	brne	.-6      	; 0x3dee <read_line_init+0x1c>
    3df4:	31 97       	sbiw	r30, 0x01	; 1
    3df6:	e4 1b       	sub	r30, r20
    3df8:	f5 0b       	sbc	r31, r21
    3dfa:	e0 93 b9 01 	sts	0x01B9, r30
  sour_x = x;
    3dfe:	60 93 ba 01 	sts	0x01BA, r22
  sour_y = y;
    3e02:	80 93 bb 01 	sts	0x01BB, r24
  str = s;
    3e06:	40 93 bc 01 	sts	0x01BC, r20
    3e0a:	50 93 bd 01 	sts	0x01BD, r21
    3e0e:	c0 e0       	ldi	r28, 0x00	; 0
    3e10:	d0 e0       	ldi	r29, 0x00	; 0
    3e12:	09 c0       	rjmp	.+18     	; 0x3e26 <read_line_init+0x54>
  for (i = 0; i < max_len ; i++){
    printcxyd(y,x + i,' ');
    3e14:	be 01       	movw	r22, r28
    3e16:	60 0f       	add	r22, r16
    3e18:	71 1f       	adc	r23, r17
    3e1a:	8f 2d       	mov	r24, r15
    3e1c:	9e 2d       	mov	r25, r14
    3e1e:	40 e2       	ldi	r20, 0x20	; 32
    3e20:	0e 94 fc 11 	call	0x23f8	; 0x23f8 <printcxyd>
  char_counter = 0;
  max_len = (char) strlen(s);
  sour_x = x;
  sour_y = y;
  str = s;
  for (i = 0; i < max_len ; i++){
    3e24:	21 96       	adiw	r28, 0x01	; 1
    3e26:	80 91 b9 01 	lds	r24, 0x01B9
    3e2a:	90 e0       	ldi	r25, 0x00	; 0
    3e2c:	c8 17       	cp	r28, r24
    3e2e:	d9 07       	cpc	r29, r25
    3e30:	8c f3       	brlt	.-30     	; 0x3e14 <read_line_init+0x42>
    printcxyd(y,x + i,' ');
  }
  if (char_counter + sour_x < (LCD_X_MAX - 1)){
    3e32:	80 91 ba 01 	lds	r24, 0x01BA
    3e36:	60 91 b7 01 	lds	r22, 0x01B7
    3e3a:	70 91 b8 01 	lds	r23, 0x01B8
    3e3e:	68 0f       	add	r22, r24
    3e40:	71 1d       	adc	r23, r1
    3e42:	67 32       	cpi	r22, 0x27	; 39
    3e44:	71 05       	cpc	r23, r1
    3e46:	3c f4       	brge	.+14     	; 0x3e56 <read_line_init+0x84>
    printxyd(sour_y,char_counter + sour_x,"_");
    3e48:	80 91 bb 01 	lds	r24, 0x01BB
    3e4c:	90 e0       	ldi	r25, 0x00	; 0
    3e4e:	48 eb       	ldi	r20, 0xB8	; 184
    3e50:	50 e0       	ldi	r21, 0x00	; 0
    3e52:	0e 94 26 14 	call	0x284c	; 0x284c <printxyd>
  }

}
    3e56:	df 91       	pop	r29
    3e58:	cf 91       	pop	r28
    3e5a:	1f 91       	pop	r17
    3e5c:	0f 91       	pop	r16
    3e5e:	ff 90       	pop	r15
    3e60:	ef 90       	pop	r14
    3e62:	08 95       	ret

00003e64 <new_menu_item>:
/// V tÏch je nadefinov·n ukazatel na pole popisk˘ hodnot.
/// x,y jsou sou¯adnice poË·tku n·pisu
/// val je aktu·lnÌ hodnota menu
/// len je poËet moûn˝ch hodnot menu. Je li v poli popisk˘ mÌsto 
/// ukazatele na ¯etÏzec ukazatel na NULL, doch·zÌ k p¯eskakov·nÌ tÈto hodnoty.
MENU_ITEM *new_menu_item(void){
    3e64:	cf 93       	push	r28
    3e66:	df 93       	push	r29
  MENU_ITEM *p_pom;
  p_pom = (MENU_ITEM *) malloc(sizeof(MENU_ITEM));
    3e68:	86 e0       	ldi	r24, 0x06	; 6
    3e6a:	90 e0       	ldi	r25, 0x00	; 0
    3e6c:	0e 94 19 32 	call	0x6432	; 0x6432 <malloc>
    3e70:	ec 01       	movw	r28, r24
  if(p_pom == NULL){
    3e72:	00 97       	sbiw	r24, 0x00	; 0
    3e74:	19 f4       	brne	.+6      	; 0x3e7c <new_menu_item+0x18>
    new_error(88);
    3e76:	88 e5       	ldi	r24, 0x58	; 88
    3e78:	0e 94 4e 19 	call	0x329c	; 0x329c <new_error>
  }
  return p_pom;
}
    3e7c:	ce 01       	movw	r24, r28
    3e7e:	df 91       	pop	r29
    3e80:	cf 91       	pop	r28
    3e82:	08 95       	ret

00003e84 <read_line_kill>:

/**
 * Funkce m· za ˙kol ukonËenÌ zad·v·nÌ ¯etÏzce z venku. ZajistÌ uvolnÏnÌ zdroj˘.
 */
void read_line_kill(void){
  free((void *)str);
    3e84:	80 91 bc 01 	lds	r24, 0x01BC
    3e88:	90 91 bd 01 	lds	r25, 0x01BD
    3e8c:	0e 94 c6 32 	call	0x658c	; 0x658c <free>
  max_len = 0;
    3e90:	10 92 b9 01 	sts	0x01B9, r1
  char_counter = 0;
    3e94:	10 92 b8 01 	sts	0x01B8, r1
    3e98:	10 92 b7 01 	sts	0x01B7, r1
  if (def_str != NULL){
    3e9c:	80 91 b5 01 	lds	r24, 0x01B5
    3ea0:	90 91 b6 01 	lds	r25, 0x01B6
    3ea4:	00 97       	sbiw	r24, 0x00	; 0
    3ea6:	31 f0       	breq	.+12     	; 0x3eb4 <read_line_kill+0x30>
    free((void *)def_str);
    3ea8:	0e 94 c6 32 	call	0x658c	; 0x658c <free>
    def_str = NULL;
    3eac:	10 92 b6 01 	sts	0x01B6, r1
    3eb0:	10 92 b5 01 	sts	0x01B5, r1
    3eb4:	08 95       	ret

00003eb6 <read_line>:
 *
 * @retval char*str
 * Pokud bylo ukonËeno zad·v·nÌ ¯etÏzce, n·vratov· hodnota je ukazatel na dan˝
 * ¯etÏzec.
 */
 char *read_line (void){
    3eb6:	0f 93       	push	r16
    3eb8:	1f 93       	push	r17
    3eba:	df 93       	push	r29
    3ebc:	cf 93       	push	r28
    3ebe:	00 d0       	rcall	.+0      	; 0x3ec0 <read_line+0xa>
    3ec0:	0f 92       	push	r0
    3ec2:	cd b7       	in	r28, 0x3d	; 61
    3ec4:	de b7       	in	r29, 0x3e	; 62
   char xpchc = sour_x + char_counter;
    3ec6:	10 91 ba 01 	lds	r17, 0x01BA
    3eca:	00 91 b7 01 	lds	r16, 0x01B7
   char c[3] = {' ','_','\0'};
    3ece:	de 01       	movw	r26, r28
    3ed0:	11 96       	adiw	r26, 0x01	; 1
    3ed2:	ee eb       	ldi	r30, 0xBE	; 190
    3ed4:	f0 e0       	ldi	r31, 0x00	; 0
    3ed6:	83 e0       	ldi	r24, 0x03	; 3
    3ed8:	01 90       	ld	r0, Z+
    3eda:	0d 92       	st	X+, r0
    3edc:	81 50       	subi	r24, 0x01	; 1
    3ede:	e1 f7       	brne	.-8      	; 0x3ed8 <read_line+0x22>
   if ((c[0] = get_spec()) != 0){
    3ee0:	0e 94 f2 1c 	call	0x39e4	; 0x39e4 <get_spec>
    3ee4:	89 83       	std	Y+1, r24	; 0x01
    3ee6:	88 23       	and	r24, r24
    3ee8:	09 f4       	brne	.+2      	; 0x3eec <read_line+0x36>
    3eea:	8d c0       	rjmp	.+282    	; 0x4006 <read_line+0x150>
     switch(c[0]){
    3eec:	85 30       	cpi	r24, 0x05	; 5
    3eee:	79 f0       	breq	.+30     	; 0x3f0e <read_line+0x58>
    3ef0:	86 30       	cpi	r24, 0x06	; 6
    3ef2:	30 f4       	brcc	.+12     	; 0x3f00 <read_line+0x4a>
    3ef4:	81 30       	cpi	r24, 0x01	; 1
    3ef6:	71 f0       	breq	.+28     	; 0x3f14 <read_line+0x5e>
    3ef8:	84 30       	cpi	r24, 0x04	; 4
    3efa:	09 f0       	breq	.+2      	; 0x3efe <read_line+0x48>
    3efc:	ce c0       	rjmp	.+412    	; 0x409a <read_line+0x1e4>
    3efe:	4b c0       	rjmp	.+150    	; 0x3f96 <read_line+0xe0>
    3f00:	85 31       	cpi	r24, 0x15	; 21
    3f02:	09 f4       	brne	.+2      	; 0x3f06 <read_line+0x50>
    3f04:	7a c0       	rjmp	.+244    	; 0x3ffa <read_line+0x144>
    3f06:	86 31       	cpi	r24, 0x16	; 22
    3f08:	09 f0       	breq	.+2      	; 0x3f0c <read_line+0x56>
    3f0a:	c7 c0       	rjmp	.+398    	; 0x409a <read_line+0x1e4>
    3f0c:	79 c0       	rjmp	.+242    	; 0x4000 <read_line+0x14a>
    3f0e:	2a eb       	ldi	r18, 0xBA	; 186
    3f10:	30 e0       	ldi	r19, 0x00	; 0
    3f12:	c5 c0       	rjmp	.+394    	; 0x409e <read_line+0x1e8>
     case 5: //esc
       return "";
       break;
     case 1:
       if (char_counter > 0){
    3f14:	60 91 b7 01 	lds	r22, 0x01B7
    3f18:	70 91 b8 01 	lds	r23, 0x01B8
    3f1c:	16 16       	cp	r1, r22
    3f1e:	17 06       	cpc	r1, r23
    3f20:	0c f0       	brlt	.+2      	; 0x3f24 <read_line+0x6e>
    3f22:	bb c0       	rjmp	.+374    	; 0x409a <read_line+0x1e4>
         char_counter--;
    3f24:	61 50       	subi	r22, 0x01	; 1
    3f26:	70 40       	sbci	r23, 0x00	; 0
    3f28:	70 93 b8 01 	sts	0x01B8, r23
    3f2c:	60 93 b7 01 	sts	0x01B7, r22
         if (char_counter == (max_len)){
    3f30:	80 91 b9 01 	lds	r24, 0x01B9
    3f34:	90 e0       	ldi	r25, 0x00	; 0
    3f36:	20 91 ba 01 	lds	r18, 0x01BA
    3f3a:	30 91 bb 01 	lds	r19, 0x01BB
    3f3e:	68 17       	cp	r22, r24
    3f40:	79 07       	cpc	r23, r25
    3f42:	a1 f4       	brne	.+40     	; 0x3f6c <read_line+0xb6>
           printxyd(sour_y,sour_x + char_counter,"_");
    3f44:	62 0f       	add	r22, r18
    3f46:	71 1d       	adc	r23, r1
    3f48:	83 2f       	mov	r24, r19
    3f4a:	90 e0       	ldi	r25, 0x00	; 0
    3f4c:	48 eb       	ldi	r20, 0xB8	; 184
    3f4e:	50 e0       	ldi	r21, 0x00	; 0
    3f50:	0e 94 26 14 	call	0x284c	; 0x284c <printxyd>
           str[char_counter - 1] = ' ';
    3f54:	e0 91 bc 01 	lds	r30, 0x01BC
    3f58:	f0 91 bd 01 	lds	r31, 0x01BD
    3f5c:	80 91 b7 01 	lds	r24, 0x01B7
    3f60:	90 91 b8 01 	lds	r25, 0x01B8
    3f64:	e8 0f       	add	r30, r24
    3f66:	f9 1f       	adc	r31, r25
    3f68:	31 97       	sbiw	r30, 0x01	; 1
    3f6a:	12 c0       	rjmp	.+36     	; 0x3f90 <read_line+0xda>
         }
         else{
           printxyd(sour_y,sour_x + char_counter,"_ ");
    3f6c:	62 0f       	add	r22, r18
    3f6e:	71 1d       	adc	r23, r1
    3f70:	83 2f       	mov	r24, r19
    3f72:	90 e0       	ldi	r25, 0x00	; 0
    3f74:	4b eb       	ldi	r20, 0xBB	; 187
    3f76:	50 e0       	ldi	r21, 0x00	; 0
    3f78:	0e 94 26 14 	call	0x284c	; 0x284c <printxyd>
           str[char_counter] = ' ';
    3f7c:	e0 91 bc 01 	lds	r30, 0x01BC
    3f80:	f0 91 bd 01 	lds	r31, 0x01BD
    3f84:	80 91 b7 01 	lds	r24, 0x01B7
    3f88:	90 91 b8 01 	lds	r25, 0x01B8
    3f8c:	e8 0f       	add	r30, r24
    3f8e:	f9 1f       	adc	r31, r25
    3f90:	80 e2       	ldi	r24, 0x20	; 32
    3f92:	80 83       	st	Z, r24
    3f94:	82 c0       	rjmp	.+260    	; 0x409a <read_line+0x1e4>
         }
       }
       break;
     case 4: //enter
       if ((char_counter == 0)&&(def_str != NULL)){
    3f96:	80 91 b7 01 	lds	r24, 0x01B7
    3f9a:	90 91 b8 01 	lds	r25, 0x01B8
    3f9e:	00 97       	sbiw	r24, 0x00	; 0
    3fa0:	91 f4       	brne	.+36     	; 0x3fc6 <read_line+0x110>
    3fa2:	60 91 b5 01 	lds	r22, 0x01B5
    3fa6:	70 91 b6 01 	lds	r23, 0x01B6
    3faa:	61 15       	cp	r22, r1
    3fac:	71 05       	cpc	r23, r1
    3fae:	59 f0       	breq	.+22     	; 0x3fc6 <read_line+0x110>
         strcpy(str,def_str);
    3fb0:	80 91 bc 01 	lds	r24, 0x01BC
    3fb4:	90 91 bd 01 	lds	r25, 0x01BD
    3fb8:	0e 94 37 33 	call	0x666e	; 0x666e <strcpy>
         free((void *)def_str);
    3fbc:	80 91 b5 01 	lds	r24, 0x01B5
    3fc0:	90 91 b6 01 	lds	r25, 0x01B6
    3fc4:	0f c0       	rjmp	.+30     	; 0x3fe4 <read_line+0x12e>
         def_str = NULL;
       }
       else {
         str[char_counter] = '\0';
    3fc6:	e0 91 bc 01 	lds	r30, 0x01BC
    3fca:	f0 91 bd 01 	lds	r31, 0x01BD
    3fce:	e8 0f       	add	r30, r24
    3fd0:	f9 1f       	adc	r31, r25
    3fd2:	10 82       	st	Z, r1
         if (def_str == NULL){
    3fd4:	80 91 b5 01 	lds	r24, 0x01B5
    3fd8:	90 91 b6 01 	lds	r25, 0x01B6
    3fdc:	89 2b       	or	r24, r25
    3fde:	41 f4       	brne	.+16     	; 0x3ff0 <read_line+0x13a>
           free((void *)def_str);
    3fe0:	80 e0       	ldi	r24, 0x00	; 0
    3fe2:	90 e0       	ldi	r25, 0x00	; 0
    3fe4:	0e 94 c6 32 	call	0x658c	; 0x658c <free>
           def_str = NULL;
    3fe8:	10 92 b6 01 	sts	0x01B6, r1
    3fec:	10 92 b5 01 	sts	0x01B5, r1
         }
       }
       return str;
    3ff0:	20 91 bc 01 	lds	r18, 0x01BC
    3ff4:	30 91 bd 01 	lds	r19, 0x01BD
    3ff8:	52 c0       	rjmp	.+164    	; 0x409e <read_line+0x1e8>
       break;
     case 21: // F11 - Strorno mÏ¯enÌ
       kf_zrusit();
    3ffa:	0e 94 09 32 	call	0x6412	; 0x6412 <kf_zrusit>
    3ffe:	4d c0       	rjmp	.+154    	; 0x409a <read_line+0x1e4>
       break;
     case 22: //F12
       // Odesl·nÌ dat.
       send_data();
    4000:	0e 94 3c 2f 	call	0x5e78	; 0x5e78 <send_data>
    4004:	4a c0       	rjmp	.+148    	; 0x409a <read_line+0x1e4>
     default:
       break;
     }
     
   }
   else if ((c[0] = get_char()) != 0){
    4006:	0e 94 bc 1c 	call	0x3978	; 0x3978 <get_char>
    400a:	e8 2f       	mov	r30, r24
    400c:	88 23       	and	r24, r24
    400e:	09 f4       	brne	.+2      	; 0x4012 <read_line+0x15c>
    4010:	44 c0       	rjmp	.+136    	; 0x409a <read_line+0x1e4>
     if (char_counter >= (max_len - 1)){
    4012:	40 91 b7 01 	lds	r20, 0x01B7
    4016:	50 91 b8 01 	lds	r21, 0x01B8
    401a:	80 91 b9 01 	lds	r24, 0x01B9
    401e:	90 e0       	ldi	r25, 0x00	; 0
    4020:	9c 01       	movw	r18, r24
    4022:	21 50       	subi	r18, 0x01	; 1
    4024:	30 40       	sbci	r19, 0x00	; 0
    4026:	42 17       	cp	r20, r18
    4028:	53 07       	cpc	r21, r19
    402a:	4c f0       	brlt	.+18     	; 0x403e <read_line+0x188>
       c[1] = '\0';
    402c:	1a 82       	std	Y+2, r1	; 0x02
       if (char_counter == max_len)
    402e:	48 17       	cp	r20, r24
    4030:	59 07       	cpc	r21, r25
    4032:	39 f4       	brne	.+14     	; 0x4042 <read_line+0x18c>
         char_counter--;
    4034:	30 93 b8 01 	sts	0x01B8, r19
    4038:	20 93 b7 01 	sts	0x01B7, r18
    403c:	02 c0       	rjmp	.+4      	; 0x4042 <read_line+0x18c>
     }
     else {
       c[1] = '_';
    403e:	8f e5       	ldi	r24, 0x5F	; 95
    4040:	8a 83       	std	Y+2, r24	; 0x02
     }
     printxyd(sour_y,sour_x + char_counter,c);
    4042:	80 91 bb 01 	lds	r24, 0x01BB
    4046:	90 91 ba 01 	lds	r25, 0x01BA
    404a:	60 91 b7 01 	lds	r22, 0x01B7
    404e:	70 91 b8 01 	lds	r23, 0x01B8
    4052:	69 0f       	add	r22, r25
    4054:	71 1d       	adc	r23, r1
     default:
       break;
     }
     
   }
   else if ((c[0] = get_char()) != 0){
    4056:	e9 83       	std	Y+1, r30	; 0x01
         char_counter--;
     }
     else {
       c[1] = '_';
     }
     printxyd(sour_y,sour_x + char_counter,c);
    4058:	90 e0       	ldi	r25, 0x00	; 0
    405a:	ae 01       	movw	r20, r28
    405c:	4f 5f       	subi	r20, 0xFF	; 255
    405e:	5f 4f       	sbci	r21, 0xFF	; 255
    4060:	0e 94 26 14 	call	0x284c	; 0x284c <printxyd>
     str[char_counter] = c[0];
    4064:	20 91 b7 01 	lds	r18, 0x01B7
    4068:	30 91 b8 01 	lds	r19, 0x01B8
    406c:	e0 91 bc 01 	lds	r30, 0x01BC
    4070:	f0 91 bd 01 	lds	r31, 0x01BD
    4074:	e2 0f       	add	r30, r18
    4076:	f3 1f       	adc	r31, r19
    4078:	89 81       	ldd	r24, Y+1	; 0x01
    407a:	80 83       	st	Z, r24
     if ((xpchc < (LCD_X_MAX - 1))&&(char_counter < max_len)){
    407c:	10 0f       	add	r17, r16
    407e:	17 32       	cpi	r17, 0x27	; 39
    4080:	60 f4       	brcc	.+24     	; 0x409a <read_line+0x1e4>
    4082:	80 91 b9 01 	lds	r24, 0x01B9
    4086:	90 e0       	ldi	r25, 0x00	; 0
    4088:	28 17       	cp	r18, r24
    408a:	39 07       	cpc	r19, r25
    408c:	34 f4       	brge	.+12     	; 0x409a <read_line+0x1e4>
       char_counter++;
    408e:	2f 5f       	subi	r18, 0xFF	; 255
    4090:	3f 4f       	sbci	r19, 0xFF	; 255
    4092:	30 93 b8 01 	sts	0x01B8, r19
    4096:	20 93 b7 01 	sts	0x01B7, r18
    409a:	20 e0       	ldi	r18, 0x00	; 0
    409c:	30 e0       	ldi	r19, 0x00	; 0
     }
   }
   return NULL;
 }
    409e:	c9 01       	movw	r24, r18
    40a0:	0f 90       	pop	r0
    40a2:	0f 90       	pop	r0
    40a4:	0f 90       	pop	r0
    40a6:	cf 91       	pop	r28
    40a8:	df 91       	pop	r29
    40aa:	1f 91       	pop	r17
    40ac:	0f 91       	pop	r16
    40ae:	08 95       	ret

000040b0 <read_line_init_edefault>:
/**
 * Funkce zah·jÌ zad·v·nÌ ¯etÏzce stejnÏ jako read_line_init.
 * RozdÌlem vöak je, ûe v p¯ÌpadÏ, ûe je zad·v·nÌ ukonËeno enterem p¯i nulovÈ dÈlce,
 * je nastavena defaultnÌÌ hodnota ¯eùÏzce, kter· je zÌsk·na z poË·teËnÌho stavu.
 */
void read_line_init_edefault(int y, int x, char *s,char len){ 
    40b0:	ef 92       	push	r14
    40b2:	ff 92       	push	r15
    40b4:	0f 93       	push	r16
    40b6:	1f 93       	push	r17
    40b8:	cf 93       	push	r28
    40ba:	df 93       	push	r29
    40bc:	f8 2e       	mov	r15, r24
    40be:	e9 2e       	mov	r14, r25
    40c0:	eb 01       	movw	r28, r22
    40c2:	14 2f       	mov	r17, r20
    40c4:	05 2f       	mov	r16, r21
  int i;
  
  char_counter = 0;
    40c6:	10 92 b8 01 	sts	0x01B8, r1
    40ca:	10 92 b7 01 	sts	0x01B7, r1
  max_len = len; //(char) strlen(s);
    40ce:	20 93 b9 01 	sts	0x01B9, r18
  def_str = mmalloc(strlen(s) + 1);
    40d2:	e4 2f       	mov	r30, r20
    40d4:	f5 2f       	mov	r31, r21
    40d6:	df 01       	movw	r26, r30
    40d8:	0d 90       	ld	r0, X+
    40da:	00 20       	and	r0, r0
    40dc:	e9 f7       	brne	.-6      	; 0x40d8 <read_line_init_edefault+0x28>
    40de:	cd 01       	movw	r24, r26
    40e0:	8e 1b       	sub	r24, r30
    40e2:	9f 0b       	sbc	r25, r31
    40e4:	0e 94 c1 06 	call	0xd82	; 0xd82 <mmalloc>
    40e8:	80 93 b5 01 	sts	0x01B5, r24
    40ec:	90 93 b6 01 	sts	0x01B6, r25
  strcpy(def_str, s);
    40f0:	61 2f       	mov	r22, r17
    40f2:	70 2f       	mov	r23, r16
    40f4:	0e 94 37 33 	call	0x666e	; 0x666e <strcpy>
  sour_x = x;
    40f8:	c0 93 ba 01 	sts	0x01BA, r28
  sour_y = y;
    40fc:	f0 92 bb 01 	sts	0x01BB, r15
  str = s;
    4100:	10 93 bc 01 	sts	0x01BC, r17
    4104:	00 93 bd 01 	sts	0x01BD, r16
    4108:	00 e0       	ldi	r16, 0x00	; 0
    410a:	10 e0       	ldi	r17, 0x00	; 0
    410c:	0a c0       	rjmp	.+20     	; 0x4122 <read_line_init_edefault+0x72>
  for (i = 0; i < max_len ; i++){
    printcxyd(y,x + i,' ');
    410e:	b8 01       	movw	r22, r16
    4110:	6c 0f       	add	r22, r28
    4112:	7d 1f       	adc	r23, r29
    4114:	8f 2d       	mov	r24, r15
    4116:	9e 2d       	mov	r25, r14
    4118:	40 e2       	ldi	r20, 0x20	; 32
    411a:	0e 94 fc 11 	call	0x23f8	; 0x23f8 <printcxyd>
  def_str = mmalloc(strlen(s) + 1);
  strcpy(def_str, s);
  sour_x = x;
  sour_y = y;
  str = s;
  for (i = 0; i < max_len ; i++){
    411e:	0f 5f       	subi	r16, 0xFF	; 255
    4120:	1f 4f       	sbci	r17, 0xFF	; 255
    4122:	80 91 b9 01 	lds	r24, 0x01B9
    4126:	90 e0       	ldi	r25, 0x00	; 0
    4128:	08 17       	cp	r16, r24
    412a:	19 07       	cpc	r17, r25
    412c:	84 f3       	brlt	.-32     	; 0x410e <read_line_init_edefault+0x5e>
    printcxyd(y,x + i,' ');
  }
  if (char_counter + sour_x < (LCD_X_MAX - 1)){
    412e:	80 91 ba 01 	lds	r24, 0x01BA
    4132:	60 91 b7 01 	lds	r22, 0x01B7
    4136:	70 91 b8 01 	lds	r23, 0x01B8
    413a:	68 0f       	add	r22, r24
    413c:	71 1d       	adc	r23, r1
    413e:	67 32       	cpi	r22, 0x27	; 39
    4140:	71 05       	cpc	r23, r1
    4142:	3c f4       	brge	.+14     	; 0x4152 <read_line_init_edefault+0xa2>
    printxyd(sour_y,char_counter + sour_x,"_");
    4144:	80 91 bb 01 	lds	r24, 0x01BB
    4148:	90 e0       	ldi	r25, 0x00	; 0
    414a:	48 eb       	ldi	r20, 0xB8	; 184
    414c:	50 e0       	ldi	r21, 0x00	; 0
    414e:	0e 94 26 14 	call	0x284c	; 0x284c <printxyd>
  }

}
    4152:	df 91       	pop	r29
    4154:	cf 91       	pop	r28
    4156:	1f 91       	pop	r17
    4158:	0f 91       	pop	r16
    415a:	ff 90       	pop	r15
    415c:	ef 90       	pop	r14
    415e:	08 95       	ret

00004160 <save_menu_values>:

void save_menu_values(void){
  int i = 0;
  
  for (i=0; i < VELIKOST_MENU_HODNOT; i++){
    menu_values[i] = menu[i] -> val;
    4160:	e0 91 c4 01 	lds	r30, 0x01C4
    4164:	f0 91 c5 01 	lds	r31, 0x01C5
    4168:	85 81       	ldd	r24, Z+5	; 0x05
    416a:	80 93 be 01 	sts	0x01BE, r24
    416e:	e0 91 c6 01 	lds	r30, 0x01C6
    4172:	f0 91 c7 01 	lds	r31, 0x01C7
    4176:	85 81       	ldd	r24, Z+5	; 0x05
    4178:	80 93 bf 01 	sts	0x01BF, r24
    417c:	e0 91 c8 01 	lds	r30, 0x01C8
    4180:	f0 91 c9 01 	lds	r31, 0x01C9
    4184:	85 81       	ldd	r24, Z+5	; 0x05
    4186:	80 93 c0 01 	sts	0x01C0, r24
    418a:	e0 91 ca 01 	lds	r30, 0x01CA
    418e:	f0 91 cb 01 	lds	r31, 0x01CB
    4192:	85 81       	ldd	r24, Z+5	; 0x05
    4194:	80 93 c1 01 	sts	0x01C1, r24
    4198:	e0 91 cc 01 	lds	r30, 0x01CC
    419c:	f0 91 cd 01 	lds	r31, 0x01CD
    41a0:	85 81       	ldd	r24, Z+5	; 0x05
    41a2:	80 93 c2 01 	sts	0x01C2, r24
  }
}
    41a6:	08 95       	ret

000041a8 <load_menu_values>:

void load_menu_values(void){
  int i = 0;
  
  for (i=0; i < VELIKOST_MENU_HODNOT; i++){
    menu[i] -> val = menu_values[i];
    41a8:	e0 91 c4 01 	lds	r30, 0x01C4
    41ac:	f0 91 c5 01 	lds	r31, 0x01C5
    41b0:	80 91 be 01 	lds	r24, 0x01BE
    41b4:	85 83       	std	Z+5, r24	; 0x05
    41b6:	e0 91 c6 01 	lds	r30, 0x01C6
    41ba:	f0 91 c7 01 	lds	r31, 0x01C7
    41be:	80 91 bf 01 	lds	r24, 0x01BF
    41c2:	85 83       	std	Z+5, r24	; 0x05
    41c4:	e0 91 c8 01 	lds	r30, 0x01C8
    41c8:	f0 91 c9 01 	lds	r31, 0x01C9
    41cc:	80 91 c0 01 	lds	r24, 0x01C0
    41d0:	85 83       	std	Z+5, r24	; 0x05
    41d2:	e0 91 ca 01 	lds	r30, 0x01CA
    41d6:	f0 91 cb 01 	lds	r31, 0x01CB
    41da:	80 91 c1 01 	lds	r24, 0x01C1
    41de:	85 83       	std	Z+5, r24	; 0x05
    41e0:	e0 91 cc 01 	lds	r30, 0x01CC
    41e4:	f0 91 cd 01 	lds	r31, 0x01CD
    41e8:	80 91 c2 01 	lds	r24, 0x01C2
    41ec:	85 83       	std	Z+5, r24	; 0x05
  }
}
    41ee:	08 95       	ret

000041f0 <measure_scr_init>:
//  m_jmena[MAX_ZAKAZNIK] = menu_pridat;


  //menu_jmena_i = &(menu[0] -> val);

}
    41f0:	08 95       	ret

000041f2 <get_stored_menu_jmena_i>:
  else {
    return menu_values[0];
  }
*/
  return menu_values[0];
}
    41f2:	80 91 be 01 	lds	r24, 0x01BE
    41f6:	08 95       	ret

000041f8 <get_menu_jmena_i>:
 * @warning 
 * V nÏkter˝ch situacÌch je vhodnÏjöÌ volat funkce get_stored_menu_jmena_i().
 * Jedn· se zejmÈna o situace bÏhem p¯epÌn·nÌ obrazovek.
 */ 
unsigned char get_menu_jmena_i(void){
  if (akt_scr == MSR_SCR){
    41f8:	80 91 a5 01 	lds	r24, 0x01A5
    41fc:	88 23       	and	r24, r24
    41fe:	31 f4       	brne	.+12     	; 0x420c <get_menu_jmena_i+0x14>
    return menu[0] -> val;
    4200:	e0 91 c4 01 	lds	r30, 0x01C4
    4204:	f0 91 c5 01 	lds	r31, 0x01C5
    4208:	85 81       	ldd	r24, Z+5	; 0x05
    420a:	08 95       	ret
  }
  else {
    return menu_values[0];
    420c:	80 91 be 01 	lds	r24, 0x01BE
  }
}
    4210:	08 95       	ret

00004212 <set_menu_jmena_i>:
/**
 * Funkce slouûÌ k nastavenÌ aktu·lnÌho z·kaznÌka z vnÏjöku.
 * Nap¯Ìklad ji vyuûÌv· modul pro vykreslov·nÌ seznamu
 * dneönÌch z·kaznÌk˘.
 */
void set_menu_jmena_i(unsigned char i){
    4212:	98 2f       	mov	r25, r24
  if (akt_scr == MSR_SCR){
    4214:	80 91 a5 01 	lds	r24, 0x01A5
    4218:	88 23       	and	r24, r24
    421a:	31 f4       	brne	.+12     	; 0x4228 <set_menu_jmena_i+0x16>
    menu[0] -> val = i;
    421c:	e0 91 c4 01 	lds	r30, 0x01C4
    4220:	f0 91 c5 01 	lds	r31, 0x01C5
    4224:	95 83       	std	Z+5, r25	; 0x05
    4226:	08 95       	ret
  }
  else{
    menu_values[0] = i;
    4228:	90 93 be 01 	sts	0x01BE, r25
    422c:	08 95       	ret

0000422e <uloz_posledni_data>:
 * uloûenÌ a pak je i uloûit.
 * Je vol·na po stisknutÌ tlaËÌtek pro zah·jenÌ mÏ¯enÌ, nebo pro konec mÏ¯enÌ,
 * nebo pak z vnÏjöku v p¯ÌpadÏ v˝padku nap·jenÌ, aby nez˘stal poslednÌ
 * z·znam neuloûen˝,
 * */
  void uloz_posledni_data(void){
    422e:	0f 93       	push	r16
    4230:	1f 93       	push	r17
    if ((msr_status == ZMERENY_PRUMERY)&&((menu[0] -> val != 255))){ ///@todo zauvaûovat jestli by se nemÏl
    4232:	80 91 44 01 	lds	r24, 0x0144
    4236:	83 30       	cpi	r24, 0x03	; 3
    4238:	91 f5       	brne	.+100    	; 0x429e <uloz_posledni_data+0x70>
    423a:	e0 91 c4 01 	lds	r30, 0x01C4
    423e:	f0 91 c5 01 	lds	r31, 0x01C5
    4242:	55 81       	ldd	r21, Z+5	; 0x05
    4244:	5f 3f       	cpi	r21, 0xFF	; 255
    4246:	59 f1       	breq	.+86     	; 0x429e <uloz_posledni_data+0x70>
								     ///ukl·dat i bezejmen˝
    char scr_zakaznik = menu[0] -> val;
    char scr_drevo = menu[1] -> val;
    char scr_operace = 0 | (((menu[2] -> val) & 1) << 3);
    scr_operace |= ((menu[3] -> val) & 3) << 1;
    scr_operace |= (menu[4] -> val) & 1;
    4248:	e0 91 c8 01 	lds	r30, 0x01C8
    424c:	f0 91 c9 01 	lds	r31, 0x01C9
    4250:	45 81       	ldd	r20, Z+5	; 0x05
    4252:	41 70       	andi	r20, 0x01	; 1
    4254:	44 0f       	add	r20, r20
    4256:	44 0f       	add	r20, r20
    4258:	44 0f       	add	r20, r20
    425a:	e0 91 cc 01 	lds	r30, 0x01CC
    425e:	f0 91 cd 01 	lds	r31, 0x01CD
    4262:	85 81       	ldd	r24, Z+5	; 0x05
    4264:	81 70       	andi	r24, 0x01	; 1
    4266:	48 2b       	or	r20, r24
    4268:	e0 91 ca 01 	lds	r30, 0x01CA
    426c:	f0 91 cb 01 	lds	r31, 0x01CB
    4270:	85 81       	ldd	r24, Z+5	; 0x05
    4272:	90 e0       	ldi	r25, 0x00	; 0
    4274:	83 70       	andi	r24, 0x03	; 3
    4276:	90 70       	andi	r25, 0x00	; 0
    4278:	88 0f       	add	r24, r24
    427a:	99 1f       	adc	r25, r25
    427c:	48 2b       	or	r20, r24
    
    new_record(scr_zakaznik, scr_drevo, scr_operace, msr_delka, msr_prumer);
    427e:	e0 91 c6 01 	lds	r30, 0x01C6
    4282:	f0 91 c7 01 	lds	r31, 0x01C7
    4286:	20 91 3e 01 	lds	r18, 0x013E
    428a:	30 91 3f 01 	lds	r19, 0x013F
    428e:	00 91 40 01 	lds	r16, 0x0140
    4292:	10 91 41 01 	lds	r17, 0x0141
    4296:	85 2f       	mov	r24, r21
    4298:	65 81       	ldd	r22, Z+5	; 0x05
    429a:	0e 94 10 17 	call	0x2e20	; 0x2e20 <new_record>
  }
}
    429e:	1f 91       	pop	r17
    42a0:	0f 91       	pop	r16
    42a2:	08 95       	ret

000042a4 <measure_scr_close>:
  menu[5] -> val = 255;

  load_menu_values();
}

void measure_scr_close(void){
    42a4:	cf 93       	push	r28
    42a6:	df 93       	push	r29

void save_menu_values(void){
  int i = 0;
  
  for (i=0; i < VELIKOST_MENU_HODNOT; i++){
    menu_values[i] = menu[i] -> val;
    42a8:	e0 91 c4 01 	lds	r30, 0x01C4
    42ac:	f0 91 c5 01 	lds	r31, 0x01C5
    42b0:	85 81       	ldd	r24, Z+5	; 0x05
    42b2:	80 93 be 01 	sts	0x01BE, r24
    42b6:	e0 91 c6 01 	lds	r30, 0x01C6
    42ba:	f0 91 c7 01 	lds	r31, 0x01C7
    42be:	85 81       	ldd	r24, Z+5	; 0x05
    42c0:	80 93 bf 01 	sts	0x01BF, r24
    42c4:	e0 91 c8 01 	lds	r30, 0x01C8
    42c8:	f0 91 c9 01 	lds	r31, 0x01C9
    42cc:	85 81       	ldd	r24, Z+5	; 0x05
    42ce:	80 93 c0 01 	sts	0x01C0, r24
    42d2:	e0 91 ca 01 	lds	r30, 0x01CA
    42d6:	f0 91 cb 01 	lds	r31, 0x01CB
    42da:	85 81       	ldd	r24, Z+5	; 0x05
    42dc:	80 93 c1 01 	sts	0x01C1, r24
    42e0:	e0 91 cc 01 	lds	r30, 0x01CC
    42e4:	f0 91 cd 01 	lds	r31, 0x01CD
    42e8:	85 81       	ldd	r24, Z+5	; 0x05
    42ea:	80 93 c2 01 	sts	0x01C2, r24
    42ee:	c4 ec       	ldi	r28, 0xC4	; 196
    42f0:	d1 e0       	ldi	r29, 0x01	; 1
  int i = 0;

  save_menu_values();

  for (i = 0; i < VELIKOST_MENU; i++){
    free((void *)menu[i]);
    42f2:	88 81       	ld	r24, Y
    42f4:	99 81       	ldd	r25, Y+1	; 0x01
    42f6:	0e 94 c6 32 	call	0x658c	; 0x658c <free>
    menu[i] = NULL;
    42fa:	19 92       	st	Y+, r1
    42fc:	19 92       	st	Y+, r1
void measure_scr_close(void){
  int i = 0;

  save_menu_values();

  for (i = 0; i < VELIKOST_MENU; i++){
    42fe:	81 e0       	ldi	r24, 0x01	; 1
    4300:	c0 3d       	cpi	r28, 0xD0	; 208
    4302:	d8 07       	cpc	r29, r24
    4304:	b1 f7       	brne	.-20     	; 0x42f2 <measure_scr_close+0x4e>
    free((void *)menu[i]);
    menu[i] = NULL;
  }
  
}
    4306:	df 91       	pop	r29
    4308:	cf 91       	pop	r28
    430a:	08 95       	ret

0000430c <measure_scr_draw>:



void measure_scr_draw(void){
  clear_dscreen();
    430c:	0e 94 9e 11 	call	0x233c	; 0x233c <clear_dscreen>
  akt_scr = MSR_SCR;
    4310:	10 92 a5 01 	sts	0x01A5, r1
  printxyd(0,0, strcpy_P(str_buf,s_zakz));
    4314:	85 e2       	ldi	r24, 0x25	; 37
    4316:	92 e0       	ldi	r25, 0x02	; 2
    4318:	69 ee       	ldi	r22, 0xE9	; 233
    431a:	7a e0       	ldi	r23, 0x0A	; 10
    431c:	0e 94 27 33 	call	0x664e	; 0x664e <strcpy_P>
    4320:	ac 01       	movw	r20, r24
    4322:	80 e0       	ldi	r24, 0x00	; 0
    4324:	90 e0       	ldi	r25, 0x00	; 0
    4326:	60 e0       	ldi	r22, 0x00	; 0
    4328:	70 e0       	ldi	r23, 0x00	; 0
    432a:	0e 94 26 14 	call	0x284c	; 0x284c <printxyd>
  printxyd(1,0, strcpy_P(str_buf,s_drev));
    432e:	85 e2       	ldi	r24, 0x25	; 37
    4330:	92 e0       	ldi	r25, 0x02	; 2
    4332:	6e ee       	ldi	r22, 0xEE	; 238
    4334:	7a e0       	ldi	r23, 0x0A	; 10
    4336:	0e 94 27 33 	call	0x664e	; 0x664e <strcpy_P>
    433a:	ac 01       	movw	r20, r24
    433c:	81 e0       	ldi	r24, 0x01	; 1
    433e:	90 e0       	ldi	r25, 0x00	; 0
    4340:	60 e0       	ldi	r22, 0x00	; 0
    4342:	70 e0       	ldi	r23, 0x00	; 0
    4344:	0e 94 26 14 	call	0x284c	; 0x284c <printxyd>
  printxyd(2,0, strcpy_P(str_buf,s_oper));
    4348:	85 e2       	ldi	r24, 0x25	; 37
    434a:	92 e0       	ldi	r25, 0x02	; 2
    434c:	63 ef       	ldi	r22, 0xF3	; 243
    434e:	7a e0       	ldi	r23, 0x0A	; 10
    4350:	0e 94 27 33 	call	0x664e	; 0x664e <strcpy_P>
    4354:	ac 01       	movw	r20, r24
    4356:	82 e0       	ldi	r24, 0x02	; 2
    4358:	90 e0       	ldi	r25, 0x00	; 0
    435a:	60 e0       	ldi	r22, 0x00	; 0
    435c:	70 e0       	ldi	r23, 0x00	; 0
    435e:	0e 94 26 14 	call	0x284c	; 0x284c <printxyd>
  printxyd_P(3,0, (void*) s_dat_scr);
    4362:	83 e0       	ldi	r24, 0x03	; 3
    4364:	90 e0       	ldi	r25, 0x00	; 0
    4366:	60 e0       	ldi	r22, 0x00	; 0
    4368:	70 e0       	ldi	r23, 0x00	; 0
    436a:	48 ef       	ldi	r20, 0xF8	; 248
    436c:	5a e0       	ldi	r21, 0x0A	; 10
    436e:	0e 94 47 13 	call	0x268e	; 0x268e <printxyd_P>

  printxyd(1, 25, strcpy_P(str_buf,s_delka));
    4372:	85 e2       	ldi	r24, 0x25	; 37
    4374:	92 e0       	ldi	r25, 0x02	; 2
    4376:	6d ef       	ldi	r22, 0xFD	; 253
    4378:	7a e0       	ldi	r23, 0x0A	; 10
    437a:	0e 94 27 33 	call	0x664e	; 0x664e <strcpy_P>
    437e:	ac 01       	movw	r20, r24
    4380:	81 e0       	ldi	r24, 0x01	; 1
    4382:	90 e0       	ldi	r25, 0x00	; 0
    4384:	69 e1       	ldi	r22, 0x19	; 25
    4386:	70 e0       	ldi	r23, 0x00	; 0
    4388:	0e 94 26 14 	call	0x284c	; 0x284c <printxyd>
  printxyd(2, 25, strcpy_P(str_buf,s_prumer_v));
    438c:	85 e2       	ldi	r24, 0x25	; 37
    438e:	92 e0       	ldi	r25, 0x02	; 2
    4390:	63 e0       	ldi	r22, 0x03	; 3
    4392:	7b e0       	ldi	r23, 0x0B	; 11
    4394:	0e 94 27 33 	call	0x664e	; 0x664e <strcpy_P>
    4398:	ac 01       	movw	r20, r24
    439a:	82 e0       	ldi	r24, 0x02	; 2
    439c:	90 e0       	ldi	r25, 0x00	; 0
    439e:	69 e1       	ldi	r22, 0x19	; 25
    43a0:	70 e0       	ldi	r23, 0x00	; 0
    43a2:	0e 94 26 14 	call	0x284c	; 0x284c <printxyd>
  if (width_src > 0){
    43a6:	80 91 60 00 	lds	r24, 0x0060
    43aa:	88 23       	and	r24, r24
    43ac:	a1 f0       	breq	.+40     	; 0x43d6 <measure_scr_draw+0xca>
    printxyd(3, 25, strcpy_P(str_buf,s_prumer_h));
    43ae:	85 e2       	ldi	r24, 0x25	; 37
    43b0:	92 e0       	ldi	r25, 0x02	; 2
    43b2:	6a e0       	ldi	r22, 0x0A	; 10
    43b4:	7b e0       	ldi	r23, 0x0B	; 11
    43b6:	0e 94 27 33 	call	0x664e	; 0x664e <strcpy_P>
    43ba:	ac 01       	movw	r20, r24
    43bc:	83 e0       	ldi	r24, 0x03	; 3
    43be:	90 e0       	ldi	r25, 0x00	; 0
    43c0:	69 e1       	ldi	r22, 0x19	; 25
    43c2:	70 e0       	ldi	r23, 0x00	; 0
    43c4:	0e 94 26 14 	call	0x284c	; 0x284c <printxyd>
    printcxyd(3,37, '.');
    43c8:	83 e0       	ldi	r24, 0x03	; 3
    43ca:	90 e0       	ldi	r25, 0x00	; 0
    43cc:	65 e2       	ldi	r22, 0x25	; 37
    43ce:	70 e0       	ldi	r23, 0x00	; 0
    43d0:	4e e2       	ldi	r20, 0x2E	; 46
    43d2:	0e 94 fc 11 	call	0x23f8	; 0x23f8 <printcxyd>
  }

  printcxyd(1,37, '.');
    43d6:	81 e0       	ldi	r24, 0x01	; 1
    43d8:	90 e0       	ldi	r25, 0x00	; 0
    43da:	65 e2       	ldi	r22, 0x25	; 37
    43dc:	70 e0       	ldi	r23, 0x00	; 0
    43de:	4e e2       	ldi	r20, 0x2E	; 46
    43e0:	0e 94 fc 11 	call	0x23f8	; 0x23f8 <printcxyd>
  printcxyd(2,37, '.');
    43e4:	82 e0       	ldi	r24, 0x02	; 2
    43e6:	90 e0       	ldi	r25, 0x00	; 0
    43e8:	65 e2       	ldi	r22, 0x25	; 37
    43ea:	70 e0       	ldi	r23, 0x00	; 0
    43ec:	4e e2       	ldi	r20, 0x2E	; 46
    43ee:	0e 94 fc 11 	call	0x23f8	; 0x23f8 <printcxyd>

  menu_draw(menu,VELIKOST_MENU,menu_i);
    43f2:	84 ec       	ldi	r24, 0xC4	; 196
    43f4:	91 e0       	ldi	r25, 0x01	; 1
    43f6:	66 e0       	ldi	r22, 0x06	; 6
    43f8:	40 91 c3 01 	lds	r20, 0x01C3
    43fc:	0e 94 66 1e 	call	0x3ccc	; 0x3ccc <menu_draw>

}
    4400:	08 95       	ret

00004402 <measure_scr_control>:
/// Funkce udrûuje LCD aktu·lnÌ. Vykresluje nep¯etrûitÏ spr·vnÈ ˙daje.
/// Na konci je vol·na funkce pro kontrolu kl·vesnice.
/// @todo Bylo by moûnÈ zde zÌskat rychlost. ÿada ˙daj˘ se vykresluje
/// nep¯etrûitÏ, p¯itom by staËilo je aktualizovat poze p¯i zmÏnÏ
/// promÏnnÈ msr_status.
void measure_scr_control(void){
    4402:	cf 93       	push	r28
    4404:	df 93       	push	r29
  //uint16_t l,d_v,d_h;

// vykreslov·nÌ stavu
  switch (msr_status){
    4406:	80 91 44 01 	lds	r24, 0x0144
    440a:	83 30       	cpi	r24, 0x03	; 3
    440c:	d1 f0       	breq	.+52     	; 0x4442 <measure_scr_control+0x40>
    440e:	84 30       	cpi	r24, 0x04	; 4
    4410:	28 f4       	brcc	.+10     	; 0x441c <measure_scr_control+0x1a>
    4412:	81 30       	cpi	r24, 0x01	; 1
    4414:	31 f0       	breq	.+12     	; 0x4422 <measure_scr_control+0x20>
    4416:	82 30       	cpi	r24, 0x02	; 2
    4418:	11 f5       	brne	.+68     	; 0x445e <measure_scr_control+0x5c>
    441a:	0a c0       	rjmp	.+20     	; 0x4430 <measure_scr_control+0x2e>
    441c:	86 30       	cpi	r24, 0x06	; 6
    441e:	f8 f4       	brcc	.+62     	; 0x445e <measure_scr_control+0x5c>
    4420:	17 c0       	rjmp	.+46     	; 0x4450 <measure_scr_control+0x4e>
  case L_NEZMERENO:
    printxyd_P(0,20,(void *)s_msr_zahajeno);
    4422:	80 e0       	ldi	r24, 0x00	; 0
    4424:	90 e0       	ldi	r25, 0x00	; 0
    4426:	64 e1       	ldi	r22, 0x14	; 20
    4428:	70 e0       	ldi	r23, 0x00	; 0
    442a:	45 e7       	ldi	r20, 0x75	; 117
    442c:	5a e0       	ldi	r21, 0x0A	; 10
    442e:	06 c0       	rjmp	.+12     	; 0x443c <measure_scr_control+0x3a>
    break;
  case L_ZMERENO:
    printxyd_P(0,20,(void *)s_msr_delka);
    4430:	80 e0       	ldi	r24, 0x00	; 0
    4432:	90 e0       	ldi	r25, 0x00	; 0
    4434:	64 e1       	ldi	r22, 0x14	; 20
    4436:	70 e0       	ldi	r23, 0x00	; 0
    4438:	48 e8       	ldi	r20, 0x88	; 136
    443a:	5a e0       	ldi	r21, 0x0A	; 10
    443c:	0e 94 47 13 	call	0x268e	; 0x268e <printxyd_P>
    4440:	1a c0       	rjmp	.+52     	; 0x4476 <measure_scr_control+0x74>
    break;
  case ZMERENY_PRUMERY:
    printxyd_P(0,20,(void *)s_msr_domereno);
    4442:	80 e0       	ldi	r24, 0x00	; 0
    4444:	90 e0       	ldi	r25, 0x00	; 0
    4446:	64 e1       	ldi	r22, 0x14	; 20
    4448:	70 e0       	ldi	r23, 0x00	; 0
    444a:	4b e9       	ldi	r20, 0x9B	; 155
    444c:	5a e0       	ldi	r21, 0x0A	; 10
    444e:	f6 cf       	rjmp	.-20     	; 0x443c <measure_scr_control+0x3a>
    break;
  case PAUSE_L_NEZMERENO:
  case PAUSE_L_ZMERENO:
    printxyd_P(0,20,(void *)s_msr_pause);
    4450:	80 e0       	ldi	r24, 0x00	; 0
    4452:	90 e0       	ldi	r25, 0x00	; 0
    4454:	64 e1       	ldi	r22, 0x14	; 20
    4456:	70 e0       	ldi	r23, 0x00	; 0
    4458:	4e ea       	ldi	r20, 0xAE	; 174
    445a:	5a e0       	ldi	r21, 0x0A	; 10
    445c:	ef cf       	rjmp	.-34     	; 0x443c <measure_scr_control+0x3a>
    break;
  default:
    printxyd(0,20,mezery(str_buf,20));
    445e:	85 e2       	ldi	r24, 0x25	; 37
    4460:	92 e0       	ldi	r25, 0x02	; 2
    4462:	64 e1       	ldi	r22, 0x14	; 20
    4464:	0e 94 3a 14 	call	0x2874	; 0x2874 <mezery>
    4468:	ac 01       	movw	r20, r24
    446a:	80 e0       	ldi	r24, 0x00	; 0
    446c:	90 e0       	ldi	r25, 0x00	; 0
    446e:	64 e1       	ldi	r22, 0x14	; 20
    4470:	70 e0       	ldi	r23, 0x00	; 0
    4472:	0e 94 26 14 	call	0x284c	; 0x284c <printxyd>
    break;
  }

  if (msr_status >= L_ZMERENO){
    4476:	80 91 44 01 	lds	r24, 0x0144
    447a:	82 30       	cpi	r24, 0x02	; 2
    447c:	d0 f1       	brcs	.+116    	; 0x44f2 <measure_scr_control+0xf0>
    //l = msr_delka;
    printxyd(1,19, int2strn(str_buf,2,(msr_delka / 100)));
    447e:	80 91 3e 01 	lds	r24, 0x013E
    4482:	90 91 3f 01 	lds	r25, 0x013F
    4486:	64 e6       	ldi	r22, 0x64	; 100
    4488:	70 e0       	ldi	r23, 0x00	; 0
    448a:	0e 94 82 3b 	call	0x7704	; 0x7704 <__udivmodhi4>
    448e:	ab 01       	movw	r20, r22
    4490:	85 e2       	ldi	r24, 0x25	; 37
    4492:	92 e0       	ldi	r25, 0x02	; 2
    4494:	62 e0       	ldi	r22, 0x02	; 2
    4496:	70 e0       	ldi	r23, 0x00	; 0
    4498:	0e 94 5d 14 	call	0x28ba	; 0x28ba <int2strn>
    449c:	ac 01       	movw	r20, r24
    449e:	81 e0       	ldi	r24, 0x01	; 1
    44a0:	90 e0       	ldi	r25, 0x00	; 0
    44a2:	63 e1       	ldi	r22, 0x13	; 19
    44a4:	70 e0       	ldi	r23, 0x00	; 0
    44a6:	0e 94 26 14 	call	0x284c	; 0x284c <printxyd>
    str_buf[0] = '0';
    44aa:	80 e3       	ldi	r24, 0x30	; 48
    44ac:	80 93 25 02 	sts	0x0225, r24
    printxyd(1,22, int2strn(str_buf,2,(msr_delka % 100)));
    44b0:	80 91 3e 01 	lds	r24, 0x013E
    44b4:	90 91 3f 01 	lds	r25, 0x013F
    44b8:	64 e6       	ldi	r22, 0x64	; 100
    44ba:	70 e0       	ldi	r23, 0x00	; 0
    44bc:	0e 94 82 3b 	call	0x7704	; 0x7704 <__udivmodhi4>
    44c0:	ac 01       	movw	r20, r24
    44c2:	85 e2       	ldi	r24, 0x25	; 37
    44c4:	92 e0       	ldi	r25, 0x02	; 2
    44c6:	62 e0       	ldi	r22, 0x02	; 2
    44c8:	70 e0       	ldi	r23, 0x00	; 0
    44ca:	0e 94 5d 14 	call	0x28ba	; 0x28ba <int2strn>
    44ce:	ac 01       	movw	r20, r24
    44d0:	81 e0       	ldi	r24, 0x01	; 1
    44d2:	90 e0       	ldi	r25, 0x00	; 0
    44d4:	66 e1       	ldi	r22, 0x16	; 22
    44d6:	70 e0       	ldi	r23, 0x00	; 0
    44d8:	0e 94 26 14 	call	0x284c	; 0x284c <printxyd>
    printcxyd(1,21,'.');
    44dc:	81 e0       	ldi	r24, 0x01	; 1
    44de:	90 e0       	ldi	r25, 0x00	; 0
    44e0:	65 e1       	ldi	r22, 0x15	; 21
    44e2:	70 e0       	ldi	r23, 0x00	; 0
    44e4:	4e e2       	ldi	r20, 0x2E	; 46
    44e6:	0e 94 fc 11 	call	0x23f8	; 0x23f8 <printcxyd>
    str_buf[0] = ' ';
    44ea:	80 e2       	ldi	r24, 0x20	; 32
    44ec:	80 93 25 02 	sts	0x0225, r24
    44f0:	0c c0       	rjmp	.+24     	; 0x450a <measure_scr_control+0x108>

  }
  else{
    printxyd(1,18,mezery(str_buf,7));
    44f2:	85 e2       	ldi	r24, 0x25	; 37
    44f4:	92 e0       	ldi	r25, 0x02	; 2
    44f6:	67 e0       	ldi	r22, 0x07	; 7
    44f8:	0e 94 3a 14 	call	0x2874	; 0x2874 <mezery>
    44fc:	ac 01       	movw	r20, r24
    44fe:	81 e0       	ldi	r24, 0x01	; 1
    4500:	90 e0       	ldi	r25, 0x00	; 0
    4502:	62 e1       	ldi	r22, 0x12	; 18
    4504:	70 e0       	ldi	r23, 0x00	; 0
    4506:	0e 94 26 14 	call	0x284c	; 0x284c <printxyd>
//    l = irc_get_l();
  }
  
  if (msr_status == ZMERENY_PRUMERY){
    450a:	80 91 44 01 	lds	r24, 0x0144
    450e:	83 30       	cpi	r24, 0x03	; 3
    4510:	09 f0       	breq	.+2      	; 0x4514 <measure_scr_control+0x112>
    4512:	60 c0       	rjmp	.+192    	; 0x45d4 <measure_scr_control+0x1d2>

    printxyd( 2,18, int2strn(str_buf, 3,(uint16_t)(msr_prumer_v / 10)));
    4514:	80 91 18 03 	lds	r24, 0x0318
    4518:	90 91 19 03 	lds	r25, 0x0319
    451c:	6a e0       	ldi	r22, 0x0A	; 10
    451e:	70 e0       	ldi	r23, 0x00	; 0
    4520:	0e 94 82 3b 	call	0x7704	; 0x7704 <__udivmodhi4>
    4524:	ab 01       	movw	r20, r22
    4526:	85 e2       	ldi	r24, 0x25	; 37
    4528:	92 e0       	ldi	r25, 0x02	; 2
    452a:	63 e0       	ldi	r22, 0x03	; 3
    452c:	70 e0       	ldi	r23, 0x00	; 0
    452e:	0e 94 5d 14 	call	0x28ba	; 0x28ba <int2strn>
    4532:	ac 01       	movw	r20, r24
    4534:	82 e0       	ldi	r24, 0x02	; 2
    4536:	90 e0       	ldi	r25, 0x00	; 0
    4538:	62 e1       	ldi	r22, 0x12	; 18
    453a:	70 e0       	ldi	r23, 0x00	; 0
    453c:	0e 94 26 14 	call	0x284c	; 0x284c <printxyd>
    
    printcxyd( 2,22,(msr_prumer_v % 10) + '0');
    4540:	80 91 18 03 	lds	r24, 0x0318
    4544:	90 91 19 03 	lds	r25, 0x0319
    4548:	6a e0       	ldi	r22, 0x0A	; 10
    454a:	70 e0       	ldi	r23, 0x00	; 0
    454c:	0e 94 82 3b 	call	0x7704	; 0x7704 <__udivmodhi4>
    4550:	48 2f       	mov	r20, r24
    4552:	40 5d       	subi	r20, 0xD0	; 208
    4554:	82 e0       	ldi	r24, 0x02	; 2
    4556:	90 e0       	ldi	r25, 0x00	; 0
    4558:	66 e1       	ldi	r22, 0x16	; 22
    455a:	70 e0       	ldi	r23, 0x00	; 0
    455c:	0e 94 fc 11 	call	0x23f8	; 0x23f8 <printcxyd>
    printcxyd( 2,21,'.');
    4560:	82 e0       	ldi	r24, 0x02	; 2
    4562:	90 e0       	ldi	r25, 0x00	; 0
    4564:	65 e1       	ldi	r22, 0x15	; 21
    4566:	70 e0       	ldi	r23, 0x00	; 0
    4568:	4e e2       	ldi	r20, 0x2E	; 46
    456a:	0e 94 fc 11 	call	0x23f8	; 0x23f8 <printcxyd>

    if (width_src > 0){
    456e:	80 91 60 00 	lds	r24, 0x0060
    4572:	88 23       	and	r24, r24
    4574:	09 f4       	brne	.+2      	; 0x4578 <measure_scr_control+0x176>
    4576:	46 c0       	rjmp	.+140    	; 0x4604 <measure_scr_control+0x202>
      printxyd( 3,18, int2strn(str_buf,3,(msr_prumer_h / 10)));
    4578:	80 91 52 02 	lds	r24, 0x0252
    457c:	90 91 53 02 	lds	r25, 0x0253
    4580:	6a e0       	ldi	r22, 0x0A	; 10
    4582:	70 e0       	ldi	r23, 0x00	; 0
    4584:	0e 94 82 3b 	call	0x7704	; 0x7704 <__udivmodhi4>
    4588:	ab 01       	movw	r20, r22
    458a:	85 e2       	ldi	r24, 0x25	; 37
    458c:	92 e0       	ldi	r25, 0x02	; 2
    458e:	63 e0       	ldi	r22, 0x03	; 3
    4590:	70 e0       	ldi	r23, 0x00	; 0
    4592:	0e 94 5d 14 	call	0x28ba	; 0x28ba <int2strn>
    4596:	ac 01       	movw	r20, r24
    4598:	83 e0       	ldi	r24, 0x03	; 3
    459a:	90 e0       	ldi	r25, 0x00	; 0
    459c:	62 e1       	ldi	r22, 0x12	; 18
    459e:	70 e0       	ldi	r23, 0x00	; 0
    45a0:	0e 94 26 14 	call	0x284c	; 0x284c <printxyd>
      printcxyd(3,22, (msr_prumer_h % 10) + 48);
    45a4:	80 91 52 02 	lds	r24, 0x0252
    45a8:	90 91 53 02 	lds	r25, 0x0253
    45ac:	6a e0       	ldi	r22, 0x0A	; 10
    45ae:	70 e0       	ldi	r23, 0x00	; 0
    45b0:	0e 94 82 3b 	call	0x7704	; 0x7704 <__udivmodhi4>
    45b4:	48 2f       	mov	r20, r24
    45b6:	40 5d       	subi	r20, 0xD0	; 208
    45b8:	83 e0       	ldi	r24, 0x03	; 3
    45ba:	90 e0       	ldi	r25, 0x00	; 0
    45bc:	66 e1       	ldi	r22, 0x16	; 22
    45be:	70 e0       	ldi	r23, 0x00	; 0
    45c0:	0e 94 fc 11 	call	0x23f8	; 0x23f8 <printcxyd>
      printcxyd(3,21,'.');
    45c4:	83 e0       	ldi	r24, 0x03	; 3
    45c6:	90 e0       	ldi	r25, 0x00	; 0
    45c8:	65 e1       	ldi	r22, 0x15	; 21
    45ca:	70 e0       	ldi	r23, 0x00	; 0
    45cc:	4e e2       	ldi	r20, 0x2E	; 46
    45ce:	0e 94 fc 11 	call	0x23f8	; 0x23f8 <printcxyd>
    45d2:	18 c0       	rjmp	.+48     	; 0x4604 <measure_scr_control+0x202>
//    printxyd( 0,35, int2strn(str_buf,1,(msr_objem / 1000)));
//    printxyd( 0,37, int2strn(str_buf,3,(msr_objem % 1000)));
//    printcxyd(0,36,'.');
  }
  else{
    printxyd( 2,18, mezery(str_buf,7));
    45d4:	85 e2       	ldi	r24, 0x25	; 37
    45d6:	92 e0       	ldi	r25, 0x02	; 2
    45d8:	67 e0       	ldi	r22, 0x07	; 7
    45da:	0e 94 3a 14 	call	0x2874	; 0x2874 <mezery>
    45de:	ac 01       	movw	r20, r24
    45e0:	82 e0       	ldi	r24, 0x02	; 2
    45e2:	90 e0       	ldi	r25, 0x00	; 0
    45e4:	62 e1       	ldi	r22, 0x12	; 18
    45e6:	70 e0       	ldi	r23, 0x00	; 0
    45e8:	0e 94 26 14 	call	0x284c	; 0x284c <printxyd>
    printxyd( 3,18, mezery(str_buf,7));
    45ec:	85 e2       	ldi	r24, 0x25	; 37
    45ee:	92 e0       	ldi	r25, 0x02	; 2
    45f0:	67 e0       	ldi	r22, 0x07	; 7
    45f2:	0e 94 3a 14 	call	0x2874	; 0x2874 <mezery>
    45f6:	ac 01       	movw	r20, r24
    45f8:	83 e0       	ldi	r24, 0x03	; 3
    45fa:	90 e0       	ldi	r25, 0x00	; 0
    45fc:	62 e1       	ldi	r22, 0x12	; 18
    45fe:	70 e0       	ldi	r23, 0x00	; 0
    4600:	0e 94 26 14 	call	0x284c	; 0x284c <printxyd>
  }
  
//  printcxyd( 3,10, msr_status + '0');
//  printxyd( 3,13, int2strn(str_buf,2,msr_pocet_mereni));    

  printxyd( 1,34, int2strn(str_buf,3,(irc_get_l() / 100)));
    4604:	0e 94 30 0f 	call	0x1e60	; 0x1e60 <irc_get_l>
    4608:	64 e6       	ldi	r22, 0x64	; 100
    460a:	70 e0       	ldi	r23, 0x00	; 0
    460c:	0e 94 82 3b 	call	0x7704	; 0x7704 <__udivmodhi4>
    4610:	ab 01       	movw	r20, r22
    4612:	85 e2       	ldi	r24, 0x25	; 37
    4614:	92 e0       	ldi	r25, 0x02	; 2
    4616:	63 e0       	ldi	r22, 0x03	; 3
    4618:	70 e0       	ldi	r23, 0x00	; 0
    461a:	0e 94 5d 14 	call	0x28ba	; 0x28ba <int2strn>
    461e:	ac 01       	movw	r20, r24
    4620:	81 e0       	ldi	r24, 0x01	; 1
    4622:	90 e0       	ldi	r25, 0x00	; 0
    4624:	62 e2       	ldi	r22, 0x22	; 34
    4626:	70 e0       	ldi	r23, 0x00	; 0
    4628:	0e 94 26 14 	call	0x284c	; 0x284c <printxyd>
  str_buf[0] = '0';
    462c:	80 e3       	ldi	r24, 0x30	; 48
    462e:	80 93 25 02 	sts	0x0225, r24
  printxyd( 1,38, int2strn(str_buf,2,(irc_get_l() % 100)));
    4632:	0e 94 30 0f 	call	0x1e60	; 0x1e60 <irc_get_l>
    4636:	64 e6       	ldi	r22, 0x64	; 100
    4638:	70 e0       	ldi	r23, 0x00	; 0
    463a:	0e 94 82 3b 	call	0x7704	; 0x7704 <__udivmodhi4>
    463e:	ac 01       	movw	r20, r24
    4640:	85 e2       	ldi	r24, 0x25	; 37
    4642:	92 e0       	ldi	r25, 0x02	; 2
    4644:	62 e0       	ldi	r22, 0x02	; 2
    4646:	70 e0       	ldi	r23, 0x00	; 0
    4648:	0e 94 5d 14 	call	0x28ba	; 0x28ba <int2strn>
    464c:	ac 01       	movw	r20, r24
    464e:	81 e0       	ldi	r24, 0x01	; 1
    4650:	90 e0       	ldi	r25, 0x00	; 0
    4652:	66 e2       	ldi	r22, 0x26	; 38
    4654:	70 e0       	ldi	r23, 0x00	; 0
    4656:	0e 94 26 14 	call	0x284c	; 0x284c <printxyd>
  str_buf[0] = ' ';
    465a:	80 e2       	ldi	r24, 0x20	; 32
    465c:	80 93 25 02 	sts	0x0225, r24

  printxyd( 2,34, int2strn(str_buf,3,(prumer_v / 10)));
    4660:	80 91 16 03 	lds	r24, 0x0316
    4664:	90 91 17 03 	lds	r25, 0x0317
    4668:	6a e0       	ldi	r22, 0x0A	; 10
    466a:	70 e0       	ldi	r23, 0x00	; 0
    466c:	0e 94 82 3b 	call	0x7704	; 0x7704 <__udivmodhi4>
    4670:	ab 01       	movw	r20, r22
    4672:	85 e2       	ldi	r24, 0x25	; 37
    4674:	92 e0       	ldi	r25, 0x02	; 2
    4676:	63 e0       	ldi	r22, 0x03	; 3
    4678:	70 e0       	ldi	r23, 0x00	; 0
    467a:	0e 94 5d 14 	call	0x28ba	; 0x28ba <int2strn>
    467e:	ac 01       	movw	r20, r24
    4680:	82 e0       	ldi	r24, 0x02	; 2
    4682:	90 e0       	ldi	r25, 0x00	; 0
    4684:	62 e2       	ldi	r22, 0x22	; 34
    4686:	70 e0       	ldi	r23, 0x00	; 0
    4688:	0e 94 26 14 	call	0x284c	; 0x284c <printxyd>


  printcxyd( 2,38,(prumer_v % 10) + 48);
    468c:	80 91 16 03 	lds	r24, 0x0316
    4690:	90 91 17 03 	lds	r25, 0x0317
    4694:	6a e0       	ldi	r22, 0x0A	; 10
    4696:	70 e0       	ldi	r23, 0x00	; 0
    4698:	0e 94 82 3b 	call	0x7704	; 0x7704 <__udivmodhi4>
    469c:	48 2f       	mov	r20, r24
    469e:	40 5d       	subi	r20, 0xD0	; 208
    46a0:	82 e0       	ldi	r24, 0x02	; 2
    46a2:	90 e0       	ldi	r25, 0x00	; 0
    46a4:	66 e2       	ldi	r22, 0x26	; 38
    46a6:	70 e0       	ldi	r23, 0x00	; 0
    46a8:	0e 94 fc 11 	call	0x23f8	; 0x23f8 <printcxyd>
  
//  printxyd(,34,"00");
  if (width_src >  0){
    46ac:	80 91 60 00 	lds	r24, 0x0060
    46b0:	88 23       	and	r24, r24
    46b2:	31 f1       	breq	.+76     	; 0x4700 <measure_scr_control+0x2fe>
    printxyd( 3,34, int2strn(str_buf,3,(prumer_h / 10)));
    46b4:	80 91 50 02 	lds	r24, 0x0250
    46b8:	90 91 51 02 	lds	r25, 0x0251
    46bc:	6a e0       	ldi	r22, 0x0A	; 10
    46be:	70 e0       	ldi	r23, 0x00	; 0
    46c0:	0e 94 82 3b 	call	0x7704	; 0x7704 <__udivmodhi4>
    46c4:	ab 01       	movw	r20, r22
    46c6:	85 e2       	ldi	r24, 0x25	; 37
    46c8:	92 e0       	ldi	r25, 0x02	; 2
    46ca:	63 e0       	ldi	r22, 0x03	; 3
    46cc:	70 e0       	ldi	r23, 0x00	; 0
    46ce:	0e 94 5d 14 	call	0x28ba	; 0x28ba <int2strn>
    46d2:	ac 01       	movw	r20, r24
    46d4:	83 e0       	ldi	r24, 0x03	; 3
    46d6:	90 e0       	ldi	r25, 0x00	; 0
    46d8:	62 e2       	ldi	r22, 0x22	; 34
    46da:	70 e0       	ldi	r23, 0x00	; 0
    46dc:	0e 94 26 14 	call	0x284c	; 0x284c <printxyd>
    printcxyd( 3,38, (prumer_h % 10) + 48);
    46e0:	80 91 50 02 	lds	r24, 0x0250
    46e4:	90 91 51 02 	lds	r25, 0x0251
    46e8:	6a e0       	ldi	r22, 0x0A	; 10
    46ea:	70 e0       	ldi	r23, 0x00	; 0
    46ec:	0e 94 82 3b 	call	0x7704	; 0x7704 <__udivmodhi4>
    46f0:	48 2f       	mov	r20, r24
    46f2:	40 5d       	subi	r20, 0xD0	; 208
    46f4:	83 e0       	ldi	r24, 0x03	; 3
    46f6:	90 e0       	ldi	r25, 0x00	; 0
    46f8:	66 e2       	ldi	r22, 0x26	; 38
    46fa:	70 e0       	ldi	r23, 0x00	; 0
    46fc:	0e 94 fc 11 	call	0x23f8	; 0x23f8 <printcxyd>
}

static void keyb(void){
  char c;
  static char run = 2;
  if (run == 1){
    4700:	80 91 c1 00 	lds	r24, 0x00C1
    4704:	81 30       	cpi	r24, 0x01	; 1
    4706:	a1 f5       	brne	.+104    	; 0x4770 <measure_scr_control+0x36e>
    char * s;
    if ((s = read_line()) != NULL){
    4708:	0e 94 5b 1f 	call	0x3eb6	; 0x3eb6 <read_line>
    470c:	fc 01       	movw	r30, r24
    470e:	00 97       	sbiw	r24, 0x00	; 0
    4710:	09 f4       	brne	.+2      	; 0x4714 <measure_scr_control+0x312>
    4712:	45 c1       	rjmp	.+650    	; 0x499e <measure_scr_control+0x59c>
      if (s[0] != '\0'){
    4714:	80 81       	ld	r24, Z
    4716:	88 23       	and	r24, r24
    4718:	61 f0       	breq	.+24     	; 0x4732 <measure_scr_control+0x330>
        //tady by to ölo p¯ealokovat
        // TODO pamÏù
        m_jmena[MAX_ZAKAZNIK - 1] = menu_pridat;
    471a:	80 91 93 00 	lds	r24, 0x0093
    471e:	90 91 94 00 	lds	r25, 0x0094
    4722:	90 93 13 03 	sts	0x0313, r25
    4726:	80 93 12 03 	sts	0x0312, r24
        dat_add_zakaznik(s);
    472a:	cf 01       	movw	r24, r30
    472c:	0e 94 46 16 	call	0x2c8c	; 0x2c8c <dat_add_zakaznik>
    4730:	33 c0       	rjmp	.+102    	; 0x4798 <measure_scr_control+0x396>
      }
      else { // pokud Esc,  nebo je retezec nulove delky
        free((void *) m_jmena[menu[0] -> len - 1]);
    4732:	e0 91 c4 01 	lds	r30, 0x01C4
    4736:	f0 91 c5 01 	lds	r31, 0x01C5
    473a:	e2 81       	ldd	r30, Z+2	; 0x02
    473c:	f0 e0       	ldi	r31, 0x00	; 0
    473e:	ee 0f       	add	r30, r30
    4740:	ff 1f       	adc	r31, r31
    4742:	ee 50       	subi	r30, 0x0E	; 14
    4744:	fd 4f       	sbci	r31, 0xFD	; 253
    4746:	80 81       	ld	r24, Z
    4748:	91 81       	ldd	r25, Z+1	; 0x01
    474a:	0e 94 c6 32 	call	0x658c	; 0x658c <free>
        m_jmena[menu[0] -> len - 1] = menu_pridat;
    474e:	e0 91 c4 01 	lds	r30, 0x01C4
    4752:	f0 91 c5 01 	lds	r31, 0x01C5
    4756:	e2 81       	ldd	r30, Z+2	; 0x02
    4758:	f0 e0       	ldi	r31, 0x00	; 0
    475a:	ee 0f       	add	r30, r30
    475c:	ff 1f       	adc	r31, r31
    475e:	ee 50       	subi	r30, 0x0E	; 14
    4760:	fd 4f       	sbci	r31, 0xFD	; 253
    4762:	80 91 93 00 	lds	r24, 0x0093
    4766:	90 91 94 00 	lds	r25, 0x0094
    476a:	91 83       	std	Z+1, r25	; 0x01
    476c:	80 83       	st	Z, r24
    476e:	14 c0       	rjmp	.+40     	; 0x4798 <measure_scr_control+0x396>
      }
      run = 2;
    }
  }
  else if (run == 3){  // PotvrzenÌ p¯ed smaz·nÌm jmÈna
    4770:	83 30       	cpi	r24, 0x03	; 3
    4772:	59 f5       	brne	.+86     	; 0x47ca <measure_scr_control+0x3c8>
    clear_dscreen();
    4774:	0e 94 9e 11 	call	0x233c	; 0x233c <clear_dscreen>
    ok_scr_init((char *) s_smazat);
    4778:	81 ec       	ldi	r24, 0xC1	; 193
    477a:	9a e0       	ldi	r25, 0x0A	; 10
    477c:	0e 94 2a 19 	call	0x3254	; 0x3254 <ok_scr_init>
    
    switch (ok_scr()){
    4780:	0e 94 0b 19 	call	0x3216	; 0x3216 <ok_scr>
    4784:	2f ef       	ldi	r18, 0xFF	; 255
    4786:	8f 3f       	cpi	r24, 0xFF	; 255
    4788:	92 07       	cpc	r25, r18
    478a:	21 f0       	breq	.+8      	; 0x4794 <measure_scr_control+0x392>
    478c:	01 97       	sbiw	r24, 0x01	; 1
    478e:	09 f0       	breq	.+2      	; 0x4792 <measure_scr_control+0x390>
    4790:	06 c1       	rjmp	.+524    	; 0x499e <measure_scr_control+0x59c>
    4792:	06 c0       	rjmp	.+12     	; 0x47a0 <measure_scr_control+0x39e>
    case -1:
      measure_scr_draw();
    4794:	0e 94 86 21 	call	0x430c	; 0x430c <measure_scr_draw>
      run = 2;
    4798:	82 e0       	ldi	r24, 0x02	; 2
    479a:	80 93 c1 00 	sts	0x00C1, r24
    479e:	ff c0       	rjmp	.+510    	; 0x499e <measure_scr_control+0x59c>
      break;
    case 1:
      run = 2;
    47a0:	82 e0       	ldi	r24, 0x02	; 2
    47a2:	80 93 c1 00 	sts	0x00C1, r24
      dat_odstran_zakaznika(menu[0] -> val);
    47a6:	e0 91 c4 01 	lds	r30, 0x01C4
    47aa:	f0 91 c5 01 	lds	r31, 0x01C5
    47ae:	85 81       	ldd	r24, Z+5	; 0x05
    47b0:	90 e0       	ldi	r25, 0x00	; 0
    47b2:	0e 94 64 16 	call	0x2cc8	; 0x2cc8 <dat_odstran_zakaznika>
      menu_next_value(menu, menu_i);
    47b6:	84 ec       	ldi	r24, 0xC4	; 196
    47b8:	91 e0       	ldi	r25, 0x01	; 1
    47ba:	60 91 c3 01 	lds	r22, 0x01C3
    47be:	0e 94 b9 1d 	call	0x3b72	; 0x3b72 <menu_next_value>
      scr_draw(MSR_SCR);
    47c2:	80 e0       	ldi	r24, 0x00	; 0
    47c4:	0e 94 a1 18 	call	0x3142	; 0x3142 <scr_draw>
    47c8:	ea c0       	rjmp	.+468    	; 0x499e <measure_scr_control+0x59c>
    //      scr_draw(MSR_SCR);
    //      //measure_scr_draw();
    //      run = 2;
    //    }
    
  }else if ((c = get_char()) != 0){
    47ca:	0e 94 bc 1c 	call	0x3978	; 0x3978 <get_char>
    47ce:	88 23       	and	r24, r24
    47d0:	69 f1       	breq	.+90     	; 0x482c <measure_scr_control+0x42a>
    switch(c){
    47d2:	83 33       	cpi	r24, 0x33	; 51
    47d4:	f9 f0       	breq	.+62     	; 0x4814 <measure_scr_control+0x412>
    47d6:	84 33       	cpi	r24, 0x34	; 52
    47d8:	40 f4       	brcc	.+16     	; 0x47ea <measure_scr_control+0x3e8>
    47da:	81 33       	cpi	r24, 0x31	; 49
    47dc:	89 f0       	breq	.+34     	; 0x4800 <measure_scr_control+0x3fe>
    47de:	82 33       	cpi	r24, 0x32	; 50
    47e0:	a8 f4       	brcc	.+42     	; 0x480c <measure_scr_control+0x40a>
    47e2:	80 32       	cpi	r24, 0x20	; 32
    47e4:	09 f0       	breq	.+2      	; 0x47e8 <measure_scr_control+0x3e6>
    47e6:	db c0       	rjmp	.+438    	; 0x499e <measure_scr_control+0x59c>
    47e8:	06 c0       	rjmp	.+12     	; 0x47f6 <measure_scr_control+0x3f4>
    47ea:	84 33       	cpi	r24, 0x34	; 52
    47ec:	b9 f0       	breq	.+46     	; 0x481c <measure_scr_control+0x41a>
    47ee:	85 33       	cpi	r24, 0x35	; 53
    47f0:	09 f0       	breq	.+2      	; 0x47f4 <measure_scr_control+0x3f2>
    47f2:	d5 c0       	rjmp	.+426    	; 0x499e <measure_scr_control+0x59c>
    47f4:	17 c0       	rjmp	.+46     	; 0x4824 <measure_scr_control+0x422>
    case ' ':
      menu_next_value(menu, menu_i);
    47f6:	84 ec       	ldi	r24, 0xC4	; 196
    47f8:	91 e0       	ldi	r25, 0x01	; 1
    47fa:	60 91 c3 01 	lds	r22, 0x01C3
    47fe:	03 c0       	rjmp	.+6      	; 0x4806 <measure_scr_control+0x404>
      break;
    case '1':
      menu_next_value(menu, 0);
    4800:	84 ec       	ldi	r24, 0xC4	; 196
    4802:	91 e0       	ldi	r25, 0x01	; 1
    4804:	60 e0       	ldi	r22, 0x00	; 0
    4806:	0e 94 b9 1d 	call	0x3b72	; 0x3b72 <menu_next_value>
    480a:	c9 c0       	rjmp	.+402    	; 0x499e <measure_scr_control+0x59c>
      break;
    case '2':
      menu_next_value(menu, 1);
    480c:	84 ec       	ldi	r24, 0xC4	; 196
    480e:	91 e0       	ldi	r25, 0x01	; 1
    4810:	61 e0       	ldi	r22, 0x01	; 1
    4812:	f9 cf       	rjmp	.-14     	; 0x4806 <measure_scr_control+0x404>
      break;
    case '3':
      menu_next_value(menu, 2);
    4814:	84 ec       	ldi	r24, 0xC4	; 196
    4816:	91 e0       	ldi	r25, 0x01	; 1
    4818:	62 e0       	ldi	r22, 0x02	; 2
    481a:	f5 cf       	rjmp	.-22     	; 0x4806 <measure_scr_control+0x404>
      break;
    case '4':
      menu_next_value(menu, 3);
    481c:	84 ec       	ldi	r24, 0xC4	; 196
    481e:	91 e0       	ldi	r25, 0x01	; 1
    4820:	63 e0       	ldi	r22, 0x03	; 3
    4822:	f1 cf       	rjmp	.-30     	; 0x4806 <measure_scr_control+0x404>
      break;
    case '5':
      menu_next_value(menu, 4);
    4824:	84 ec       	ldi	r24, 0xC4	; 196
    4826:	91 e0       	ldi	r25, 0x01	; 1
    4828:	64 e0       	ldi	r22, 0x04	; 4
    482a:	ed cf       	rjmp	.-38     	; 0x4806 <measure_scr_control+0x404>
      
    default:
      break;
    }
  }
  else if ((c = get_spec()) != 0){
    482c:	0e 94 f2 1c 	call	0x39e4	; 0x39e4 <get_spec>
    4830:	88 23       	and	r24, r24
    4832:	09 f4       	brne	.+2      	; 0x4836 <measure_scr_control+0x434>
    4834:	b4 c0       	rjmp	.+360    	; 0x499e <measure_scr_control+0x59c>
    switch (c){
    4836:	8b 30       	cpi	r24, 0x0B	; 11
    4838:	09 f4       	brne	.+2      	; 0x483c <measure_scr_control+0x43a>
    483a:	8b c0       	rjmp	.+278    	; 0x4952 <measure_scr_control+0x550>
    483c:	8c 30       	cpi	r24, 0x0C	; 12
    483e:	80 f4       	brcc	.+32     	; 0x4860 <measure_scr_control+0x45e>
    4840:	87 30       	cpi	r24, 0x07	; 7
    4842:	79 f1       	breq	.+94     	; 0x48a2 <measure_scr_control+0x4a0>
    4844:	88 30       	cpi	r24, 0x08	; 8
    4846:	48 f4       	brcc	.+18     	; 0x485a <measure_scr_control+0x458>
    4848:	84 30       	cpi	r24, 0x04	; 4
    484a:	a9 f1       	breq	.+106    	; 0x48b6 <measure_scr_control+0x4b4>
    484c:	86 30       	cpi	r24, 0x06	; 6
    484e:	09 f4       	brne	.+2      	; 0x4852 <measure_scr_control+0x450>
    4850:	6c c0       	rjmp	.+216    	; 0x492a <measure_scr_control+0x528>
    4852:	82 30       	cpi	r24, 0x02	; 2
    4854:	09 f0       	breq	.+2      	; 0x4858 <measure_scr_control+0x456>
    4856:	a3 c0       	rjmp	.+326    	; 0x499e <measure_scr_control+0x59c>
    4858:	1c c0       	rjmp	.+56     	; 0x4892 <measure_scr_control+0x490>
    485a:	89 30       	cpi	r24, 0x09	; 9
    485c:	d1 f4       	brne	.+52     	; 0x4892 <measure_scr_control+0x490>
    485e:	21 c0       	rjmp	.+66     	; 0x48a2 <measure_scr_control+0x4a0>
    4860:	83 31       	cpi	r24, 0x13	; 19
    4862:	09 f4       	brne	.+2      	; 0x4866 <measure_scr_control+0x464>
    4864:	80 c0       	rjmp	.+256    	; 0x4966 <measure_scr_control+0x564>
    4866:	84 31       	cpi	r24, 0x14	; 20
    4868:	50 f4       	brcc	.+20     	; 0x487e <measure_scr_control+0x47c>
    486a:	8e 30       	cpi	r24, 0x0E	; 14
    486c:	09 f4       	brne	.+2      	; 0x4870 <measure_scr_control+0x46e>
    486e:	75 c0       	rjmp	.+234    	; 0x495a <measure_scr_control+0x558>
    4870:	80 31       	cpi	r24, 0x10	; 16
    4872:	09 f4       	brne	.+2      	; 0x4876 <measure_scr_control+0x474>
    4874:	74 c0       	rjmp	.+232    	; 0x495e <measure_scr_control+0x55c>
    4876:	8c 30       	cpi	r24, 0x0C	; 12
    4878:	09 f0       	breq	.+2      	; 0x487c <measure_scr_control+0x47a>
    487a:	91 c0       	rjmp	.+290    	; 0x499e <measure_scr_control+0x59c>
    487c:	6c c0       	rjmp	.+216    	; 0x4956 <measure_scr_control+0x554>
    487e:	85 31       	cpi	r24, 0x15	; 21
    4880:	09 f4       	brne	.+2      	; 0x4884 <measure_scr_control+0x482>
    4882:	88 c0       	rjmp	.+272    	; 0x4994 <measure_scr_control+0x592>
    4884:	85 31       	cpi	r24, 0x15	; 21
    4886:	08 f4       	brcc	.+2      	; 0x488a <measure_scr_control+0x488>
    4888:	71 c0       	rjmp	.+226    	; 0x496c <measure_scr_control+0x56a>
    488a:	86 31       	cpi	r24, 0x16	; 22
    488c:	09 f0       	breq	.+2      	; 0x4890 <measure_scr_control+0x48e>
    488e:	87 c0       	rjmp	.+270    	; 0x499e <measure_scr_control+0x59c>
    4890:	84 c0       	rjmp	.+264    	; 0x499a <measure_scr_control+0x598>
      //menu_next_value(menu, menu_i);
      break;
    case 2:  //Tab
    case 8:  //DownArrow
    case 10: //RightArrow
      menu_i = menu_next_item(menu, menu_i, VELIKOST_MENU);
    4892:	84 ec       	ldi	r24, 0xC4	; 196
    4894:	91 e0       	ldi	r25, 0x01	; 1
    4896:	60 91 c3 01 	lds	r22, 0x01C3
    489a:	46 e0       	ldi	r20, 0x06	; 6
    489c:	0e 94 7b 1d 	call	0x3af6	; 0x3af6 <menu_next_item>
    48a0:	07 c0       	rjmp	.+14     	; 0x48b0 <measure_scr_control+0x4ae>
      break;
    case 7:
    case 9:
      menu_i = menu_prev_item(menu, menu_i, VELIKOST_MENU);
    48a2:	84 ec       	ldi	r24, 0xC4	; 196
    48a4:	91 e0       	ldi	r25, 0x01	; 1
    48a6:	60 91 c3 01 	lds	r22, 0x01C3
    48aa:	46 e0       	ldi	r20, 0x06	; 6
    48ac:	0e 94 44 1d 	call	0x3a88	; 0x3a88 <menu_prev_item>
    48b0:	80 93 c3 01 	sts	0x01C3, r24
    48b4:	74 c0       	rjmp	.+232    	; 0x499e <measure_scr_control+0x59c>
      break;
    case 4: //Enter
      if (menu_i == 0){
    48b6:	60 91 c3 01 	lds	r22, 0x01C3
    48ba:	66 23       	and	r22, r22
    48bc:	89 f5       	brne	.+98     	; 0x4920 <measure_scr_control+0x51e>
        
        if ((menu[0] -> val == (MAX_ZAKAZNIK - 1))&&
    48be:	e0 91 c4 01 	lds	r30, 0x01C4
    48c2:	f0 91 c5 01 	lds	r31, 0x01C5
    48c6:	85 81       	ldd	r24, Z+5	; 0x05
    48c8:	8f 30       	cpi	r24, 0x0F	; 15
    48ca:	41 f5       	brne	.+80     	; 0x491c <measure_scr_control+0x51a>
    48cc:	20 91 12 03 	lds	r18, 0x0312
    48d0:	30 91 13 03 	lds	r19, 0x0313
    48d4:	80 91 93 00 	lds	r24, 0x0093
    48d8:	90 91 94 00 	lds	r25, 0x0094
    48dc:	28 17       	cp	r18, r24
    48de:	39 07       	cpc	r19, r25
    48e0:	e9 f4       	brne	.+58     	; 0x491c <measure_scr_control+0x51a>
          (m_jmena[menu[0] -> val] == menu_pridat)){ // spouötÏnÌ za·v·nÌ novÈho ËlovÏka
        
        char * s = (char *)mmalloc(9); // ölo by to pak p¯ealokovat na menöÌ
    48e2:	89 e0       	ldi	r24, 0x09	; 9
    48e4:	90 e0       	ldi	r25, 0x00	; 0
    48e6:	0e 94 c1 06 	call	0xd82	; 0xd82 <mmalloc>
    48ea:	ec 01       	movw	r28, r24
        if (s == NULL)
    48ec:	00 97       	sbiw	r24, 0x00	; 0
    48ee:	11 f4       	brne	.+4      	; 0x48f4 <measure_scr_control+0x4f2>
          new_error(88);
    48f0:	88 e5       	ldi	r24, 0x58	; 88
    48f2:	48 c0       	rjmp	.+144    	; 0x4984 <measure_scr_control+0x582>
        else{
          mezery(s,8);
    48f4:	68 e0       	ldi	r22, 0x08	; 8
    48f6:	0e 94 3a 14 	call	0x2874	; 0x2874 <mezery>
          m_jmena[MAX_ZAKAZNIK - 1] = s;
    48fa:	d0 93 13 03 	sts	0x0313, r29
    48fe:	c0 93 12 03 	sts	0x0312, r28
          read_line_init (menu[0] -> y, menu[0] -> x, s);
    4902:	e0 91 c4 01 	lds	r30, 0x01C4
    4906:	f0 91 c5 01 	lds	r31, 0x01C5
    490a:	60 81       	ld	r22, Z
    490c:	81 81       	ldd	r24, Z+1	; 0x01
    490e:	90 e0       	ldi	r25, 0x00	; 0
    4910:	70 e0       	ldi	r23, 0x00	; 0
    4912:	ae 01       	movw	r20, r28
    4914:	0e 94 e9 1e 	call	0x3dd2	; 0x3dd2 <read_line_init>
          run = 1;
    4918:	81 e0       	ldi	r24, 0x01	; 1
    491a:	3f cf       	rjmp	.-386    	; 0x479a <measure_scr_control+0x398>
        }
          }
          else{
            // zde je ¯eöeno p¯ed·v·nÌ parametr˘ jmÈna z·kaznÌka do
            // obrazovky z·kaznÌk˘
            scr_ch(DLST_SCR);
    491c:	85 e0       	ldi	r24, 0x05	; 5
    491e:	20 c0       	rjmp	.+64     	; 0x4960 <measure_scr_control+0x55e>
          }
      }
      else if(menu_i == 5){
    4920:	65 30       	cpi	r22, 0x05	; 5
    4922:	c9 f0       	breq	.+50     	; 0x4956 <measure_scr_control+0x554>
        scr_ch(DAT_SCR);
      }
      else{
        menu_next_value(menu, menu_i);
    4924:	84 ec       	ldi	r24, 0xC4	; 196
    4926:	91 e0       	ldi	r25, 0x01	; 1
    4928:	6e cf       	rjmp	.-292    	; 0x4806 <measure_scr_control+0x404>
        //	scr_ch(LST_SCR);
        //list_scr_draw();
      }
      break;
    case 6: //Del
      if (menu[0] -> val != 255){ // nelze mazat "pr·zdnÈ"
    492a:	e0 91 c4 01 	lds	r30, 0x01C4
    492e:	f0 91 c5 01 	lds	r31, 0x01C5
    4932:	85 81       	ldd	r24, Z+5	; 0x05
    4934:	8f 3f       	cpi	r24, 0xFF	; 255
    4936:	99 f1       	breq	.+102    	; 0x499e <measure_scr_control+0x59c>
        // nutno testovat, zda z·znam nenÌ p¯i¯azen k nÏkterÈmu stromu
        if (find_last_record_of_zakaznik(menu[0] -> val) != -1){
    4938:	0e 94 17 16 	call	0x2c2e	; 0x2c2e <find_last_record_of_zakaznik>
    493c:	8f 5f       	subi	r24, 0xFF	; 255
    493e:	9f 4f       	sbci	r25, 0xFF	; 255
    4940:	11 f0       	breq	.+4      	; 0x4946 <measure_scr_control+0x544>
          new_error(95);
    4942:	8f e5       	ldi	r24, 0x5F	; 95
    4944:	1f c0       	rjmp	.+62     	; 0x4984 <measure_scr_control+0x582>
          //	  ok_scr_init((char *) s_nelze_smazat);
          //	  run = 4;
        }
        else{
          
          ok_scr_init((char *)s_smazat);
    4946:	81 ec       	ldi	r24, 0xC1	; 193
    4948:	9a e0       	ldi	r25, 0x0A	; 10
    494a:	0e 94 2a 19 	call	0x3254	; 0x3254 <ok_scr_init>
          run = 3;
    494e:	83 e0       	ldi	r24, 0x03	; 3
    4950:	24 cf       	rjmp	.-440    	; 0x479a <measure_scr_control+0x398>
        }
      }
      break;
    case 11:  /// - F1 : Help screen
      //lcd_init(); /// @todo odstanil jsem to, nevim co se stande
      scr_ch(HLP_SCR);
    4952:	82 e0       	ldi	r24, 0x02	; 2
    4954:	05 c0       	rjmp	.+10     	; 0x4960 <measure_scr_control+0x55e>
      //help_scr_draw();
      break;
    case 12:  /// - F2 : Data screen
      scr_ch(DAT_SCR);
    4956:	84 e0       	ldi	r24, 0x04	; 4
    4958:	03 c0       	rjmp	.+6      	; 0x4960 <measure_scr_control+0x55e>
      //assert(1==5);
      //scr_ch(LST_SCR);
      //data_scr_draw();
      break;
    case 14:  /// - F4 : Error screen
      scr_ch(ERR_SCR);
    495a:	83 e0       	ldi	r24, 0x03	; 3
    495c:	01 c0       	rjmp	.+2      	; 0x4960 <measure_scr_control+0x55e>
      /// odstaveno. Pro odlazov·nÌ by vöak tento prost¯edek mohl b˝t
      /// uûiteöËn˝.
      //      scr_ch(SER_SCR);
      break;
    case 16: 
      scr_ch(STP_SCR);
    495e:	88 e0       	ldi	r24, 0x08	; 8
    4960:	0e 94 c3 18 	call	0x3186	; 0x3186 <scr_ch>
    4964:	1c c0       	rjmp	.+56     	; 0x499e <measure_scr_control+0x59c>
      _delay_ms(1);
      }
      break;
      }*/
    case 19:  //F9
      kf_start();
    4966:	0e 94 ed 31 	call	0x63da	; 0x63da <kf_start>
    496a:	19 c0       	rjmp	.+50     	; 0x499e <measure_scr_control+0x59c>
      break;
    case 20:  //F10
      if (msr_status == ZMERENY_PRUMERY){
    496c:	80 91 44 01 	lds	r24, 0x0144
    4970:	83 30       	cpi	r24, 0x03	; 3
    4972:	a9 f4       	brne	.+42     	; 0x499e <measure_scr_control+0x59c>
        if (menu[0] -> val == 255){
    4974:	e0 91 c4 01 	lds	r30, 0x01C4
    4978:	f0 91 c5 01 	lds	r31, 0x01C5
    497c:	85 81       	ldd	r24, Z+5	; 0x05
    497e:	8f 3f       	cpi	r24, 0xFF	; 255
    4980:	21 f4       	brne	.+8      	; 0x498a <measure_scr_control+0x588>
          new_error(94);
    4982:	8e e5       	ldi	r24, 0x5E	; 94
    4984:	0e 94 4e 19 	call	0x329c	; 0x329c <new_error>
    4988:	0a c0       	rjmp	.+20     	; 0x499e <measure_scr_control+0x59c>
        }
        else{
          uloz_posledni_data();
    498a:	0e 94 17 21 	call	0x422e	; 0x422e <uloz_posledni_data>
          msr_status = VOLNO;
    498e:	10 92 44 01 	sts	0x0144, r1
    4992:	05 c0       	rjmp	.+10     	; 0x499e <measure_scr_control+0x59c>
        }
      }
      break;
    case 21: // F11 - Strorno mÏ¯enÌ
      kf_zrusit();
    4994:	0e 94 09 32 	call	0x6412	; 0x6412 <kf_zrusit>
    4998:	02 c0       	rjmp	.+4      	; 0x499e <measure_scr_control+0x59c>
      break;
    case 22: //F12
      // Odesl·nÌ dat.
      send_data();
    499a:	0e 94 3c 2f 	call	0x5e78	; 0x5e78 <send_data>
  
  
//  printxyd( 3,35, int2strn(str_buf,4,msr_prumer) );
 
  keyb();
}
    499e:	df 91       	pop	r29
    49a0:	cf 91       	pop	r28
    49a2:	08 95       	ret

000049a4 <measure_scr_open>:

  //menu_jmena_i = &(menu[0] -> val);

}

void measure_scr_open(void){
    49a4:	cf 93       	push	r28
    49a6:	df 93       	push	r29
    49a8:	c4 ec       	ldi	r28, 0xC4	; 196
    49aa:	d1 e0       	ldi	r29, 0x01	; 1
  int i = 0;

  for (i = 0; i < VELIKOST_MENU; i++){
    menu[i] = new_menu_item();
    49ac:	0e 94 32 1f 	call	0x3e64	; 0x3e64 <new_menu_item>
    49b0:	fc 01       	movw	r30, r24
    49b2:	89 93       	st	Y+, r24
    49b4:	99 93       	st	Y+, r25
  
    menu[i] -> val = 0;
    49b6:	15 82       	std	Z+5, r1	; 0x05
}

void measure_scr_open(void){
  int i = 0;

  for (i = 0; i < VELIKOST_MENU; i++){
    49b8:	81 e0       	ldi	r24, 0x01	; 1
    49ba:	c0 3d       	cpi	r28, 0xD0	; 208
    49bc:	d8 07       	cpc	r29, r24
    49be:	b1 f7       	brne	.-20     	; 0x49ac <measure_scr_open+0x8>
    menu[i] = new_menu_item();
  
    menu[i] -> val = 0;
  }

  menu[0] -> x = 7;
    49c0:	e0 91 c4 01 	lds	r30, 0x01C4
    49c4:	f0 91 c5 01 	lds	r31, 0x01C5
    49c8:	47 e0       	ldi	r20, 0x07	; 7
    49ca:	40 83       	st	Z, r20
  menu[0] -> y = 0;
    49cc:	e0 91 c4 01 	lds	r30, 0x01C4
    49d0:	f0 91 c5 01 	lds	r31, 0x01C5
    49d4:	11 82       	std	Z+1, r1	; 0x01
  menu[0] -> polozky = m_jmena;
    49d6:	e0 91 c4 01 	lds	r30, 0x01C4
    49da:	f0 91 c5 01 	lds	r31, 0x01C5
    49de:	84 ef       	ldi	r24, 0xF4	; 244
    49e0:	92 e0       	ldi	r25, 0x02	; 2
    49e2:	94 83       	std	Z+4, r25	; 0x04
    49e4:	83 83       	std	Z+3, r24	; 0x03
  menu[0] -> len = MAX_ZAKAZNIK;
    49e6:	80 e1       	ldi	r24, 0x10	; 16
    49e8:	82 83       	std	Z+2, r24	; 0x02

  menu[1] -> x = 7;
    49ea:	e0 91 c6 01 	lds	r30, 0x01C6
    49ee:	f0 91 c7 01 	lds	r31, 0x01C7
    49f2:	40 83       	st	Z, r20
  menu[1] -> y = 1;
    49f4:	e0 91 c6 01 	lds	r30, 0x01C6
    49f8:	f0 91 c7 01 	lds	r31, 0x01C7
    49fc:	81 e0       	ldi	r24, 0x01	; 1
    49fe:	81 83       	std	Z+1, r24	; 0x01
  menu[1] -> polozky = m_drevo;
    4a00:	e0 91 c6 01 	lds	r30, 0x01C6
    4a04:	f0 91 c7 01 	lds	r31, 0x01C7
    4a08:	82 ee       	ldi	r24, 0xE2	; 226
    4a0a:	90 e0       	ldi	r25, 0x00	; 0
    4a0c:	94 83       	std	Z+4, r25	; 0x04
    4a0e:	83 83       	std	Z+3, r24	; 0x03
  menu[1] -> len = 5;
    4a10:	85 e0       	ldi	r24, 0x05	; 5
    4a12:	82 83       	std	Z+2, r24	; 0x02

  menu[2] -> x = 7;
    4a14:	e0 91 c8 01 	lds	r30, 0x01C8
    4a18:	f0 91 c9 01 	lds	r31, 0x01C9
    4a1c:	40 83       	st	Z, r20
  menu[2] -> y = 2; 
    4a1e:	e0 91 c8 01 	lds	r30, 0x01C8
    4a22:	f0 91 c9 01 	lds	r31, 0x01C9
    4a26:	22 e0       	ldi	r18, 0x02	; 2
    4a28:	21 83       	std	Z+1, r18	; 0x01
  menu[2] -> polozky = m_katrem;
    4a2a:	e0 91 c8 01 	lds	r30, 0x01C8
    4a2e:	f0 91 c9 01 	lds	r31, 0x01C9
    4a32:	80 ef       	ldi	r24, 0xF0	; 240
    4a34:	90 e0       	ldi	r25, 0x00	; 0
    4a36:	94 83       	std	Z+4, r25	; 0x04
    4a38:	83 83       	std	Z+3, r24	; 0x03
  menu[2] -> len = 2;
    4a3a:	22 83       	std	Z+2, r18	; 0x02

  menu[3] -> x = 9;
    4a3c:	e0 91 ca 01 	lds	r30, 0x01CA
    4a40:	f0 91 cb 01 	lds	r31, 0x01CB
    4a44:	89 e0       	ldi	r24, 0x09	; 9
    4a46:	80 83       	st	Z, r24
  menu[3] -> y = 2; 
    4a48:	e0 91 ca 01 	lds	r30, 0x01CA
    4a4c:	f0 91 cb 01 	lds	r31, 0x01CB
    4a50:	21 83       	std	Z+1, r18	; 0x01
  menu[3] -> polozky = m_dalsi;
    4a52:	e0 91 ca 01 	lds	r30, 0x01CA
    4a56:	f0 91 cb 01 	lds	r31, 0x01CB
    4a5a:	8f ef       	ldi	r24, 0xFF	; 255
    4a5c:	90 e0       	ldi	r25, 0x00	; 0
    4a5e:	94 83       	std	Z+4, r25	; 0x04
    4a60:	83 83       	std	Z+3, r24	; 0x03
  menu[3] -> len = 3;
    4a62:	33 e0       	ldi	r19, 0x03	; 3
    4a64:	32 83       	std	Z+2, r19	; 0x02

  menu[4] -> x = 14;
    4a66:	e0 91 cc 01 	lds	r30, 0x01CC
    4a6a:	f0 91 cd 01 	lds	r31, 0x01CD
    4a6e:	8e e0       	ldi	r24, 0x0E	; 14
    4a70:	80 83       	st	Z, r24
  menu[4] -> y = 2; 
    4a72:	e0 91 cc 01 	lds	r30, 0x01CC
    4a76:	f0 91 cd 01 	lds	r31, 0x01CD
    4a7a:	21 83       	std	Z+1, r18	; 0x01
  menu[4] -> polozky = m_manipulace;
    4a7c:	e0 91 cc 01 	lds	r30, 0x01CC
    4a80:	f0 91 cd 01 	lds	r31, 0x01CD
    4a84:	89 e0       	ldi	r24, 0x09	; 9
    4a86:	91 e0       	ldi	r25, 0x01	; 1
    4a88:	94 83       	std	Z+4, r25	; 0x04
    4a8a:	83 83       	std	Z+3, r24	; 0x03
  menu[4] -> len = 2;
    4a8c:	22 83       	std	Z+2, r18	; 0x02

  menu[5] -> x = 7;
    4a8e:	e0 91 ce 01 	lds	r30, 0x01CE
    4a92:	f0 91 cf 01 	lds	r31, 0x01CF
    4a96:	40 83       	st	Z, r20
  menu[5] -> y = 3;
    4a98:	e0 91 ce 01 	lds	r30, 0x01CE
    4a9c:	f0 91 cf 01 	lds	r31, 0x01CF
    4aa0:	31 83       	std	Z+1, r19	; 0x01
  menu[5] -> polozky = NULL;
    4aa2:	e0 91 ce 01 	lds	r30, 0x01CE
    4aa6:	f0 91 cf 01 	lds	r31, 0x01CF
    4aaa:	14 82       	std	Z+4, r1	; 0x04
    4aac:	13 82       	std	Z+3, r1	; 0x03
  menu[5] -> len = 0;
    4aae:	12 82       	std	Z+2, r1	; 0x02
  menu[5] -> val = 255;
    4ab0:	e0 91 ce 01 	lds	r30, 0x01CE
    4ab4:	f0 91 cf 01 	lds	r31, 0x01CF
    4ab8:	8f ef       	ldi	r24, 0xFF	; 255
    4aba:	85 83       	std	Z+5, r24	; 0x05

void load_menu_values(void){
  int i = 0;
  
  for (i=0; i < VELIKOST_MENU_HODNOT; i++){
    menu[i] -> val = menu_values[i];
    4abc:	e0 91 c4 01 	lds	r30, 0x01C4
    4ac0:	f0 91 c5 01 	lds	r31, 0x01C5
    4ac4:	80 91 be 01 	lds	r24, 0x01BE
    4ac8:	85 83       	std	Z+5, r24	; 0x05
    4aca:	e0 91 c6 01 	lds	r30, 0x01C6
    4ace:	f0 91 c7 01 	lds	r31, 0x01C7
    4ad2:	80 91 bf 01 	lds	r24, 0x01BF
    4ad6:	85 83       	std	Z+5, r24	; 0x05
    4ad8:	e0 91 c8 01 	lds	r30, 0x01C8
    4adc:	f0 91 c9 01 	lds	r31, 0x01C9
    4ae0:	80 91 c0 01 	lds	r24, 0x01C0
    4ae4:	85 83       	std	Z+5, r24	; 0x05
    4ae6:	e0 91 ca 01 	lds	r30, 0x01CA
    4aea:	f0 91 cb 01 	lds	r31, 0x01CB
    4aee:	80 91 c1 01 	lds	r24, 0x01C1
    4af2:	85 83       	std	Z+5, r24	; 0x05
    4af4:	e0 91 cc 01 	lds	r30, 0x01CC
    4af8:	f0 91 cd 01 	lds	r31, 0x01CD
    4afc:	80 91 c2 01 	lds	r24, 0x01C2
    4b00:	85 83       	std	Z+5, r24	; 0x05
  menu[5] -> polozky = NULL;
  menu[5] -> len = 0;
  menu[5] -> val = 255;

  load_menu_values();
}
    4b02:	df 91       	pop	r29
    4b04:	cf 91       	pop	r28
    4b06:	08 95       	ret

00004b08 <hlp_scr_open>:
static char dat1[] PROGMEM = "Seznam mereni: \nEnter(OK) - Upravit radek";
static char err1[] PROGMEM = "Chybova obrazovka: \nEnter(OK), Esc(ZRUSIT) - odchod";


void hlp_scr_open(void){
  if (akt_scr != HLP_SCR)
    4b08:	80 91 a5 01 	lds	r24, 0x01A5
    4b0c:	82 30       	cpi	r24, 0x02	; 2
    4b0e:	19 f0       	breq	.+6      	; 0x4b16 <hlp_scr_open+0xe>
    prev_scr = akt_scr;
    4b10:	80 93 d0 01 	sts	0x01D0, r24
    4b14:	08 95       	ret
  else
    prev_scr = MSR_SCR;
    4b16:	10 92 d0 01 	sts	0x01D0, r1
    4b1a:	08 95       	ret

00004b1c <help_scr_control>:
  }
}

void help_scr_control(void){
  char c;
  if ((c = get_spec()) != 0){
    4b1c:	0e 94 f2 1c 	call	0x39e4	; 0x39e4 <get_spec>
    4b20:	88 23       	and	r24, r24
    4b22:	81 f0       	breq	.+32     	; 0x4b44 <help_scr_control+0x28>
    switch(c){
    4b24:	85 31       	cpi	r24, 0x15	; 21
    4b26:	49 f0       	breq	.+18     	; 0x4b3a <help_scr_control+0x1e>
    4b28:	86 31       	cpi	r24, 0x16	; 22
    4b2a:	51 f0       	breq	.+20     	; 0x4b40 <help_scr_control+0x24>
    4b2c:	85 30       	cpi	r24, 0x05	; 5
    4b2e:	51 f4       	brne	.+20     	; 0x4b44 <help_scr_control+0x28>
    case 5:
      scr_ch(prev_scr);
    4b30:	80 91 d0 01 	lds	r24, 0x01D0
    4b34:	0e 94 c3 18 	call	0x3186	; 0x3186 <scr_ch>
    4b38:	08 95       	ret
      break;
      /// @todo Rozhodnout o implementaci tlaËÌtka START
    case 21: // F11 - Strorno mÏ¯enÌ
      kf_zrusit();
    4b3a:	0e 94 09 32 	call	0x6412	; 0x6412 <kf_zrusit>
    4b3e:	08 95       	ret
      break;
    case 22: //F12
      // Odesl·nÌ dat.
      send_data();
    4b40:	0e 94 3c 2f 	call	0x5e78	; 0x5e78 <send_data>
    4b44:	08 95       	ret

00004b46 <help_scr_draw>:
    prev_scr = MSR_SCR;
  //TODO jeötÏ by se nechala dopsat n·povÏda k help screenu
}

void help_scr_draw(void){
  clear_dscreen();
    4b46:	0e 94 9e 11 	call	0x233c	; 0x233c <clear_dscreen>
  akt_scr = HLP_SCR;
    4b4a:	82 e0       	ldi	r24, 0x02	; 2
    4b4c:	80 93 a5 01 	sts	0x01A5, r24

  switch(prev_scr){
    4b50:	80 91 d0 01 	lds	r24, 0x01D0
    4b54:	83 30       	cpi	r24, 0x03	; 3
    4b56:	19 f1       	breq	.+70     	; 0x4b9e <help_scr_draw+0x58>
    4b58:	84 30       	cpi	r24, 0x04	; 4
    4b5a:	18 f4       	brcc	.+6      	; 0x4b62 <help_scr_draw+0x1c>
    4b5c:	88 23       	and	r24, r24
    4b5e:	31 f0       	breq	.+12     	; 0x4b6c <help_scr_draw+0x26>
    4b60:	08 95       	ret
    4b62:	84 30       	cpi	r24, 0x04	; 4
    4b64:	99 f0       	breq	.+38     	; 0x4b8c <help_scr_draw+0x46>
    4b66:	85 30       	cpi	r24, 0x05	; 5
    4b68:	11 f5       	brne	.+68     	; 0x4bae <help_scr_draw+0x68>
    4b6a:	07 c0       	rjmp	.+14     	; 0x4b7a <help_scr_draw+0x34>
  case MSR_SCR:
    printxyd_P(0,0,(void *)msr1);
    4b6c:	80 e0       	ldi	r24, 0x00	; 0
    4b6e:	90 e0       	ldi	r25, 0x00	; 0
    4b70:	60 e0       	ldi	r22, 0x00	; 0
    4b72:	70 e0       	ldi	r23, 0x00	; 0
    4b74:	41 e1       	ldi	r20, 0x11	; 17
    4b76:	5b e0       	ldi	r21, 0x0B	; 11
    4b78:	06 c0       	rjmp	.+12     	; 0x4b86 <help_scr_draw+0x40>
    break;
  case DLST_SCR:
    printxyd_P(0,0,(void *)lst1);
    4b7a:	80 e0       	ldi	r24, 0x00	; 0
    4b7c:	90 e0       	ldi	r25, 0x00	; 0
    4b7e:	60 e0       	ldi	r22, 0x00	; 0
    4b80:	70 e0       	ldi	r23, 0x00	; 0
    4b82:	43 e8       	ldi	r20, 0x83	; 131
    4b84:	5b e0       	ldi	r21, 0x0B	; 11
    4b86:	0e 94 47 13 	call	0x268e	; 0x268e <printxyd_P>
    4b8a:	08 95       	ret
    break;
  case DAT_SCR:
    printxyd(0,0,(void *)dat1);
    4b8c:	80 e0       	ldi	r24, 0x00	; 0
    4b8e:	90 e0       	ldi	r25, 0x00	; 0
    4b90:	60 e0       	ldi	r22, 0x00	; 0
    4b92:	70 e0       	ldi	r23, 0x00	; 0
    4b94:	4e eb       	ldi	r20, 0xBE	; 190
    4b96:	5b e0       	ldi	r21, 0x0B	; 11
    4b98:	0e 94 26 14 	call	0x284c	; 0x284c <printxyd>
    4b9c:	08 95       	ret
    break;
  case ERR_SCR:
    printxyd(0,0,(void *)err1);
    4b9e:	80 e0       	ldi	r24, 0x00	; 0
    4ba0:	90 e0       	ldi	r25, 0x00	; 0
    4ba2:	60 e0       	ldi	r22, 0x00	; 0
    4ba4:	70 e0       	ldi	r23, 0x00	; 0
    4ba6:	48 ee       	ldi	r20, 0xE8	; 232
    4ba8:	5b e0       	ldi	r21, 0x0B	; 11
    4baa:	0e 94 26 14 	call	0x284c	; 0x284c <printxyd>
    4bae:	08 95       	ret

00004bb0 <data_up>:
}

/// Posune kurzor smÏrem vzh˘ru.
void data_up(void){
	//  assert(-1);
  if ((data_top > 0)&&(prohlizeny < ((unsigned char)(data_top - 0)))){ // -0 protoûe na vrchu je jeötÏ p¯idat
    4bb0:	20 91 9b 01 	lds	r18, 0x019B
    4bb4:	30 91 9c 01 	lds	r19, 0x019C
    4bb8:	12 16       	cp	r1, r18
    4bba:	13 06       	cpc	r1, r19
    4bbc:	3c f4       	brge	.+14     	; 0x4bcc <data_up+0x1c>
    4bbe:	80 91 d2 01 	lds	r24, 0x01D2
    4bc2:	82 17       	cp	r24, r18
    4bc4:	18 f4       	brcc	.+6      	; 0x4bcc <data_up+0x1c>
    prohlizeny++;
    4bc6:	8f 5f       	subi	r24, 0xFF	; 255
    4bc8:	80 93 d2 01 	sts	0x01D2, r24
    4bcc:	08 95       	ret

00004bce <data_down>:


/// Posune kurzor dolu.
void data_down(void){
	//  assert(1==0);
  if ((data_top > 0)&&(prohlizeny > 0)){
    4bce:	80 91 9b 01 	lds	r24, 0x019B
    4bd2:	90 91 9c 01 	lds	r25, 0x019C
    4bd6:	18 16       	cp	r1, r24
    4bd8:	19 06       	cpc	r1, r25
    4bda:	3c f4       	brge	.+14     	; 0x4bea <data_down+0x1c>
    4bdc:	80 91 d2 01 	lds	r24, 0x01D2
    4be0:	88 23       	and	r24, r24
    4be2:	19 f0       	breq	.+6      	; 0x4bea <data_down+0x1c>
    prohlizeny--;
    4be4:	81 50       	subi	r24, 0x01	; 1
    4be6:	80 93 d2 01 	sts	0x01D2, r24
    4bea:	08 95       	ret

00004bec <data_scr_init>:
  }
}

/// InicializaËnÌ funkce je pr·zdn·. é·dnÈ inicializace nejsou pot¯ebnÈ.
void data_scr_init(void){
}
    4bec:	08 95       	ret

00004bee <menu_close>:
  printcxyd(radek,4,255); // vykreslenÌ spr·vnÈho kurzoru
  printcxyd(radek,0,' ');
}

/** Funkce uzavÌr· menu */
void menu_close(void){
    4bee:	bf 92       	push	r11
    4bf0:	cf 92       	push	r12
    4bf2:	df 92       	push	r13
    4bf4:	ef 92       	push	r14
    4bf6:	ff 92       	push	r15
    4bf8:	0f 93       	push	r16
    4bfa:	1f 93       	push	r17
  char scr_zakaznik = menu[0] -> val;
    4bfc:	e0 91 d4 01 	lds	r30, 0x01D4
    4c00:	f0 91 d5 01 	lds	r31, 0x01D5
    4c04:	b5 80       	ldd	r11, Z+5	; 0x05
  char scr_drevo = menu[1] -> val;
    4c06:	e0 91 d6 01 	lds	r30, 0x01D6
    4c0a:	f0 91 d7 01 	lds	r31, 0x01D7
    4c0e:	c5 80       	ldd	r12, Z+5	; 0x05
  char scr_operace = 0 | (((menu[2] -> val) & 1) << 3);
    4c10:	e0 91 d8 01 	lds	r30, 0x01D8
    4c14:	f0 91 d9 01 	lds	r31, 0x01D9
    4c18:	d5 80       	ldd	r13, Z+5	; 0x05
  int * p_cislo = NULL;

  scr_operace |= ((menu[3] -> val) & 3) << 1;
    4c1a:	e0 91 da 01 	lds	r30, 0x01DA
    4c1e:	f0 91 db 01 	lds	r31, 0x01DB
    4c22:	05 81       	ldd	r16, Z+5	; 0x05
  scr_operace |= (menu[4] -> val) & 1;
    4c24:	e0 91 dc 01 	lds	r30, 0x01DC
    4c28:	f0 91 dd 01 	lds	r31, 0x01DD
    4c2c:	15 81       	ldd	r17, Z+5	; 0x05

  
  r_record((unsigned int)prohlizeny);
    4c2e:	80 91 d2 01 	lds	r24, 0x01D2
    4c32:	90 e0       	ldi	r25, 0x00	; 0
    4c34:	0e 94 30 15 	call	0x2a60	; 0x2a60 <r_record>
  
	// ukl·d·nÌ ¯eùezc˘    
  if ((menu[5] -> polozky) != NULL){
    4c38:	a0 91 de 01 	lds	r26, 0x01DE
    4c3c:	b0 91 df 01 	lds	r27, 0x01DF
    4c40:	13 96       	adiw	r26, 0x03	; 3
    4c42:	ed 91       	ld	r30, X+
    4c44:	fc 91       	ld	r31, X
    4c46:	14 97       	sbiw	r26, 0x04	; 4
    4c48:	30 97       	sbiw	r30, 0x00	; 0
    4c4a:	51 f0       	breq	.+20     	; 0x4c60 <menu_close+0x72>
    p_cislo = (int *)menu[5] -> polozky;
    data_delka = (uint16_t) *p_cislo;
    4c4c:	80 81       	ld	r24, Z
    4c4e:	91 81       	ldd	r25, Z+1	; 0x01
    4c50:	90 93 9f 01 	sts	0x019F, r25
    4c54:	80 93 9e 01 	sts	0x019E, r24
    menu[5] -> polozky = NULL;
    4c58:	14 96       	adiw	r26, 0x04	; 4
    4c5a:	1c 92       	st	X, r1
    4c5c:	1e 92       	st	-X, r1
    4c5e:	13 97       	sbiw	r26, 0x03	; 3
  }

  if ((menu[6] -> polozky) != NULL){
    4c60:	a0 91 e0 01 	lds	r26, 0x01E0
    4c64:	b0 91 e1 01 	lds	r27, 0x01E1
    4c68:	13 96       	adiw	r26, 0x03	; 3
    4c6a:	ed 91       	ld	r30, X+
    4c6c:	fc 91       	ld	r31, X
    4c6e:	14 97       	sbiw	r26, 0x04	; 4
    4c70:	30 97       	sbiw	r30, 0x00	; 0
    4c72:	51 f0       	breq	.+20     	; 0x4c88 <menu_close+0x9a>
    p_cislo = (int *)menu[6] -> polozky;
    data_prumer = (uint16_t) *p_cislo;
    4c74:	80 81       	ld	r24, Z
    4c76:	91 81       	ldd	r25, Z+1	; 0x01
    4c78:	90 93 a2 01 	sts	0x01A2, r25
    4c7c:	80 93 a1 01 	sts	0x01A1, r24
    menu[6] -> polozky = NULL;
    4c80:	14 96       	adiw	r26, 0x04	; 4
    4c82:	1c 92       	st	X, r1
    4c84:	1e 92       	st	-X, r1
    4c86:	13 97       	sbiw	r26, 0x03	; 3
  char scr_drevo = menu[1] -> val;
  char scr_operace = 0 | (((menu[2] -> val) & 1) << 3);
  int * p_cislo = NULL;

  scr_operace |= ((menu[3] -> val) & 3) << 1;
  scr_operace |= (menu[4] -> val) & 1;
    4c88:	81 e0       	ldi	r24, 0x01	; 1
    4c8a:	d8 22       	and	r13, r24
    4c8c:	dd 0c       	add	r13, r13
    4c8e:	dd 0c       	add	r13, r13
    4c90:	dd 0c       	add	r13, r13
    4c92:	11 70       	andi	r17, 0x01	; 1
    4c94:	d1 2a       	or	r13, r17
    4c96:	80 2f       	mov	r24, r16
    4c98:	90 e0       	ldi	r25, 0x00	; 0
    4c9a:	83 70       	andi	r24, 0x03	; 3
    4c9c:	90 70       	andi	r25, 0x00	; 0
    4c9e:	88 0f       	add	r24, r24
    4ca0:	99 1f       	adc	r25, r25
    4ca2:	d8 2a       	or	r13, r24
    p_cislo = (int *)menu[6] -> polozky;
    data_prumer = (uint16_t) *p_cislo;
    menu[6] -> polozky = NULL;
  }

  w_record((unsigned int)prohlizeny ,scr_zakaznik, scr_drevo, scr_operace, data_delka, data_prumer);
    4ca4:	00 91 9e 01 	lds	r16, 0x019E
    4ca8:	10 91 9f 01 	lds	r17, 0x019F
    4cac:	e0 90 a1 01 	lds	r14, 0x01A1
    4cb0:	f0 90 a2 01 	lds	r15, 0x01A2
    4cb4:	80 91 d2 01 	lds	r24, 0x01D2
    4cb8:	90 e0       	ldi	r25, 0x00	; 0
    4cba:	6b 2d       	mov	r22, r11
    4cbc:	4c 2d       	mov	r20, r12
    4cbe:	2d 2d       	mov	r18, r13
    4cc0:	0e 94 99 16 	call	0x2d32	; 0x2d32 <w_record>

  dat_scr_status = 0;
    4cc4:	10 92 d1 01 	sts	0x01D1, r1

   // vykreslenÌ spr·vnÈho kurzoru
  printcxyd(menu[0]->y,0,255);
    4cc8:	e0 91 d4 01 	lds	r30, 0x01D4
    4ccc:	f0 91 d5 01 	lds	r31, 0x01D5
    4cd0:	81 81       	ldd	r24, Z+1	; 0x01
    4cd2:	90 e0       	ldi	r25, 0x00	; 0
    4cd4:	60 e0       	ldi	r22, 0x00	; 0
    4cd6:	70 e0       	ldi	r23, 0x00	; 0
    4cd8:	4f ef       	ldi	r20, 0xFF	; 255
    4cda:	0e 94 fc 11 	call	0x23f8	; 0x23f8 <printcxyd>
  printcxyd(menu[0]->y,menu[menu_i]->x - 1,' ');
    4cde:	a0 91 d4 01 	lds	r26, 0x01D4
    4ce2:	b0 91 d5 01 	lds	r27, 0x01D5
    4ce6:	e0 91 d3 01 	lds	r30, 0x01D3
    4cea:	f0 e0       	ldi	r31, 0x00	; 0
    4cec:	ee 0f       	add	r30, r30
    4cee:	ff 1f       	adc	r31, r31
    4cf0:	ec 52       	subi	r30, 0x2C	; 44
    4cf2:	fe 4f       	sbci	r31, 0xFE	; 254
    4cf4:	01 90       	ld	r0, Z+
    4cf6:	f0 81       	ld	r31, Z
    4cf8:	e0 2d       	mov	r30, r0
    4cfa:	60 81       	ld	r22, Z
    4cfc:	70 e0       	ldi	r23, 0x00	; 0
    4cfe:	61 50       	subi	r22, 0x01	; 1
    4d00:	70 40       	sbci	r23, 0x00	; 0
    4d02:	11 96       	adiw	r26, 0x01	; 1
    4d04:	8c 91       	ld	r24, X
    4d06:	90 e0       	ldi	r25, 0x00	; 0
    4d08:	40 e2       	ldi	r20, 0x20	; 32
    4d0a:	0e 94 fc 11 	call	0x23f8	; 0x23f8 <printcxyd>
}
    4d0e:	1f 91       	pop	r17
    4d10:	0f 91       	pop	r16
    4d12:	ff 90       	pop	r15
    4d14:	ef 90       	pop	r14
    4d16:	df 90       	pop	r13
    4d18:	cf 90       	pop	r12
    4d1a:	bf 90       	pop	r11
    4d1c:	08 95       	ret

00004d1e <data_scr_close>:

}


/// Funkce prov·dÌ uvolnÏnÌ naalokovan˝ch prost¯edk˘.
void data_scr_close(void){
    4d1e:	cf 93       	push	r28
    4d20:	df 93       	push	r29
  int i = 0;
  free((void *)m_drevo[0]);
    4d22:	80 91 e2 01 	lds	r24, 0x01E2
    4d26:	90 91 e3 01 	lds	r25, 0x01E3
    4d2a:	0e 94 c6 32 	call	0x658c	; 0x658c <free>
  free((void *)m_drevo[1]);
    4d2e:	80 91 e4 01 	lds	r24, 0x01E4
    4d32:	90 91 e5 01 	lds	r25, 0x01E5
    4d36:	0e 94 c6 32 	call	0x658c	; 0x658c <free>
  free((void *)m_drevo[2]);
    4d3a:	80 91 e6 01 	lds	r24, 0x01E6
    4d3e:	90 91 e7 01 	lds	r25, 0x01E7
    4d42:	0e 94 c6 32 	call	0x658c	; 0x658c <free>
  free((void *)m_drevo[3]);
    4d46:	80 91 e8 01 	lds	r24, 0x01E8
    4d4a:	90 91 e9 01 	lds	r25, 0x01E9
    4d4e:	0e 94 c6 32 	call	0x658c	; 0x658c <free>
  free((void *)m_drevo[4]);
    4d52:	80 91 ea 01 	lds	r24, 0x01EA
    4d56:	90 91 eb 01 	lds	r25, 0x01EB
    4d5a:	0e 94 c6 32 	call	0x658c	; 0x658c <free>
  free((void *)m_katrem[0]);
    4d5e:	80 91 ec 01 	lds	r24, 0x01EC
    4d62:	90 91 ed 01 	lds	r25, 0x01ED
    4d66:	0e 94 c6 32 	call	0x658c	; 0x658c <free>
  free((void *)m_katrem[1]);
    4d6a:	80 91 ee 01 	lds	r24, 0x01EE
    4d6e:	90 91 ef 01 	lds	r25, 0x01EF
    4d72:	0e 94 c6 32 	call	0x658c	; 0x658c <free>
  free((void *)m_dalsi[1]);
    4d76:	80 91 2a 01 	lds	r24, 0x012A
    4d7a:	90 91 2b 01 	lds	r25, 0x012B
    4d7e:	0e 94 c6 32 	call	0x658c	; 0x658c <free>
  free((void *)m_dalsi[2]);
    4d82:	80 91 2c 01 	lds	r24, 0x012C
    4d86:	90 91 2d 01 	lds	r25, 0x012D
    4d8a:	0e 94 c6 32 	call	0x658c	; 0x658c <free>
  free((void *)m_manipulace[1]);
    4d8e:	80 91 30 01 	lds	r24, 0x0130
    4d92:	90 91 31 01 	lds	r25, 0x0131
    4d96:	0e 94 c6 32 	call	0x658c	; 0x658c <free>
    4d9a:	c4 ed       	ldi	r28, 0xD4	; 212
    4d9c:	d1 e0       	ldi	r29, 0x01	; 1

  for (i = 0; i < VELIKOST_MENU; i++){
    free((void *)menu[i]);
    4d9e:	88 81       	ld	r24, Y
    4da0:	99 81       	ldd	r25, Y+1	; 0x01
    4da2:	0e 94 c6 32 	call	0x658c	; 0x658c <free>
    menu[i] = NULL;
    4da6:	19 92       	st	Y+, r1
    4da8:	19 92       	st	Y+, r1
  free((void *)m_katrem[1]);
  free((void *)m_dalsi[1]);
  free((void *)m_dalsi[2]);
  free((void *)m_manipulace[1]);

  for (i = 0; i < VELIKOST_MENU; i++){
    4daa:	81 e0       	ldi	r24, 0x01	; 1
    4dac:	c2 3e       	cpi	r28, 0xE2	; 226
    4dae:	d8 07       	cpc	r29, r24
    4db0:	b1 f7       	brne	.-20     	; 0x4d9e <data_scr_close+0x80>
    free((void *)menu[i]);
    menu[i] = NULL;
  }

	// ˙klid v p¯ÌpadÏ, ûe dojde k p¯eruöenÌ nap¯Ìklad vyvol·nÌm erroru
  switch(dat_scr_status){
    4db2:	80 91 d1 01 	lds	r24, 0x01D1
    4db6:	81 30       	cpi	r24, 0x01	; 1
    4db8:	31 f0       	breq	.+12     	; 0x4dc6 <data_scr_close+0xa8>
    4dba:	81 30       	cpi	r24, 0x01	; 1
    4dbc:	58 f0       	brcs	.+22     	; 0x4dd4 <data_scr_close+0xb6>
    4dbe:	83 50       	subi	r24, 0x03	; 3
    4dc0:	82 30       	cpi	r24, 0x02	; 2
    4dc2:	40 f4       	brcc	.+16     	; 0x4dd4 <data_scr_close+0xb6>
    4dc4:	03 c0       	rjmp	.+6      	; 0x4dcc <data_scr_close+0xae>
  case 1: //upravy
    //wtch_reset2();
    menu_close();
    4dc6:	0e 94 f7 25 	call	0x4bee	; 0x4bee <menu_close>
    4dca:	02 c0       	rjmp	.+4      	; 0x4dd0 <data_scr_close+0xb2>
    dat_scr_status = 0;
    break;
  case 3:
  case 4:
    //wtch_reset2();
    read_line_kill();
    4dcc:	0e 94 42 1f 	call	0x3e84	; 0x3e84 <read_line_kill>
    //menu_close();
    dat_scr_status = 0;
    4dd0:	10 92 d1 01 	sts	0x01D1, r1
    break;
  default:
    break;
  }
}
    4dd4:	df 91       	pop	r29
    4dd6:	cf 91       	pop	r28
    4dd8:	08 95       	ret

00004dda <data_scr_open>:

/**
 * Funkce alokuje prost¯edky pro menu, d·le pak naËÌt· do pamÏti texty ("Smrk", "man" ...)
 * z programovÈ pamÏti.
 */
void data_scr_open(void){
    4dda:	cf 93       	push	r28
    4ddc:	df 93       	push	r29
  int i = 0;

  m_drevo[0] = getstr_P(smrk);
    4dde:	8c e1       	ldi	r24, 0x1C	; 28
    4de0:	9c e0       	ldi	r25, 0x0C	; 12
    4de2:	0e 94 f9 06 	call	0xdf2	; 0xdf2 <getstr_P>
    4de6:	90 93 e3 01 	sts	0x01E3, r25
    4dea:	80 93 e2 01 	sts	0x01E2, r24
  m_drevo[1] = getstr_P(boro_k);
    4dee:	81 e2       	ldi	r24, 0x21	; 33
    4df0:	9c e0       	ldi	r25, 0x0C	; 12
    4df2:	0e 94 f9 06 	call	0xdf2	; 0xdf2 <getstr_P>
    4df6:	90 93 e5 01 	sts	0x01E5, r25
    4dfa:	80 93 e4 01 	sts	0x01E4, r24
  m_drevo[2] = getstr_P(boro_b);
    4dfe:	86 e2       	ldi	r24, 0x26	; 38
    4e00:	9c e0       	ldi	r25, 0x0C	; 12
    4e02:	0e 94 f9 06 	call	0xdf2	; 0xdf2 <getstr_P>
    4e06:	90 93 e7 01 	sts	0x01E7, r25
    4e0a:	80 93 e6 01 	sts	0x01E6, r24
  m_drevo[3] = getstr_P(buk);
    4e0e:	8b e2       	ldi	r24, 0x2B	; 43
    4e10:	9c e0       	ldi	r25, 0x0C	; 12
    4e12:	0e 94 f9 06 	call	0xdf2	; 0xdf2 <getstr_P>
    4e16:	90 93 e9 01 	sts	0x01E9, r25
    4e1a:	80 93 e8 01 	sts	0x01E8, r24
  m_drevo[4] = getstr_P(dub);
    4e1e:	80 e3       	ldi	r24, 0x30	; 48
    4e20:	9c e0       	ldi	r25, 0x0C	; 12
    4e22:	0e 94 f9 06 	call	0xdf2	; 0xdf2 <getstr_P>
    4e26:	90 93 eb 01 	sts	0x01EB, r25
    4e2a:	80 93 ea 01 	sts	0x01EA, r24
  m_katrem[0] = getstr_P(n1);
    4e2e:	85 e3       	ldi	r24, 0x35	; 53
    4e30:	9c e0       	ldi	r25, 0x0C	; 12
    4e32:	0e 94 f9 06 	call	0xdf2	; 0xdf2 <getstr_P>
    4e36:	90 93 ed 01 	sts	0x01ED, r25
    4e3a:	80 93 ec 01 	sts	0x01EC, r24
  m_katrem[1] = getstr_P(n2);
    4e3e:	87 e3       	ldi	r24, 0x37	; 55
    4e40:	9c e0       	ldi	r25, 0x0C	; 12
    4e42:	0e 94 f9 06 	call	0xdf2	; 0xdf2 <getstr_P>
    4e46:	90 93 ef 01 	sts	0x01EF, r25
    4e4a:	80 93 ee 01 	sts	0x01EE, r24
  m_dalsi[1] = getstr_P(ctyr);
    4e4e:	89 e3       	ldi	r24, 0x39	; 57
    4e50:	9c e0       	ldi	r25, 0x0C	; 12
    4e52:	0e 94 f9 06 	call	0xdf2	; 0xdf2 <getstr_P>
    4e56:	90 93 2b 01 	sts	0x012B, r25
    4e5a:	80 93 2a 01 	sts	0x012A, r24
  m_dalsi[2] = getstr_P(paso);
    4e5e:	8e e3       	ldi	r24, 0x3E	; 62
    4e60:	9c e0       	ldi	r25, 0x0C	; 12
    4e62:	0e 94 f9 06 	call	0xdf2	; 0xdf2 <getstr_P>
    4e66:	90 93 2d 01 	sts	0x012D, r25
    4e6a:	80 93 2c 01 	sts	0x012C, r24
  m_manipulace[1] = getstr_P(man);
    4e6e:	83 e4       	ldi	r24, 0x43	; 67
    4e70:	9c e0       	ldi	r25, 0x0C	; 12
    4e72:	0e 94 f9 06 	call	0xdf2	; 0xdf2 <getstr_P>
    4e76:	90 93 31 01 	sts	0x0131, r25
    4e7a:	80 93 30 01 	sts	0x0130, r24
    4e7e:	c4 ed       	ldi	r28, 0xD4	; 212
    4e80:	d1 e0       	ldi	r29, 0x01	; 1

  for (i = 0; i < VELIKOST_MENU; i++){
    menu[i] = new_menu_item();
    4e82:	0e 94 32 1f 	call	0x3e64	; 0x3e64 <new_menu_item>
    4e86:	fc 01       	movw	r30, r24
    4e88:	99 83       	std	Y+1, r25	; 0x01
    4e8a:	88 83       	st	Y, r24
    menu[i] -> y = 0;
    4e8c:	11 82       	std	Z+1, r1	; 0x01
    menu[i] -> val = 0;
    4e8e:	e9 91       	ld	r30, Y+
    4e90:	f9 91       	ld	r31, Y+
    4e92:	15 82       	std	Z+5, r1	; 0x05
  m_katrem[1] = getstr_P(n2);
  m_dalsi[1] = getstr_P(ctyr);
  m_dalsi[2] = getstr_P(paso);
  m_manipulace[1] = getstr_P(man);

  for (i = 0; i < VELIKOST_MENU; i++){
    4e94:	81 e0       	ldi	r24, 0x01	; 1
    4e96:	c2 3e       	cpi	r28, 0xE2	; 226
    4e98:	d8 07       	cpc	r29, r24
    4e9a:	99 f7       	brne	.-26     	; 0x4e82 <data_scr_open+0xa8>

	//  menu[0] -> x = 1;
	//  menu[0] -> polozky = NULL;
	//  menu[0] -> len = 0;

  menu[0] -> x = 5;
    4e9c:	e0 91 d4 01 	lds	r30, 0x01D4
    4ea0:	f0 91 d5 01 	lds	r31, 0x01D5
    4ea4:	25 e0       	ldi	r18, 0x05	; 5
    4ea6:	20 83       	st	Z, r18
  menu[0] -> polozky = m_jmena;
    4ea8:	e0 91 d4 01 	lds	r30, 0x01D4
    4eac:	f0 91 d5 01 	lds	r31, 0x01D5
    4eb0:	84 ef       	ldi	r24, 0xF4	; 244
    4eb2:	92 e0       	ldi	r25, 0x02	; 2
    4eb4:	94 83       	std	Z+4, r25	; 0x04
    4eb6:	83 83       	std	Z+3, r24	; 0x03
  menu[0] -> len = MAX_ZAKAZNIK;
    4eb8:	80 e1       	ldi	r24, 0x10	; 16
    4eba:	82 83       	std	Z+2, r24	; 0x02

  menu[1] -> x = 14;
    4ebc:	e0 91 d6 01 	lds	r30, 0x01D6
    4ec0:	f0 91 d7 01 	lds	r31, 0x01D7
    4ec4:	8e e0       	ldi	r24, 0x0E	; 14
    4ec6:	80 83       	st	Z, r24
  menu[1] -> polozky = m_drevo;
    4ec8:	e0 91 d6 01 	lds	r30, 0x01D6
    4ecc:	f0 91 d7 01 	lds	r31, 0x01D7
    4ed0:	82 ee       	ldi	r24, 0xE2	; 226
    4ed2:	91 e0       	ldi	r25, 0x01	; 1
    4ed4:	94 83       	std	Z+4, r25	; 0x04
    4ed6:	83 83       	std	Z+3, r24	; 0x03
  menu[1] -> len = 5;
    4ed8:	22 83       	std	Z+2, r18	; 0x02

  menu[2] -> x = 19;
    4eda:	e0 91 d8 01 	lds	r30, 0x01D8
    4ede:	f0 91 d9 01 	lds	r31, 0x01D9
    4ee2:	83 e1       	ldi	r24, 0x13	; 19
    4ee4:	80 83       	st	Z, r24
  menu[2] -> polozky = m_katrem;
    4ee6:	e0 91 d8 01 	lds	r30, 0x01D8
    4eea:	f0 91 d9 01 	lds	r31, 0x01D9
    4eee:	8c ee       	ldi	r24, 0xEC	; 236
    4ef0:	91 e0       	ldi	r25, 0x01	; 1
    4ef2:	94 83       	std	Z+4, r25	; 0x04
    4ef4:	83 83       	std	Z+3, r24	; 0x03
  menu[2] -> len = 2;
    4ef6:	22 e0       	ldi	r18, 0x02	; 2
    4ef8:	22 83       	std	Z+2, r18	; 0x02

  menu[3] -> x = 21;
    4efa:	e0 91 da 01 	lds	r30, 0x01DA
    4efe:	f0 91 db 01 	lds	r31, 0x01DB
    4f02:	85 e1       	ldi	r24, 0x15	; 21
    4f04:	80 83       	st	Z, r24
  menu[3] -> polozky = m_dalsi;
    4f06:	e0 91 da 01 	lds	r30, 0x01DA
    4f0a:	f0 91 db 01 	lds	r31, 0x01DB
    4f0e:	88 e2       	ldi	r24, 0x28	; 40
    4f10:	91 e0       	ldi	r25, 0x01	; 1
    4f12:	94 83       	std	Z+4, r25	; 0x04
    4f14:	83 83       	std	Z+3, r24	; 0x03
  menu[3] -> len = 3;
    4f16:	83 e0       	ldi	r24, 0x03	; 3
    4f18:	82 83       	std	Z+2, r24	; 0x02

  menu[4] -> x = 26;
    4f1a:	e0 91 dc 01 	lds	r30, 0x01DC
    4f1e:	f0 91 dd 01 	lds	r31, 0x01DD
    4f22:	8a e1       	ldi	r24, 0x1A	; 26
    4f24:	80 83       	st	Z, r24
  menu[4] -> polozky = m_manipulace;
    4f26:	e0 91 dc 01 	lds	r30, 0x01DC
    4f2a:	f0 91 dd 01 	lds	r31, 0x01DD
    4f2e:	8e e2       	ldi	r24, 0x2E	; 46
    4f30:	91 e0       	ldi	r25, 0x01	; 1
    4f32:	94 83       	std	Z+4, r25	; 0x04
    4f34:	83 83       	std	Z+3, r24	; 0x03
  menu[4] -> len = 2;
    4f36:	22 83       	std	Z+2, r18	; 0x02

  menu[5] -> x = 30;
    4f38:	e0 91 de 01 	lds	r30, 0x01DE
    4f3c:	f0 91 df 01 	lds	r31, 0x01DF
    4f40:	8e e1       	ldi	r24, 0x1E	; 30
    4f42:	80 83       	st	Z, r24
  menu[5] -> polozky = NULL;
    4f44:	e0 91 de 01 	lds	r30, 0x01DE
    4f48:	f0 91 df 01 	lds	r31, 0x01DF
    4f4c:	14 82       	std	Z+4, r1	; 0x04
    4f4e:	13 82       	std	Z+3, r1	; 0x03
  menu[5] -> len = 0;
    4f50:	12 82       	std	Z+2, r1	; 0x02

  menu[6] -> x = 36;
    4f52:	e0 91 e0 01 	lds	r30, 0x01E0
    4f56:	f0 91 e1 01 	lds	r31, 0x01E1
    4f5a:	84 e2       	ldi	r24, 0x24	; 36
    4f5c:	80 83       	st	Z, r24
  menu[6] -> polozky = NULL;
    4f5e:	e0 91 e0 01 	lds	r30, 0x01E0
    4f62:	f0 91 e1 01 	lds	r31, 0x01E1
    4f66:	14 82       	std	Z+4, r1	; 0x04
    4f68:	13 82       	std	Z+3, r1	; 0x03
  menu[6] -> len = 0;
    4f6a:	12 82       	std	Z+2, r1	; 0x02

  if (data_top > 0){
    4f6c:	80 91 9b 01 	lds	r24, 0x019B
    4f70:	90 91 9c 01 	lds	r25, 0x019C
    4f74:	18 16       	cp	r1, r24
    4f76:	19 06       	cpc	r1, r25
    4f78:	24 f4       	brge	.+8      	; 0x4f82 <data_scr_open+0x1a8>
    prohlizeny = data_top - 1;
    4f7a:	81 50       	subi	r24, 0x01	; 1
    4f7c:	80 93 d2 01 	sts	0x01D2, r24
    4f80:	02 c0       	rjmp	.+4      	; 0x4f86 <data_scr_open+0x1ac>
  }
  else{
    prohlizeny = 0;
    4f82:	10 92 d2 01 	sts	0x01D2, r1
  }

}
    4f86:	df 91       	pop	r29
    4f88:	cf 91       	pop	r28
    4f8a:	08 95       	ret

00004f8c <vykresli_radek>:
/**
 * Funkce vykresli radek
 * @param zaznam ËÌslo z·znamu, kter˝ je vykreslov·n
 * @param i ¯·dek, na kter˝ je z·znam vykreslov·n
 */
static void vykresli_radek(char zaznam,char i){
    4f8c:	ef 92       	push	r14
    4f8e:	ff 92       	push	r15
    4f90:	1f 93       	push	r17
    4f92:	48 2f       	mov	r20, r24
    4f94:	16 2f       	mov	r17, r22
  str_buf[0] = ' ';
    4f96:	e5 e2       	ldi	r30, 0x25	; 37
    4f98:	ee 2e       	mov	r14, r30
    4f9a:	e2 e0       	ldi	r30, 0x02	; 2
    4f9c:	fe 2e       	mov	r15, r30
    4f9e:	80 e2       	ldi	r24, 0x20	; 32
    4fa0:	80 93 25 02 	sts	0x0225, r24
  printxyd(i,1,int2strn(str_buf,3,(uint16_t)zaznam));
    4fa4:	c7 01       	movw	r24, r14
    4fa6:	63 e0       	ldi	r22, 0x03	; 3
    4fa8:	70 e0       	ldi	r23, 0x00	; 0
    4faa:	50 e0       	ldi	r21, 0x00	; 0
    4fac:	0e 94 5d 14 	call	0x28ba	; 0x28ba <int2strn>
    4fb0:	ac 01       	movw	r20, r24
    4fb2:	81 2f       	mov	r24, r17
    4fb4:	90 e0       	ldi	r25, 0x00	; 0
    4fb6:	61 e0       	ldi	r22, 0x01	; 1
    4fb8:	70 e0       	ldi	r23, 0x00	; 0
    4fba:	0e 94 26 14 	call	0x284c	; 0x284c <printxyd>
  //printcxyd(i,4,(data_zakaznik % 10)+ '0'); /// @todo odstranit
  printxyd(i,5,m_jmena[(int)data_zakaznik]);
    4fbe:	e0 91 a0 01 	lds	r30, 0x01A0
    4fc2:	f0 e0       	ldi	r31, 0x00	; 0
    4fc4:	ee 0f       	add	r30, r30
    4fc6:	ff 1f       	adc	r31, r31
    4fc8:	ec 50       	subi	r30, 0x0C	; 12
    4fca:	fd 4f       	sbci	r31, 0xFD	; 253
    4fcc:	40 81       	ld	r20, Z
    4fce:	51 81       	ldd	r21, Z+1	; 0x01
    4fd0:	81 2f       	mov	r24, r17
    4fd2:	90 e0       	ldi	r25, 0x00	; 0
    4fd4:	65 e0       	ldi	r22, 0x05	; 5
    4fd6:	70 e0       	ldi	r23, 0x00	; 0
    4fd8:	0e 94 26 14 	call	0x284c	; 0x284c <printxyd>
  printxyd(i,14,m_drevo[(int)data_druh_dreva]);
    4fdc:	e0 91 a3 01 	lds	r30, 0x01A3
    4fe0:	f0 e0       	ldi	r31, 0x00	; 0
    4fe2:	ee 0f       	add	r30, r30
    4fe4:	ff 1f       	adc	r31, r31
    4fe6:	ee 51       	subi	r30, 0x1E	; 30
    4fe8:	fe 4f       	sbci	r31, 0xFE	; 254
    4fea:	40 81       	ld	r20, Z
    4fec:	51 81       	ldd	r21, Z+1	; 0x01
    4fee:	81 2f       	mov	r24, r17
    4ff0:	90 e0       	ldi	r25, 0x00	; 0
    4ff2:	6e e0       	ldi	r22, 0x0E	; 14
    4ff4:	70 e0       	ldi	r23, 0x00	; 0
    4ff6:	0e 94 26 14 	call	0x284c	; 0x284c <printxyd>
  printxyd(i,19,m_katrem[(int)((data_operace >> 3)&1)]);
    4ffa:	e0 91 a4 01 	lds	r30, 0x01A4
    4ffe:	e6 95       	lsr	r30
    5000:	e6 95       	lsr	r30
    5002:	e6 95       	lsr	r30
    5004:	f0 e0       	ldi	r31, 0x00	; 0
    5006:	e1 70       	andi	r30, 0x01	; 1
    5008:	f0 70       	andi	r31, 0x00	; 0
    500a:	ee 0f       	add	r30, r30
    500c:	ff 1f       	adc	r31, r31
    500e:	e4 51       	subi	r30, 0x14	; 20
    5010:	fe 4f       	sbci	r31, 0xFE	; 254
    5012:	40 81       	ld	r20, Z
    5014:	51 81       	ldd	r21, Z+1	; 0x01
    5016:	81 2f       	mov	r24, r17
    5018:	90 e0       	ldi	r25, 0x00	; 0
    501a:	63 e1       	ldi	r22, 0x13	; 19
    501c:	70 e0       	ldi	r23, 0x00	; 0
    501e:	0e 94 26 14 	call	0x284c	; 0x284c <printxyd>
  printxyd(i,21,m_dalsi[(int)((data_operace >> 1)&3)]);
    5022:	e0 91 a4 01 	lds	r30, 0x01A4
    5026:	e6 95       	lsr	r30
    5028:	f0 e0       	ldi	r31, 0x00	; 0
    502a:	e3 70       	andi	r30, 0x03	; 3
    502c:	f0 70       	andi	r31, 0x00	; 0
    502e:	ee 0f       	add	r30, r30
    5030:	ff 1f       	adc	r31, r31
    5032:	e8 5d       	subi	r30, 0xD8	; 216
    5034:	fe 4f       	sbci	r31, 0xFE	; 254
    5036:	40 81       	ld	r20, Z
    5038:	51 81       	ldd	r21, Z+1	; 0x01
    503a:	81 2f       	mov	r24, r17
    503c:	90 e0       	ldi	r25, 0x00	; 0
    503e:	65 e1       	ldi	r22, 0x15	; 21
    5040:	70 e0       	ldi	r23, 0x00	; 0
    5042:	0e 94 26 14 	call	0x284c	; 0x284c <printxyd>
  printxyd(i,26,m_manipulace[(int)((data_operace)&1)]);
    5046:	e0 91 a4 01 	lds	r30, 0x01A4
    504a:	f0 e0       	ldi	r31, 0x00	; 0
    504c:	e1 70       	andi	r30, 0x01	; 1
    504e:	f0 70       	andi	r31, 0x00	; 0
    5050:	ee 0f       	add	r30, r30
    5052:	ff 1f       	adc	r31, r31
    5054:	e2 5d       	subi	r30, 0xD2	; 210
    5056:	fe 4f       	sbci	r31, 0xFE	; 254
    5058:	40 81       	ld	r20, Z
    505a:	51 81       	ldd	r21, Z+1	; 0x01
    505c:	81 2f       	mov	r24, r17
    505e:	90 e0       	ldi	r25, 0x00	; 0
    5060:	6a e1       	ldi	r22, 0x1A	; 26
    5062:	70 e0       	ldi	r23, 0x00	; 0
    5064:	0e 94 26 14 	call	0x284c	; 0x284c <printxyd>
  printxyd(i,30,int2strn(str_buf,2,data_delka / 100));
    5068:	80 91 9e 01 	lds	r24, 0x019E
    506c:	90 91 9f 01 	lds	r25, 0x019F
    5070:	64 e6       	ldi	r22, 0x64	; 100
    5072:	70 e0       	ldi	r23, 0x00	; 0
    5074:	0e 94 82 3b 	call	0x7704	; 0x7704 <__udivmodhi4>
    5078:	ab 01       	movw	r20, r22
    507a:	c7 01       	movw	r24, r14
    507c:	62 e0       	ldi	r22, 0x02	; 2
    507e:	70 e0       	ldi	r23, 0x00	; 0
    5080:	0e 94 5d 14 	call	0x28ba	; 0x28ba <int2strn>
    5084:	ac 01       	movw	r20, r24
    5086:	81 2f       	mov	r24, r17
    5088:	90 e0       	ldi	r25, 0x00	; 0
    508a:	6e e1       	ldi	r22, 0x1E	; 30
    508c:	70 e0       	ldi	r23, 0x00	; 0
    508e:	0e 94 26 14 	call	0x284c	; 0x284c <printxyd>
  printcxyd(i,32,'.');
    5092:	81 2f       	mov	r24, r17
    5094:	90 e0       	ldi	r25, 0x00	; 0
    5096:	60 e2       	ldi	r22, 0x20	; 32
    5098:	70 e0       	ldi	r23, 0x00	; 0
    509a:	4e e2       	ldi	r20, 0x2E	; 46
    509c:	0e 94 fc 11 	call	0x23f8	; 0x23f8 <printcxyd>
  str_buf[0] = '0';
    50a0:	80 e3       	ldi	r24, 0x30	; 48
    50a2:	80 93 25 02 	sts	0x0225, r24
  printxyd(i,33,int2strn(str_buf,2,data_delka % 100));
    50a6:	80 91 9e 01 	lds	r24, 0x019E
    50aa:	90 91 9f 01 	lds	r25, 0x019F
    50ae:	64 e6       	ldi	r22, 0x64	; 100
    50b0:	70 e0       	ldi	r23, 0x00	; 0
    50b2:	0e 94 82 3b 	call	0x7704	; 0x7704 <__udivmodhi4>
    50b6:	ac 01       	movw	r20, r24
    50b8:	c7 01       	movw	r24, r14
    50ba:	62 e0       	ldi	r22, 0x02	; 2
    50bc:	70 e0       	ldi	r23, 0x00	; 0
    50be:	0e 94 5d 14 	call	0x28ba	; 0x28ba <int2strn>
    50c2:	ac 01       	movw	r20, r24
    50c4:	81 2f       	mov	r24, r17
    50c6:	90 e0       	ldi	r25, 0x00	; 0
    50c8:	61 e2       	ldi	r22, 0x21	; 33
    50ca:	70 e0       	ldi	r23, 0x00	; 0
    50cc:	0e 94 26 14 	call	0x284c	; 0x284c <printxyd>
  printxyd(i,36,int2strn(str_buf,2,data_prumer / 10));
    50d0:	80 91 a1 01 	lds	r24, 0x01A1
    50d4:	90 91 a2 01 	lds	r25, 0x01A2
    50d8:	6a e0       	ldi	r22, 0x0A	; 10
    50da:	70 e0       	ldi	r23, 0x00	; 0
    50dc:	0e 94 82 3b 	call	0x7704	; 0x7704 <__udivmodhi4>
    50e0:	ab 01       	movw	r20, r22
    50e2:	c7 01       	movw	r24, r14
    50e4:	62 e0       	ldi	r22, 0x02	; 2
    50e6:	70 e0       	ldi	r23, 0x00	; 0
    50e8:	0e 94 5d 14 	call	0x28ba	; 0x28ba <int2strn>
    50ec:	ac 01       	movw	r20, r24
    50ee:	81 2f       	mov	r24, r17
    50f0:	90 e0       	ldi	r25, 0x00	; 0
    50f2:	64 e2       	ldi	r22, 0x24	; 36
    50f4:	70 e0       	ldi	r23, 0x00	; 0
    50f6:	0e 94 26 14 	call	0x284c	; 0x284c <printxyd>
  printcxyd(i,38,'.');
    50fa:	81 2f       	mov	r24, r17
    50fc:	90 e0       	ldi	r25, 0x00	; 0
    50fe:	66 e2       	ldi	r22, 0x26	; 38
    5100:	70 e0       	ldi	r23, 0x00	; 0
    5102:	4e e2       	ldi	r20, 0x2E	; 46
    5104:	0e 94 fc 11 	call	0x23f8	; 0x23f8 <printcxyd>
  printcxyd(i,39,(data_prumer % 10) + '0');
    5108:	80 91 a1 01 	lds	r24, 0x01A1
    510c:	90 91 a2 01 	lds	r25, 0x01A2
    5110:	6a e0       	ldi	r22, 0x0A	; 10
    5112:	70 e0       	ldi	r23, 0x00	; 0
    5114:	0e 94 82 3b 	call	0x7704	; 0x7704 <__udivmodhi4>
    5118:	48 2f       	mov	r20, r24
    511a:	40 5d       	subi	r20, 0xD0	; 208
    511c:	81 2f       	mov	r24, r17
    511e:	90 e0       	ldi	r25, 0x00	; 0
    5120:	67 e2       	ldi	r22, 0x27	; 39
    5122:	70 e0       	ldi	r23, 0x00	; 0
    5124:	0e 94 fc 11 	call	0x23f8	; 0x23f8 <printcxyd>
}
    5128:	1f 91       	pop	r17
    512a:	ff 90       	pop	r15
    512c:	ef 90       	pop	r14
    512e:	08 95       	ret

00005130 <data_scr_draw>:


static void vykresli_radek(char zaznam,char i);

/// Funkce zajiöùuje vykreslenÌ obrazovky s daty.
void data_scr_draw(void){
    5130:	0f 93       	push	r16
    5132:	1f 93       	push	r17
    5134:	cf 93       	push	r28
    5136:	df 93       	push	r29
  //char s[15];
  //strcpy_P(s,pole[0]);
  //m_drevo[0] = (char *)malloc(5);
  //m_drevo[0]
  if (akt_scr != DAT_SCR){
    5138:	80 91 a5 01 	lds	r24, 0x01A5
    513c:	84 30       	cpi	r24, 0x04	; 4
    513e:	41 f0       	breq	.+16     	; 0x5150 <data_scr_draw+0x20>
    prohlizeny = (unsigned char) data_top - 1;
    5140:	80 91 9b 01 	lds	r24, 0x019B
    5144:	81 50       	subi	r24, 0x01	; 1
    5146:	80 93 d2 01 	sts	0x01D2, r24
    akt_scr = DAT_SCR;
    514a:	84 e0       	ldi	r24, 0x04	; 4
    514c:	80 93 a5 01 	sts	0x01A5, r24
void vypis_seznam(void){
  int i;
  int zaznam;
  unsigned char prvni_vykreslovany = 0;
  
  clear_dscreen();
    5150:	0e 94 9e 11 	call	0x233c	; 0x233c <clear_dscreen>
  printxyd(0,0, strcpy_P(str_buf,s_prazdne));
  //    strcpy_P(str_buf, s_prazdne);
  //    printcxyd(0,1,str_buf);
  }
  else{*/
  if (prohlizeny < 4){
    5154:	10 91 d2 01 	lds	r17, 0x01D2
    5158:	14 30       	cpi	r17, 0x04	; 4
    515a:	58 f4       	brcc	.+22     	; 0x5172 <data_scr_draw+0x42>
    prvni_vykreslovany = 3;
    printcxyd(3 - (int)prohlizeny,0,CURSOR);
    515c:	83 e0       	ldi	r24, 0x03	; 3
    515e:	90 e0       	ldi	r25, 0x00	; 0
    5160:	81 1b       	sub	r24, r17
    5162:	91 09       	sbc	r25, r1
    5164:	60 e0       	ldi	r22, 0x00	; 0
    5166:	70 e0       	ldi	r23, 0x00	; 0
    5168:	4f ef       	ldi	r20, 0xFF	; 255
    516a:	0e 94 fc 11 	call	0x23f8	; 0x23f8 <printcxyd>
    516e:	13 e0       	ldi	r17, 0x03	; 3
    5170:	07 c0       	rjmp	.+14     	; 0x5180 <data_scr_draw+0x50>
  }
  else{
    prvni_vykreslovany = prohlizeny;
    printcxyd(0,0,CURSOR);
    5172:	80 e0       	ldi	r24, 0x00	; 0
    5174:	90 e0       	ldi	r25, 0x00	; 0
    5176:	60 e0       	ldi	r22, 0x00	; 0
    5178:	70 e0       	ldi	r23, 0x00	; 0
    517a:	4f ef       	ldi	r20, 0xFF	; 255
    517c:	0e 94 fc 11 	call	0x23f8	; 0x23f8 <printcxyd>
  }
  
  i = ((data_top + 1) < LCD_Y_MAX)? LCD_Y_MAX - (data_top + 1):0;
    5180:	60 91 9b 01 	lds	r22, 0x019B
    5184:	70 91 9c 01 	lds	r23, 0x019C
    5188:	63 30       	cpi	r22, 0x03	; 3
    518a:	71 05       	cpc	r23, r1
    518c:	1c f0       	brlt	.+6      	; 0x5194 <data_scr_draw+0x64>
    518e:	c0 e0       	ldi	r28, 0x00	; 0
    5190:	d0 e0       	ldi	r29, 0x00	; 0
    5192:	04 c0       	rjmp	.+8      	; 0x519c <data_scr_draw+0x6c>
    5194:	eb 01       	movw	r28, r22
    5196:	c0 95       	com	r28
    5198:	d0 95       	com	r29
    519a:	24 96       	adiw	r28, 0x04	; 4
    519c:	01 2f       	mov	r16, r17
    519e:	10 e0       	ldi	r17, 0x00	; 0
    51a0:	0c 1b       	sub	r16, r28
    51a2:	1d 0b       	sbc	r17, r29
    51a4:	1b c0       	rjmp	.+54     	; 0x51dc <data_scr_draw+0xac>
  for(; (i < LCD_Y_MAX) ; i++){
    zaznam = (int)(prvni_vykreslovany - i);
    if (zaznam != data_top){
    51a6:	80 91 9b 01 	lds	r24, 0x019B
    51aa:	90 91 9c 01 	lds	r25, 0x019C
    51ae:	08 17       	cp	r16, r24
    51b0:	19 07       	cpc	r17, r25
    51b2:	41 f0       	breq	.+16     	; 0x51c4 <data_scr_draw+0x94>
      r_record(zaznam);
    51b4:	c8 01       	movw	r24, r16
    51b6:	0e 94 30 15 	call	0x2a60	; 0x2a60 <r_record>
      
      //strcpy(str_buf, "   ");
      vykresli_radek(zaznam,i);
    51ba:	80 2f       	mov	r24, r16
    51bc:	6c 2f       	mov	r22, r28
    51be:	0e 94 c6 27 	call	0x4f8c	; 0x4f8c <vykresli_radek>
    51c2:	09 c0       	rjmp	.+18     	; 0x51d6 <data_scr_draw+0xa6>
    }
    else{
      printxyd(i,5,menu_pridat);
    51c4:	40 91 93 00 	lds	r20, 0x0093
    51c8:	50 91 94 00 	lds	r21, 0x0094
    51cc:	ce 01       	movw	r24, r28
    51ce:	65 e0       	ldi	r22, 0x05	; 5
    51d0:	70 e0       	ldi	r23, 0x00	; 0
    51d2:	0e 94 26 14 	call	0x284c	; 0x284c <printxyd>
    prvni_vykreslovany = prohlizeny;
    printcxyd(0,0,CURSOR);
  }
  
  i = ((data_top + 1) < LCD_Y_MAX)? LCD_Y_MAX - (data_top + 1):0;
  for(; (i < LCD_Y_MAX) ; i++){
    51d6:	21 96       	adiw	r28, 0x01	; 1
    51d8:	01 50       	subi	r16, 0x01	; 1
    51da:	10 40       	sbci	r17, 0x00	; 0
    51dc:	c4 30       	cpi	r28, 0x04	; 4
    51de:	d1 05       	cpc	r29, r1
    51e0:	14 f3       	brlt	.-60     	; 0x51a6 <data_scr_draw+0x76>
  if (akt_scr != DAT_SCR){
    prohlizeny = (unsigned char) data_top - 1;
    akt_scr = DAT_SCR;
  }
  vypis_seznam();
}
    51e2:	df 91       	pop	r29
    51e4:	cf 91       	pop	r28
    51e6:	1f 91       	pop	r17
    51e8:	0f 91       	pop	r16
    51ea:	08 95       	ret

000051ec <control_ok>:
void control_ok(void){
    // PotvrzenÌ p¯ed smaz·nÌm jmÈna
		//  clear_dscreen();
		//  ok_scr_init((char *) s_smazat);
  
  switch (ok_scr()){
    51ec:	0e 94 0b 19 	call	0x3216	; 0x3216 <ok_scr>
    51f0:	2f ef       	ldi	r18, 0xFF	; 255
    51f2:	8f 3f       	cpi	r24, 0xFF	; 255
    51f4:	92 07       	cpc	r25, r18
    51f6:	19 f0       	breq	.+6      	; 0x51fe <control_ok+0x12>
    51f8:	01 97       	sbiw	r24, 0x01	; 1
    51fa:	e9 f4       	brne	.+58     	; 0x5236 <control_ok+0x4a>
    51fc:	05 c0       	rjmp	.+10     	; 0x5208 <control_ok+0x1c>
  case -1:
    dat_scr_status = 0;
    51fe:	10 92 d1 01 	sts	0x01D1, r1
    data_scr_draw();
    5202:	0e 94 98 28 	call	0x5130	; 0x5130 <data_scr_draw>
    5206:	08 95       	ret
    break;
  case 1:
    dat_scr_status = 0;
    5208:	10 92 d1 01 	sts	0x01D1, r1
    dat_del_record(prohlizeny);
    520c:	80 91 d2 01 	lds	r24, 0x01D2
    5210:	90 e0       	ldi	r25, 0x00	; 0
    5212:	0e 94 31 17 	call	0x2e62	; 0x2e62 <dat_del_record>


/// Posune kurzor dolu.
void data_down(void){
	//  assert(1==0);
  if ((data_top > 0)&&(prohlizeny > 0)){
    5216:	80 91 9b 01 	lds	r24, 0x019B
    521a:	90 91 9c 01 	lds	r25, 0x019C
    521e:	18 16       	cp	r1, r24
    5220:	19 06       	cpc	r1, r25
    5222:	3c f4       	brge	.+14     	; 0x5232 <control_ok+0x46>
    5224:	80 91 d2 01 	lds	r24, 0x01D2
    5228:	88 23       	and	r24, r24
    522a:	19 f0       	breq	.+6      	; 0x5232 <control_ok+0x46>
    prohlizeny--;
    522c:	81 50       	subi	r24, 0x01	; 1
    522e:	80 93 d2 01 	sts	0x01D2, r24
    break;
  case 1:
    dat_scr_status = 0;
    dat_del_record(prohlizeny);
    data_down();
    data_scr_draw();
    5232:	0e 94 98 28 	call	0x5130	; 0x5130 <data_scr_draw>
    5236:	08 95       	ret

00005238 <data_scr_control>:

/**
 * Funkce zajiöùuje funkci kl·ves(a nejen jich) v tÈto obrazovce. Je
 * vol·na p¯i kaûdÈ otoËce nekoneËnÈ smyËky v mainu
 */
void data_scr_control(void){
    5238:	bf 92       	push	r11
    523a:	cf 92       	push	r12
    523c:	df 92       	push	r13
    523e:	ef 92       	push	r14
    5240:	ff 92       	push	r15
    5242:	0f 93       	push	r16
    5244:	1f 93       	push	r17
    5246:	df 93       	push	r29
    5248:	cf 93       	push	r28
    524a:	cd b7       	in	r28, 0x3d	; 61
    524c:	de b7       	in	r29, 0x3e	; 62
    524e:	2c 97       	sbiw	r28, 0x0c	; 12
    5250:	0f b6       	in	r0, 0x3f	; 63
    5252:	f8 94       	cli
    5254:	de bf       	out	0x3e, r29	; 62
    5256:	0f be       	out	0x3f, r0	; 63
    5258:	cd bf       	out	0x3d, r28	; 61
  switch (dat_scr_status){
    525a:	80 91 d1 01 	lds	r24, 0x01D1
    525e:	82 30       	cpi	r24, 0x02	; 2
    5260:	09 f4       	brne	.+2      	; 0x5264 <data_scr_control+0x2c>
    5262:	c4 c0       	rjmp	.+392    	; 0x53ec <data_scr_control+0x1b4>
    5264:	83 30       	cpi	r24, 0x03	; 3
    5266:	20 f4       	brcc	.+8      	; 0x5270 <data_scr_control+0x38>
    5268:	81 30       	cpi	r24, 0x01	; 1
    526a:	09 f0       	breq	.+2      	; 0x526e <data_scr_control+0x36>
    526c:	e0 c1       	rjmp	.+960    	; 0x562e <data_scr_control+0x3f6>
    526e:	07 c0       	rjmp	.+14     	; 0x527e <data_scr_control+0x46>
    5270:	83 30       	cpi	r24, 0x03	; 3
    5272:	09 f4       	brne	.+2      	; 0x5276 <data_scr_control+0x3e>
    5274:	be c0       	rjmp	.+380    	; 0x53f2 <data_scr_control+0x1ba>
    5276:	84 30       	cpi	r24, 0x04	; 4
    5278:	09 f0       	breq	.+2      	; 0x527c <data_scr_control+0x44>
    527a:	d9 c1       	rjmp	.+946    	; 0x562e <data_scr_control+0x3f6>
    527c:	48 c1       	rjmp	.+656    	; 0x550e <data_scr_control+0x2d6>
}

/** P¯ebÌr· kontrolu pokud editujeme data. */
void control_edit(void){
  char c;
  if ((c = get_char()) != 0){
    527e:	0e 94 bc 1c 	call	0x3978	; 0x3978 <get_char>
    5282:	88 23       	and	r24, r24
    5284:	09 f0       	breq	.+2      	; 0x5288 <data_scr_control+0x50>
    5286:	10 c3       	rjmp	.+1568   	; 0x58a8 <data_scr_control+0x670>
    case ' ':
      break;
    default:
      break;
    }
  }else if ((c = get_spec()) != 0){
    5288:	0e 94 f2 1c 	call	0x39e4	; 0x39e4 <get_spec>
    528c:	88 23       	and	r24, r24
    528e:	09 f4       	brne	.+2      	; 0x5292 <data_scr_control+0x5a>
    5290:	0b c3       	rjmp	.+1558   	; 0x58a8 <data_scr_control+0x670>
    switch(c){
    5292:	88 30       	cpi	r24, 0x08	; 8
    5294:	39 f1       	breq	.+78     	; 0x52e4 <data_scr_control+0xac>
    5296:	89 30       	cpi	r24, 0x09	; 9
    5298:	78 f4       	brcc	.+30     	; 0x52b8 <data_scr_control+0x80>
    529a:	84 30       	cpi	r24, 0x04	; 4
    529c:	59 f1       	breq	.+86     	; 0x52f4 <data_scr_control+0xbc>
    529e:	85 30       	cpi	r24, 0x05	; 5
    52a0:	20 f4       	brcc	.+8      	; 0x52aa <data_scr_control+0x72>
    52a2:	82 30       	cpi	r24, 0x02	; 2
    52a4:	09 f0       	breq	.+2      	; 0x52a8 <data_scr_control+0x70>
    52a6:	00 c3       	rjmp	.+1536   	; 0x58a8 <data_scr_control+0x670>
    52a8:	1a c0       	rjmp	.+52     	; 0x52de <data_scr_control+0xa6>
    52aa:	85 30       	cpi	r24, 0x05	; 5
    52ac:	09 f4       	brne	.+2      	; 0x52b0 <data_scr_control+0x78>
    52ae:	9b c0       	rjmp	.+310    	; 0x53e6 <data_scr_control+0x1ae>
    52b0:	87 30       	cpi	r24, 0x07	; 7
    52b2:	09 f0       	breq	.+2      	; 0x52b6 <data_scr_control+0x7e>
    52b4:	f9 c2       	rjmp	.+1522   	; 0x58a8 <data_scr_control+0x670>
    52b6:	8d c0       	rjmp	.+282    	; 0x53d2 <data_scr_control+0x19a>
    52b8:	8b 30       	cpi	r24, 0x0B	; 11
    52ba:	09 f4       	brne	.+2      	; 0x52be <data_scr_control+0x86>
    52bc:	ec c2       	rjmp	.+1496   	; 0x5896 <data_scr_control+0x65e>
    52be:	8c 30       	cpi	r24, 0x0C	; 12
    52c0:	38 f4       	brcc	.+14     	; 0x52d0 <data_scr_control+0x98>
    52c2:	89 30       	cpi	r24, 0x09	; 9
    52c4:	09 f4       	brne	.+2      	; 0x52c8 <data_scr_control+0x90>
    52c6:	85 c0       	rjmp	.+266    	; 0x53d2 <data_scr_control+0x19a>
    52c8:	8a 30       	cpi	r24, 0x0A	; 10
    52ca:	09 f0       	breq	.+2      	; 0x52ce <data_scr_control+0x96>
    52cc:	ed c2       	rjmp	.+1498   	; 0x58a8 <data_scr_control+0x670>
    52ce:	0a c0       	rjmp	.+20     	; 0x52e4 <data_scr_control+0xac>
    52d0:	85 31       	cpi	r24, 0x15	; 21
    52d2:	09 f4       	brne	.+2      	; 0x52d6 <data_scr_control+0x9e>
    52d4:	e4 c2       	rjmp	.+1480   	; 0x589e <data_scr_control+0x666>
    52d6:	86 31       	cpi	r24, 0x16	; 22
    52d8:	09 f0       	breq	.+2      	; 0x52dc <data_scr_control+0xa4>
    52da:	e6 c2       	rjmp	.+1484   	; 0x58a8 <data_scr_control+0x670>
    52dc:	e3 c2       	rjmp	.+1478   	; 0x58a4 <data_scr_control+0x66c>
    case 2: // Tab
      menu_close();
    52de:	0e 94 f7 25 	call	0x4bee	; 0x4bee <menu_close>
    52e2:	e2 c2       	rjmp	.+1476   	; 0x58a8 <data_scr_control+0x670>
      break;
    case 8:
    case 10:
      menu_i = menu_next_item(menu, menu_i, VELIKOST_MENU);
    52e4:	84 ed       	ldi	r24, 0xD4	; 212
    52e6:	91 e0       	ldi	r25, 0x01	; 1
    52e8:	60 91 d3 01 	lds	r22, 0x01D3
    52ec:	47 e0       	ldi	r20, 0x07	; 7
    52ee:	0e 94 7b 1d 	call	0x3af6	; 0x3af6 <menu_next_item>
    52f2:	76 c0       	rjmp	.+236    	; 0x53e0 <data_scr_control+0x1a8>
      break;
    case 4://Enter
      if (menu_i == 5){
    52f4:	60 91 d3 01 	lds	r22, 0x01D3
    52f8:	65 30       	cpi	r22, 0x05	; 5
    52fa:	89 f5       	brne	.+98     	; 0x535e <data_scr_control+0x126>

/**
 * Funkce zah·jÌ z·pis dÈlky.
 */
void menu_str_delka(void){
  char * s = (char *)mmalloc(MAX_STR_DELKA + 1); // TODO ölo by to pak p¯ealokovat na menöÌ
    52fc:	85 e0       	ldi	r24, 0x05	; 5
    52fe:	90 e0       	ldi	r25, 0x00	; 0
    5300:	0e 94 c1 06 	call	0xd82	; 0xd82 <mmalloc>
    5304:	8c 01       	movw	r16, r24
  if (s != NULL){
    5306:	00 97       	sbiw	r24, 0x00	; 0
    5308:	09 f4       	brne	.+2      	; 0x530c <data_scr_control+0xd4>
    530a:	ce c2       	rjmp	.+1436   	; 0x58a8 <data_scr_control+0x670>
    mezery(s,MAX_STR_DELKA);
    530c:	64 e0       	ldi	r22, 0x04	; 4
    530e:	0e 94 3a 14 	call	0x2874	; 0x2874 <mezery>
    s[MAX_STR_DELKA] = '\0';
    5312:	d8 01       	movw	r26, r16
    5314:	14 96       	adiw	r26, 0x04	; 4
    5316:	1c 92       	st	X, r1
    //m_jmena[MAX_STR_DELKA] = s;
    read_line_init (menu[(int)menu_i] -> y, menu[(int)menu_i] -> x, s);
    5318:	e0 91 d3 01 	lds	r30, 0x01D3
    531c:	f0 e0       	ldi	r31, 0x00	; 0
    531e:	ee 0f       	add	r30, r30
    5320:	ff 1f       	adc	r31, r31
    5322:	ec 52       	subi	r30, 0x2C	; 44
    5324:	fe 4f       	sbci	r31, 0xFE	; 254
    5326:	01 90       	ld	r0, Z+
    5328:	f0 81       	ld	r31, Z
    532a:	e0 2d       	mov	r30, r0
    532c:	60 81       	ld	r22, Z
    532e:	81 81       	ldd	r24, Z+1	; 0x01
    5330:	90 e0       	ldi	r25, 0x00	; 0
    5332:	70 e0       	ldi	r23, 0x00	; 0
    5334:	a8 01       	movw	r20, r16
    5336:	0e 94 e9 1e 	call	0x3dd2	; 0x3dd2 <read_line_init>
    dat_scr_status = 3;
    533a:	83 e0       	ldi	r24, 0x03	; 3
    533c:	80 93 d1 01 	sts	0x01D1, r24
    printcxyd(menu[(int)menu_i] -> y,34,' ');
    5340:	e0 91 d3 01 	lds	r30, 0x01D3
    5344:	f0 e0       	ldi	r31, 0x00	; 0
    5346:	ee 0f       	add	r30, r30
    5348:	ff 1f       	adc	r31, r31
    534a:	ec 52       	subi	r30, 0x2C	; 44
    534c:	fe 4f       	sbci	r31, 0xFE	; 254
    534e:	01 90       	ld	r0, Z+
    5350:	f0 81       	ld	r31, Z
    5352:	e0 2d       	mov	r30, r0
    5354:	81 81       	ldd	r24, Z+1	; 0x01
    5356:	90 e0       	ldi	r25, 0x00	; 0
    5358:	62 e2       	ldi	r22, 0x22	; 34
    535a:	70 e0       	ldi	r23, 0x00	; 0
    535c:	31 c0       	rjmp	.+98     	; 0x53c0 <data_scr_control+0x188>
      break;
    case 4://Enter
      if (menu_i == 5){
        menu_str_delka();
      }
      else if (menu_i == 6){
    535e:	66 30       	cpi	r22, 0x06	; 6
    5360:	99 f5       	brne	.+102    	; 0x53c8 <data_scr_control+0x190>

/**
 * Funkce zahajuje zad·v·nÌ pr˘mÏru.
 */
void menu_str_prumer(void){
  char * s = (char *)mmalloc(MAX_STR_DELKA + 1); // TODO ölo by to pak p¯ealokovat na menöÌ
    5362:	85 e0       	ldi	r24, 0x05	; 5
    5364:	90 e0       	ldi	r25, 0x00	; 0
    5366:	0e 94 c1 06 	call	0xd82	; 0xd82 <mmalloc>
    536a:	8c 01       	movw	r16, r24
  if (s != NULL){
    536c:	00 97       	sbiw	r24, 0x00	; 0
    536e:	09 f4       	brne	.+2      	; 0x5372 <data_scr_control+0x13a>
    5370:	9b c2       	rjmp	.+1334   	; 0x58a8 <data_scr_control+0x670>
    mezery(s,MAX_STR_DELKA);
    5372:	64 e0       	ldi	r22, 0x04	; 4
    5374:	0e 94 3a 14 	call	0x2874	; 0x2874 <mezery>
    s[MAX_STR_DELKA] = '\0';
    5378:	f8 01       	movw	r30, r16
    537a:	14 82       	std	Z+4, r1	; 0x04
    //m_jmena[MAX_STR_DELKA] = s;
    read_line_init (menu[(int)menu_i] -> y, menu[(int)menu_i] -> x, s);
    537c:	e0 91 d3 01 	lds	r30, 0x01D3
    5380:	f0 e0       	ldi	r31, 0x00	; 0
    5382:	ee 0f       	add	r30, r30
    5384:	ff 1f       	adc	r31, r31
    5386:	ec 52       	subi	r30, 0x2C	; 44
    5388:	fe 4f       	sbci	r31, 0xFE	; 254
    538a:	01 90       	ld	r0, Z+
    538c:	f0 81       	ld	r31, Z
    538e:	e0 2d       	mov	r30, r0
    5390:	60 81       	ld	r22, Z
    5392:	81 81       	ldd	r24, Z+1	; 0x01
    5394:	90 e0       	ldi	r25, 0x00	; 0
    5396:	70 e0       	ldi	r23, 0x00	; 0
    5398:	a8 01       	movw	r20, r16
    539a:	0e 94 e9 1e 	call	0x3dd2	; 0x3dd2 <read_line_init>
    dat_scr_status = 4;
    539e:	84 e0       	ldi	r24, 0x04	; 4
    53a0:	80 93 d1 01 	sts	0x01D1, r24
    printcxyd(menu[(int)menu_i] -> y,39,' ');
    53a4:	e0 91 d3 01 	lds	r30, 0x01D3
    53a8:	f0 e0       	ldi	r31, 0x00	; 0
    53aa:	ee 0f       	add	r30, r30
    53ac:	ff 1f       	adc	r31, r31
    53ae:	ec 52       	subi	r30, 0x2C	; 44
    53b0:	fe 4f       	sbci	r31, 0xFE	; 254
    53b2:	01 90       	ld	r0, Z+
    53b4:	f0 81       	ld	r31, Z
    53b6:	e0 2d       	mov	r30, r0
    53b8:	81 81       	ldd	r24, Z+1	; 0x01
    53ba:	90 e0       	ldi	r25, 0x00	; 0
    53bc:	67 e2       	ldi	r22, 0x27	; 39
    53be:	70 e0       	ldi	r23, 0x00	; 0
    53c0:	40 e2       	ldi	r20, 0x20	; 32
    53c2:	0e 94 fc 11 	call	0x23f8	; 0x23f8 <printcxyd>
    53c6:	70 c2       	rjmp	.+1248   	; 0x58a8 <data_scr_control+0x670>
      }
      else if (menu_i == 6){
        menu_str_prumer();
      }
      else {
        menu_next_value(menu, menu_i);
    53c8:	84 ed       	ldi	r24, 0xD4	; 212
    53ca:	91 e0       	ldi	r25, 0x01	; 1
    53cc:	0e 94 b9 1d 	call	0x3b72	; 0x3b72 <menu_next_value>
    53d0:	6b c2       	rjmp	.+1238   	; 0x58a8 <data_scr_control+0x670>
      }
      break;
    case 7:
    case 9:
      menu_i = menu_prev_item(menu, menu_i, VELIKOST_MENU);
    53d2:	84 ed       	ldi	r24, 0xD4	; 212
    53d4:	91 e0       	ldi	r25, 0x01	; 1
    53d6:	60 91 d3 01 	lds	r22, 0x01D3
    53da:	47 e0       	ldi	r20, 0x07	; 7
    53dc:	0e 94 44 1d 	call	0x3a88	; 0x3a88 <menu_prev_item>
    53e0:	80 93 d3 01 	sts	0x01D3, r24
    53e4:	61 c2       	rjmp	.+1218   	; 0x58a8 <data_scr_control+0x670>
      break;
    case 5: //esc
      menu_close();
    53e6:	0e 94 f7 25 	call	0x4bee	; 0x4bee <menu_close>
    53ea:	50 c2       	rjmp	.+1184   	; 0x588c <data_scr_control+0x654>
  switch (dat_scr_status){
  case 1:
    control_edit();
    break;
  case 2:
    control_ok();
    53ec:	0e 94 f6 28 	call	0x51ec	; 0x51ec <control_ok>
    53f0:	5b c2       	rjmp	.+1206   	; 0x58a8 <data_scr_control+0x670>

void control_delka(void){
  char *s;
  unsigned char radek = 0;

  if (prohlizeny < 4){
    53f2:	90 91 d2 01 	lds	r25, 0x01D2
    53f6:	94 30       	cpi	r25, 0x04	; 4
    53f8:	10 f0       	brcs	.+4      	; 0x53fe <data_scr_control+0x1c6>
    53fa:	bb 24       	eor	r11, r11
    53fc:	02 c0       	rjmp	.+4      	; 0x5402 <data_scr_control+0x1ca>
    radek = 3 - (unsigned char)prohlizeny;
    53fe:	b8 2e       	mov	r11, r24
    5400:	b9 1a       	sub	r11, r25
  }

  if ((s = read_line()) != NULL){
    5402:	0e 94 5b 1f 	call	0x3eb6	; 0x3eb6 <read_line>
    5406:	6c 01       	movw	r12, r24
    5408:	00 97       	sbiw	r24, 0x00	; 0
    540a:	09 f4       	brne	.+2      	; 0x540e <data_scr_control+0x1d6>
    540c:	4d c2       	rjmp	.+1178   	; 0x58a8 <data_scr_control+0x670>
    if (s[0] != '\0'){
    540e:	dc 01       	movw	r26, r24
    5410:	8c 91       	ld	r24, X
    5412:	88 23       	and	r24, r24
    5414:	09 f4       	brne	.+2      	; 0x5418 <data_scr_control+0x1e0>
    5416:	76 c0       	rjmp	.+236    	; 0x5504 <data_scr_control+0x2cc>
      int cislo;
      int * p_cislo = (int *)mmalloc(sizeof(int));
    5418:	82 e0       	ldi	r24, 0x02	; 2
    541a:	90 e0       	ldi	r25, 0x00	; 0
    541c:	0e 94 c1 06 	call	0xd82	; 0xd82 <mmalloc>
    5420:	f8 2e       	mov	r15, r24
    5422:	e9 2e       	mov	r14, r25
      char s2[10];
      if (sscanf(s,"%i",&cislo) == 0){
    5424:	00 d0       	rcall	.+0      	; 0x5426 <data_scr_control+0x1ee>
    5426:	00 d0       	rcall	.+0      	; 0x5428 <data_scr_control+0x1f0>
    5428:	00 d0       	rcall	.+0      	; 0x542a <data_scr_control+0x1f2>
    542a:	ed b7       	in	r30, 0x3d	; 61
    542c:	fe b7       	in	r31, 0x3e	; 62
    542e:	31 96       	adiw	r30, 0x01	; 1
    5430:	ad b7       	in	r26, 0x3d	; 61
    5432:	be b7       	in	r27, 0x3e	; 62
    5434:	12 96       	adiw	r26, 0x02	; 2
    5436:	dc 92       	st	X, r13
    5438:	ce 92       	st	-X, r12
    543a:	11 97       	sbiw	r26, 0x01	; 1
    543c:	8d e0       	ldi	r24, 0x0D	; 13
    543e:	91 e0       	ldi	r25, 0x01	; 1
    5440:	93 83       	std	Z+3, r25	; 0x03
    5442:	82 83       	std	Z+2, r24	; 0x02
    5444:	ce 01       	movw	r24, r28
    5446:	01 96       	adiw	r24, 0x01	; 1
    5448:	95 83       	std	Z+5, r25	; 0x05
    544a:	84 83       	std	Z+4, r24	; 0x04
    544c:	0e 94 d4 33 	call	0x67a8	; 0x67a8 <sscanf>
    5450:	ed b7       	in	r30, 0x3d	; 61
    5452:	fe b7       	in	r31, 0x3e	; 62
    5454:	36 96       	adiw	r30, 0x06	; 6
    5456:	0f b6       	in	r0, 0x3f	; 63
    5458:	f8 94       	cli
    545a:	fe bf       	out	0x3e, r31	; 62
    545c:	0f be       	out	0x3f, r0	; 63
    545e:	ed bf       	out	0x3d, r30	; 61
    5460:	89 2b       	or	r24, r25
    5462:	49 f4       	brne	.+18     	; 0x5476 <data_scr_control+0x23e>
        //new_error(100); 
        printxyd(1,30,"blbe");
    5464:	81 e0       	ldi	r24, 0x01	; 1
    5466:	90 e0       	ldi	r25, 0x00	; 0
    5468:	6e e1       	ldi	r22, 0x1E	; 30
    546a:	70 e0       	ldi	r23, 0x00	; 0
    546c:	40 e1       	ldi	r20, 0x10	; 16
    546e:	51 e0       	ldi	r21, 0x01	; 1
    5470:	0e 94 26 14 	call	0x284c	; 0x284c <printxyd>
    5474:	d0 c0       	rjmp	.+416    	; 0x5616 <data_scr_control+0x3de>
  }

  if ((s = read_line()) != NULL){
    if (s[0] != '\0'){
      int cislo;
      int * p_cislo = (int *)mmalloc(sizeof(int));
    5476:	0f 2d       	mov	r16, r15
    5478:	1e 2d       	mov	r17, r14
        //new_error(100); 
        printxyd(1,30,"blbe");
        //printxyd(2,30,s);
      }
      else{
        sprintf(s2,"%2i.%02i",cislo/100,cislo%100); 
    547a:	29 81       	ldd	r18, Y+1	; 0x01
    547c:	3a 81       	ldd	r19, Y+2	; 0x02
    547e:	8d b7       	in	r24, 0x3d	; 61
    5480:	9e b7       	in	r25, 0x3e	; 62
    5482:	08 97       	sbiw	r24, 0x08	; 8
    5484:	0f b6       	in	r0, 0x3f	; 63
    5486:	f8 94       	cli
    5488:	9e bf       	out	0x3e, r25	; 62
    548a:	0f be       	out	0x3f, r0	; 63
    548c:	8d bf       	out	0x3d, r24	; 61
    548e:	ed b7       	in	r30, 0x3d	; 61
    5490:	fe b7       	in	r31, 0x3e	; 62
    5492:	31 96       	adiw	r30, 0x01	; 1
    5494:	43 e0       	ldi	r20, 0x03	; 3
    5496:	e4 2e       	mov	r14, r20
    5498:	f1 2c       	mov	r15, r1
    549a:	ec 0e       	add	r14, r28
    549c:	fd 1e       	adc	r15, r29
    549e:	ad b7       	in	r26, 0x3d	; 61
    54a0:	be b7       	in	r27, 0x3e	; 62
    54a2:	12 96       	adiw	r26, 0x02	; 2
    54a4:	fc 92       	st	X, r15
    54a6:	ee 92       	st	-X, r14
    54a8:	11 97       	sbiw	r26, 0x01	; 1
    54aa:	85 e1       	ldi	r24, 0x15	; 21
    54ac:	91 e0       	ldi	r25, 0x01	; 1
    54ae:	93 83       	std	Z+3, r25	; 0x03
    54b0:	82 83       	std	Z+2, r24	; 0x02
    54b2:	c9 01       	movw	r24, r18
    54b4:	64 e6       	ldi	r22, 0x64	; 100
    54b6:	70 e0       	ldi	r23, 0x00	; 0
    54b8:	0e 94 96 3b 	call	0x772c	; 0x772c <__divmodhi4>
    54bc:	75 83       	std	Z+5, r23	; 0x05
    54be:	64 83       	std	Z+4, r22	; 0x04
    54c0:	c9 01       	movw	r24, r18
    54c2:	64 e6       	ldi	r22, 0x64	; 100
    54c4:	70 e0       	ldi	r23, 0x00	; 0
    54c6:	0e 94 96 3b 	call	0x772c	; 0x772c <__divmodhi4>
    54ca:	97 83       	std	Z+7, r25	; 0x07
    54cc:	86 83       	std	Z+6, r24	; 0x06
    54ce:	0e 94 b0 33 	call	0x6760	; 0x6760 <sprintf>
        printxyd(radek,30,s2);
    54d2:	ed b7       	in	r30, 0x3d	; 61
    54d4:	fe b7       	in	r31, 0x3e	; 62
    54d6:	38 96       	adiw	r30, 0x08	; 8
    54d8:	0f b6       	in	r0, 0x3f	; 63
    54da:	f8 94       	cli
    54dc:	fe bf       	out	0x3e, r31	; 62
    54de:	0f be       	out	0x3f, r0	; 63
    54e0:	ed bf       	out	0x3d, r30	; 61
    54e2:	8b 2d       	mov	r24, r11
    54e4:	90 e0       	ldi	r25, 0x00	; 0
    54e6:	6e e1       	ldi	r22, 0x1E	; 30
    54e8:	70 e0       	ldi	r23, 0x00	; 0
    54ea:	a7 01       	movw	r20, r14
    54ec:	0e 94 26 14 	call	0x284c	; 0x284c <printxyd>
        *p_cislo = cislo;
    54f0:	89 81       	ldd	r24, Y+1	; 0x01
    54f2:	9a 81       	ldd	r25, Y+2	; 0x02
    54f4:	d8 01       	movw	r26, r16
    54f6:	8d 93       	st	X+, r24
    54f8:	9c 93       	st	X, r25
        menu[5] -> polozky = (char **) p_cislo;
    54fa:	e0 91 de 01 	lds	r30, 0x01DE
    54fe:	f0 91 df 01 	lds	r31, 0x01DF
    5502:	87 c0       	rjmp	.+270    	; 0x5612 <data_scr_control+0x3da>
      }
      free((void *) s);
    }
    else { // pokud Esc,  nebo je retezec nulove delky
      //printxyd(1,35,"esc_null");
      menu[5] -> polozky = NULL; // ale asi to tu b˝t nemusÌ.
    5504:	e0 91 de 01 	lds	r30, 0x01DE
    5508:	f0 91 df 01 	lds	r31, 0x01DF
    550c:	8c c0       	rjmp	.+280    	; 0x5626 <data_scr_control+0x3ee>

void control_prumer(void){
  char *s;
  unsigned char radek = 0;

  if (prohlizeny < 4){
    550e:	80 91 d2 01 	lds	r24, 0x01D2
    5512:	84 30       	cpi	r24, 0x04	; 4
    5514:	10 f0       	brcs	.+4      	; 0x551a <data_scr_control+0x2e2>
    5516:	bb 24       	eor	r11, r11
    5518:	03 c0       	rjmp	.+6      	; 0x5520 <data_scr_control+0x2e8>
    radek = 3 - (unsigned char)prohlizeny;
    551a:	93 e0       	ldi	r25, 0x03	; 3
    551c:	b9 2e       	mov	r11, r25
    551e:	b8 1a       	sub	r11, r24
  }

  if ((s = read_line()) != NULL){
    5520:	0e 94 5b 1f 	call	0x3eb6	; 0x3eb6 <read_line>
    5524:	6c 01       	movw	r12, r24
    5526:	00 97       	sbiw	r24, 0x00	; 0
    5528:	09 f4       	brne	.+2      	; 0x552c <data_scr_control+0x2f4>
    552a:	be c1       	rjmp	.+892    	; 0x58a8 <data_scr_control+0x670>
    if (s[0] != '\0'){
    552c:	fc 01       	movw	r30, r24
    552e:	80 81       	ld	r24, Z
    5530:	88 23       	and	r24, r24
    5532:	09 f4       	brne	.+2      	; 0x5536 <data_scr_control+0x2fe>
    5534:	74 c0       	rjmp	.+232    	; 0x561e <data_scr_control+0x3e6>
      int cislo;
      int * p_cislo = (int *)mmalloc(sizeof(int));
    5536:	82 e0       	ldi	r24, 0x02	; 2
    5538:	90 e0       	ldi	r25, 0x00	; 0
    553a:	0e 94 c1 06 	call	0xd82	; 0xd82 <mmalloc>
    553e:	7c 01       	movw	r14, r24
      char s2[10];
      if (sscanf(s,"%i",&cislo) == 0){
    5540:	00 d0       	rcall	.+0      	; 0x5542 <data_scr_control+0x30a>
    5542:	00 d0       	rcall	.+0      	; 0x5544 <data_scr_control+0x30c>
    5544:	00 d0       	rcall	.+0      	; 0x5546 <data_scr_control+0x30e>
    5546:	ed b7       	in	r30, 0x3d	; 61
    5548:	fe b7       	in	r31, 0x3e	; 62
    554a:	31 96       	adiw	r30, 0x01	; 1
    554c:	ad b7       	in	r26, 0x3d	; 61
    554e:	be b7       	in	r27, 0x3e	; 62
    5550:	12 96       	adiw	r26, 0x02	; 2
    5552:	dc 92       	st	X, r13
    5554:	ce 92       	st	-X, r12
    5556:	11 97       	sbiw	r26, 0x01	; 1
    5558:	8d e0       	ldi	r24, 0x0D	; 13
    555a:	91 e0       	ldi	r25, 0x01	; 1
    555c:	93 83       	std	Z+3, r25	; 0x03
    555e:	82 83       	std	Z+2, r24	; 0x02
    5560:	ce 01       	movw	r24, r28
    5562:	01 96       	adiw	r24, 0x01	; 1
    5564:	95 83       	std	Z+5, r25	; 0x05
    5566:	84 83       	std	Z+4, r24	; 0x04
    5568:	0e 94 d4 33 	call	0x67a8	; 0x67a8 <sscanf>
    556c:	ed b7       	in	r30, 0x3d	; 61
    556e:	fe b7       	in	r31, 0x3e	; 62
    5570:	36 96       	adiw	r30, 0x06	; 6
    5572:	0f b6       	in	r0, 0x3f	; 63
    5574:	f8 94       	cli
    5576:	fe bf       	out	0x3e, r31	; 62
    5578:	0f be       	out	0x3f, r0	; 63
    557a:	ed bf       	out	0x3d, r30	; 61
    557c:	89 2b       	or	r24, r25
    557e:	21 f4       	brne	.+8      	; 0x5588 <data_scr_control+0x350>
	new_error(100);
    5580:	84 e6       	ldi	r24, 0x64	; 100
    5582:	0e 94 4e 19 	call	0x329c	; 0x329c <new_error>
    5586:	47 c0       	rjmp	.+142    	; 0x5616 <data_scr_control+0x3de>
  }

  if ((s = read_line()) != NULL){
    if (s[0] != '\0'){
      int cislo;
      int * p_cislo = (int *)mmalloc(sizeof(int));
    5588:	87 01       	movw	r16, r14
	new_error(100);
	//printxyd(1,30,"blbe");
	//printxyd(2,30,s);
      }
      else{
	sprintf(s2,"%2i.%01i",cislo/10,cislo%10); 
    558a:	29 81       	ldd	r18, Y+1	; 0x01
    558c:	3a 81       	ldd	r19, Y+2	; 0x02
    558e:	8d b7       	in	r24, 0x3d	; 61
    5590:	9e b7       	in	r25, 0x3e	; 62
    5592:	08 97       	sbiw	r24, 0x08	; 8
    5594:	0f b6       	in	r0, 0x3f	; 63
    5596:	f8 94       	cli
    5598:	9e bf       	out	0x3e, r25	; 62
    559a:	0f be       	out	0x3f, r0	; 63
    559c:	8d bf       	out	0x3d, r24	; 61
    559e:	ed b7       	in	r30, 0x3d	; 61
    55a0:	fe b7       	in	r31, 0x3e	; 62
    55a2:	31 96       	adiw	r30, 0x01	; 1
    55a4:	83 e0       	ldi	r24, 0x03	; 3
    55a6:	e8 2e       	mov	r14, r24
    55a8:	f1 2c       	mov	r15, r1
    55aa:	ec 0e       	add	r14, r28
    55ac:	fd 1e       	adc	r15, r29
    55ae:	ad b7       	in	r26, 0x3d	; 61
    55b0:	be b7       	in	r27, 0x3e	; 62
    55b2:	12 96       	adiw	r26, 0x02	; 2
    55b4:	fc 92       	st	X, r15
    55b6:	ee 92       	st	-X, r14
    55b8:	11 97       	sbiw	r26, 0x01	; 1
    55ba:	8e e1       	ldi	r24, 0x1E	; 30
    55bc:	91 e0       	ldi	r25, 0x01	; 1
    55be:	93 83       	std	Z+3, r25	; 0x03
    55c0:	82 83       	std	Z+2, r24	; 0x02
    55c2:	c9 01       	movw	r24, r18
    55c4:	6a e0       	ldi	r22, 0x0A	; 10
    55c6:	70 e0       	ldi	r23, 0x00	; 0
    55c8:	0e 94 96 3b 	call	0x772c	; 0x772c <__divmodhi4>
    55cc:	75 83       	std	Z+5, r23	; 0x05
    55ce:	64 83       	std	Z+4, r22	; 0x04
    55d0:	c9 01       	movw	r24, r18
    55d2:	6a e0       	ldi	r22, 0x0A	; 10
    55d4:	70 e0       	ldi	r23, 0x00	; 0
    55d6:	0e 94 96 3b 	call	0x772c	; 0x772c <__divmodhi4>
    55da:	97 83       	std	Z+7, r25	; 0x07
    55dc:	86 83       	std	Z+6, r24	; 0x06
    55de:	0e 94 b0 33 	call	0x6760	; 0x6760 <sprintf>
	printxyd(radek,36,s2);
    55e2:	ed b7       	in	r30, 0x3d	; 61
    55e4:	fe b7       	in	r31, 0x3e	; 62
    55e6:	38 96       	adiw	r30, 0x08	; 8
    55e8:	0f b6       	in	r0, 0x3f	; 63
    55ea:	f8 94       	cli
    55ec:	fe bf       	out	0x3e, r31	; 62
    55ee:	0f be       	out	0x3f, r0	; 63
    55f0:	ed bf       	out	0x3d, r30	; 61
    55f2:	8b 2d       	mov	r24, r11
    55f4:	90 e0       	ldi	r25, 0x00	; 0
    55f6:	64 e2       	ldi	r22, 0x24	; 36
    55f8:	70 e0       	ldi	r23, 0x00	; 0
    55fa:	a7 01       	movw	r20, r14
    55fc:	0e 94 26 14 	call	0x284c	; 0x284c <printxyd>
	//stp_nastav(menu_i,(float)cislo);
	*p_cislo = cislo;
    5600:	89 81       	ldd	r24, Y+1	; 0x01
    5602:	9a 81       	ldd	r25, Y+2	; 0x02
    5604:	d8 01       	movw	r26, r16
    5606:	8d 93       	st	X+, r24
    5608:	9c 93       	st	X, r25
	menu[6] -> polozky = (char **) p_cislo;
    560a:	e0 91 e0 01 	lds	r30, 0x01E0
    560e:	f0 91 e1 01 	lds	r31, 0x01E1
    5612:	14 83       	std	Z+4, r17	; 0x04
    5614:	03 83       	std	Z+3, r16	; 0x03
      }
      free((void *) s);
    5616:	c6 01       	movw	r24, r12
    5618:	0e 94 c6 32 	call	0x658c	; 0x658c <free>
    561c:	06 c0       	rjmp	.+12     	; 0x562a <data_scr_control+0x3f2>
    }
    else { // pokud Esc,  nebo je retezec nulove delky
      menu[6] -> polozky = NULL; // ale asi to tu b˝t nemusÌ
    561e:	e0 91 e0 01 	lds	r30, 0x01E0
    5622:	f0 91 e1 01 	lds	r31, 0x01E1
    5626:	14 82       	std	Z+4, r1	; 0x04
    5628:	13 82       	std	Z+3, r1	; 0x03
    }
    dat_scr_status = 1; 
    562a:	81 e0       	ldi	r24, 0x01	; 1
    562c:	1e c1       	rjmp	.+572    	; 0x586a <data_scr_control+0x632>

/// Zajiöùuje pohyb kurzoru, p¯epÌn·nÌ do editaËnÈÈho reûimu
void control1(void){
  char c;
  
  if ((c = get_char()) != 0){
    562e:	0e 94 bc 1c 	call	0x3978	; 0x3978 <get_char>
    5632:	88 23       	and	r24, r24
    5634:	21 f0       	breq	.+8      	; 0x563e <data_scr_control+0x406>
    switch (c){
    5636:	80 32       	cpi	r24, 0x20	; 32
    5638:	09 f0       	breq	.+2      	; 0x563c <data_scr_control+0x404>
    563a:	36 c1       	rjmp	.+620    	; 0x58a8 <data_scr_control+0x670>
    563c:	31 c0       	rjmp	.+98     	; 0x56a0 <data_scr_control+0x468>
      data_scr_draw();        
      break;
    default:
      break;
    }
  }else if ((c = get_spec()) != 0){
    563e:	0e 94 f2 1c 	call	0x39e4	; 0x39e4 <get_spec>
    5642:	88 23       	and	r24, r24
    5644:	09 f4       	brne	.+2      	; 0x5648 <data_scr_control+0x410>
    5646:	30 c1       	rjmp	.+608    	; 0x58a8 <data_scr_control+0x670>
    switch(c){
    5648:	88 30       	cpi	r24, 0x08	; 8
    564a:	51 f1       	breq	.+84     	; 0x56a0 <data_scr_control+0x468>
    564c:	89 30       	cpi	r24, 0x09	; 9
    564e:	90 f4       	brcc	.+36     	; 0x5674 <data_scr_control+0x43c>
    5650:	85 30       	cpi	r24, 0x05	; 5
    5652:	09 f4       	brne	.+2      	; 0x5656 <data_scr_control+0x41e>
    5654:	1e c1       	rjmp	.+572    	; 0x5892 <data_scr_control+0x65a>
    5656:	86 30       	cpi	r24, 0x06	; 6
    5658:	30 f4       	brcc	.+12     	; 0x5666 <data_scr_control+0x42e>
    565a:	82 30       	cpi	r24, 0x02	; 2
    565c:	09 f1       	breq	.+66     	; 0x56a0 <data_scr_control+0x468>
    565e:	84 30       	cpi	r24, 0x04	; 4
    5660:	09 f0       	breq	.+2      	; 0x5664 <data_scr_control+0x42c>
    5662:	22 c1       	rjmp	.+580    	; 0x58a8 <data_scr_control+0x670>
    5664:	2c c0       	rjmp	.+88     	; 0x56be <data_scr_control+0x486>
    5666:	86 30       	cpi	r24, 0x06	; 6
    5668:	09 f4       	brne	.+2      	; 0x566c <data_scr_control+0x434>
    566a:	ee c0       	rjmp	.+476    	; 0x5848 <data_scr_control+0x610>
    566c:	87 30       	cpi	r24, 0x07	; 7
    566e:	09 f0       	breq	.+2      	; 0x5672 <data_scr_control+0x43a>
    5670:	1b c1       	rjmp	.+566    	; 0x58a8 <data_scr_control+0x670>
    5672:	fe c0       	rjmp	.+508    	; 0x5870 <data_scr_control+0x638>
    5674:	8b 30       	cpi	r24, 0x0B	; 11
    5676:	09 f4       	brne	.+2      	; 0x567a <data_scr_control+0x442>
    5678:	0e c1       	rjmp	.+540    	; 0x5896 <data_scr_control+0x65e>
    567a:	8c 30       	cpi	r24, 0x0C	; 12
    567c:	38 f4       	brcc	.+14     	; 0x568c <data_scr_control+0x454>
    567e:	89 30       	cpi	r24, 0x09	; 9
    5680:	09 f4       	brne	.+2      	; 0x5684 <data_scr_control+0x44c>
    5682:	f6 c0       	rjmp	.+492    	; 0x5870 <data_scr_control+0x638>
    5684:	8a 30       	cpi	r24, 0x0A	; 10
    5686:	09 f0       	breq	.+2      	; 0x568a <data_scr_control+0x452>
    5688:	0f c1       	rjmp	.+542    	; 0x58a8 <data_scr_control+0x670>
    568a:	0a c0       	rjmp	.+20     	; 0x56a0 <data_scr_control+0x468>
    568c:	85 31       	cpi	r24, 0x15	; 21
    568e:	09 f4       	brne	.+2      	; 0x5692 <data_scr_control+0x45a>
    5690:	06 c1       	rjmp	.+524    	; 0x589e <data_scr_control+0x666>
    5692:	86 31       	cpi	r24, 0x16	; 22
    5694:	09 f4       	brne	.+2      	; 0x5698 <data_scr_control+0x460>
    5696:	06 c1       	rjmp	.+524    	; 0x58a4 <data_scr_control+0x66c>
    5698:	8c 30       	cpi	r24, 0x0C	; 12
    569a:	09 f0       	breq	.+2      	; 0x569e <data_scr_control+0x466>
    569c:	05 c1       	rjmp	.+522    	; 0x58a8 <data_scr_control+0x670>
    569e:	f9 c0       	rjmp	.+498    	; 0x5892 <data_scr_control+0x65a>


/// Posune kurzor dolu.
void data_down(void){
	//  assert(1==0);
  if ((data_top > 0)&&(prohlizeny > 0)){
    56a0:	80 91 9b 01 	lds	r24, 0x019B
    56a4:	90 91 9c 01 	lds	r25, 0x019C
    56a8:	18 16       	cp	r1, r24
    56aa:	19 06       	cpc	r1, r25
    56ac:	0c f0       	brlt	.+2      	; 0x56b0 <data_scr_control+0x478>
    56ae:	ee c0       	rjmp	.+476    	; 0x588c <data_scr_control+0x654>
    56b0:	80 91 d2 01 	lds	r24, 0x01D2
    56b4:	88 23       	and	r24, r24
    56b6:	09 f4       	brne	.+2      	; 0x56ba <data_scr_control+0x482>
    56b8:	e9 c0       	rjmp	.+466    	; 0x588c <data_scr_control+0x654>
    prohlizeny--;
    56ba:	81 50       	subi	r24, 0x01	; 1
    56bc:	e5 c0       	rjmp	.+458    	; 0x5888 <data_scr_control+0x650>
 * Funkce zakl·d· menu pro editaci ˙daj˘ u namÏ¯en˝ch kmen˘.
 */
void menu_open(void){
  unsigned char radek =0;
  
  menu_i = 0;
    56be:	10 92 d3 01 	sts	0x01D3, r1
  dat_scr_status = 1;
    56c2:	81 e0       	ldi	r24, 0x01	; 1
    56c4:	80 93 d1 01 	sts	0x01D1, r24

	/* NastavenÌ ¯·dku */
  if (prohlizeny < 4){
    56c8:	20 91 d2 01 	lds	r18, 0x01D2
    56cc:	24 30       	cpi	r18, 0x04	; 4
    56ce:	10 f0       	brcs	.+4      	; 0x56d4 <data_scr_control+0x49c>
    56d0:	ee 24       	eor	r14, r14
    56d2:	03 c0       	rjmp	.+6      	; 0x56da <data_scr_control+0x4a2>
    radek = 3 - (unsigned char)prohlizeny;
    56d4:	b3 e0       	ldi	r27, 0x03	; 3
    56d6:	eb 2e       	mov	r14, r27
    56d8:	e2 1a       	sub	r14, r18
  }

	// oöet¯enÌ poloûky p¯idat
  if (prohlizeny == data_top){ //pridat
    56da:	42 2f       	mov	r20, r18
    56dc:	50 e0       	ldi	r21, 0x00	; 0
    56de:	80 91 9b 01 	lds	r24, 0x019B
    56e2:	90 91 9c 01 	lds	r25, 0x019C
    56e6:	48 17       	cp	r20, r24
    56e8:	59 07       	cpc	r21, r25
    56ea:	09 f0       	breq	.+2      	; 0x56ee <data_scr_control+0x4b6>
    56ec:	50 c0       	rjmp	.+160    	; 0x578e <data_scr_control+0x556>
    //printxyd(1,5,"pridavame");
    
    
    if (prohlizeny == (unsigned char) 0){
    56ee:	22 23       	and	r18, r18
    56f0:	39 f5       	brne	.+78     	; 0x5740 <data_scr_control+0x508>
      //printxyd(1,20,"prvni");
      //new_error(94);
      
      
      if (m_jmena[get_stored_menu_jmena_i()] != NULL){ // existuje nÏjak˝ z·kaznÌk
    56f2:	0e 94 f9 20 	call	0x41f2	; 0x41f2 <get_stored_menu_jmena_i>
    56f6:	e8 2f       	mov	r30, r24
    56f8:	f0 e0       	ldi	r31, 0x00	; 0
    56fa:	ee 0f       	add	r30, r30
    56fc:	ff 1f       	adc	r31, r31
    56fe:	ec 50       	subi	r30, 0x0C	; 12
    5700:	fd 4f       	sbci	r31, 0xFD	; 253
    5702:	80 81       	ld	r24, Z
    5704:	91 81       	ldd	r25, Z+1	; 0x01
    5706:	89 2b       	or	r24, r25
    5708:	b9 f0       	breq	.+46     	; 0x5738 <data_scr_control+0x500>
        data_zakaznik = get_stored_menu_jmena_i();
    570a:	0e 94 f9 20 	call	0x41f2	; 0x41f2 <get_stored_menu_jmena_i>
    570e:	80 93 a0 01 	sts	0x01A0, r24
        data_druh_dreva = (unsigned char)0;
    5712:	10 92 a3 01 	sts	0x01A3, r1
        data_operace = (unsigned char) 0;
    5716:	10 92 a4 01 	sts	0x01A4, r1
        data_delka = (unsigned char) 0;
    571a:	10 92 9f 01 	sts	0x019F, r1
    571e:	10 92 9e 01 	sts	0x019E, r1
        data_prumer = (unsigned char) 0;
    5722:	10 92 a2 01 	sts	0x01A2, r1
    5726:	10 92 a1 01 	sts	0x01A1, r1
        
        new_record(data_zakaznik, data_druh_dreva, data_operace, data_delka, data_prumer);
    572a:	60 e0       	ldi	r22, 0x00	; 0
    572c:	40 e0       	ldi	r20, 0x00	; 0
    572e:	20 e0       	ldi	r18, 0x00	; 0
    5730:	30 e0       	ldi	r19, 0x00	; 0
    5732:	00 e0       	ldi	r16, 0x00	; 0
    5734:	10 e0       	ldi	r17, 0x00	; 0
    5736:	16 c0       	rjmp	.+44     	; 0x5764 <data_scr_control+0x52c>
        printxyd(radek, 4,mezery(str_buf,8));
        vykresli_radek(data_top - 1, radek);
      }
      else{
        new_error(94);
    5738:	8e e5       	ldi	r24, 0x5E	; 94
    573a:	0e 94 4e 19 	call	0x329c	; 0x329c <new_error>
    573e:	2b c0       	rjmp	.+86     	; 0x5796 <data_scr_control+0x55e>
      } 
    }
    else{
      r_record((unsigned int)(data_top - 1));
    5740:	ca 01       	movw	r24, r20
    5742:	01 97       	sbiw	r24, 0x01	; 1
    5744:	0e 94 30 15 	call	0x2a60	; 0x2a60 <r_record>
      new_record(data_zakaznik, data_druh_dreva, data_operace, data_delka, data_prumer);
    5748:	20 91 9e 01 	lds	r18, 0x019E
    574c:	30 91 9f 01 	lds	r19, 0x019F
    5750:	00 91 a1 01 	lds	r16, 0x01A1
    5754:	10 91 a2 01 	lds	r17, 0x01A2
    5758:	80 91 a0 01 	lds	r24, 0x01A0
    575c:	60 91 a3 01 	lds	r22, 0x01A3
    5760:	40 91 a4 01 	lds	r20, 0x01A4
    5764:	0e 94 10 17 	call	0x2e20	; 0x2e20 <new_record>
      printxyd(radek, 4,mezery(str_buf,8));
    5768:	85 e2       	ldi	r24, 0x25	; 37
    576a:	92 e0       	ldi	r25, 0x02	; 2
    576c:	68 e0       	ldi	r22, 0x08	; 8
    576e:	0e 94 3a 14 	call	0x2874	; 0x2874 <mezery>
    5772:	ac 01       	movw	r20, r24
    5774:	8e 2d       	mov	r24, r14
    5776:	90 e0       	ldi	r25, 0x00	; 0
    5778:	64 e0       	ldi	r22, 0x04	; 4
    577a:	70 e0       	ldi	r23, 0x00	; 0
    577c:	0e 94 26 14 	call	0x284c	; 0x284c <printxyd>
      vykresli_radek(data_top - 1, radek);
    5780:	80 91 9b 01 	lds	r24, 0x019B
    5784:	81 50       	subi	r24, 0x01	; 1
    5786:	6e 2d       	mov	r22, r14
    5788:	0e 94 c6 27 	call	0x4f8c	; 0x4f8c <vykresli_radek>
    578c:	04 c0       	rjmp	.+8      	; 0x5796 <data_scr_control+0x55e>
    }

  }
  else{ //jinak
    r_record((unsigned int)prohlizeny);
    578e:	82 2f       	mov	r24, r18
    5790:	90 e0       	ldi	r25, 0x00	; 0
    5792:	0e 94 30 15 	call	0x2a60	; 0x2a60 <r_record>
  }



  menu[0] -> y = radek;  
    5796:	e0 91 d4 01 	lds	r30, 0x01D4
    579a:	f0 91 d5 01 	lds	r31, 0x01D5
    579e:	e1 82       	std	Z+1, r14	; 0x01
  menu[1] -> y = radek;  
    57a0:	e0 91 d6 01 	lds	r30, 0x01D6
    57a4:	f0 91 d7 01 	lds	r31, 0x01D7
    57a8:	e1 82       	std	Z+1, r14	; 0x01
  menu[2] -> y = radek;
    57aa:	e0 91 d8 01 	lds	r30, 0x01D8
    57ae:	f0 91 d9 01 	lds	r31, 0x01D9
    57b2:	e1 82       	std	Z+1, r14	; 0x01
  menu[3] -> y = radek;  
    57b4:	e0 91 da 01 	lds	r30, 0x01DA
    57b8:	f0 91 db 01 	lds	r31, 0x01DB
    57bc:	e1 82       	std	Z+1, r14	; 0x01
  menu[4] -> y = radek;
    57be:	e0 91 dc 01 	lds	r30, 0x01DC
    57c2:	f0 91 dd 01 	lds	r31, 0x01DD
    57c6:	e1 82       	std	Z+1, r14	; 0x01
  menu[5] -> y = radek;
    57c8:	e0 91 de 01 	lds	r30, 0x01DE
    57cc:	f0 91 df 01 	lds	r31, 0x01DF
    57d0:	e1 82       	std	Z+1, r14	; 0x01
  menu[6] -> y = radek;
    57d2:	e0 91 e0 01 	lds	r30, 0x01E0
    57d6:	f0 91 e1 01 	lds	r31, 0x01E1
    57da:	e1 82       	std	Z+1, r14	; 0x01

  menu[0] -> val = data_zakaznik;
    57dc:	e0 91 d4 01 	lds	r30, 0x01D4
    57e0:	f0 91 d5 01 	lds	r31, 0x01D5
    57e4:	80 91 a0 01 	lds	r24, 0x01A0
    57e8:	85 83       	std	Z+5, r24	; 0x05
  menu[1] -> val = data_druh_dreva;
    57ea:	e0 91 d6 01 	lds	r30, 0x01D6
    57ee:	f0 91 d7 01 	lds	r31, 0x01D7
    57f2:	80 91 a3 01 	lds	r24, 0x01A3
    57f6:	85 83       	std	Z+5, r24	; 0x05
  menu[2] -> val = ((data_operace >> 3) &1);  //1,2
    57f8:	e0 91 d8 01 	lds	r30, 0x01D8
    57fc:	f0 91 d9 01 	lds	r31, 0x01D9
    5800:	80 91 a4 01 	lds	r24, 0x01A4
    5804:	86 95       	lsr	r24
    5806:	86 95       	lsr	r24
    5808:	86 95       	lsr	r24
    580a:	81 70       	andi	r24, 0x01	; 1
    580c:	85 83       	std	Z+5, r24	; 0x05
  menu[3] -> val = ((data_operace >> 1) &3);  // dalsi_operace
    580e:	e0 91 da 01 	lds	r30, 0x01DA
    5812:	f0 91 db 01 	lds	r31, 0x01DB
    5816:	80 91 a4 01 	lds	r24, 0x01A4
    581a:	86 95       	lsr	r24
    581c:	83 70       	andi	r24, 0x03	; 3
    581e:	85 83       	std	Z+5, r24	; 0x05
  menu[4] -> val = ((data_operace) & 1);      // manipulace
    5820:	e0 91 dc 01 	lds	r30, 0x01DC
    5824:	f0 91 dd 01 	lds	r31, 0x01DD
    5828:	80 91 a4 01 	lds	r24, 0x01A4
    582c:	81 70       	andi	r24, 0x01	; 1
    582e:	85 83       	std	Z+5, r24	; 0x05

  printcxyd(radek,4,255); // vykreslenÌ spr·vnÈho kurzoru
    5830:	8e 2d       	mov	r24, r14
    5832:	90 e0       	ldi	r25, 0x00	; 0
    5834:	64 e0       	ldi	r22, 0x04	; 4
    5836:	70 e0       	ldi	r23, 0x00	; 0
    5838:	4f ef       	ldi	r20, 0xFF	; 255
    583a:	0e 94 fc 11 	call	0x23f8	; 0x23f8 <printcxyd>
  printcxyd(radek,0,' ');
    583e:	8e 2d       	mov	r24, r14
    5840:	90 e0       	ldi	r25, 0x00	; 0
    5842:	60 e0       	ldi	r22, 0x00	; 0
    5844:	70 e0       	ldi	r23, 0x00	; 0
    5846:	bc cd       	rjmp	.-1160   	; 0x53c0 <data_scr_control+0x188>
      //if (data_top != 0){
        menu_open();
      //}
      break;
    case 6: //Del
      if (prohlizeny != data_top){
    5848:	80 91 d2 01 	lds	r24, 0x01D2
    584c:	90 e0       	ldi	r25, 0x00	; 0
    584e:	20 91 9b 01 	lds	r18, 0x019B
    5852:	30 91 9c 01 	lds	r19, 0x019C
    5856:	82 17       	cp	r24, r18
    5858:	93 07       	cpc	r25, r19
    585a:	31 f1       	breq	.+76     	; 0x58a8 <data_scr_control+0x670>
        clear_dscreen();
    585c:	0e 94 9e 11 	call	0x233c	; 0x233c <clear_dscreen>
        ok_scr_init((char *)s_smazat_mereni);
    5860:	87 e4       	ldi	r24, 0x47	; 71
    5862:	9c e0       	ldi	r25, 0x0C	; 12
    5864:	0e 94 2a 19 	call	0x3254	; 0x3254 <ok_scr_init>
        dat_scr_status = 2;
    5868:	82 e0       	ldi	r24, 0x02	; 2
    586a:	80 93 d1 01 	sts	0x01D1, r24
    586e:	1c c0       	rjmp	.+56     	; 0x58a8 <data_scr_control+0x670>
}

/// Posune kurzor smÏrem vzh˘ru.
void data_up(void){
	//  assert(-1);
  if ((data_top > 0)&&(prohlizeny < ((unsigned char)(data_top - 0)))){ // -0 protoûe na vrchu je jeötÏ p¯idat
    5870:	20 91 9b 01 	lds	r18, 0x019B
    5874:	30 91 9c 01 	lds	r19, 0x019C
    5878:	12 16       	cp	r1, r18
    587a:	13 06       	cpc	r1, r19
    587c:	3c f4       	brge	.+14     	; 0x588c <data_scr_control+0x654>
    587e:	80 91 d2 01 	lds	r24, 0x01D2
    5882:	82 17       	cp	r24, r18
    5884:	18 f4       	brcc	.+6      	; 0x588c <data_scr_control+0x654>
    prohlizeny++;
    5886:	8f 5f       	subi	r24, 0xFF	; 255
    5888:	80 93 d2 01 	sts	0x01D2, r24
      }
      break;
    case 7:
    case 9:
      data_up();
      data_scr_draw();        
    588c:	0e 94 98 28 	call	0x5130	; 0x5130 <data_scr_draw>
    5890:	0b c0       	rjmp	.+22     	; 0x58a8 <data_scr_control+0x670>
      break;
    case 12://F2
    case 5: //Esc
      scr_ch(MSR_SCR);
    5892:	80 e0       	ldi	r24, 0x00	; 0
    5894:	01 c0       	rjmp	.+2      	; 0x5898 <data_scr_control+0x660>
      //measure_scr_draw();
      break;
    case 11: //F1
      scr_ch(HLP_SCR);
    5896:	82 e0       	ldi	r24, 0x02	; 2
    5898:	0e 94 c3 18 	call	0x3186	; 0x3186 <scr_ch>
    589c:	05 c0       	rjmp	.+10     	; 0x58a8 <data_scr_control+0x670>
      //help_scr_draw();
      break;
    case 21: // F11 - Strorno mÏ¯enÌ
      kf_zrusit();
    589e:	0e 94 09 32 	call	0x6412	; 0x6412 <kf_zrusit>
    58a2:	02 c0       	rjmp	.+4      	; 0x58a8 <data_scr_control+0x670>
      break;
    case 22: //F12
      // Odesl·nÌ dat.
      send_data();
    58a4:	0e 94 3c 2f 	call	0x5e78	; 0x5e78 <send_data>
    break;
  default:
    control1();
    break;
  }
}
    58a8:	2c 96       	adiw	r28, 0x0c	; 12
    58aa:	0f b6       	in	r0, 0x3f	; 63
    58ac:	f8 94       	cli
    58ae:	de bf       	out	0x3e, r29	; 62
    58b0:	0f be       	out	0x3f, r0	; 63
    58b2:	cd bf       	out	0x3d, r28	; 61
    58b4:	cf 91       	pop	r28
    58b6:	df 91       	pop	r29
    58b8:	1f 91       	pop	r17
    58ba:	0f 91       	pop	r16
    58bc:	ff 90       	pop	r15
    58be:	ef 90       	pop	r14
    58c0:	df 90       	pop	r13
    58c2:	cf 90       	pop	r12
    58c4:	bf 90       	pop	r11
    58c6:	08 95       	ret

000058c8 <dlst_scr_init>:
static char run = 0;


void dlst_scr_init(void){

}
    58c8:	08 95       	ret

000058ca <set_dlst_menu_i>:

/**
 * Funkce nastavÌ pozici kurzoru tak, aby jmÈno kterÈ je v msr_scr bylo vybr·no
 * i zde.
 */
void set_dlst_menu_i(char menu_jmena_i){
    58ca:	98 2f       	mov	r25, r24
    58cc:	a3 ef       	ldi	r26, 0xF3	; 243
    58ce:	b1 e0       	ldi	r27, 0x01	; 1
    58d0:	20 e0       	ldi	r18, 0x00	; 0
    58d2:	30 e0       	ldi	r19, 0x00	; 0
  int i =0;

  for (i = 0; i < (MAX_ZAKAZNIK + 1); i++){
    if (menu[i] -> val == menu_jmena_i ){
    58d4:	ed 91       	ld	r30, X+
    58d6:	fc 91       	ld	r31, X
    58d8:	11 97       	sbiw	r26, 0x01	; 1
    58da:	85 81       	ldd	r24, Z+5	; 0x05
    58dc:	89 17       	cp	r24, r25
    58de:	31 f0       	breq	.+12     	; 0x58ec <set_dlst_menu_i+0x22>
 * i zde.
 */
void set_dlst_menu_i(char menu_jmena_i){
  int i =0;

  for (i = 0; i < (MAX_ZAKAZNIK + 1); i++){
    58e0:	2f 5f       	subi	r18, 0xFF	; 255
    58e2:	3f 4f       	sbci	r19, 0xFF	; 255
    58e4:	12 96       	adiw	r26, 0x02	; 2
    58e6:	21 31       	cpi	r18, 0x11	; 17
    58e8:	31 05       	cpc	r19, r1
    58ea:	a1 f7       	brne	.-24     	; 0x58d4 <set_dlst_menu_i+0xa>
    if (menu[i] -> val == menu_jmena_i ){
      menu_i = i;
      break;
    }
  }
  menu_i = 0;
    58ec:	10 92 f2 01 	sts	0x01F2, r1
}
    58f0:	08 95       	ret

000058f2 <dlst_scr_close>:

void dlst_scr_close(void){
    58f2:	cf 93       	push	r28
    58f4:	df 93       	push	r29
    58f6:	c3 ef       	ldi	r28, 0xF3	; 243
    58f8:	d1 e0       	ldi	r29, 0x01	; 1
  int i;

  for ( i = 0; i < MAX_ZAKAZNIK; i++){
    free((void *)menu[i]);
    58fa:	89 91       	ld	r24, Y+
    58fc:	99 91       	ld	r25, Y+
    58fe:	0e 94 c6 32 	call	0x658c	; 0x658c <free>
}

void dlst_scr_close(void){
  int i;

  for ( i = 0; i < MAX_ZAKAZNIK; i++){
    5902:	82 e0       	ldi	r24, 0x02	; 2
    5904:	c3 31       	cpi	r28, 0x13	; 19
    5906:	d8 07       	cpc	r29, r24
    5908:	c1 f7       	brne	.-16     	; 0x58fa <dlst_scr_close+0x8>
    free((void *)menu[i]);
  }


  switch (run){
    590a:	80 91 f0 01 	lds	r24, 0x01F0
    590e:	81 30       	cpi	r24, 0x01	; 1
    5910:	11 f4       	brne	.+4      	; 0x5916 <dlst_scr_close+0x24>
  case 1:
    read_line_kill();
    5912:	0e 94 42 1f 	call	0x3e84	; 0x3e84 <read_line_kill>
    break;
  default:
    break;
  }

}
    5916:	df 91       	pop	r29
    5918:	cf 91       	pop	r28
    591a:	08 95       	ret

0000591c <dlst_scr_open>:
  akt_scr = DLST_SCR;
  clear_dscreen();
  menu_draw(menu,menu_len,menu_i);
}

void dlst_scr_open(void){
    591c:	df 92       	push	r13
    591e:	ef 92       	push	r14
    5920:	ff 92       	push	r15
    5922:	0f 93       	push	r16
    5924:	1f 93       	push	r17
    5926:	cf 93       	push	r28
    5928:	df 93       	push	r29
    592a:	03 ef       	ldi	r16, 0xF3	; 243
    592c:	11 e0       	ldi	r17, 0x01	; 1
    592e:	c0 e0       	ldi	r28, 0x00	; 0
    5930:	d0 e0       	ldi	r29, 0x00	; 0

  for (i = 0; i < (MAX_ZAKAZNIK ); i++) {
    menu[i] = new_menu_item();
    menu[i] -> x =(char) 1 + ((i / 4) * 9);
    menu[i] -> y =(char) (i % 4);
    menu[i] -> polozky = m_jmena;
    5932:	74 ef       	ldi	r23, 0xF4	; 244
    5934:	e7 2e       	mov	r14, r23
    5936:	72 e0       	ldi	r23, 0x02	; 2
    5938:	f7 2e       	mov	r15, r23
    menu[i] -> len = (char) MAX_ZAKAZNIK + 1;
    593a:	61 e1       	ldi	r22, 0x11	; 17
    593c:	d6 2e       	mov	r13, r22
  
  //if (menu_len < MAX_ZAKAZNIK) // pokud uû je seznam pln˝, tak se nevypisuje "Pridat"
    //m_jmena[MAX_ZAKAZNIK - 1] = menu_pridat;

  for (i = 0; i < (MAX_ZAKAZNIK ); i++) {
    menu[i] = new_menu_item();
    593e:	0e 94 32 1f 	call	0x3e64	; 0x3e64 <new_menu_item>
    5942:	fc 01       	movw	r30, r24
    5944:	d8 01       	movw	r26, r16
    5946:	11 96       	adiw	r26, 0x01	; 1
    5948:	9c 93       	st	X, r25
    594a:	8e 93       	st	-X, r24
    menu[i] -> x =(char) 1 + ((i / 4) * 9);
    594c:	9e 01       	movw	r18, r28
    594e:	35 95       	asr	r19
    5950:	27 95       	ror	r18
    5952:	35 95       	asr	r19
    5954:	27 95       	ror	r18
    5956:	c9 01       	movw	r24, r18
    5958:	43 e0       	ldi	r20, 0x03	; 3
    595a:	88 0f       	add	r24, r24
    595c:	99 1f       	adc	r25, r25
    595e:	4a 95       	dec	r20
    5960:	e1 f7       	brne	.-8      	; 0x595a <dlst_scr_open+0x3e>
    5962:	82 0f       	add	r24, r18
    5964:	93 1f       	adc	r25, r19
    5966:	8f 5f       	subi	r24, 0xFF	; 255
    5968:	80 83       	st	Z, r24
    menu[i] -> y =(char) (i % 4);
    596a:	ed 91       	ld	r30, X+
    596c:	fc 91       	ld	r31, X
    596e:	11 97       	sbiw	r26, 0x01	; 1
    5970:	ce 01       	movw	r24, r28
    5972:	83 70       	andi	r24, 0x03	; 3
    5974:	90 70       	andi	r25, 0x00	; 0
    5976:	81 83       	std	Z+1, r24	; 0x01
    menu[i] -> polozky = m_jmena;
    5978:	ed 91       	ld	r30, X+
    597a:	fd 91       	ld	r31, X+
    597c:	8d 01       	movw	r16, r26
    597e:	f4 82       	std	Z+4, r15	; 0x04
    5980:	e3 82       	std	Z+3, r14	; 0x03
    menu[i] -> len = (char) MAX_ZAKAZNIK + 1;
    5982:	d2 82       	std	Z+2, r13	; 0x02

  
  //if (menu_len < MAX_ZAKAZNIK) // pokud uû je seznam pln˝, tak se nevypisuje "Pridat"
    //m_jmena[MAX_ZAKAZNIK - 1] = menu_pridat;

  for (i = 0; i < (MAX_ZAKAZNIK ); i++) {
    5984:	21 96       	adiw	r28, 0x01	; 1
    5986:	c0 31       	cpi	r28, 0x10	; 16
    5988:	d1 05       	cpc	r29, r1
    598a:	c9 f6       	brne	.-78     	; 0x593e <dlst_scr_open+0x22>
  }

  i = 0;

//menu_jmena_i = 0
  menu_jmena_i = get_stored_menu_jmena_i();  
    598c:	0e 94 f9 20 	call	0x41f2	; 0x41f2 <get_stored_menu_jmena_i>
    5990:	10 91 f2 01 	lds	r17, 0x01F2
    5994:	d7 01       	movw	r26, r14
    5996:	40 e0       	ldi	r20, 0x00	; 0
    5998:	50 e0       	ldi	r21, 0x00	; 0
    599a:	20 e0       	ldi	r18, 0x00	; 0
    599c:	30 e0       	ldi	r19, 0x00	; 0

  // Tohle p¯i¯azuje kaûdÈ poloûce menu hodnotu o jedna vyûöÌ, ale p¯eskakuje to NULL
  while (j < (MAX_ZAKAZNIK + 1)){ // ta plus jedniËka je tam protoûe pole je o jedna vÏtöÌ. PoslednÌ poloûka pole je "p¯idat".
    if (m_jmena[j] != NULL){
      menu[i] -> val = j;
       if (menu_jmena_i == j) 
    599e:	68 2f       	mov	r22, r24
    59a0:	70 e0       	ldi	r23, 0x00	; 0
//menu_jmena_i = 0
  menu_jmena_i = get_stored_menu_jmena_i();  

  // Tohle p¯i¯azuje kaûdÈ poloûce menu hodnotu o jedna vyûöÌ, ale p¯eskakuje to NULL
  while (j < (MAX_ZAKAZNIK + 1)){ // ta plus jedniËka je tam protoûe pole je o jedna vÏtöÌ. PoslednÌ poloûka pole je "p¯idat".
    if (m_jmena[j] != NULL){
    59a2:	8d 91       	ld	r24, X+
    59a4:	9c 91       	ld	r25, X
    59a6:	11 97       	sbiw	r26, 0x01	; 1
    59a8:	89 2b       	or	r24, r25
    59aa:	79 f0       	breq	.+30     	; 0x59ca <dlst_scr_open+0xae>
      menu[i] -> val = j;
    59ac:	fa 01       	movw	r30, r20
    59ae:	ee 0f       	add	r30, r30
    59b0:	ff 1f       	adc	r31, r31
    59b2:	ed 50       	subi	r30, 0x0D	; 13
    59b4:	fe 4f       	sbci	r31, 0xFE	; 254
    59b6:	01 90       	ld	r0, Z+
    59b8:	f0 81       	ld	r31, Z
    59ba:	e0 2d       	mov	r30, r0
    59bc:	25 83       	std	Z+5, r18	; 0x05
       if (menu_jmena_i == j) 
    59be:	62 17       	cp	r22, r18
    59c0:	73 07       	cpc	r23, r19
    59c2:	09 f4       	brne	.+2      	; 0x59c6 <dlst_scr_open+0xaa>
         menu_i = i; 
    59c4:	14 2f       	mov	r17, r20
      i++;
    59c6:	4f 5f       	subi	r20, 0xFF	; 255
    59c8:	5f 4f       	sbci	r21, 0xFF	; 255
    }
    j++;
    59ca:	2f 5f       	subi	r18, 0xFF	; 255
    59cc:	3f 4f       	sbci	r19, 0xFF	; 255
    59ce:	12 96       	adiw	r26, 0x02	; 2

//menu_jmena_i = 0
  menu_jmena_i = get_stored_menu_jmena_i();  

  // Tohle p¯i¯azuje kaûdÈ poloûce menu hodnotu o jedna vyûöÌ, ale p¯eskakuje to NULL
  while (j < (MAX_ZAKAZNIK + 1)){ // ta plus jedniËka je tam protoûe pole je o jedna vÏtöÌ. PoslednÌ poloûka pole je "p¯idat".
    59d0:	21 31       	cpi	r18, 0x11	; 17
    59d2:	31 05       	cpc	r19, r1
    59d4:	31 f7       	brne	.-52     	; 0x59a2 <dlst_scr_open+0x86>
    59d6:	10 93 f2 01 	sts	0x01F2, r17
         menu_i = i; 
      i++;
    }
    j++;
  }
  menu_len =(char) (i < MAX_ZAKAZNIK + 1)? i :(MAX_ZAKAZNIK);
    59da:	fa 01       	movw	r30, r20
    59dc:	41 31       	cpi	r20, 0x11	; 17
    59de:	51 05       	cpc	r21, r1
    59e0:	14 f0       	brlt	.+4      	; 0x59e6 <dlst_scr_open+0xca>
    59e2:	e0 e1       	ldi	r30, 0x10	; 16
    59e4:	f0 e0       	ldi	r31, 0x00	; 0
    59e6:	e0 93 f1 01 	sts	0x01F1, r30
  if (menu_len <= menu_jmena_i){
    menu_jmena_i = 0;
  }
}
    59ea:	df 91       	pop	r29
    59ec:	cf 91       	pop	r28
    59ee:	1f 91       	pop	r17
    59f0:	0f 91       	pop	r16
    59f2:	ff 90       	pop	r15
    59f4:	ef 90       	pop	r14
    59f6:	df 90       	pop	r13
    59f8:	08 95       	ret

000059fa <dlst_scr_draw>:
void dlst_scr_init(void){

}

void dlst_scr_draw(void){
  akt_scr = DLST_SCR;
    59fa:	85 e0       	ldi	r24, 0x05	; 5
    59fc:	80 93 a5 01 	sts	0x01A5, r24
  clear_dscreen();
    5a00:	0e 94 9e 11 	call	0x233c	; 0x233c <clear_dscreen>
  menu_draw(menu,menu_len,menu_i);
    5a04:	83 ef       	ldi	r24, 0xF3	; 243
    5a06:	91 e0       	ldi	r25, 0x01	; 1
    5a08:	60 91 f1 01 	lds	r22, 0x01F1
    5a0c:	40 91 f2 01 	lds	r20, 0x01F2
    5a10:	0e 94 66 1e 	call	0x3ccc	; 0x3ccc <menu_draw>
}
    5a14:	08 95       	ret

00005a16 <dlst_scr_control>:
 * ve stavu 0 je obrazovka v norm·lnÌm reûimu
 * ve stavu jedna uûivatel zd·v· jmÈno a vöechny znaky z kl·vesnice jsou proto
 * posÌl·ny do jmÈna.
 * stav 2 je stav, v nÏmû je obrazovka p¯i potvrzov·nÌ vymaz·nÌ jmÈna
 */
void dlst_scr_control(void){
    5a16:	1f 93       	push	r17
    5a18:	cf 93       	push	r28
    5a1a:	df 93       	push	r29

  char c;
  if (run == 1){
    5a1c:	80 91 f0 01 	lds	r24, 0x01F0
    5a20:	81 30       	cpi	r24, 0x01	; 1
    5a22:	69 f5       	brne	.+90     	; 0x5a7e <dlst_scr_control+0x68>
    char *s;
    if ((s = read_line()) != NULL){
    5a24:	0e 94 5b 1f 	call	0x3eb6	; 0x3eb6 <read_line>
    5a28:	fc 01       	movw	r30, r24
    5a2a:	00 97       	sbiw	r24, 0x00	; 0
    5a2c:	09 f4       	brne	.+2      	; 0x5a30 <dlst_scr_control+0x1a>
    5a2e:	13 c1       	rjmp	.+550    	; 0x5c56 <dlst_scr_control+0x240>
      if (s[0] != '\0'){
    5a30:	80 81       	ld	r24, Z
    5a32:	88 23       	and	r24, r24
    5a34:	a9 f0       	breq	.+42     	; 0x5a60 <dlst_scr_control+0x4a>
	char m;
        //tady by to ölo p¯ealokovat
        /// @TODO Zde je moûnÈ uöet¯it pamÏù.
        m_jmena[MAX_ZAKAZNIK] = menu_pridat;
    5a36:	80 91 93 00 	lds	r24, 0x0093
    5a3a:	90 91 94 00 	lds	r25, 0x0094
    5a3e:	90 93 15 03 	sts	0x0315, r25
    5a42:	80 93 14 03 	sts	0x0314, r24
        m = dat_add_zakaznik(s);
    5a46:	cf 01       	movw	r24, r30
    5a48:	0e 94 46 16 	call	0x2c8c	; 0x2c8c <dat_add_zakaznik>
    5a4c:	18 2f       	mov	r17, r24

	run = 0; // je to zde proto, aby nedoch·zelo k n·silnÈmu
    5a4e:	10 92 f0 01 	sts	0x01F0, r1
		 // ukonËenÌ funkcÌ read_line_kill bÏhem
		 // n·sledujÌcÌho uzav¯enÌ a otev¯enÌ dlst_scr
        
	// tyto ¯·dky jsou zde (asi :-) ) proto, aby p¯i zad·nÌ novÈho jmÈna doölo k posunu k
	// p¯ekrreslen displeje a posusu tlaËÌtka "pridat"
	dlst_scr_close();
    5a52:	0e 94 79 2c 	call	0x58f2	; 0x58f2 <dlst_scr_close>
        dlst_scr_open();
    5a56:	0e 94 8e 2c 	call	0x591c	; 0x591c <dlst_scr_open>
        menu_i = m;
    5a5a:	10 93 f2 01 	sts	0x01F2, r17
    5a5e:	1b c0       	rjmp	.+54     	; 0x5a96 <dlst_scr_control+0x80>
        
      }
      else { // pokud Esc,  nebo je retezec nulove delky
        free((void *) m_jmena[MAX_ZAKAZNIK]);
    5a60:	80 91 14 03 	lds	r24, 0x0314
    5a64:	90 91 15 03 	lds	r25, 0x0315
    5a68:	0e 94 c6 32 	call	0x658c	; 0x658c <free>
        m_jmena[MAX_ZAKAZNIK] = menu_pridat;
    5a6c:	80 91 93 00 	lds	r24, 0x0093
    5a70:	90 91 94 00 	lds	r25, 0x0094
    5a74:	90 93 15 03 	sts	0x0315, r25
    5a78:	80 93 14 03 	sts	0x0314, r24
    5a7c:	0c c0       	rjmp	.+24     	; 0x5a96 <dlst_scr_control+0x80>
      }
      dlst_scr_draw(); 
      run = 0;
    }
  }else if (run == 2){ //potvrzenÌ p¯ed smaz·nÌm jmÈna
    5a7e:	82 30       	cpi	r24, 0x02	; 2
    5a80:	31 f5       	brne	.+76     	; 0x5ace <dlst_scr_control+0xb8>
    switch (ok_scr()){
    5a82:	0e 94 0b 19 	call	0x3216	; 0x3216 <ok_scr>
    5a86:	2f ef       	ldi	r18, 0xFF	; 255
    5a88:	8f 3f       	cpi	r24, 0xFF	; 255
    5a8a:	92 07       	cpc	r25, r18
    5a8c:	21 f0       	breq	.+8      	; 0x5a96 <dlst_scr_control+0x80>
    5a8e:	01 97       	sbiw	r24, 0x01	; 1
    5a90:	09 f0       	breq	.+2      	; 0x5a94 <dlst_scr_control+0x7e>
    5a92:	e1 c0       	rjmp	.+450    	; 0x5c56 <dlst_scr_control+0x240>
    5a94:	05 c0       	rjmp	.+10     	; 0x5aa0 <dlst_scr_control+0x8a>
    case -1:
      dlst_scr_draw();
    5a96:	0e 94 fd 2c 	call	0x59fa	; 0x59fa <dlst_scr_draw>
//        clear_dscreen();
      //menu_draw(menu,menu_len, menu_i);
      run = 0;
    5a9a:	10 92 f0 01 	sts	0x01F0, r1
    5a9e:	db c0       	rjmp	.+438    	; 0x5c56 <dlst_scr_control+0x240>
      break;
    case 1:
      run = 0;
    5aa0:	10 92 f0 01 	sts	0x01F0, r1
      //free((void *)jmena[(int)menu_i]);
      //odstran_jmeno(menu_i);
      dat_odstran_zakaznika(menu[(int)menu_i] -> val);
    5aa4:	e0 91 f2 01 	lds	r30, 0x01F2
    5aa8:	f0 e0       	ldi	r31, 0x00	; 0
    5aaa:	ee 0f       	add	r30, r30
    5aac:	ff 1f       	adc	r31, r31
    5aae:	ed 50       	subi	r30, 0x0D	; 13
    5ab0:	fe 4f       	sbci	r31, 0xFE	; 254
    5ab2:	01 90       	ld	r0, Z+
    5ab4:	f0 81       	ld	r31, Z
    5ab6:	e0 2d       	mov	r30, r0
    5ab8:	85 81       	ldd	r24, Z+5	; 0x05
    5aba:	90 e0       	ldi	r25, 0x00	; 0
    5abc:	0e 94 64 16 	call	0x2cc8	; 0x2cc8 <dat_odstran_zakaznika>
      dlst_scr_close();
    5ac0:	0e 94 79 2c 	call	0x58f2	; 0x58f2 <dlst_scr_close>
      dlst_scr_open();
    5ac4:	0e 94 8e 2c 	call	0x591c	; 0x591c <dlst_scr_open>
      dlst_scr_draw();
    5ac8:	0e 94 fd 2c 	call	0x59fa	; 0x59fa <dlst_scr_draw>
    5acc:	c4 c0       	rjmp	.+392    	; 0x5c56 <dlst_scr_control+0x240>
      //menu_draw(menu,menu_len, menu_i);
      break;
    default:
      break;
    }    
  }else if ((c = get_spec()) != 0){
    5ace:	0e 94 f2 1c 	call	0x39e4	; 0x39e4 <get_spec>
    5ad2:	88 23       	and	r24, r24
    5ad4:	09 f4       	brne	.+2      	; 0x5ad8 <dlst_scr_control+0xc2>
    5ad6:	bf c0       	rjmp	.+382    	; 0x5c56 <dlst_scr_control+0x240>
    switch(c){
    5ad8:	88 30       	cpi	r24, 0x08	; 8
    5ada:	31 f1       	breq	.+76     	; 0x5b28 <dlst_scr_control+0x112>
    5adc:	89 30       	cpi	r24, 0x09	; 9
    5ade:	90 f4       	brcc	.+36     	; 0x5b04 <dlst_scr_control+0xee>
    5ae0:	85 30       	cpi	r24, 0x05	; 5
    5ae2:	09 f4       	brne	.+2      	; 0x5ae6 <dlst_scr_control+0xd0>
    5ae4:	8f c0       	rjmp	.+286    	; 0x5c04 <dlst_scr_control+0x1ee>
    5ae6:	86 30       	cpi	r24, 0x06	; 6
    5ae8:	30 f4       	brcc	.+12     	; 0x5af6 <dlst_scr_control+0xe0>
    5aea:	82 30       	cpi	r24, 0x02	; 2
    5aec:	e9 f0       	breq	.+58     	; 0x5b28 <dlst_scr_control+0x112>
    5aee:	84 30       	cpi	r24, 0x04	; 4
    5af0:	09 f0       	breq	.+2      	; 0x5af4 <dlst_scr_control+0xde>
    5af2:	b1 c0       	rjmp	.+354    	; 0x5c56 <dlst_scr_control+0x240>
    5af4:	2d c0       	rjmp	.+90     	; 0x5b50 <dlst_scr_control+0x13a>
    5af6:	86 30       	cpi	r24, 0x06	; 6
    5af8:	09 f4       	brne	.+2      	; 0x5afc <dlst_scr_control+0xe6>
    5afa:	86 c0       	rjmp	.+268    	; 0x5c08 <dlst_scr_control+0x1f2>
    5afc:	87 30       	cpi	r24, 0x07	; 7
    5afe:	09 f0       	breq	.+2      	; 0x5b02 <dlst_scr_control+0xec>
    5b00:	aa c0       	rjmp	.+340    	; 0x5c56 <dlst_scr_control+0x240>
    5b02:	1b c0       	rjmp	.+54     	; 0x5b3a <dlst_scr_control+0x124>
    5b04:	8b 30       	cpi	r24, 0x0B	; 11
    5b06:	09 f4       	brne	.+2      	; 0x5b0a <dlst_scr_control+0xf4>
    5b08:	9d c0       	rjmp	.+314    	; 0x5c44 <dlst_scr_control+0x22e>
    5b0a:	8c 30       	cpi	r24, 0x0C	; 12
    5b0c:	30 f4       	brcc	.+12     	; 0x5b1a <dlst_scr_control+0x104>
    5b0e:	89 30       	cpi	r24, 0x09	; 9
    5b10:	a1 f0       	breq	.+40     	; 0x5b3a <dlst_scr_control+0x124>
    5b12:	8a 30       	cpi	r24, 0x0A	; 10
    5b14:	09 f0       	breq	.+2      	; 0x5b18 <dlst_scr_control+0x102>
    5b16:	9f c0       	rjmp	.+318    	; 0x5c56 <dlst_scr_control+0x240>
    5b18:	07 c0       	rjmp	.+14     	; 0x5b28 <dlst_scr_control+0x112>
    5b1a:	85 31       	cpi	r24, 0x15	; 21
    5b1c:	09 f4       	brne	.+2      	; 0x5b20 <dlst_scr_control+0x10a>
    5b1e:	96 c0       	rjmp	.+300    	; 0x5c4c <dlst_scr_control+0x236>
    5b20:	86 31       	cpi	r24, 0x16	; 22
    5b22:	09 f0       	breq	.+2      	; 0x5b26 <dlst_scr_control+0x110>
    5b24:	98 c0       	rjmp	.+304    	; 0x5c56 <dlst_scr_control+0x240>
    5b26:	95 c0       	rjmp	.+298    	; 0x5c52 <dlst_scr_control+0x23c>
    case 2: //Tab
    case 8:
    case 10:
      menu_i = menu_next_item(menu, menu_i, menu_len);
    5b28:	83 ef       	ldi	r24, 0xF3	; 243
    5b2a:	91 e0       	ldi	r25, 0x01	; 1
    5b2c:	60 91 f2 01 	lds	r22, 0x01F2
    5b30:	40 91 f1 01 	lds	r20, 0x01F1
    5b34:	0e 94 7b 1d 	call	0x3af6	; 0x3af6 <menu_next_item>
    5b38:	08 c0       	rjmp	.+16     	; 0x5b4a <dlst_scr_control+0x134>
      break;
    case 7:
    case 9:
      menu_i = menu_prev_item(menu, menu_i, menu_len);
    5b3a:	83 ef       	ldi	r24, 0xF3	; 243
    5b3c:	91 e0       	ldi	r25, 0x01	; 1
    5b3e:	60 91 f2 01 	lds	r22, 0x01F2
    5b42:	40 91 f1 01 	lds	r20, 0x01F1
    5b46:	0e 94 44 1d 	call	0x3a88	; 0x3a88 <menu_prev_item>
    5b4a:	80 93 f2 01 	sts	0x01F2, r24
    5b4e:	83 c0       	rjmp	.+262    	; 0x5c56 <dlst_scr_control+0x240>
      break;
    case 4: //Enter
      // p¯epoËet z indexu menu v dlst_scr na index seznamu jmen na msr_scr
      if (m_jmena[menu[(int)menu_i] ->val] == menu_pridat){ //nove jmeno
    5b50:	e0 91 f2 01 	lds	r30, 0x01F2
    5b54:	f0 e0       	ldi	r31, 0x00	; 0
    5b56:	ee 0f       	add	r30, r30
    5b58:	ff 1f       	adc	r31, r31
    5b5a:	ed 50       	subi	r30, 0x0D	; 13
    5b5c:	fe 4f       	sbci	r31, 0xFE	; 254
    5b5e:	01 90       	ld	r0, Z+
    5b60:	f0 81       	ld	r31, Z
    5b62:	e0 2d       	mov	r30, r0
    5b64:	45 81       	ldd	r20, Z+5	; 0x05
    5b66:	e4 2f       	mov	r30, r20
    5b68:	f0 e0       	ldi	r31, 0x00	; 0
    5b6a:	ee 0f       	add	r30, r30
    5b6c:	ff 1f       	adc	r31, r31
    5b6e:	ec 50       	subi	r30, 0x0C	; 12
    5b70:	fd 4f       	sbci	r31, 0xFD	; 253
    5b72:	20 81       	ld	r18, Z
    5b74:	31 81       	ldd	r19, Z+1	; 0x01
    5b76:	80 91 93 00 	lds	r24, 0x0093
    5b7a:	90 91 94 00 	lds	r25, 0x0094
    5b7e:	28 17       	cp	r18, r24
    5b80:	39 07       	cpc	r19, r25
    5b82:	e9 f5       	brne	.+122    	; 0x5bfe <dlst_scr_control+0x1e8>
	char * s = (char *)malloc(9); // TODO ölo by to pak p¯ealokovat na menöÌ
    5b84:	89 e0       	ldi	r24, 0x09	; 9
    5b86:	90 e0       	ldi	r25, 0x00	; 0
    5b88:	0e 94 19 32 	call	0x6432	; 0x6432 <malloc>
    5b8c:	ec 01       	movw	r28, r24
	if (s == NULL)
    5b8e:	00 97       	sbiw	r24, 0x00	; 0
    5b90:	11 f4       	brne	.+4      	; 0x5b96 <dlst_scr_control+0x180>
	  new_error(88);
    5b92:	88 e5       	ldi	r24, 0x58	; 88
    5b94:	54 c0       	rjmp	.+168    	; 0x5c3e <dlst_scr_control+0x228>
	else{
	  mezery(s,8);
    5b96:	68 e0       	ldi	r22, 0x08	; 8
    5b98:	0e 94 3a 14 	call	0x2874	; 0x2874 <mezery>
	  s[8] = '\0';
    5b9c:	18 86       	std	Y+8, r1	; 0x08
	  s[0] = 'z';
    5b9e:	8a e7       	ldi	r24, 0x7A	; 122
    5ba0:	88 83       	st	Y, r24
	  s[1] = 'a';
    5ba2:	81 e6       	ldi	r24, 0x61	; 97
    5ba4:	89 83       	std	Y+1, r24	; 0x01
	  s[2] = 'k';
    5ba6:	8b e6       	ldi	r24, 0x6B	; 107
    5ba8:	8a 83       	std	Y+2, r24	; 0x02
	  s[3] = ((menu_i + 1) / 10) + '0';
    5baa:	e0 91 f2 01 	lds	r30, 0x01F2
    5bae:	f0 e0       	ldi	r31, 0x00	; 0
    5bb0:	9f 01       	movw	r18, r30
    5bb2:	2f 5f       	subi	r18, 0xFF	; 255
    5bb4:	3f 4f       	sbci	r19, 0xFF	; 255
    5bb6:	c9 01       	movw	r24, r18
    5bb8:	6a e0       	ldi	r22, 0x0A	; 10
    5bba:	70 e0       	ldi	r23, 0x00	; 0
    5bbc:	0e 94 96 3b 	call	0x772c	; 0x772c <__divmodhi4>
    5bc0:	60 5d       	subi	r22, 0xD0	; 208
    5bc2:	6b 83       	std	Y+3, r22	; 0x03
	  s[4] = ((menu_i + 1) % 10) + '0';
    5bc4:	c9 01       	movw	r24, r18
    5bc6:	6a e0       	ldi	r22, 0x0A	; 10
    5bc8:	70 e0       	ldi	r23, 0x00	; 0
    5bca:	0e 94 96 3b 	call	0x772c	; 0x772c <__divmodhi4>
    5bce:	80 5d       	subi	r24, 0xD0	; 208
    5bd0:	8c 83       	std	Y+4, r24	; 0x04
	  s[5] = '\0';
    5bd2:	1d 82       	std	Y+5, r1	; 0x05
	  m_jmena[MAX_ZAKAZNIK] = s;
    5bd4:	d0 93 15 03 	sts	0x0315, r29
    5bd8:	c0 93 14 03 	sts	0x0314, r28
	  read_line_init_edefault (menu[(int)menu_i] -> y, menu[(int)menu_i] -> x, s,8);
    5bdc:	ee 0f       	add	r30, r30
    5bde:	ff 1f       	adc	r31, r31
    5be0:	ed 50       	subi	r30, 0x0D	; 13
    5be2:	fe 4f       	sbci	r31, 0xFE	; 254
    5be4:	01 90       	ld	r0, Z+
    5be6:	f0 81       	ld	r31, Z
    5be8:	e0 2d       	mov	r30, r0
    5bea:	60 81       	ld	r22, Z
    5bec:	81 81       	ldd	r24, Z+1	; 0x01
    5bee:	90 e0       	ldi	r25, 0x00	; 0
    5bf0:	70 e0       	ldi	r23, 0x00	; 0
    5bf2:	ae 01       	movw	r20, r28
    5bf4:	28 e0       	ldi	r18, 0x08	; 8
    5bf6:	0e 94 58 20 	call	0x40b0	; 0x40b0 <read_line_init_edefault>
	  run = 1;
    5bfa:	81 e0       	ldi	r24, 0x01	; 1
    5bfc:	1c c0       	rjmp	.+56     	; 0x5c36 <dlst_scr_control+0x220>
	}
        
      }
      else{
	set_menu_jmena_i((unsigned char)menu[(int)menu_i] -> val);
    5bfe:	84 2f       	mov	r24, r20
    5c00:	0e 94 09 21 	call	0x4212	; 0x4212 <set_menu_jmena_i>
	scr_ch(MSR_SCR);
      }
      break;
    case 5: //Esc  
      scr_ch(MSR_SCR);
    5c04:	80 e0       	ldi	r24, 0x00	; 0
    5c06:	1f c0       	rjmp	.+62     	; 0x5c46 <dlst_scr_control+0x230>
      break;
    case 6: //Del
      if (menu[(int)menu_i] -> val != MAX_ZAKAZNIK){
    5c08:	e0 91 f2 01 	lds	r30, 0x01F2
    5c0c:	f0 e0       	ldi	r31, 0x00	; 0
    5c0e:	ee 0f       	add	r30, r30
    5c10:	ff 1f       	adc	r31, r31
    5c12:	ed 50       	subi	r30, 0x0D	; 13
    5c14:	fe 4f       	sbci	r31, 0xFE	; 254
    5c16:	01 90       	ld	r0, Z+
    5c18:	f0 81       	ld	r31, Z
    5c1a:	e0 2d       	mov	r30, r0
    5c1c:	85 81       	ldd	r24, Z+5	; 0x05
    5c1e:	80 31       	cpi	r24, 0x10	; 16
    5c20:	d1 f0       	breq	.+52     	; 0x5c56 <dlst_scr_control+0x240>
	if (find_last_record_of_zakaznik(menu[(int)menu_i] -> val) == -1){
    5c22:	0e 94 17 16 	call	0x2c2e	; 0x2c2e <find_last_record_of_zakaznik>
    5c26:	8f 5f       	subi	r24, 0xFF	; 255
    5c28:	9f 4f       	sbci	r25, 0xFF	; 255
    5c2a:	41 f4       	brne	.+16     	; 0x5c3c <dlst_scr_control+0x226>
	  ok_scr_init((char *)s_smazat);
    5c2c:	8c e6       	ldi	r24, 0x6C	; 108
    5c2e:	9c e0       	ldi	r25, 0x0C	; 12
    5c30:	0e 94 2a 19 	call	0x3254	; 0x3254 <ok_scr_init>
	  run = 2;
    5c34:	82 e0       	ldi	r24, 0x02	; 2
    5c36:	80 93 f0 01 	sts	0x01F0, r24
    5c3a:	0d c0       	rjmp	.+26     	; 0x5c56 <dlst_scr_control+0x240>
	}
	else{
	  new_error(95);
    5c3c:	8f e5       	ldi	r24, 0x5F	; 95
    5c3e:	0e 94 4e 19 	call	0x329c	; 0x329c <new_error>
    5c42:	09 c0       	rjmp	.+18     	; 0x5c56 <dlst_scr_control+0x240>
      }
      break;
      
      
    case 11: //F11
      scr_ch(HLP_SCR);
    5c44:	82 e0       	ldi	r24, 0x02	; 2
    5c46:	0e 94 c3 18 	call	0x3186	; 0x3186 <scr_ch>
    5c4a:	05 c0       	rjmp	.+10     	; 0x5c56 <dlst_scr_control+0x240>
      //help_scr_draw();
      break;
    case 21: // F11 - Strorno mÏ¯enÌ
      kf_zrusit();
    5c4c:	0e 94 09 32 	call	0x6412	; 0x6412 <kf_zrusit>
    5c50:	02 c0       	rjmp	.+4      	; 0x5c56 <dlst_scr_control+0x240>
      break;
    case 22: //F12
      // Odesl·nÌ dat.
      send_data();
    5c52:	0e 94 3c 2f 	call	0x5e78	; 0x5e78 <send_data>
      break;
    default:
      break;
    }
  }
}
    5c56:	df 91       	pop	r29
    5c58:	cf 91       	pop	r28
    5c5a:	1f 91       	pop	r17
    5c5c:	08 95       	ret

00005c5e <send_next_data>:

/**
 * Funkce odeöle dalöÌ data.
 * Je vol·na z venku od seriovÈ linky.
 */
void send_next_data(char*s){  
    5c5e:	cf 93       	push	r28
    5c60:	df 93       	push	r29


  if (stav == 1){// umlceni katru //Zatim nefunkcni pocatecni stav neni 1, ale 2
    5c62:	80 91 13 02 	lds	r24, 0x0213
    5c66:	81 30       	cpi	r24, 0x01	; 1
    5c68:	49 f4       	brne	.+18     	; 0x5c7c <send_next_data+0x1e>
    char * msg;
    msg =(void*) mmalloc (LenOfMsg);
    5c6a:	8b e0       	ldi	r24, 0x0B	; 11
    5c6c:	90 e0       	ldi	r25, 0x00	; 0
    5c6e:	0e 94 c1 06 	call	0xd82	; 0xd82 <mmalloc>
    5c72:	fc 01       	movw	r30, r24
    
    msg[0] = '\x09';
    5c74:	89 e0       	ldi	r24, 0x09	; 9
    5c76:	80 83       	st	Z, r24
    msg[1] = 0;
    5c78:	11 82       	std	Z+1, r1	; 0x01
    5c7a:	09 c0       	rjmp	.+18     	; 0x5c8e <send_next_data+0x30>
    new_ack_msg(msg,MSG_REPEATS,send_next_data, err91);
    stav++;
    return;
  }
  if (stav == 2){ // informace pro server o zah·jenÌ odesÌl·nÌ dat
    5c7c:	82 30       	cpi	r24, 0x02	; 2
    5c7e:	a9 f4       	brne	.+42     	; 0x5caa <send_next_data+0x4c>
    char * msg;
    msg =(void*) mmalloc (LenOfMsg);
    5c80:	8b e0       	ldi	r24, 0x0B	; 11
    5c82:	90 e0       	ldi	r25, 0x00	; 0
    5c84:	0e 94 c1 06 	call	0xd82	; 0xd82 <mmalloc>
    5c88:	fc 01       	movw	r30, r24

    msg[0] = '\x44'; //TODO nevim jestli je ËÌslo zpr·vy spr·vnÏ
    5c8a:	84 e4       	ldi	r24, 0x44	; 68
    5c8c:	80 83       	st	Z, r24
    new_ack_msg(msg,MSG_REPEATS,send_next_data,err91);
    5c8e:	cf 01       	movw	r24, r30
    5c90:	62 e0       	ldi	r22, 0x02	; 2
    5c92:	4f e2       	ldi	r20, 0x2F	; 47
    5c94:	5e e2       	ldi	r21, 0x2E	; 46
    5c96:	28 e4       	ldi	r18, 0x48	; 72
    5c98:	3f e2       	ldi	r19, 0x2F	; 47
    5c9a:	0e 94 c8 0c 	call	0x1990	; 0x1990 <new_ack_msg>
    stav++;
    5c9e:	80 91 13 02 	lds	r24, 0x0213
    5ca2:	8f 5f       	subi	r24, 0xFF	; 255
    5ca4:	80 93 13 02 	sts	0x0213, r24
    5ca8:	e4 c0       	rjmp	.+456    	; 0x5e72 <send_next_data+0x214>
    return;
  }
  if (stav == 3){//odesÌl·nÌ jmen
    5caa:	83 30       	cpi	r24, 0x03	; 3
    5cac:	09 f0       	breq	.+2      	; 0x5cb0 <send_next_data+0x52>
    5cae:	4e c0       	rjmp	.+156    	; 0x5d4c <send_next_data+0xee>
    5cb0:	20 91 14 02 	lds	r18, 0x0214
    5cb4:	30 91 15 02 	lds	r19, 0x0215
    5cb8:	f9 01       	movw	r30, r18
    5cba:	ee 0f       	add	r30, r30
    5cbc:	ff 1f       	adc	r31, r31
    5cbe:	ec 50       	subi	r30, 0x0C	; 12
    5cc0:	fd 4f       	sbci	r31, 0xFD	; 253
    5cc2:	02 c0       	rjmp	.+4      	; 0x5cc8 <send_next_data+0x6a>
    5cc4:	2f 5f       	subi	r18, 0xFF	; 255
    5cc6:	3f 4f       	sbci	r19, 0xFF	; 255
/**
 * Funkce sestavÌ zpr·vu kter· obsahuje jmÈno z·kaznÌka a jeho id.
 * Tato zpr·va je uloûena do server_data_buffer
 */
char * name_msg(void){
  while ((m_jmena[(int)id_counter] == NULL)&&(id_counter < MAX_ZAKAZNIK - 1)){
    5cc8:	80 81       	ld	r24, Z
    5cca:	91 81       	ldd	r25, Z+1	; 0x01
    5ccc:	89 2b       	or	r24, r25
    5cce:	29 f4       	brne	.+10     	; 0x5cda <send_next_data+0x7c>
    5cd0:	32 96       	adiw	r30, 0x02	; 2
    5cd2:	2f 30       	cpi	r18, 0x0F	; 15
    5cd4:	31 05       	cpc	r19, r1
    5cd6:	b0 f3       	brcs	.-20     	; 0x5cc4 <send_next_data+0x66>
    5cd8:	30 c0       	rjmp	.+96     	; 0x5d3a <send_next_data+0xdc>
    5cda:	30 93 15 02 	sts	0x0215, r19
    5cde:	20 93 14 02 	sts	0x0214, r18
    id_counter++;
  }
  if (m_jmena[(int)id_counter] != NULL){
    char * msg;
    msg =(void*) mmalloc (LenOfMsg);
    5ce2:	8b e0       	ldi	r24, 0x0B	; 11
    5ce4:	90 e0       	ldi	r25, 0x00	; 0
    5ce6:	0e 94 c1 06 	call	0xd82	; 0xd82 <mmalloc>
    5cea:	ec 01       	movw	r28, r24
    msg[0]='\x41';
    5cec:	81 e4       	ldi	r24, 0x41	; 65
    5cee:	88 83       	st	Y, r24
    msg[1] = id_counter;
    5cf0:	e0 91 14 02 	lds	r30, 0x0214
    5cf4:	f0 91 15 02 	lds	r31, 0x0215
    5cf8:	e9 83       	std	Y+1, r30	; 0x01
    strncpy(msg + 3, m_jmena[(int)id_counter], 8);
    5cfa:	ee 0f       	add	r30, r30
    5cfc:	ff 1f       	adc	r31, r31
    5cfe:	ec 50       	subi	r30, 0x0C	; 12
    5d00:	fd 4f       	sbci	r31, 0xFD	; 253
    5d02:	60 81       	ld	r22, Z
    5d04:	71 81       	ldd	r23, Z+1	; 0x01
    5d06:	ce 01       	movw	r24, r28
    5d08:	03 96       	adiw	r24, 0x03	; 3
    5d0a:	48 e0       	ldi	r20, 0x08	; 8
    5d0c:	50 e0       	ldi	r21, 0x00	; 0
    5d0e:	0e 94 3e 33 	call	0x667c	; 0x667c <strncpy>
    id_counter++;
    5d12:	80 91 14 02 	lds	r24, 0x0214
    5d16:	90 91 15 02 	lds	r25, 0x0215
    5d1a:	01 96       	adiw	r24, 0x01	; 1
    5d1c:	90 93 15 02 	sts	0x0215, r25
    5d20:	80 93 14 02 	sts	0x0214, r24
    stav++;
    return;
  }
  if (stav == 3){//odesÌl·nÌ jmen
    char * msg;
    if ((msg = name_msg()) != NULL){
    5d24:	20 97       	sbiw	r28, 0x00	; 0
    5d26:	49 f0       	breq	.+18     	; 0x5d3a <send_next_data+0xdc>
      new_ack_msg(msg,MSG_REPEATS,send_next_data,err91);
    5d28:	ce 01       	movw	r24, r28
    5d2a:	62 e0       	ldi	r22, 0x02	; 2
    5d2c:	4f e2       	ldi	r20, 0x2F	; 47
    5d2e:	5e e2       	ldi	r21, 0x2E	; 46
    5d30:	28 e4       	ldi	r18, 0x48	; 72
    5d32:	3f e2       	ldi	r19, 0x2F	; 47
    5d34:	0e 94 c8 0c 	call	0x1990	; 0x1990 <new_ack_msg>
    5d38:	09 c0       	rjmp	.+18     	; 0x5d4c <send_next_data+0xee>
    }
    else{
      stav++;
    5d3a:	80 91 13 02 	lds	r24, 0x0213
    5d3e:	8f 5f       	subi	r24, 0xFF	; 255
    5d40:	80 93 13 02 	sts	0x0213, r24
      id_counter = 0;
    5d44:	10 92 15 02 	sts	0x0215, r1
    5d48:	10 92 14 02 	sts	0x0214, r1
    }
  } 
  if (stav == 4){ //odesÌl·nÌ vlastnÌch dat
    5d4c:	80 91 13 02 	lds	r24, 0x0213
    5d50:	84 30       	cpi	r24, 0x04	; 4
    5d52:	09 f0       	breq	.+2      	; 0x5d56 <send_next_data+0xf8>
    5d54:	6e c0       	rjmp	.+220    	; 0x5e32 <send_next_data+0x1d4>
/**
 * Funkce vytvo¯Ì zpr·vu, kter· obsahuje namÏ¯en· data. Zpr·va je uloûena
 * do server_data_buffer.
 */
char * mereni_msg(void){//todo
  if (id_counter < data_top){
    5d56:	20 91 14 02 	lds	r18, 0x0214
    5d5a:	30 91 15 02 	lds	r19, 0x0215
    5d5e:	80 91 9b 01 	lds	r24, 0x019B
    5d62:	90 91 9c 01 	lds	r25, 0x019C
    5d66:	28 17       	cp	r18, r24
    5d68:	39 07       	cpc	r19, r25
    5d6a:	08 f0       	brcs	.+2      	; 0x5d6e <send_next_data+0x110>
    5d6c:	5d c0       	rjmp	.+186    	; 0x5e28 <send_next_data+0x1ca>
    char * msg;
    msg =(void*) mmalloc (LenOfMsg);
    5d6e:	8b e0       	ldi	r24, 0x0B	; 11
    5d70:	90 e0       	ldi	r25, 0x00	; 0
    5d72:	0e 94 c1 06 	call	0xd82	; 0xd82 <mmalloc>
    5d76:	ec 01       	movw	r28, r24

    r_record((unsigned int)id_counter);
    5d78:	80 91 14 02 	lds	r24, 0x0214
    5d7c:	90 91 15 02 	lds	r25, 0x0215
    5d80:	0e 94 30 15 	call	0x2a60	; 0x2a60 <r_record>
    //r_record((uint16_t)0);
    msg[0] = '\x42';
    5d84:	82 e4       	ldi	r24, 0x42	; 66
    5d86:	88 83       	st	Y, r24
    msg[1] = (unsigned char)id_counter;
    5d88:	20 91 14 02 	lds	r18, 0x0214
    5d8c:	30 91 15 02 	lds	r19, 0x0215
    5d90:	29 83       	std	Y+1, r18	; 0x01
    msg[2] = (unsigned char)data_zakaznik;
    5d92:	80 91 a0 01 	lds	r24, 0x01A0
    5d96:	8a 83       	std	Y+2, r24	; 0x02
    msg[3] = (unsigned char)(data_delka / 255);
    5d98:	80 91 9e 01 	lds	r24, 0x019E
    5d9c:	90 91 9f 01 	lds	r25, 0x019F
    5da0:	6f ef       	ldi	r22, 0xFF	; 255
    5da2:	70 e0       	ldi	r23, 0x00	; 0
    5da4:	0e 94 82 3b 	call	0x7704	; 0x7704 <__udivmodhi4>
    5da8:	6b 83       	std	Y+3, r22	; 0x03
    msg[4] = (unsigned char)(data_delka % 255);
    5daa:	80 91 9e 01 	lds	r24, 0x019E
    5dae:	90 91 9f 01 	lds	r25, 0x019F
    5db2:	6f ef       	ldi	r22, 0xFF	; 255
    5db4:	70 e0       	ldi	r23, 0x00	; 0
    5db6:	0e 94 82 3b 	call	0x7704	; 0x7704 <__udivmodhi4>
    5dba:	8c 83       	std	Y+4, r24	; 0x04
    msg[5] = (unsigned char)(data_prumer / 255);
    5dbc:	80 91 a1 01 	lds	r24, 0x01A1
    5dc0:	90 91 a2 01 	lds	r25, 0x01A2
    5dc4:	6f ef       	ldi	r22, 0xFF	; 255
    5dc6:	70 e0       	ldi	r23, 0x00	; 0
    5dc8:	0e 94 82 3b 	call	0x7704	; 0x7704 <__udivmodhi4>
    5dcc:	6d 83       	std	Y+5, r22	; 0x05
    msg[6] = (unsigned char)(data_prumer % 255);
    5dce:	80 91 a1 01 	lds	r24, 0x01A1
    5dd2:	90 91 a2 01 	lds	r25, 0x01A2
    5dd6:	6f ef       	ldi	r22, 0xFF	; 255
    5dd8:	70 e0       	ldi	r23, 0x00	; 0
    5dda:	0e 94 82 3b 	call	0x7704	; 0x7704 <__udivmodhi4>
    5dde:	8e 83       	std	Y+6, r24	; 0x06
    msg[7] = (unsigned char)data_druh_dreva;
    5de0:	80 91 a3 01 	lds	r24, 0x01A3
    5de4:	8f 83       	std	Y+7, r24	; 0x07
    msg[8] = (unsigned char)((data_operace >> 3)&1); /* jednou, dvakr·t */
    5de6:	80 91 a4 01 	lds	r24, 0x01A4
    5dea:	86 95       	lsr	r24
    5dec:	86 95       	lsr	r24
    5dee:	86 95       	lsr	r24
    5df0:	81 70       	andi	r24, 0x01	; 1
    5df2:	88 87       	std	Y+8, r24	; 0x08
    msg[9] = (unsigned char)((data_operace >> 1)&3); /* dalöÌ operace */
    5df4:	80 91 a4 01 	lds	r24, 0x01A4
    5df8:	86 95       	lsr	r24
    5dfa:	83 70       	andi	r24, 0x03	; 3
    5dfc:	89 87       	std	Y+9, r24	; 0x09
    msg[10]= (unsigned char)((data_operace)&1); /* manipulace */  
    5dfe:	80 91 a4 01 	lds	r24, 0x01A4
    5e02:	81 70       	andi	r24, 0x01	; 1
    5e04:	8a 87       	std	Y+10, r24	; 0x0a
    id_counter++;
    5e06:	2f 5f       	subi	r18, 0xFF	; 255
    5e08:	3f 4f       	sbci	r19, 0xFF	; 255
    5e0a:	30 93 15 02 	sts	0x0215, r19
    5e0e:	20 93 14 02 	sts	0x0214, r18
      id_counter = 0;
    }
  } 
  if (stav == 4){ //odesÌl·nÌ vlastnÌch dat
    char * msg;
    if ((msg = mereni_msg()) != NULL){
    5e12:	20 97       	sbiw	r28, 0x00	; 0
    5e14:	49 f0       	breq	.+18     	; 0x5e28 <send_next_data+0x1ca>
      new_ack_msg(msg,MSG_REPEATS,send_next_data,err91);
    5e16:	ce 01       	movw	r24, r28
    5e18:	62 e0       	ldi	r22, 0x02	; 2
    5e1a:	4f e2       	ldi	r20, 0x2F	; 47
    5e1c:	5e e2       	ldi	r21, 0x2E	; 46
    5e1e:	28 e4       	ldi	r18, 0x48	; 72
    5e20:	3f e2       	ldi	r19, 0x2F	; 47
    5e22:	0e 94 c8 0c 	call	0x1990	; 0x1990 <new_ack_msg>
    5e26:	05 c0       	rjmp	.+10     	; 0x5e32 <send_next_data+0x1d4>
    }
    else{
      stav++;
    5e28:	80 91 13 02 	lds	r24, 0x0213
    5e2c:	8f 5f       	subi	r24, 0xFF	; 255
    5e2e:	80 93 13 02 	sts	0x0213, r24
    }
  }
  if (stav == 5){ //z·vÏreËn· zpr·va
    5e32:	80 91 13 02 	lds	r24, 0x0213
    5e36:	85 30       	cpi	r24, 0x05	; 5
    5e38:	39 f4       	brne	.+14     	; 0x5e48 <send_next_data+0x1ea>
 * servru dojde k neËtenÌ dat do datab·ze. Po p¯Ìjmu jejÌho potvrzenÌ zde jsou
 * smaz·ny z·znamy.
 */
char * over_msg(void){
    char * msg;
    msg =(void*) mmalloc (LenOfMsg);
    5e3a:	8b e0       	ldi	r24, 0x0B	; 11
    5e3c:	90 e0       	ldi	r25, 0x00	; 0
    5e3e:	0e 94 c1 06 	call	0xd82	; 0xd82 <mmalloc>
    5e42:	fc 01       	movw	r30, r24

    msg[0] = '\x43';
    5e44:	83 e4       	ldi	r24, 0x43	; 67
    5e46:	22 cf       	rjmp	.-444    	; 0x5c8c <send_next_data+0x2e>
    msg = over_msg();
    new_ack_msg(msg,MSG_REPEATS,send_next_data,err91);
    stav++;
    return;
  }
  if (stav == 6){ // TODO zatÌm neaktivnÌ - odkomentovat
    5e48:	86 30       	cpi	r24, 0x06	; 6
    5e4a:	51 f4       	brne	.+20     	; 0x5e60 <send_next_data+0x202>
/// @todo odstranÏnÌ z·znam˘.
// Zde by mÏlo dojÌt k vymaz·nÌ datab·ze.
// Je to totiû nejblÌûe od poslednÌ zpr·vy
// pro server.
    char * msg;
    msg =(void*) mmalloc (LenOfMsg);
    5e4c:	8b e0       	ldi	r24, 0x0B	; 11
    5e4e:	90 e0       	ldi	r25, 0x00	; 0
    5e50:	0e 94 c1 06 	call	0xd82	; 0xd82 <mmalloc>
    5e54:	fc 01       	movw	r30, r24

    msg[0] = '\x09';
    5e56:	89 e0       	ldi	r24, 0x09	; 9
    5e58:	80 83       	st	Z, r24
    msg[1] = 1;
    5e5a:	81 e0       	ldi	r24, 0x01	; 1
    5e5c:	81 83       	std	Z+1, r24	; 0x01
    5e5e:	17 cf       	rjmp	.-466    	; 0x5c8e <send_next_data+0x30>
    new_ack_msg(msg,MSG_REPEATS,send_next_data,err91);
    stav++;
    return;
  }

  if (stav == 7){
    5e60:	87 30       	cpi	r24, 0x07	; 7
    5e62:	39 f4       	brne	.+14     	; 0x5e72 <send_next_data+0x214>
    new_error(200); // V˝pis : Data odesl·na.
    5e64:	88 ec       	ldi	r24, 0xC8	; 200
    5e66:	0e 94 4e 19 	call	0x329c	; 0x329c <new_error>
    // prisla odpoved na posledni zpravu -> delete zaznamy
    dat_del_all();
    5e6a:	0e 94 90 16 	call	0x2d20	; 0x2d20 <dat_del_all>
    msr_storno();
    5e6e:	0e 94 cc 07 	call	0xf98	; 0xf98 <msr_storno>
  }

}
    5e72:	df 91       	pop	r29
    5e74:	cf 91       	pop	r28
    5e76:	08 95       	ret

00005e78 <send_data>:

}

/** Funkce zahajuje odeslÌl·nÌ dat */
void send_data(void){
  id_counter = 0;
    5e78:	10 92 15 02 	sts	0x0215, r1
    5e7c:	10 92 14 02 	sts	0x0214, r1
  stav = 1;
    5e80:	81 e0       	ldi	r24, 0x01	; 1
    5e82:	80 93 13 02 	sts	0x0213, r24
  
  send_next_data(NULL);
    5e86:	80 e0       	ldi	r24, 0x00	; 0
    5e88:	90 e0       	ldi	r25, 0x00	; 0
    5e8a:	0e 94 2f 2e 	call	0x5c5e	; 0x5c5e <send_next_data>
  //if (name_msg() == 1){
  //new_ack_msg(server_data_buffer,send_next_data);
  //}
}
    5e8e:	08 95       	ret

00005e90 <err91>:
 * Funkce je vol·na v p¯ÌpadÏ ne˙spÏönÈho Ëek·nÌ na odpovÏÔ. VypÌöe
 * chybovou hl·öku a obnovÌ komunikaci se za¯ÌzenÌm na katru.
 */
static void err91(void){
  char * msg;
  new_error(91);
    5e90:	8b e5       	ldi	r24, 0x5B	; 91
    5e92:	0e 94 4e 19 	call	0x329c	; 0x329c <new_error>
 * servru dojde k neËtenÌ dat do datab·ze. Po p¯Ìjmu jejÌho potvrzenÌ zde jsou
 * smaz·ny z·znamy.
 */
char * over_msg(void){
    char * msg;
    msg =(void*) mmalloc (LenOfMsg);
    5e96:	8b e0       	ldi	r24, 0x0B	; 11
    5e98:	90 e0       	ldi	r25, 0x00	; 0
    5e9a:	0e 94 c1 06 	call	0xd82	; 0xd82 <mmalloc>
    5e9e:	fc 01       	movw	r30, r24

    msg[0] = '\x43';
    5ea0:	83 e4       	ldi	r24, 0x43	; 67
    5ea2:	80 83       	st	Z, r24
 */
static void err91(void){
  char * msg;
  new_error(91);
  msg = over_msg();
  new_msg(msg);
    5ea4:	cf 01       	movw	r24, r30
    5ea6:	0e 94 46 0c 	call	0x188c	; 0x188c <new_msg>

}
    5eaa:	08 95       	ret

00005eac <buttons_init>:

void buttons_init(void){
  //NastavenÌ pull-up
  // Ve skuteËnosti bude PORTC == 0xff, protoûe na prvnÌm pinu je
  // kl·vesnice, kter· si jej taky nastavÌ.
  PORTC |= 0xFE;
    5eac:	85 b3       	in	r24, 0x15	; 21
    5eae:	8e 6f       	ori	r24, 0xFE	; 254
    5eb0:	85 bb       	out	0x15, r24	; 21
  minuly_stav = 254; //PINC
    5eb2:	8e ef       	ldi	r24, 0xFE	; 254
    5eb4:	80 93 16 02 	sts	0x0216, r24
}
    5eb8:	08 95       	ret

00005eba <buttons>:

void buttons(void){
    5eba:	ff 92       	push	r15
    5ebc:	0f 93       	push	r16
    5ebe:	1f 93       	push	r17
    5ec0:	cf 93       	push	r28
    5ec2:	df 93       	push	r29
  char zmena;
  char vzorek_pinc = PINC;
    5ec4:	f3 b2       	in	r15, 0x13	; 19
  int i = 0;



  zmena = minuly_stav^vzorek_pinc;
    5ec6:	80 91 16 02 	lds	r24, 0x0216
    5eca:	8f 25       	eor	r24, r15
    5ecc:	c1 e0       	ldi	r28, 0x01	; 1
    5ece:	d0 e0       	ldi	r29, 0x00	; 0


  for (i = 1; i < 8; i++)
  {
    if (((zmena >> i) & 1 ) == 1)
    5ed0:	08 2f       	mov	r16, r24
    5ed2:	10 e0       	ldi	r17, 0x00	; 0
    5ed4:	c8 01       	movw	r24, r16
    5ed6:	0c 2e       	mov	r0, r28
    5ed8:	02 c0       	rjmp	.+4      	; 0x5ede <buttons+0x24>
    5eda:	95 95       	asr	r25
    5edc:	87 95       	ror	r24
    5ede:	0a 94       	dec	r0
    5ee0:	e2 f7       	brpl	.-8      	; 0x5eda <buttons+0x20>
    5ee2:	80 ff       	sbrs	r24, 0
    5ee4:	33 c0       	rjmp	.+102    	; 0x5f4c <buttons+0x92>
    { //doölo-li ke zmÏnÏ na p¯sluönÈm pinu
      if (((minuly_stav >> i) & 1) == 1)
    5ee6:	80 91 16 02 	lds	r24, 0x0216
    5eea:	90 e0       	ldi	r25, 0x00	; 0
    5eec:	0c 2e       	mov	r0, r28
    5eee:	02 c0       	rjmp	.+4      	; 0x5ef4 <buttons+0x3a>
    5ef0:	95 95       	asr	r25
    5ef2:	87 95       	ror	r24
    5ef4:	0a 94       	dec	r0
    5ef6:	e2 f7       	brpl	.-8      	; 0x5ef0 <buttons+0x36>
    5ef8:	80 ff       	sbrs	r24, 0
    5efa:	28 c0       	rjmp	.+80     	; 0x5f4c <buttons+0x92>
 * 
 * @param button
 * Ud·v· kterÈ tlaËÌtko bylo stisknuto.
 */
void button_on(char button){
  switch(button)
    5efc:	c4 30       	cpi	r28, 0x04	; 4
    5efe:	c9 f0       	breq	.+50     	; 0x5f32 <buttons+0x78>
    5f00:	c5 30       	cpi	r28, 0x05	; 5
    5f02:	38 f4       	brcc	.+14     	; 0x5f12 <buttons+0x58>
    5f04:	c2 30       	cpi	r28, 0x02	; 2
    5f06:	79 f0       	breq	.+30     	; 0x5f26 <buttons+0x6c>
    5f08:	c3 30       	cpi	r28, 0x03	; 3
    5f0a:	80 f4       	brcc	.+32     	; 0x5f2c <buttons+0x72>
    5f0c:	c1 30       	cpi	r28, 0x01	; 1
    5f0e:	f1 f4       	brne	.+60     	; 0x5f4c <buttons+0x92>
    5f10:	07 c0       	rjmp	.+14     	; 0x5f20 <buttons+0x66>
    5f12:	c6 30       	cpi	r28, 0x06	; 6
    5f14:	a1 f0       	breq	.+40     	; 0x5f3e <buttons+0x84>
    5f16:	c6 30       	cpi	r28, 0x06	; 6
    5f18:	78 f0       	brcs	.+30     	; 0x5f38 <buttons+0x7e>
    5f1a:	c7 30       	cpi	r28, 0x07	; 7
    5f1c:	b9 f4       	brne	.+46     	; 0x5f4c <buttons+0x92>
    5f1e:	12 c0       	rjmp	.+36     	; 0x5f44 <buttons+0x8a>
  {
  case 1:
    keyb_in_buff(2,22);
    5f20:	82 e0       	ldi	r24, 0x02	; 2
    5f22:	66 e1       	ldi	r22, 0x16	; 22
    5f24:	11 c0       	rjmp	.+34     	; 0x5f48 <buttons+0x8e>
    break;
  case 2:
    keyb_in_buff(2,19);
    5f26:	82 e0       	ldi	r24, 0x02	; 2
    5f28:	63 e1       	ldi	r22, 0x13	; 19
    5f2a:	0e c0       	rjmp	.+28     	; 0x5f48 <buttons+0x8e>
    break;
  case 3:
    keyb_in_buff(2,21);
    5f2c:	82 e0       	ldi	r24, 0x02	; 2
    5f2e:	65 e1       	ldi	r22, 0x15	; 21
    5f30:	0b c0       	rjmp	.+22     	; 0x5f48 <buttons+0x8e>
    break;
  case 4:
    keyb_in_buff(2,7);
    5f32:	82 e0       	ldi	r24, 0x02	; 2
    5f34:	67 e0       	ldi	r22, 0x07	; 7
    5f36:	08 c0       	rjmp	.+16     	; 0x5f48 <buttons+0x8e>
    break;
  case 5:
    keyb_in_buff(2,8);
    5f38:	82 e0       	ldi	r24, 0x02	; 2
    5f3a:	68 e0       	ldi	r22, 0x08	; 8
    5f3c:	05 c0       	rjmp	.+10     	; 0x5f48 <buttons+0x8e>
    break;
  case 6:
    keyb_in_buff(2,4);
    5f3e:	82 e0       	ldi	r24, 0x02	; 2
    5f40:	64 e0       	ldi	r22, 0x04	; 4
    5f42:	02 c0       	rjmp	.+4      	; 0x5f48 <buttons+0x8e>
    break;
  case 7:
    keyb_in_buff(2,5);
    5f44:	82 e0       	ldi	r24, 0x02	; 2
    5f46:	65 e0       	ldi	r22, 0x05	; 5
    5f48:	0e 94 31 1b 	call	0x3662	; 0x3662 <keyb_in_buff>


  zmena = minuly_stav^vzorek_pinc;


  for (i = 1; i < 8; i++)
    5f4c:	21 96       	adiw	r28, 0x01	; 1
    5f4e:	c8 30       	cpi	r28, 0x08	; 8
    5f50:	d1 05       	cpc	r29, r1
    5f52:	09 f0       	breq	.+2      	; 0x5f56 <buttons+0x9c>
    5f54:	bf cf       	rjmp	.-130    	; 0x5ed4 <buttons+0x1a>
      {
        // button_off((char)i);
      }
    }
  }
  minuly_stav = vzorek_pinc;
    5f56:	f0 92 16 02 	sts	0x0216, r15
}
    5f5a:	df 91       	pop	r29
    5f5c:	cf 91       	pop	r28
    5f5e:	1f 91       	pop	r17
    5f60:	0f 91       	pop	r16
    5f62:	ff 90       	pop	r15
    5f64:	08 95       	ret

00005f66 <ser_scr_open>:
#include "main.h"
#include "keyboard.h"
#include "ser_scr.h"


void ser_scr_open(void){
    5f66:	df 92       	push	r13
    5f68:	ef 92       	push	r14
    5f6a:	ff 92       	push	r15
    5f6c:	0f 93       	push	r16
    5f6e:	1f 93       	push	r17
    5f70:	cf 93       	push	r28
    5f72:	df 93       	push	r29
  int i;
  akt_scr = SER_SCR;
    5f74:	87 e0       	ldi	r24, 0x07	; 7
    5f76:	80 93 a5 01 	sts	0x01A5, r24
  clear_dscreen();
    5f7a:	0e 94 9e 11 	call	0x233c	; 0x233c <clear_dscreen>
    5f7e:	c0 e0       	ldi	r28, 0x00	; 0
    5f80:	d0 e0       	ldi	r29, 0x00	; 0
  
  for (i = 0;i < LenOfRecvBuff; i++){
    char c;
    c = usart_get_recv_buff(i);
    5f82:	ce 01       	movw	r24, r28
    5f84:	0e 94 41 0c 	call	0x1882	; 0x1882 <usart_get_recv_buff>
    5f88:	d8 2e       	mov	r13, r24
    printcxyd(i%4,(i/4) * 7, c);
    5f8a:	43 e0       	ldi	r20, 0x03	; 3
    5f8c:	e4 2e       	mov	r14, r20
    5f8e:	f1 2c       	mov	r15, r1
    5f90:	ec 22       	and	r14, r28
    5f92:	fd 22       	and	r15, r29
    5f94:	ce 01       	movw	r24, r28
    5f96:	95 95       	asr	r25
    5f98:	87 95       	ror	r24
    5f9a:	95 95       	asr	r25
    5f9c:	87 95       	ror	r24
    5f9e:	8c 01       	movw	r16, r24
    5fa0:	23 e0       	ldi	r18, 0x03	; 3
    5fa2:	00 0f       	add	r16, r16
    5fa4:	11 1f       	adc	r17, r17
    5fa6:	2a 95       	dec	r18
    5fa8:	e1 f7       	brne	.-8      	; 0x5fa2 <ser_scr_open+0x3c>
    5faa:	08 1b       	sub	r16, r24
    5fac:	19 0b       	sbc	r17, r25
    5fae:	c7 01       	movw	r24, r14
    5fb0:	b8 01       	movw	r22, r16
    5fb2:	4d 2d       	mov	r20, r13
    5fb4:	0e 94 fc 11 	call	0x23f8	; 0x23f8 <printcxyd>
    printxyd(i%4,(i/4) * 7 + 2, int2strn(str_buf,3,(unsigned int)c));    
    5fb8:	85 e2       	ldi	r24, 0x25	; 37
    5fba:	92 e0       	ldi	r25, 0x02	; 2
    5fbc:	63 e0       	ldi	r22, 0x03	; 3
    5fbe:	70 e0       	ldi	r23, 0x00	; 0
    5fc0:	4d 2d       	mov	r20, r13
    5fc2:	50 e0       	ldi	r21, 0x00	; 0
    5fc4:	0e 94 5d 14 	call	0x28ba	; 0x28ba <int2strn>
    5fc8:	ac 01       	movw	r20, r24
    5fca:	0e 5f       	subi	r16, 0xFE	; 254
    5fcc:	1f 4f       	sbci	r17, 0xFF	; 255
    5fce:	c7 01       	movw	r24, r14
    5fd0:	b8 01       	movw	r22, r16
    5fd2:	0e 94 26 14 	call	0x284c	; 0x284c <printxyd>
void ser_scr_open(void){
  int i;
  akt_scr = SER_SCR;
  clear_dscreen();
  
  for (i = 0;i < LenOfRecvBuff; i++){
    5fd6:	21 96       	adiw	r28, 0x01	; 1
    5fd8:	c2 31       	cpi	r28, 0x12	; 18
    5fda:	d1 05       	cpc	r29, r1
    5fdc:	91 f6       	brne	.-92     	; 0x5f82 <ser_scr_open+0x1c>
    char c;
    c = usart_get_recv_buff(i);
    printcxyd(i%4,(i/4) * 7, c);
    printxyd(i%4,(i/4) * 7 + 2, int2strn(str_buf,3,(unsigned int)c));    
  }
}
    5fde:	df 91       	pop	r29
    5fe0:	cf 91       	pop	r28
    5fe2:	1f 91       	pop	r17
    5fe4:	0f 91       	pop	r16
    5fe6:	ff 90       	pop	r15
    5fe8:	ef 90       	pop	r14
    5fea:	df 90       	pop	r13
    5fec:	08 95       	ret

00005fee <ser_scr_control>:

void ser_scr_control(void){
  char c;

  if ((c = get_spec()) != 0){
    5fee:	0e 94 f2 1c 	call	0x39e4	; 0x39e4 <get_spec>
    5ff2:	88 23       	and	r24, r24
    5ff4:	59 f0       	breq	.+22     	; 0x600c <ser_scr_control+0x1e>
    switch (c){
    5ff6:	85 30       	cpi	r24, 0x05	; 5
    5ff8:	19 f0       	breq	.+6      	; 0x6000 <ser_scr_control+0x12>
    5ffa:	8d 30       	cpi	r24, 0x0D	; 13
    5ffc:	39 f4       	brne	.+14     	; 0x600c <ser_scr_control+0x1e>
    5ffe:	04 c0       	rjmp	.+8      	; 0x6008 <ser_scr_control+0x1a>
    case 5: //Esc
      scr_ch(MSR_SCR);
    6000:	80 e0       	ldi	r24, 0x00	; 0
    6002:	0e 94 c3 18 	call	0x3186	; 0x3186 <scr_ch>
    6006:	08 95       	ret
      //measure_scr_draw();
      break;
    case 13: //refresh
      ser_scr_open();
    6008:	0e 94 b3 2f 	call	0x5f66	; 0x5f66 <ser_scr_open>
    600c:	08 95       	ret

0000600e <wtch_init>:
/// »ÌtaË mÈho watchdogu. pokud bude vÏtöÌ neû 200, dojde k v˝pisu chybovÈ hl·öky.
uint16_t wtch_counter = 0;


void wtch_init(void){
  wtch_enable2();
    600e:	10 92 18 02 	sts	0x0218, r1
    6012:	10 92 17 02 	sts	0x0217, r1
    6016:	2f e0       	ldi	r18, 0x0F	; 15
    6018:	88 e1       	ldi	r24, 0x18	; 24
    601a:	90 e0       	ldi	r25, 0x00	; 0
    601c:	0f b6       	in	r0, 0x3f	; 63
    601e:	f8 94       	cli
    6020:	a8 95       	wdr
    6022:	81 bd       	out	0x21, r24	; 33
    6024:	0f be       	out	0x3f, r0	; 63
    6026:	21 bd       	out	0x21, r18	; 33
//  wdt_enable(WDTO_2S);
}
    6028:	08 95       	ret

0000602a <wtch_main>:
 */
void wtch_main(void){
  if (wtch_counter < 0){ // Sluûba je vypnuta

  }
  else if (wtch_counter < MY_WATCHDOG){// vöechno v po¯·dku
    602a:	80 91 17 02 	lds	r24, 0x0217
    602e:	90 91 18 02 	lds	r25, 0x0218
    6032:	27 e2       	ldi	r18, 0x27	; 39
    6034:	80 31       	cpi	r24, 0x10	; 16
    6036:	92 07       	cpc	r25, r18
    6038:	30 f4       	brcc	.+12     	; 0x6046 <wtch_main+0x1c>
    wtch_counter++;
    603a:	01 96       	adiw	r24, 0x01	; 1
    603c:	90 93 18 02 	sts	0x0218, r25
    6040:	80 93 17 02 	sts	0x0217, r24
    for(;;){
      //tohle je resetov·nÌ softwarovÈho watchodogu.
      wtch_reset();
    };
  }
}
    6044:	08 95       	ret
  else if (wtch_counter < MY_WATCHDOG){// vöechno v po¯·dku
    wtch_counter++;
  }
  else { // Nastal problÈm
    int i;
    lcd_w_inst(0x01);
    6046:	81 e0       	ldi	r24, 0x01	; 1
    6048:	0e 94 12 12 	call	0x2424	; 0x2424 <lcd_w_inst>
    printnt_P((void *)err97);
    604c:	84 e9       	ldi	r24, 0x94	; 148
    604e:	9c e0       	ldi	r25, 0x0C	; 12
    6050:	0e 94 ee 11 	call	0x23dc	; 0x23dc <printnt_P>

    eeprom_save();
    6054:	0e 94 d9 10 	call	0x21b2	; 0x21b2 <eeprom_save>

    lcd_w_inst(0x01);
    6058:	81 e0       	ldi	r24, 0x01	; 1
    605a:	0e 94 12 12 	call	0x2424	; 0x2424 <lcd_w_inst>
    printnt_P((void *)err97b);
    605e:	8a ec       	ldi	r24, 0xCA	; 202
    6060:	9c e0       	ldi	r25, 0x0C	; 12
    6062:	0e 94 ee 11 	call	0x23dc	; 0x23dc <printnt_P>
    wtch_reset2();
    6066:	a8 95       	wdr
    6068:	20 e0       	ldi	r18, 0x00	; 0
    606a:	30 e0       	ldi	r19, 0x00	; 0
    606c:	40 ed       	ldi	r20, 0xD0	; 208
    606e:	57 e0       	ldi	r21, 0x07	; 7
    6070:	ca 01       	movw	r24, r20
    6072:	01 97       	sbiw	r24, 0x01	; 1
    6074:	f1 f7       	brne	.-4      	; 0x6072 <wtch_main+0x48>

    for(i=0 ; i < 2000;i++){
      _delay_ms(1);
      wtch_reset2();
    6076:	a8 95       	wdr

    lcd_w_inst(0x01);
    printnt_P((void *)err97b);
    wtch_reset2();

    for(i=0 ; i < 2000;i++){
    6078:	2f 5f       	subi	r18, 0xFF	; 255
    607a:	3f 4f       	sbci	r19, 0xFF	; 255
    607c:	87 e0       	ldi	r24, 0x07	; 7
    607e:	20 3d       	cpi	r18, 0xD0	; 208
    6080:	38 07       	cpc	r19, r24
    6082:	b1 f7       	brne	.-20     	; 0x6070 <wtch_main+0x46>
    6084:	ff cf       	rjmp	.-2      	; 0x6084 <wtch_main+0x5a>

00006086 <stp_scr_close>:

void stp_scr_close(void){
  int i;

  for ( i = 0; i < MAX_MENU; i++){
    free((void *)menu[i]);
    6086:	80 91 1b 02 	lds	r24, 0x021B
    608a:	90 91 1c 02 	lds	r25, 0x021C
    608e:	0e 94 c6 32 	call	0x658c	; 0x658c <free>
    6092:	80 91 1d 02 	lds	r24, 0x021D
    6096:	90 91 1e 02 	lds	r25, 0x021E
    609a:	0e 94 c6 32 	call	0x658c	; 0x658c <free>
    609e:	80 91 1f 02 	lds	r24, 0x021F
    60a2:	90 91 20 02 	lds	r25, 0x0220
    60a6:	0e 94 c6 32 	call	0x658c	; 0x658c <free>
    60aa:	80 91 21 02 	lds	r24, 0x0221
    60ae:	90 91 22 02 	lds	r25, 0x0222
    60b2:	0e 94 c6 32 	call	0x658c	; 0x658c <free>
    60b6:	80 91 23 02 	lds	r24, 0x0223
    60ba:	90 91 24 02 	lds	r25, 0x0224
    60be:	0e 94 c6 32 	call	0x658c	; 0x658c <free>
  }
}
    60c2:	08 95       	ret

000060c4 <stp_nastav>:
}

/**
Funkce provede s parametrem p¯ÌsluËnou operaci
*/
void stp_nastav (char parametr, float hodnota){
    60c4:	cf 92       	push	r12
    60c6:	df 92       	push	r13
    60c8:	ef 92       	push	r14
    60ca:	ff 92       	push	r15
    60cc:	0f 93       	push	r16
    60ce:	1f 93       	push	r17
    60d0:	6a 01       	movw	r12, r20
    60d2:	7b 01       	movw	r14, r22
  switch (parametr){
    60d4:	82 30       	cpi	r24, 0x02	; 2
    60d6:	f1 f0       	breq	.+60     	; 0x6114 <stp_nastav+0x50>
    60d8:	83 30       	cpi	r24, 0x03	; 3
    60da:	30 f4       	brcc	.+12     	; 0x60e8 <stp_nastav+0x24>
    60dc:	88 23       	and	r24, r24
    60de:	51 f0       	breq	.+20     	; 0x60f4 <stp_nastav+0x30>
    60e0:	81 30       	cpi	r24, 0x01	; 1
    60e2:	09 f0       	breq	.+2      	; 0x60e6 <stp_nastav+0x22>
    60e4:	4b c0       	rjmp	.+150    	; 0x617c <stp_nastav+0xb8>
    60e6:	0f c0       	rjmp	.+30     	; 0x6106 <stp_nastav+0x42>
    60e8:	83 30       	cpi	r24, 0x03	; 3
    60ea:	d9 f0       	breq	.+54     	; 0x6122 <stp_nastav+0x5e>
    60ec:	84 30       	cpi	r24, 0x04	; 4
    60ee:	09 f0       	breq	.+2      	; 0x60f2 <stp_nastav+0x2e>
    60f0:	45 c0       	rjmp	.+138    	; 0x617c <stp_nastav+0xb8>
    60f2:	2a c0       	rjmp	.+84     	; 0x6148 <stp_nastav+0x84>
  case 0:
    set_irc_k((uint16_t)hodnota);
    60f4:	cb 01       	movw	r24, r22
    60f6:	ba 01       	movw	r22, r20
    60f8:	0e 94 3d 3a 	call	0x747a	; 0x747a <__fixunssfsi>
    60fc:	dc 01       	movw	r26, r24
    60fe:	cb 01       	movw	r24, r22
    6100:	0e 94 43 10 	call	0x2086	; 0x2086 <set_irc_k>
    6104:	3b c0       	rjmp	.+118    	; 0x617c <stp_nastav+0xb8>
    break;
  case 1:
    set_irc_set_on_value((int32_t) hodnota);
    6106:	cb 01       	movw	r24, r22
    6108:	ba 01       	movw	r22, r20
    610a:	0e 94 38 3a 	call	0x7470	; 0x7470 <__fixsfsi>
    610e:	0e 94 10 10 	call	0x2020	; 0x2020 <set_irc_set_on_value>
    6112:	34 c0       	rjmp	.+104    	; 0x617c <stp_nastav+0xb8>
    break;
  case 2:
    {
      char * msg;
      msg = (char*)malloc(LenOfMsg);
    6114:	8b e0       	ldi	r24, 0x0B	; 11
    6116:	90 e0       	ldi	r25, 0x00	; 0
    6118:	0e 94 19 32 	call	0x6432	; 0x6432 <malloc>
    611c:	8c 01       	movw	r16, r24
      msg[0] = '\x10';
    611e:	80 e1       	ldi	r24, 0x10	; 16
    6120:	06 c0       	rjmp	.+12     	; 0x612e <stp_nastav+0x6a>
      break;
    }
  case 3:
    {
      char * msg;
      msg = (char*)malloc(LenOfMsg);
    6122:	8b e0       	ldi	r24, 0x0B	; 11
    6124:	90 e0       	ldi	r25, 0x00	; 0
    6126:	0e 94 19 32 	call	0x6432	; 0x6432 <malloc>
    612a:	8c 01       	movw	r16, r24
      msg[0] = '\x11';
    612c:	81 e1       	ldi	r24, 0x11	; 17
    612e:	f8 01       	movw	r30, r16
    6130:	80 83       	st	Z, r24
      msg[1] = ((uint16_t) hodnota) / 256;
    6132:	c7 01       	movw	r24, r14
    6134:	b6 01       	movw	r22, r12
    6136:	0e 94 3d 3a 	call	0x747a	; 0x747a <__fixunssfsi>
    613a:	f8 01       	movw	r30, r16
    613c:	71 83       	std	Z+1, r23	; 0x01
      msg[2] = ((uint16_t) hodnota) % 256;
    613e:	62 83       	std	Z+2, r22	; 0x02
      new_msg(msg);
    6140:	c8 01       	movw	r24, r16
    6142:	0e 94 46 0c 	call	0x188c	; 0x188c <new_msg>
    6146:	1a c0       	rjmp	.+52     	; 0x617c <stp_nastav+0xb8>
      break;
    }
  case 4: // nastavenÌ zdroje mÏ¯enÌ öÌ¯ky
    if ((hodnota <= 2) && (hodnota >= 0)){
    6148:	cb 01       	movw	r24, r22
    614a:	ba 01       	movw	r22, r20
    614c:	20 e0       	ldi	r18, 0x00	; 0
    614e:	30 e0       	ldi	r19, 0x00	; 0
    6150:	40 e0       	ldi	r20, 0x00	; 0
    6152:	50 e4       	ldi	r21, 0x40	; 64
    6154:	0e 94 cc 39 	call	0x7398	; 0x7398 <__cmpsf2>
    6158:	18 16       	cp	r1, r24
    615a:	84 f0       	brlt	.+32     	; 0x617c <stp_nastav+0xb8>
    615c:	c7 01       	movw	r24, r14
    615e:	b6 01       	movw	r22, r12
    6160:	20 e0       	ldi	r18, 0x00	; 0
    6162:	30 e0       	ldi	r19, 0x00	; 0
    6164:	40 e0       	ldi	r20, 0x00	; 0
    6166:	50 e0       	ldi	r21, 0x00	; 0
    6168:	0e 94 1b 3b 	call	0x7636	; 0x7636 <__gesf2>
    616c:	88 23       	and	r24, r24
    616e:	34 f0       	brlt	.+12     	; 0x617c <stp_nastav+0xb8>
      width_src = (unsigned char) hodnota;
    6170:	c7 01       	movw	r24, r14
    6172:	b6 01       	movw	r22, r12
    6174:	0e 94 3d 3a 	call	0x747a	; 0x747a <__fixunssfsi>
    6178:	60 93 60 00 	sts	0x0060, r22
    }
    break;
  default:
    break;
  }
}
    617c:	1f 91       	pop	r17
    617e:	0f 91       	pop	r16
    6180:	ff 90       	pop	r15
    6182:	ef 90       	pop	r14
    6184:	df 90       	pop	r13
    6186:	cf 90       	pop	r12
    6188:	08 95       	ret

0000618a <stp_scr_control>:
  clear_dscreen();
  printxyd_P(0,0,(void *)s_stp_scr);
}


void stp_scr_control(void){
    618a:	ef 92       	push	r14
    618c:	ff 92       	push	r15
    618e:	0f 93       	push	r16
    6190:	1f 93       	push	r17
    6192:	df 93       	push	r29
    6194:	cf 93       	push	r28
    6196:	cd b7       	in	r28, 0x3d	; 61
    6198:	de b7       	in	r29, 0x3e	; 62
    619a:	2c 97       	sbiw	r28, 0x0c	; 12
    619c:	0f b6       	in	r0, 0x3f	; 63
    619e:	f8 94       	cli
    61a0:	de bf       	out	0x3e, r29	; 62
    61a2:	0f be       	out	0x3f, r0	; 63
    61a4:	cd bf       	out	0x3d, r28	; 61
  char c;
  if(run == 1){
    61a6:	80 91 19 02 	lds	r24, 0x0219
    61aa:	81 30       	cpi	r24, 0x01	; 1
    61ac:	09 f0       	breq	.+2      	; 0x61b0 <stp_scr_control+0x26>
    61ae:	6d c0       	rjmp	.+218    	; 0x628a <stp_scr_control+0x100>
    char *s;
    if ((s = read_line()) != NULL){
    61b0:	0e 94 5b 1f 	call	0x3eb6	; 0x3eb6 <read_line>
    61b4:	7c 01       	movw	r14, r24
    61b6:	00 97       	sbiw	r24, 0x00	; 0
    61b8:	09 f4       	brne	.+2      	; 0x61bc <stp_scr_control+0x32>
    61ba:	67 c0       	rjmp	.+206    	; 0x628a <stp_scr_control+0x100>
      if (s[0] != '\0'){
    61bc:	dc 01       	movw	r26, r24
    61be:	8c 91       	ld	r24, X
    61c0:	88 23       	and	r24, r24
    61c2:	09 f4       	brne	.+2      	; 0x61c6 <stp_scr_control+0x3c>
    61c4:	5d c0       	rjmp	.+186    	; 0x6280 <stp_scr_control+0xf6>
        int cislo;
        char s2[10];
        if (sscanf(s,"%i",&cislo) == 0){
    61c6:	00 d0       	rcall	.+0      	; 0x61c8 <stp_scr_control+0x3e>
    61c8:	00 d0       	rcall	.+0      	; 0x61ca <stp_scr_control+0x40>
    61ca:	00 d0       	rcall	.+0      	; 0x61cc <stp_scr_control+0x42>
    61cc:	ed b7       	in	r30, 0x3d	; 61
    61ce:	fe b7       	in	r31, 0x3e	; 62
    61d0:	31 96       	adiw	r30, 0x01	; 1
    61d2:	ad b7       	in	r26, 0x3d	; 61
    61d4:	be b7       	in	r27, 0x3e	; 62
    61d6:	12 96       	adiw	r26, 0x02	; 2
    61d8:	fc 92       	st	X, r15
    61da:	ee 92       	st	-X, r14
    61dc:	11 97       	sbiw	r26, 0x01	; 1
    61de:	82 e3       	ldi	r24, 0x32	; 50
    61e0:	91 e0       	ldi	r25, 0x01	; 1
    61e2:	93 83       	std	Z+3, r25	; 0x03
    61e4:	82 83       	std	Z+2, r24	; 0x02
    61e6:	ce 01       	movw	r24, r28
    61e8:	01 96       	adiw	r24, 0x01	; 1
    61ea:	95 83       	std	Z+5, r25	; 0x05
    61ec:	84 83       	std	Z+4, r24	; 0x04
    61ee:	0e 94 d4 33 	call	0x67a8	; 0x67a8 <sscanf>
    61f2:	ed b7       	in	r30, 0x3d	; 61
    61f4:	fe b7       	in	r31, 0x3e	; 62
    61f6:	36 96       	adiw	r30, 0x06	; 6
    61f8:	0f b6       	in	r0, 0x3f	; 63
    61fa:	f8 94       	cli
    61fc:	fe bf       	out	0x3e, r31	; 62
    61fe:	0f be       	out	0x3f, r0	; 63
    6200:	ed bf       	out	0x3d, r30	; 61
    6202:	89 2b       	or	r24, r25
    6204:	39 f4       	brne	.+14     	; 0x6214 <stp_scr_control+0x8a>
          //printxyd(1,30,"blbe");
          printxyd(2,30,s);
    6206:	82 e0       	ldi	r24, 0x02	; 2
    6208:	90 e0       	ldi	r25, 0x00	; 0
    620a:	6e e1       	ldi	r22, 0x1E	; 30
    620c:	70 e0       	ldi	r23, 0x00	; 0
    620e:	a7 01       	movw	r20, r14
    6210:	0e 94 26 14 	call	0x284c	; 0x284c <printxyd>
        }
        sprintf(s2,"%i",cislo); 
    6214:	00 d0       	rcall	.+0      	; 0x6216 <stp_scr_control+0x8c>
    6216:	00 d0       	rcall	.+0      	; 0x6218 <stp_scr_control+0x8e>
    6218:	00 d0       	rcall	.+0      	; 0x621a <stp_scr_control+0x90>
    621a:	ed b7       	in	r30, 0x3d	; 61
    621c:	fe b7       	in	r31, 0x3e	; 62
    621e:	31 96       	adiw	r30, 0x01	; 1
    6220:	8e 01       	movw	r16, r28
    6222:	0d 5f       	subi	r16, 0xFD	; 253
    6224:	1f 4f       	sbci	r17, 0xFF	; 255
    6226:	ad b7       	in	r26, 0x3d	; 61
    6228:	be b7       	in	r27, 0x3e	; 62
    622a:	12 96       	adiw	r26, 0x02	; 2
    622c:	1c 93       	st	X, r17
    622e:	0e 93       	st	-X, r16
    6230:	11 97       	sbiw	r26, 0x01	; 1
    6232:	82 e3       	ldi	r24, 0x32	; 50
    6234:	91 e0       	ldi	r25, 0x01	; 1
    6236:	93 83       	std	Z+3, r25	; 0x03
    6238:	82 83       	std	Z+2, r24	; 0x02
    623a:	89 81       	ldd	r24, Y+1	; 0x01
    623c:	9a 81       	ldd	r25, Y+2	; 0x02
    623e:	95 83       	std	Z+5, r25	; 0x05
    6240:	84 83       	std	Z+4, r24	; 0x04
    6242:	0e 94 b0 33 	call	0x6760	; 0x6760 <sprintf>
        printxyd(3,30,s2);
    6246:	ed b7       	in	r30, 0x3d	; 61
    6248:	fe b7       	in	r31, 0x3e	; 62
    624a:	36 96       	adiw	r30, 0x06	; 6
    624c:	0f b6       	in	r0, 0x3f	; 63
    624e:	f8 94       	cli
    6250:	fe bf       	out	0x3e, r31	; 62
    6252:	0f be       	out	0x3f, r0	; 63
    6254:	ed bf       	out	0x3d, r30	; 61
    6256:	83 e0       	ldi	r24, 0x03	; 3
    6258:	90 e0       	ldi	r25, 0x00	; 0
    625a:	6e e1       	ldi	r22, 0x1E	; 30
    625c:	70 e0       	ldi	r23, 0x00	; 0
    625e:	a8 01       	movw	r20, r16
    6260:	0e 94 26 14 	call	0x284c	; 0x284c <printxyd>
        stp_nastav(menu_i,(float)cislo);
    6264:	69 81       	ldd	r22, Y+1	; 0x01
    6266:	7a 81       	ldd	r23, Y+2	; 0x02
    6268:	88 27       	eor	r24, r24
    626a:	77 fd       	sbrc	r23, 7
    626c:	80 95       	com	r24
    626e:	98 2f       	mov	r25, r24
    6270:	0e 94 6b 3a 	call	0x74d6	; 0x74d6 <__floatsisf>
    6274:	ab 01       	movw	r20, r22
    6276:	bc 01       	movw	r22, r24
    6278:	80 91 1a 02 	lds	r24, 0x021A
    627c:	0e 94 62 30 	call	0x60c4	; 0x60c4 <stp_nastav>
      }
      else { // pokud Esc,  nebo je retezec nulove delky
        
      }
      free((void *) s);
    6280:	c7 01       	movw	r24, r14
    6282:	0e 94 c6 32 	call	0x658c	; 0x658c <free>
      run = 0; 
    6286:	10 92 19 02 	sts	0x0219, r1
    }
    
  }
  if ((c = get_spec()) != 0){
    628a:	0e 94 f2 1c 	call	0x39e4	; 0x39e4 <get_spec>
    628e:	88 23       	and	r24, r24
    6290:	09 f4       	brne	.+2      	; 0x6294 <stp_scr_control+0x10a>
    6292:	4d c0       	rjmp	.+154    	; 0x632e <stp_scr_control+0x1a4>
    switch(c){
    6294:	87 30       	cpi	r24, 0x07	; 7
    6296:	c1 f0       	breq	.+48     	; 0x62c8 <stp_scr_control+0x13e>
    6298:	88 30       	cpi	r24, 0x08	; 8
    629a:	40 f4       	brcc	.+16     	; 0x62ac <stp_scr_control+0x122>
    629c:	84 30       	cpi	r24, 0x04	; 4
    629e:	11 f1       	breq	.+68     	; 0x62e4 <stp_scr_control+0x15a>
    62a0:	85 30       	cpi	r24, 0x05	; 5
    62a2:	e1 f0       	breq	.+56     	; 0x62dc <stp_scr_control+0x152>
    62a4:	82 30       	cpi	r24, 0x02	; 2
    62a6:	09 f0       	breq	.+2      	; 0x62aa <stp_scr_control+0x120>
    62a8:	42 c0       	rjmp	.+132    	; 0x632e <stp_scr_control+0x1a4>
    62aa:	06 c0       	rjmp	.+12     	; 0x62b8 <stp_scr_control+0x12e>
    62ac:	89 30       	cpi	r24, 0x09	; 9
    62ae:	61 f0       	breq	.+24     	; 0x62c8 <stp_scr_control+0x13e>
    62b0:	89 30       	cpi	r24, 0x09	; 9
    62b2:	10 f0       	brcs	.+4      	; 0x62b8 <stp_scr_control+0x12e>
    62b4:	8a 30       	cpi	r24, 0x0A	; 10
    62b6:	d9 f5       	brne	.+118    	; 0x632e <stp_scr_control+0x1a4>
    case 2: //Tab
    case 8:
    case 10:
      menu_i = menu_next_item(menu, menu_i, MAX_MENU);
    62b8:	8b e1       	ldi	r24, 0x1B	; 27
    62ba:	92 e0       	ldi	r25, 0x02	; 2
    62bc:	60 91 1a 02 	lds	r22, 0x021A
    62c0:	45 e0       	ldi	r20, 0x05	; 5
    62c2:	0e 94 7b 1d 	call	0x3af6	; 0x3af6 <menu_next_item>
    62c6:	07 c0       	rjmp	.+14     	; 0x62d6 <stp_scr_control+0x14c>
      break;
    case 7:
    case 9:
      menu_i = menu_prev_item(menu, menu_i, MAX_MENU);
    62c8:	8b e1       	ldi	r24, 0x1B	; 27
    62ca:	92 e0       	ldi	r25, 0x02	; 2
    62cc:	60 91 1a 02 	lds	r22, 0x021A
    62d0:	45 e0       	ldi	r20, 0x05	; 5
    62d2:	0e 94 44 1d 	call	0x3a88	; 0x3a88 <menu_prev_item>
    62d6:	80 93 1a 02 	sts	0x021A, r24
    62da:	29 c0       	rjmp	.+82     	; 0x632e <stp_scr_control+0x1a4>
      break;
    case 5: //Esc
      scr_ch(MSR_SCR);
    62dc:	80 e0       	ldi	r24, 0x00	; 0
    62de:	0e 94 c3 18 	call	0x3186	; 0x3186 <scr_ch>
    62e2:	25 c0       	rjmp	.+74     	; 0x632e <stp_scr_control+0x1a4>
      break;
    case 4: //Enter
      // p¯epoËet z indexu menu v dlst_scr na index seznamu jmen na msr_scr
      {
        char * s = (char *)mmalloc(9); // TODO ölo by to pak p¯ealokovat na menöÌ
    62e4:	89 e0       	ldi	r24, 0x09	; 9
    62e6:	90 e0       	ldi	r25, 0x00	; 0
    62e8:	0e 94 c1 06 	call	0xd82	; 0xd82 <mmalloc>
    62ec:	8c 01       	movw	r16, r24
        if (s != NULL){
    62ee:	00 97       	sbiw	r24, 0x00	; 0
    62f0:	f1 f0       	breq	.+60     	; 0x632e <stp_scr_control+0x1a4>
          mezery(s,8);
    62f2:	68 e0       	ldi	r22, 0x08	; 8
    62f4:	0e 94 3a 14 	call	0x2874	; 0x2874 <mezery>
          s[8] = '\0';
    62f8:	d8 01       	movw	r26, r16
    62fa:	18 96       	adiw	r26, 0x08	; 8
    62fc:	1c 92       	st	X, r1
          m_jmena[MAX_MENU] = s;
    62fe:	10 93 ff 02 	sts	0x02FF, r17
    6302:	00 93 fe 02 	sts	0x02FE, r16
          read_line_init (menu[(int)menu_i] -> y, menu[(int)menu_i] -> x, s);
    6306:	e0 91 1a 02 	lds	r30, 0x021A
    630a:	f0 e0       	ldi	r31, 0x00	; 0
    630c:	ee 0f       	add	r30, r30
    630e:	ff 1f       	adc	r31, r31
    6310:	e5 5e       	subi	r30, 0xE5	; 229
    6312:	fd 4f       	sbci	r31, 0xFD	; 253
    6314:	01 90       	ld	r0, Z+
    6316:	f0 81       	ld	r31, Z
    6318:	e0 2d       	mov	r30, r0
    631a:	60 81       	ld	r22, Z
    631c:	81 81       	ldd	r24, Z+1	; 0x01
    631e:	90 e0       	ldi	r25, 0x00	; 0
    6320:	70 e0       	ldi	r23, 0x00	; 0
    6322:	a8 01       	movw	r20, r16
    6324:	0e 94 e9 1e 	call	0x3dd2	; 0x3dd2 <read_line_init>
          run = 1;
    6328:	81 e0       	ldi	r24, 0x01	; 1
    632a:	80 93 19 02 	sts	0x0219, r24
      
    default:
      break;
    }
  }
}
    632e:	2c 96       	adiw	r28, 0x0c	; 12
    6330:	0f b6       	in	r0, 0x3f	; 63
    6332:	f8 94       	cli
    6334:	de bf       	out	0x3e, r29	; 62
    6336:	0f be       	out	0x3f, r0	; 63
    6338:	cd bf       	out	0x3d, r28	; 61
    633a:	cf 91       	pop	r28
    633c:	df 91       	pop	r29
    633e:	1f 91       	pop	r17
    6340:	0f 91       	pop	r16
    6342:	ff 90       	pop	r15
    6344:	ef 90       	pop	r14
    6346:	08 95       	ret

00006348 <stp_scr_draw>:


}

void stp_scr_draw(void){
  clear_dscreen();
    6348:	0e 94 9e 11 	call	0x233c	; 0x233c <clear_dscreen>
  printxyd_P(0,0,(void *)s_stp_scr);
    634c:	80 e0       	ldi	r24, 0x00	; 0
    634e:	90 e0       	ldi	r25, 0x00	; 0
    6350:	60 e0       	ldi	r22, 0x00	; 0
    6352:	70 e0       	ldi	r23, 0x00	; 0
    6354:	49 ee       	ldi	r20, 0xE9	; 233
    6356:	5c e0       	ldi	r21, 0x0C	; 12
    6358:	0e 94 47 13 	call	0x268e	; 0x268e <printxyd_P>
}
    635c:	08 95       	ret

0000635e <stp_scr_open>:
static char  menu_i =0;


void stp_nastav (char parametr, float hodnota);

void stp_scr_open(void){
    635e:	ef 92       	push	r14
    6360:	ff 92       	push	r15
    6362:	0f 93       	push	r16
    6364:	1f 93       	push	r17
    6366:	cf 93       	push	r28
    6368:	df 93       	push	r29
    636a:	0b e1       	ldi	r16, 0x1B	; 27
    636c:	12 e0       	ldi	r17, 0x02	; 2
    636e:	c0 e0       	ldi	r28, 0x00	; 0
    6370:	d0 e0       	ldi	r29, 0x00	; 0
  int i;
  for (i = 0; i < (MAX_MENU ); i++) {
    menu[i] = new_menu_item();
    menu[i] -> x =(char) 8 + ((i / 4) * 20);
    6372:	34 e1       	ldi	r19, 0x14	; 20
    6374:	e3 2e       	mov	r14, r19
    6376:	f1 2c       	mov	r15, r1
void stp_nastav (char parametr, float hodnota);

void stp_scr_open(void){
  int i;
  for (i = 0; i < (MAX_MENU ); i++) {
    menu[i] = new_menu_item();
    6378:	0e 94 32 1f 	call	0x3e64	; 0x3e64 <new_menu_item>
    637c:	fc 01       	movw	r30, r24
    637e:	d8 01       	movw	r26, r16
    6380:	11 96       	adiw	r26, 0x01	; 1
    6382:	9c 93       	st	X, r25
    6384:	8e 93       	st	-X, r24
    menu[i] -> x =(char) 8 + ((i / 4) * 20);
    6386:	ce 01       	movw	r24, r28
    6388:	95 95       	asr	r25
    638a:	87 95       	ror	r24
    638c:	95 95       	asr	r25
    638e:	87 95       	ror	r24
    6390:	9c 01       	movw	r18, r24
    6392:	2e 9d       	mul	r18, r14
    6394:	c0 01       	movw	r24, r0
    6396:	2f 9d       	mul	r18, r15
    6398:	90 0d       	add	r25, r0
    639a:	3e 9d       	mul	r19, r14
    639c:	90 0d       	add	r25, r0
    639e:	11 24       	eor	r1, r1
    63a0:	88 5f       	subi	r24, 0xF8	; 248
    63a2:	80 83       	st	Z, r24
    menu[i] -> y =(char) (i % 4);
    63a4:	ed 91       	ld	r30, X+
    63a6:	fc 91       	ld	r31, X
    63a8:	11 97       	sbiw	r26, 0x01	; 1
    63aa:	ce 01       	movw	r24, r28
    63ac:	83 70       	andi	r24, 0x03	; 3
    63ae:	90 70       	andi	r25, 0x00	; 0
    63b0:	81 83       	std	Z+1, r24	; 0x01
    menu[i] -> polozky = NULL;;
    63b2:	ed 91       	ld	r30, X+
    63b4:	fd 91       	ld	r31, X+
    63b6:	8d 01       	movw	r16, r26
    63b8:	14 82       	std	Z+4, r1	; 0x04
    63ba:	13 82       	std	Z+3, r1	; 0x03
    menu[i] -> len = 0;
    63bc:	12 82       	std	Z+2, r1	; 0x02

void stp_nastav (char parametr, float hodnota);

void stp_scr_open(void){
  int i;
  for (i = 0; i < (MAX_MENU ); i++) {
    63be:	21 96       	adiw	r28, 0x01	; 1
    63c0:	c5 30       	cpi	r28, 0x05	; 5
    63c2:	d1 05       	cpc	r29, r1
    63c4:	c9 f6       	brne	.-78     	; 0x6378 <stp_scr_open+0x1a>
    menu[i] -> polozky = NULL;;
    menu[i] -> len = 0;
  }


}
    63c6:	df 91       	pop	r29
    63c8:	cf 91       	pop	r28
    63ca:	1f 91       	pop	r17
    63cc:	0f 91       	pop	r16
    63ce:	ff 90       	pop	r15
    63d0:	ef 90       	pop	r14
    63d2:	08 95       	ret

000063d4 <kf_global_key>:
  }
}

int kf_global_key(void){
  return 0;
}
    63d4:	80 e0       	ldi	r24, 0x00	; 0
    63d6:	90 e0       	ldi	r25, 0x00	; 0
    63d8:	08 95       	ret

000063da <kf_start>:
    break;
  }
}

void kf_start(void){
  switch(msr_status){
    63da:	80 91 44 01 	lds	r24, 0x0144
    63de:	83 30       	cpi	r24, 0x03	; 3
    63e0:	41 f0       	breq	.+16     	; 0x63f2 <kf_start+0x18>
    63e2:	84 30       	cpi	r24, 0x04	; 4
    63e4:	18 f4       	brcc	.+6      	; 0x63ec <kf_start+0x12>
    63e6:	88 23       	and	r24, r24
    63e8:	71 f0       	breq	.+28     	; 0x6406 <kf_start+0x2c>
    63ea:	08 95       	ret
    63ec:	86 30       	cpi	r24, 0x06	; 6
    63ee:	80 f4       	brcc	.+32     	; 0x6410 <kf_start+0x36>
    63f0:	0d c0       	rjmp	.+26     	; 0x640c <kf_start+0x32>
  case ZMERENY_PRUMERY:
    if (get_menu_jmena_i() == 255){
    63f2:	0e 94 fc 20 	call	0x41f8	; 0x41f8 <get_menu_jmena_i>
    63f6:	8f 3f       	cpi	r24, 0xFF	; 255
    63f8:	21 f4       	brne	.+8      	; 0x6402 <kf_start+0x28>
      new_error(94);
    63fa:	8e e5       	ldi	r24, 0x5E	; 94
    63fc:	0e 94 4e 19 	call	0x329c	; 0x329c <new_error>
    6400:	08 95       	ret
    }
    else{
      uloz_posledni_data();
    6402:	0e 94 17 21 	call	0x422e	; 0x422e <uloz_posledni_data>
      msr_start();
    }
    break;
  case VOLNO:
    msr_start();
    6406:	0e 94 b8 0b 	call	0x1770	; 0x1770 <msr_start>
    640a:	08 95       	ret
    break;
  case PAUSE_L_NEZMERENO:
  case PAUSE_L_ZMERENO:
    msr_unpause();
    640c:	0e 94 7c 0a 	call	0x14f8	; 0x14f8 <msr_unpause>
    6410:	08 95       	ret

00006412 <kf_zrusit>:
#include "error.h"
#include "msr_scr.h"


void kf_zrusit(void){
  switch(msr_status){
    6412:	80 91 44 01 	lds	r24, 0x0144
    6416:	81 30       	cpi	r24, 0x01	; 1
    6418:	58 f0       	brcs	.+22     	; 0x6430 <kf_zrusit+0x1e>
    641a:	83 30       	cpi	r24, 0x03	; 3
    641c:	20 f0       	brcs	.+8      	; 0x6426 <kf_zrusit+0x14>
    641e:	84 50       	subi	r24, 0x04	; 4
    6420:	82 30       	cpi	r24, 0x02	; 2
    6422:	30 f4       	brcc	.+12     	; 0x6430 <kf_zrusit+0x1e>
    6424:	03 c0       	rjmp	.+6      	; 0x642c <kf_zrusit+0x1a>
  case L_ZMERENO:
  case L_NEZMERENO:
    msr_pause();
    6426:	0e 94 d1 07 	call	0xfa2	; 0xfa2 <msr_pause>
    642a:	08 95       	ret
    break;
  case PAUSE_L_ZMERENO:
  case PAUSE_L_NEZMERENO:
    msr_storno();
    642c:	0e 94 cc 07 	call	0xf98	; 0xf98 <msr_storno>
    6430:	08 95       	ret

00006432 <malloc>:
    6432:	cf 93       	push	r28
    6434:	df 93       	push	r29
    6436:	bc 01       	movw	r22, r24
    6438:	82 30       	cpi	r24, 0x02	; 2
    643a:	91 05       	cpc	r25, r1
    643c:	10 f4       	brcc	.+4      	; 0x6442 <malloc+0x10>
    643e:	62 e0       	ldi	r22, 0x02	; 2
    6440:	70 e0       	ldi	r23, 0x00	; 0
    6442:	a0 91 40 06 	lds	r26, 0x0640
    6446:	b0 91 41 06 	lds	r27, 0x0641
    644a:	ed 01       	movw	r28, r26
    644c:	e0 e0       	ldi	r30, 0x00	; 0
    644e:	f0 e0       	ldi	r31, 0x00	; 0
    6450:	40 e0       	ldi	r20, 0x00	; 0
    6452:	50 e0       	ldi	r21, 0x00	; 0
    6454:	21 c0       	rjmp	.+66     	; 0x6498 <malloc+0x66>
    6456:	88 81       	ld	r24, Y
    6458:	99 81       	ldd	r25, Y+1	; 0x01
    645a:	86 17       	cp	r24, r22
    645c:	97 07       	cpc	r25, r23
    645e:	69 f4       	brne	.+26     	; 0x647a <malloc+0x48>
    6460:	8a 81       	ldd	r24, Y+2	; 0x02
    6462:	9b 81       	ldd	r25, Y+3	; 0x03
    6464:	30 97       	sbiw	r30, 0x00	; 0
    6466:	19 f0       	breq	.+6      	; 0x646e <malloc+0x3c>
    6468:	93 83       	std	Z+3, r25	; 0x03
    646a:	82 83       	std	Z+2, r24	; 0x02
    646c:	04 c0       	rjmp	.+8      	; 0x6476 <malloc+0x44>
    646e:	90 93 41 06 	sts	0x0641, r25
    6472:	80 93 40 06 	sts	0x0640, r24
    6476:	fe 01       	movw	r30, r28
    6478:	34 c0       	rjmp	.+104    	; 0x64e2 <malloc+0xb0>
    647a:	68 17       	cp	r22, r24
    647c:	79 07       	cpc	r23, r25
    647e:	38 f4       	brcc	.+14     	; 0x648e <malloc+0x5c>
    6480:	41 15       	cp	r20, r1
    6482:	51 05       	cpc	r21, r1
    6484:	19 f0       	breq	.+6      	; 0x648c <malloc+0x5a>
    6486:	84 17       	cp	r24, r20
    6488:	95 07       	cpc	r25, r21
    648a:	08 f4       	brcc	.+2      	; 0x648e <malloc+0x5c>
    648c:	ac 01       	movw	r20, r24
    648e:	fe 01       	movw	r30, r28
    6490:	8a 81       	ldd	r24, Y+2	; 0x02
    6492:	9b 81       	ldd	r25, Y+3	; 0x03
    6494:	9c 01       	movw	r18, r24
    6496:	e9 01       	movw	r28, r18
    6498:	20 97       	sbiw	r28, 0x00	; 0
    649a:	e9 f6       	brne	.-70     	; 0x6456 <malloc+0x24>
    649c:	41 15       	cp	r20, r1
    649e:	51 05       	cpc	r21, r1
    64a0:	a9 f1       	breq	.+106    	; 0x650c <malloc+0xda>
    64a2:	ca 01       	movw	r24, r20
    64a4:	86 1b       	sub	r24, r22
    64a6:	97 0b       	sbc	r25, r23
    64a8:	04 97       	sbiw	r24, 0x04	; 4
    64aa:	08 f4       	brcc	.+2      	; 0x64ae <malloc+0x7c>
    64ac:	ba 01       	movw	r22, r20
    64ae:	e0 e0       	ldi	r30, 0x00	; 0
    64b0:	f0 e0       	ldi	r31, 0x00	; 0
    64b2:	2a c0       	rjmp	.+84     	; 0x6508 <malloc+0xd6>
    64b4:	8d 91       	ld	r24, X+
    64b6:	9c 91       	ld	r25, X
    64b8:	11 97       	sbiw	r26, 0x01	; 1
    64ba:	84 17       	cp	r24, r20
    64bc:	95 07       	cpc	r25, r21
    64be:	f9 f4       	brne	.+62     	; 0x64fe <malloc+0xcc>
    64c0:	64 17       	cp	r22, r20
    64c2:	75 07       	cpc	r23, r21
    64c4:	81 f4       	brne	.+32     	; 0x64e6 <malloc+0xb4>
    64c6:	12 96       	adiw	r26, 0x02	; 2
    64c8:	8d 91       	ld	r24, X+
    64ca:	9c 91       	ld	r25, X
    64cc:	13 97       	sbiw	r26, 0x03	; 3
    64ce:	30 97       	sbiw	r30, 0x00	; 0
    64d0:	19 f0       	breq	.+6      	; 0x64d8 <malloc+0xa6>
    64d2:	93 83       	std	Z+3, r25	; 0x03
    64d4:	82 83       	std	Z+2, r24	; 0x02
    64d6:	04 c0       	rjmp	.+8      	; 0x64e0 <malloc+0xae>
    64d8:	90 93 41 06 	sts	0x0641, r25
    64dc:	80 93 40 06 	sts	0x0640, r24
    64e0:	fd 01       	movw	r30, r26
    64e2:	32 96       	adiw	r30, 0x02	; 2
    64e4:	4f c0       	rjmp	.+158    	; 0x6584 <malloc+0x152>
    64e6:	ca 01       	movw	r24, r20
    64e8:	86 1b       	sub	r24, r22
    64ea:	97 0b       	sbc	r25, r23
    64ec:	fd 01       	movw	r30, r26
    64ee:	e8 0f       	add	r30, r24
    64f0:	f9 1f       	adc	r31, r25
    64f2:	61 93       	st	Z+, r22
    64f4:	71 93       	st	Z+, r23
    64f6:	02 97       	sbiw	r24, 0x02	; 2
    64f8:	8d 93       	st	X+, r24
    64fa:	9c 93       	st	X, r25
    64fc:	43 c0       	rjmp	.+134    	; 0x6584 <malloc+0x152>
    64fe:	fd 01       	movw	r30, r26
    6500:	82 81       	ldd	r24, Z+2	; 0x02
    6502:	93 81       	ldd	r25, Z+3	; 0x03
    6504:	9c 01       	movw	r18, r24
    6506:	d9 01       	movw	r26, r18
    6508:	10 97       	sbiw	r26, 0x00	; 0
    650a:	a1 f6       	brne	.-88     	; 0x64b4 <malloc+0x82>
    650c:	80 91 3e 06 	lds	r24, 0x063E
    6510:	90 91 3f 06 	lds	r25, 0x063F
    6514:	89 2b       	or	r24, r25
    6516:	41 f4       	brne	.+16     	; 0x6528 <malloc+0xf6>
    6518:	80 91 37 01 	lds	r24, 0x0137
    651c:	90 91 38 01 	lds	r25, 0x0138
    6520:	90 93 3f 06 	sts	0x063F, r25
    6524:	80 93 3e 06 	sts	0x063E, r24
    6528:	40 91 39 01 	lds	r20, 0x0139
    652c:	50 91 3a 01 	lds	r21, 0x013A
    6530:	41 15       	cp	r20, r1
    6532:	51 05       	cpc	r21, r1
    6534:	41 f4       	brne	.+16     	; 0x6546 <malloc+0x114>
    6536:	4d b7       	in	r20, 0x3d	; 61
    6538:	5e b7       	in	r21, 0x3e	; 62
    653a:	80 91 35 01 	lds	r24, 0x0135
    653e:	90 91 36 01 	lds	r25, 0x0136
    6542:	48 1b       	sub	r20, r24
    6544:	59 0b       	sbc	r21, r25
    6546:	20 91 3e 06 	lds	r18, 0x063E
    654a:	30 91 3f 06 	lds	r19, 0x063F
    654e:	24 17       	cp	r18, r20
    6550:	35 07       	cpc	r19, r21
    6552:	b0 f4       	brcc	.+44     	; 0x6580 <malloc+0x14e>
    6554:	ca 01       	movw	r24, r20
    6556:	82 1b       	sub	r24, r18
    6558:	93 0b       	sbc	r25, r19
    655a:	86 17       	cp	r24, r22
    655c:	97 07       	cpc	r25, r23
    655e:	80 f0       	brcs	.+32     	; 0x6580 <malloc+0x14e>
    6560:	ab 01       	movw	r20, r22
    6562:	4e 5f       	subi	r20, 0xFE	; 254
    6564:	5f 4f       	sbci	r21, 0xFF	; 255
    6566:	84 17       	cp	r24, r20
    6568:	95 07       	cpc	r25, r21
    656a:	50 f0       	brcs	.+20     	; 0x6580 <malloc+0x14e>
    656c:	42 0f       	add	r20, r18
    656e:	53 1f       	adc	r21, r19
    6570:	50 93 3f 06 	sts	0x063F, r21
    6574:	40 93 3e 06 	sts	0x063E, r20
    6578:	f9 01       	movw	r30, r18
    657a:	61 93       	st	Z+, r22
    657c:	71 93       	st	Z+, r23
    657e:	02 c0       	rjmp	.+4      	; 0x6584 <malloc+0x152>
    6580:	e0 e0       	ldi	r30, 0x00	; 0
    6582:	f0 e0       	ldi	r31, 0x00	; 0
    6584:	cf 01       	movw	r24, r30
    6586:	df 91       	pop	r29
    6588:	cf 91       	pop	r28
    658a:	08 95       	ret

0000658c <free>:
    658c:	cf 93       	push	r28
    658e:	df 93       	push	r29
    6590:	00 97       	sbiw	r24, 0x00	; 0
    6592:	09 f4       	brne	.+2      	; 0x6596 <free+0xa>
    6594:	50 c0       	rjmp	.+160    	; 0x6636 <free+0xaa>
    6596:	ec 01       	movw	r28, r24
    6598:	22 97       	sbiw	r28, 0x02	; 2
    659a:	1b 82       	std	Y+3, r1	; 0x03
    659c:	1a 82       	std	Y+2, r1	; 0x02
    659e:	a0 91 40 06 	lds	r26, 0x0640
    65a2:	b0 91 41 06 	lds	r27, 0x0641
    65a6:	10 97       	sbiw	r26, 0x00	; 0
    65a8:	09 f1       	breq	.+66     	; 0x65ec <free+0x60>
    65aa:	40 e0       	ldi	r20, 0x00	; 0
    65ac:	50 e0       	ldi	r21, 0x00	; 0
    65ae:	ac 17       	cp	r26, r28
    65b0:	bd 07       	cpc	r27, r29
    65b2:	08 f1       	brcs	.+66     	; 0x65f6 <free+0x6a>
    65b4:	bb 83       	std	Y+3, r27	; 0x03
    65b6:	aa 83       	std	Y+2, r26	; 0x02
    65b8:	fe 01       	movw	r30, r28
    65ba:	21 91       	ld	r18, Z+
    65bc:	31 91       	ld	r19, Z+
    65be:	e2 0f       	add	r30, r18
    65c0:	f3 1f       	adc	r31, r19
    65c2:	ae 17       	cp	r26, r30
    65c4:	bf 07       	cpc	r27, r31
    65c6:	79 f4       	brne	.+30     	; 0x65e6 <free+0x5a>
    65c8:	8d 91       	ld	r24, X+
    65ca:	9c 91       	ld	r25, X
    65cc:	11 97       	sbiw	r26, 0x01	; 1
    65ce:	28 0f       	add	r18, r24
    65d0:	39 1f       	adc	r19, r25
    65d2:	2e 5f       	subi	r18, 0xFE	; 254
    65d4:	3f 4f       	sbci	r19, 0xFF	; 255
    65d6:	39 83       	std	Y+1, r19	; 0x01
    65d8:	28 83       	st	Y, r18
    65da:	12 96       	adiw	r26, 0x02	; 2
    65dc:	8d 91       	ld	r24, X+
    65de:	9c 91       	ld	r25, X
    65e0:	13 97       	sbiw	r26, 0x03	; 3
    65e2:	9b 83       	std	Y+3, r25	; 0x03
    65e4:	8a 83       	std	Y+2, r24	; 0x02
    65e6:	41 15       	cp	r20, r1
    65e8:	51 05       	cpc	r21, r1
    65ea:	71 f4       	brne	.+28     	; 0x6608 <free+0x7c>
    65ec:	d0 93 41 06 	sts	0x0641, r29
    65f0:	c0 93 40 06 	sts	0x0640, r28
    65f4:	20 c0       	rjmp	.+64     	; 0x6636 <free+0xaa>
    65f6:	12 96       	adiw	r26, 0x02	; 2
    65f8:	8d 91       	ld	r24, X+
    65fa:	9c 91       	ld	r25, X
    65fc:	13 97       	sbiw	r26, 0x03	; 3
    65fe:	ad 01       	movw	r20, r26
    6600:	00 97       	sbiw	r24, 0x00	; 0
    6602:	11 f0       	breq	.+4      	; 0x6608 <free+0x7c>
    6604:	dc 01       	movw	r26, r24
    6606:	d3 cf       	rjmp	.-90     	; 0x65ae <free+0x22>
    6608:	fa 01       	movw	r30, r20
    660a:	d3 83       	std	Z+3, r29	; 0x03
    660c:	c2 83       	std	Z+2, r28	; 0x02
    660e:	21 91       	ld	r18, Z+
    6610:	31 91       	ld	r19, Z+
    6612:	e2 0f       	add	r30, r18
    6614:	f3 1f       	adc	r31, r19
    6616:	ce 17       	cp	r28, r30
    6618:	df 07       	cpc	r29, r31
    661a:	69 f4       	brne	.+26     	; 0x6636 <free+0xaa>
    661c:	88 81       	ld	r24, Y
    661e:	99 81       	ldd	r25, Y+1	; 0x01
    6620:	28 0f       	add	r18, r24
    6622:	39 1f       	adc	r19, r25
    6624:	2e 5f       	subi	r18, 0xFE	; 254
    6626:	3f 4f       	sbci	r19, 0xFF	; 255
    6628:	fa 01       	movw	r30, r20
    662a:	31 83       	std	Z+1, r19	; 0x01
    662c:	20 83       	st	Z, r18
    662e:	8a 81       	ldd	r24, Y+2	; 0x02
    6630:	9b 81       	ldd	r25, Y+3	; 0x03
    6632:	93 83       	std	Z+3, r25	; 0x03
    6634:	82 83       	std	Z+2, r24	; 0x02
    6636:	df 91       	pop	r29
    6638:	cf 91       	pop	r28
    663a:	08 95       	ret

0000663c <memcpy_P>:
    663c:	fb 01       	movw	r30, r22
    663e:	dc 01       	movw	r26, r24
    6640:	02 c0       	rjmp	.+4      	; 0x6646 <memcpy_P+0xa>
    6642:	05 90       	lpm	r0, Z+
    6644:	0d 92       	st	X+, r0
    6646:	41 50       	subi	r20, 0x01	; 1
    6648:	50 40       	sbci	r21, 0x00	; 0
    664a:	d8 f7       	brcc	.-10     	; 0x6642 <memcpy_P+0x6>
    664c:	08 95       	ret

0000664e <strcpy_P>:
    664e:	fb 01       	movw	r30, r22
    6650:	dc 01       	movw	r26, r24
    6652:	05 90       	lpm	r0, Z+
    6654:	0d 92       	st	X+, r0
    6656:	00 20       	and	r0, r0
    6658:	e1 f7       	brne	.-8      	; 0x6652 <strcpy_P+0x4>
    665a:	08 95       	ret

0000665c <strlen_P>:
    665c:	fc 01       	movw	r30, r24
    665e:	05 90       	lpm	r0, Z+
    6660:	00 20       	and	r0, r0
    6662:	e9 f7       	brne	.-6      	; 0x665e <strlen_P+0x2>
    6664:	80 95       	com	r24
    6666:	90 95       	com	r25
    6668:	8e 0f       	add	r24, r30
    666a:	9f 1f       	adc	r25, r31
    666c:	08 95       	ret

0000666e <strcpy>:
    666e:	fb 01       	movw	r30, r22
    6670:	dc 01       	movw	r26, r24
    6672:	01 90       	ld	r0, Z+
    6674:	0d 92       	st	X+, r0
    6676:	00 20       	and	r0, r0
    6678:	e1 f7       	brne	.-8      	; 0x6672 <strcpy+0x4>
    667a:	08 95       	ret

0000667c <strncpy>:
    667c:	fb 01       	movw	r30, r22
    667e:	dc 01       	movw	r26, r24
    6680:	41 50       	subi	r20, 0x01	; 1
    6682:	50 40       	sbci	r21, 0x00	; 0
    6684:	48 f0       	brcs	.+18     	; 0x6698 <strncpy+0x1c>
    6686:	01 90       	ld	r0, Z+
    6688:	0d 92       	st	X+, r0
    668a:	00 20       	and	r0, r0
    668c:	c9 f7       	brne	.-14     	; 0x6680 <strncpy+0x4>
    668e:	01 c0       	rjmp	.+2      	; 0x6692 <strncpy+0x16>
    6690:	1d 92       	st	X+, r1
    6692:	41 50       	subi	r20, 0x01	; 1
    6694:	50 40       	sbci	r21, 0x00	; 0
    6696:	e0 f7       	brcc	.-8      	; 0x6690 <strncpy+0x14>
    6698:	08 95       	ret

0000669a <__eerd_block>:
    669a:	a0 e0       	ldi	r26, 0x00	; 0
    669c:	b0 e0       	ldi	r27, 0x00	; 0
    669e:	e3 e5       	ldi	r30, 0x53	; 83
    66a0:	f3 e3       	ldi	r31, 0x33	; 51
    66a2:	0c 94 e0 3b 	jmp	0x77c0	; 0x77c0 <__prologue_saves__+0x14>
    66a6:	7c 01       	movw	r14, r24
    66a8:	eb 01       	movw	r28, r22
    66aa:	8a 01       	movw	r16, r20
    66ac:	69 01       	movw	r12, r18
    66ae:	09 c0       	rjmp	.+18     	; 0x66c2 <__eerd_block+0x28>
    66b0:	ce 01       	movw	r24, r28
    66b2:	21 96       	adiw	r28, 0x01	; 1
    66b4:	f6 01       	movw	r30, r12
    66b6:	09 95       	icall
    66b8:	f7 01       	movw	r30, r14
    66ba:	81 93       	st	Z+, r24
    66bc:	7f 01       	movw	r14, r30
    66be:	01 50       	subi	r16, 0x01	; 1
    66c0:	10 40       	sbci	r17, 0x00	; 0
    66c2:	01 15       	cp	r16, r1
    66c4:	11 05       	cpc	r17, r1
    66c6:	a1 f7       	brne	.-24     	; 0x66b0 <__eerd_block+0x16>
    66c8:	cd b7       	in	r28, 0x3d	; 61
    66ca:	de b7       	in	r29, 0x3e	; 62
    66cc:	e8 e0       	ldi	r30, 0x08	; 8
    66ce:	0c 94 fc 3b 	jmp	0x77f8	; 0x77f8 <__epilogue_restores__+0x14>

000066d2 <__eerd_word>:
    66d2:	df 92       	push	r13
    66d4:	ef 92       	push	r14
    66d6:	ff 92       	push	r15
    66d8:	0f 93       	push	r16
    66da:	1f 93       	push	r17
    66dc:	7b 01       	movw	r14, r22
    66de:	8c 01       	movw	r16, r24
    66e0:	fb 01       	movw	r30, r22
    66e2:	09 95       	icall
    66e4:	d8 2e       	mov	r13, r24
    66e6:	c8 01       	movw	r24, r16
    66e8:	01 96       	adiw	r24, 0x01	; 1
    66ea:	f7 01       	movw	r30, r14
    66ec:	09 95       	icall
    66ee:	98 2f       	mov	r25, r24
    66f0:	8d 2d       	mov	r24, r13
    66f2:	1f 91       	pop	r17
    66f4:	0f 91       	pop	r16
    66f6:	ff 90       	pop	r15
    66f8:	ef 90       	pop	r14
    66fa:	df 90       	pop	r13
    66fc:	08 95       	ret

000066fe <__eewr_block>:
    66fe:	a0 e0       	ldi	r26, 0x00	; 0
    6700:	b0 e0       	ldi	r27, 0x00	; 0
    6702:	e5 e8       	ldi	r30, 0x85	; 133
    6704:	f3 e3       	ldi	r31, 0x33	; 51
    6706:	0c 94 e0 3b 	jmp	0x77c0	; 0x77c0 <__prologue_saves__+0x14>
    670a:	ec 01       	movw	r28, r24
    670c:	7b 01       	movw	r14, r22
    670e:	8a 01       	movw	r16, r20
    6710:	69 01       	movw	r12, r18
    6712:	09 c0       	rjmp	.+18     	; 0x6726 <__eewr_block+0x28>
    6714:	ce 01       	movw	r24, r28
    6716:	21 96       	adiw	r28, 0x01	; 1
    6718:	f7 01       	movw	r30, r14
    671a:	61 91       	ld	r22, Z+
    671c:	7f 01       	movw	r14, r30
    671e:	f6 01       	movw	r30, r12
    6720:	09 95       	icall
    6722:	01 50       	subi	r16, 0x01	; 1
    6724:	10 40       	sbci	r17, 0x00	; 0
    6726:	01 15       	cp	r16, r1
    6728:	11 05       	cpc	r17, r1
    672a:	a1 f7       	brne	.-24     	; 0x6714 <__eewr_block+0x16>
    672c:	cd b7       	in	r28, 0x3d	; 61
    672e:	de b7       	in	r29, 0x3e	; 62
    6730:	e8 e0       	ldi	r30, 0x08	; 8
    6732:	0c 94 fc 3b 	jmp	0x77f8	; 0x77f8 <__epilogue_restores__+0x14>

00006736 <__eewr_word>:
    6736:	df 92       	push	r13
    6738:	ef 92       	push	r14
    673a:	ff 92       	push	r15
    673c:	0f 93       	push	r16
    673e:	1f 93       	push	r17
    6740:	d7 2e       	mov	r13, r23
    6742:	7a 01       	movw	r14, r20
    6744:	8c 01       	movw	r16, r24
    6746:	fa 01       	movw	r30, r20
    6748:	09 95       	icall
    674a:	c8 01       	movw	r24, r16
    674c:	01 96       	adiw	r24, 0x01	; 1
    674e:	6d 2d       	mov	r22, r13
    6750:	f7 01       	movw	r30, r14
    6752:	09 95       	icall
    6754:	1f 91       	pop	r17
    6756:	0f 91       	pop	r16
    6758:	ff 90       	pop	r15
    675a:	ef 90       	pop	r14
    675c:	df 90       	pop	r13
    675e:	08 95       	ret

00006760 <sprintf>:
    6760:	ae e0       	ldi	r26, 0x0E	; 14
    6762:	b0 e0       	ldi	r27, 0x00	; 0
    6764:	e6 eb       	ldi	r30, 0xB6	; 182
    6766:	f3 e3       	ldi	r31, 0x33	; 51
    6768:	0c 94 e4 3b 	jmp	0x77c8	; 0x77c8 <__prologue_saves__+0x1c>
    676c:	0d 89       	ldd	r16, Y+21	; 0x15
    676e:	1e 89       	ldd	r17, Y+22	; 0x16
    6770:	86 e0       	ldi	r24, 0x06	; 6
    6772:	8c 83       	std	Y+4, r24	; 0x04
    6774:	1a 83       	std	Y+2, r17	; 0x02
    6776:	09 83       	std	Y+1, r16	; 0x01
    6778:	8f ef       	ldi	r24, 0xFF	; 255
    677a:	9f e7       	ldi	r25, 0x7F	; 127
    677c:	9e 83       	std	Y+6, r25	; 0x06
    677e:	8d 83       	std	Y+5, r24	; 0x05
    6780:	9e 01       	movw	r18, r28
    6782:	27 5e       	subi	r18, 0xE7	; 231
    6784:	3f 4f       	sbci	r19, 0xFF	; 255
    6786:	ce 01       	movw	r24, r28
    6788:	01 96       	adiw	r24, 0x01	; 1
    678a:	6f 89       	ldd	r22, Y+23	; 0x17
    678c:	78 8d       	ldd	r23, Y+24	; 0x18
    678e:	a9 01       	movw	r20, r18
    6790:	0e 94 ee 33 	call	0x67dc	; 0x67dc <vfprintf>
    6794:	2f 81       	ldd	r18, Y+7	; 0x07
    6796:	38 85       	ldd	r19, Y+8	; 0x08
    6798:	02 0f       	add	r16, r18
    679a:	13 1f       	adc	r17, r19
    679c:	f8 01       	movw	r30, r16
    679e:	10 82       	st	Z, r1
    67a0:	2e 96       	adiw	r28, 0x0e	; 14
    67a2:	e4 e0       	ldi	r30, 0x04	; 4
    67a4:	0c 94 00 3c 	jmp	0x7800	; 0x7800 <__epilogue_restores__+0x1c>

000067a8 <sscanf>:
    67a8:	ae e0       	ldi	r26, 0x0E	; 14
    67aa:	b0 e0       	ldi	r27, 0x00	; 0
    67ac:	ea ed       	ldi	r30, 0xDA	; 218
    67ae:	f3 e3       	ldi	r31, 0x33	; 51
    67b0:	0c 94 e6 3b 	jmp	0x77cc	; 0x77cc <__prologue_saves__+0x20>
    67b4:	85 e0       	ldi	r24, 0x05	; 5
    67b6:	8c 83       	std	Y+4, r24	; 0x04
    67b8:	8b 89       	ldd	r24, Y+19	; 0x13
    67ba:	9c 89       	ldd	r25, Y+20	; 0x14
    67bc:	9a 83       	std	Y+2, r25	; 0x02
    67be:	89 83       	std	Y+1, r24	; 0x01
    67c0:	9e 01       	movw	r18, r28
    67c2:	29 5e       	subi	r18, 0xE9	; 233
    67c4:	3f 4f       	sbci	r19, 0xFF	; 255
    67c6:	ce 01       	movw	r24, r28
    67c8:	01 96       	adiw	r24, 0x01	; 1
    67ca:	6d 89       	ldd	r22, Y+21	; 0x15
    67cc:	7e 89       	ldd	r23, Y+22	; 0x16
    67ce:	a9 01       	movw	r20, r18
    67d0:	0e 94 4f 37 	call	0x6e9e	; 0x6e9e <vfscanf>
    67d4:	2e 96       	adiw	r28, 0x0e	; 14
    67d6:	e2 e0       	ldi	r30, 0x02	; 2
    67d8:	0c 94 02 3c 	jmp	0x7804	; 0x7804 <__epilogue_restores__+0x20>

000067dc <vfprintf>:
    67dc:	ab e0       	ldi	r26, 0x0B	; 11
    67de:	b0 e0       	ldi	r27, 0x00	; 0
    67e0:	e4 ef       	ldi	r30, 0xF4	; 244
    67e2:	f3 e3       	ldi	r31, 0x33	; 51
    67e4:	0c 94 d6 3b 	jmp	0x77ac	; 0x77ac <__prologue_saves__>
    67e8:	3c 01       	movw	r6, r24
    67ea:	2b 01       	movw	r4, r22
    67ec:	5a 01       	movw	r10, r20
    67ee:	fc 01       	movw	r30, r24
    67f0:	17 82       	std	Z+7, r1	; 0x07
    67f2:	16 82       	std	Z+6, r1	; 0x06
    67f4:	83 81       	ldd	r24, Z+3	; 0x03
    67f6:	81 fd       	sbrc	r24, 1
    67f8:	03 c0       	rjmp	.+6      	; 0x6800 <vfprintf+0x24>
    67fa:	6f ef       	ldi	r22, 0xFF	; 255
    67fc:	7f ef       	ldi	r23, 0xFF	; 255
    67fe:	c6 c1       	rjmp	.+908    	; 0x6b8c <vfprintf+0x3b0>
    6800:	9a e0       	ldi	r25, 0x0A	; 10
    6802:	89 2e       	mov	r8, r25
    6804:	1e 01       	movw	r2, r28
    6806:	08 94       	sec
    6808:	21 1c       	adc	r2, r1
    680a:	31 1c       	adc	r3, r1
    680c:	f3 01       	movw	r30, r6
    680e:	23 81       	ldd	r18, Z+3	; 0x03
    6810:	f2 01       	movw	r30, r4
    6812:	23 fd       	sbrc	r18, 3
    6814:	85 91       	lpm	r24, Z+
    6816:	23 ff       	sbrs	r18, 3
    6818:	81 91       	ld	r24, Z+
    681a:	2f 01       	movw	r4, r30
    681c:	88 23       	and	r24, r24
    681e:	09 f4       	brne	.+2      	; 0x6822 <vfprintf+0x46>
    6820:	b2 c1       	rjmp	.+868    	; 0x6b86 <vfprintf+0x3aa>
    6822:	85 32       	cpi	r24, 0x25	; 37
    6824:	39 f4       	brne	.+14     	; 0x6834 <vfprintf+0x58>
    6826:	23 fd       	sbrc	r18, 3
    6828:	85 91       	lpm	r24, Z+
    682a:	23 ff       	sbrs	r18, 3
    682c:	81 91       	ld	r24, Z+
    682e:	2f 01       	movw	r4, r30
    6830:	85 32       	cpi	r24, 0x25	; 37
    6832:	29 f4       	brne	.+10     	; 0x683e <vfprintf+0x62>
    6834:	90 e0       	ldi	r25, 0x00	; 0
    6836:	b3 01       	movw	r22, r6
    6838:	0e 94 c3 38 	call	0x7186	; 0x7186 <fputc>
    683c:	e7 cf       	rjmp	.-50     	; 0x680c <vfprintf+0x30>
    683e:	98 2f       	mov	r25, r24
    6840:	ff 24       	eor	r15, r15
    6842:	ee 24       	eor	r14, r14
    6844:	99 24       	eor	r9, r9
    6846:	ff e1       	ldi	r31, 0x1F	; 31
    6848:	ff 15       	cp	r31, r15
    684a:	d0 f0       	brcs	.+52     	; 0x6880 <vfprintf+0xa4>
    684c:	9b 32       	cpi	r25, 0x2B	; 43
    684e:	69 f0       	breq	.+26     	; 0x686a <vfprintf+0x8e>
    6850:	9c 32       	cpi	r25, 0x2C	; 44
    6852:	28 f4       	brcc	.+10     	; 0x685e <vfprintf+0x82>
    6854:	90 32       	cpi	r25, 0x20	; 32
    6856:	59 f0       	breq	.+22     	; 0x686e <vfprintf+0x92>
    6858:	93 32       	cpi	r25, 0x23	; 35
    685a:	91 f4       	brne	.+36     	; 0x6880 <vfprintf+0xa4>
    685c:	0e c0       	rjmp	.+28     	; 0x687a <vfprintf+0x9e>
    685e:	9d 32       	cpi	r25, 0x2D	; 45
    6860:	49 f0       	breq	.+18     	; 0x6874 <vfprintf+0x98>
    6862:	90 33       	cpi	r25, 0x30	; 48
    6864:	69 f4       	brne	.+26     	; 0x6880 <vfprintf+0xa4>
    6866:	41 e0       	ldi	r20, 0x01	; 1
    6868:	24 c0       	rjmp	.+72     	; 0x68b2 <vfprintf+0xd6>
    686a:	52 e0       	ldi	r21, 0x02	; 2
    686c:	f5 2a       	or	r15, r21
    686e:	84 e0       	ldi	r24, 0x04	; 4
    6870:	f8 2a       	or	r15, r24
    6872:	28 c0       	rjmp	.+80     	; 0x68c4 <vfprintf+0xe8>
    6874:	98 e0       	ldi	r25, 0x08	; 8
    6876:	f9 2a       	or	r15, r25
    6878:	25 c0       	rjmp	.+74     	; 0x68c4 <vfprintf+0xe8>
    687a:	e0 e1       	ldi	r30, 0x10	; 16
    687c:	fe 2a       	or	r15, r30
    687e:	22 c0       	rjmp	.+68     	; 0x68c4 <vfprintf+0xe8>
    6880:	f7 fc       	sbrc	r15, 7
    6882:	29 c0       	rjmp	.+82     	; 0x68d6 <vfprintf+0xfa>
    6884:	89 2f       	mov	r24, r25
    6886:	80 53       	subi	r24, 0x30	; 48
    6888:	8a 30       	cpi	r24, 0x0A	; 10
    688a:	70 f4       	brcc	.+28     	; 0x68a8 <vfprintf+0xcc>
    688c:	f6 fe       	sbrs	r15, 6
    688e:	05 c0       	rjmp	.+10     	; 0x689a <vfprintf+0xbe>
    6890:	98 9c       	mul	r9, r8
    6892:	90 2c       	mov	r9, r0
    6894:	11 24       	eor	r1, r1
    6896:	98 0e       	add	r9, r24
    6898:	15 c0       	rjmp	.+42     	; 0x68c4 <vfprintf+0xe8>
    689a:	e8 9c       	mul	r14, r8
    689c:	e0 2c       	mov	r14, r0
    689e:	11 24       	eor	r1, r1
    68a0:	e8 0e       	add	r14, r24
    68a2:	f0 e2       	ldi	r31, 0x20	; 32
    68a4:	ff 2a       	or	r15, r31
    68a6:	0e c0       	rjmp	.+28     	; 0x68c4 <vfprintf+0xe8>
    68a8:	9e 32       	cpi	r25, 0x2E	; 46
    68aa:	29 f4       	brne	.+10     	; 0x68b6 <vfprintf+0xda>
    68ac:	f6 fc       	sbrc	r15, 6
    68ae:	6b c1       	rjmp	.+726    	; 0x6b86 <vfprintf+0x3aa>
    68b0:	40 e4       	ldi	r20, 0x40	; 64
    68b2:	f4 2a       	or	r15, r20
    68b4:	07 c0       	rjmp	.+14     	; 0x68c4 <vfprintf+0xe8>
    68b6:	9c 36       	cpi	r25, 0x6C	; 108
    68b8:	19 f4       	brne	.+6      	; 0x68c0 <vfprintf+0xe4>
    68ba:	50 e8       	ldi	r21, 0x80	; 128
    68bc:	f5 2a       	or	r15, r21
    68be:	02 c0       	rjmp	.+4      	; 0x68c4 <vfprintf+0xe8>
    68c0:	98 36       	cpi	r25, 0x68	; 104
    68c2:	49 f4       	brne	.+18     	; 0x68d6 <vfprintf+0xfa>
    68c4:	f2 01       	movw	r30, r4
    68c6:	23 fd       	sbrc	r18, 3
    68c8:	95 91       	lpm	r25, Z+
    68ca:	23 ff       	sbrs	r18, 3
    68cc:	91 91       	ld	r25, Z+
    68ce:	2f 01       	movw	r4, r30
    68d0:	99 23       	and	r25, r25
    68d2:	09 f0       	breq	.+2      	; 0x68d6 <vfprintf+0xfa>
    68d4:	b8 cf       	rjmp	.-144    	; 0x6846 <vfprintf+0x6a>
    68d6:	89 2f       	mov	r24, r25
    68d8:	85 54       	subi	r24, 0x45	; 69
    68da:	83 30       	cpi	r24, 0x03	; 3
    68dc:	18 f0       	brcs	.+6      	; 0x68e4 <vfprintf+0x108>
    68de:	80 52       	subi	r24, 0x20	; 32
    68e0:	83 30       	cpi	r24, 0x03	; 3
    68e2:	38 f4       	brcc	.+14     	; 0x68f2 <vfprintf+0x116>
    68e4:	44 e0       	ldi	r20, 0x04	; 4
    68e6:	50 e0       	ldi	r21, 0x00	; 0
    68e8:	a4 0e       	add	r10, r20
    68ea:	b5 1e       	adc	r11, r21
    68ec:	5f e3       	ldi	r21, 0x3F	; 63
    68ee:	59 83       	std	Y+1, r21	; 0x01
    68f0:	0f c0       	rjmp	.+30     	; 0x6910 <vfprintf+0x134>
    68f2:	93 36       	cpi	r25, 0x63	; 99
    68f4:	31 f0       	breq	.+12     	; 0x6902 <vfprintf+0x126>
    68f6:	93 37       	cpi	r25, 0x73	; 115
    68f8:	79 f0       	breq	.+30     	; 0x6918 <vfprintf+0x13c>
    68fa:	93 35       	cpi	r25, 0x53	; 83
    68fc:	09 f0       	breq	.+2      	; 0x6900 <vfprintf+0x124>
    68fe:	56 c0       	rjmp	.+172    	; 0x69ac <vfprintf+0x1d0>
    6900:	20 c0       	rjmp	.+64     	; 0x6942 <vfprintf+0x166>
    6902:	f5 01       	movw	r30, r10
    6904:	80 81       	ld	r24, Z
    6906:	89 83       	std	Y+1, r24	; 0x01
    6908:	42 e0       	ldi	r20, 0x02	; 2
    690a:	50 e0       	ldi	r21, 0x00	; 0
    690c:	a4 0e       	add	r10, r20
    690e:	b5 1e       	adc	r11, r21
    6910:	61 01       	movw	r12, r2
    6912:	01 e0       	ldi	r16, 0x01	; 1
    6914:	10 e0       	ldi	r17, 0x00	; 0
    6916:	12 c0       	rjmp	.+36     	; 0x693c <vfprintf+0x160>
    6918:	f5 01       	movw	r30, r10
    691a:	c0 80       	ld	r12, Z
    691c:	d1 80       	ldd	r13, Z+1	; 0x01
    691e:	f6 fc       	sbrc	r15, 6
    6920:	03 c0       	rjmp	.+6      	; 0x6928 <vfprintf+0x14c>
    6922:	6f ef       	ldi	r22, 0xFF	; 255
    6924:	7f ef       	ldi	r23, 0xFF	; 255
    6926:	02 c0       	rjmp	.+4      	; 0x692c <vfprintf+0x150>
    6928:	69 2d       	mov	r22, r9
    692a:	70 e0       	ldi	r23, 0x00	; 0
    692c:	42 e0       	ldi	r20, 0x02	; 2
    692e:	50 e0       	ldi	r21, 0x00	; 0
    6930:	a4 0e       	add	r10, r20
    6932:	b5 1e       	adc	r11, r21
    6934:	c6 01       	movw	r24, r12
    6936:	0e 94 76 38 	call	0x70ec	; 0x70ec <strnlen>
    693a:	8c 01       	movw	r16, r24
    693c:	5f e7       	ldi	r21, 0x7F	; 127
    693e:	f5 22       	and	r15, r21
    6940:	14 c0       	rjmp	.+40     	; 0x696a <vfprintf+0x18e>
    6942:	f5 01       	movw	r30, r10
    6944:	c0 80       	ld	r12, Z
    6946:	d1 80       	ldd	r13, Z+1	; 0x01
    6948:	f6 fc       	sbrc	r15, 6
    694a:	03 c0       	rjmp	.+6      	; 0x6952 <vfprintf+0x176>
    694c:	6f ef       	ldi	r22, 0xFF	; 255
    694e:	7f ef       	ldi	r23, 0xFF	; 255
    6950:	02 c0       	rjmp	.+4      	; 0x6956 <vfprintf+0x17a>
    6952:	69 2d       	mov	r22, r9
    6954:	70 e0       	ldi	r23, 0x00	; 0
    6956:	42 e0       	ldi	r20, 0x02	; 2
    6958:	50 e0       	ldi	r21, 0x00	; 0
    695a:	a4 0e       	add	r10, r20
    695c:	b5 1e       	adc	r11, r21
    695e:	c6 01       	movw	r24, r12
    6960:	0e 94 6b 38 	call	0x70d6	; 0x70d6 <strnlen_P>
    6964:	8c 01       	movw	r16, r24
    6966:	50 e8       	ldi	r21, 0x80	; 128
    6968:	f5 2a       	or	r15, r21
    696a:	f3 fe       	sbrs	r15, 3
    696c:	07 c0       	rjmp	.+14     	; 0x697c <vfprintf+0x1a0>
    696e:	1a c0       	rjmp	.+52     	; 0x69a4 <vfprintf+0x1c8>
    6970:	80 e2       	ldi	r24, 0x20	; 32
    6972:	90 e0       	ldi	r25, 0x00	; 0
    6974:	b3 01       	movw	r22, r6
    6976:	0e 94 c3 38 	call	0x7186	; 0x7186 <fputc>
    697a:	ea 94       	dec	r14
    697c:	8e 2d       	mov	r24, r14
    697e:	90 e0       	ldi	r25, 0x00	; 0
    6980:	08 17       	cp	r16, r24
    6982:	19 07       	cpc	r17, r25
    6984:	a8 f3       	brcs	.-22     	; 0x6970 <vfprintf+0x194>
    6986:	0e c0       	rjmp	.+28     	; 0x69a4 <vfprintf+0x1c8>
    6988:	f6 01       	movw	r30, r12
    698a:	f7 fc       	sbrc	r15, 7
    698c:	85 91       	lpm	r24, Z+
    698e:	f7 fe       	sbrs	r15, 7
    6990:	81 91       	ld	r24, Z+
    6992:	6f 01       	movw	r12, r30
    6994:	90 e0       	ldi	r25, 0x00	; 0
    6996:	b3 01       	movw	r22, r6
    6998:	0e 94 c3 38 	call	0x7186	; 0x7186 <fputc>
    699c:	e1 10       	cpse	r14, r1
    699e:	ea 94       	dec	r14
    69a0:	01 50       	subi	r16, 0x01	; 1
    69a2:	10 40       	sbci	r17, 0x00	; 0
    69a4:	01 15       	cp	r16, r1
    69a6:	11 05       	cpc	r17, r1
    69a8:	79 f7       	brne	.-34     	; 0x6988 <vfprintf+0x1ac>
    69aa:	ea c0       	rjmp	.+468    	; 0x6b80 <vfprintf+0x3a4>
    69ac:	94 36       	cpi	r25, 0x64	; 100
    69ae:	11 f0       	breq	.+4      	; 0x69b4 <vfprintf+0x1d8>
    69b0:	99 36       	cpi	r25, 0x69	; 105
    69b2:	69 f5       	brne	.+90     	; 0x6a0e <vfprintf+0x232>
    69b4:	f7 fe       	sbrs	r15, 7
    69b6:	08 c0       	rjmp	.+16     	; 0x69c8 <vfprintf+0x1ec>
    69b8:	f5 01       	movw	r30, r10
    69ba:	20 81       	ld	r18, Z
    69bc:	31 81       	ldd	r19, Z+1	; 0x01
    69be:	42 81       	ldd	r20, Z+2	; 0x02
    69c0:	53 81       	ldd	r21, Z+3	; 0x03
    69c2:	84 e0       	ldi	r24, 0x04	; 4
    69c4:	90 e0       	ldi	r25, 0x00	; 0
    69c6:	0a c0       	rjmp	.+20     	; 0x69dc <vfprintf+0x200>
    69c8:	f5 01       	movw	r30, r10
    69ca:	80 81       	ld	r24, Z
    69cc:	91 81       	ldd	r25, Z+1	; 0x01
    69ce:	9c 01       	movw	r18, r24
    69d0:	44 27       	eor	r20, r20
    69d2:	37 fd       	sbrc	r19, 7
    69d4:	40 95       	com	r20
    69d6:	54 2f       	mov	r21, r20
    69d8:	82 e0       	ldi	r24, 0x02	; 2
    69da:	90 e0       	ldi	r25, 0x00	; 0
    69dc:	a8 0e       	add	r10, r24
    69de:	b9 1e       	adc	r11, r25
    69e0:	9f e6       	ldi	r25, 0x6F	; 111
    69e2:	f9 22       	and	r15, r25
    69e4:	57 ff       	sbrs	r21, 7
    69e6:	09 c0       	rjmp	.+18     	; 0x69fa <vfprintf+0x21e>
    69e8:	50 95       	com	r21
    69ea:	40 95       	com	r20
    69ec:	30 95       	com	r19
    69ee:	21 95       	neg	r18
    69f0:	3f 4f       	sbci	r19, 0xFF	; 255
    69f2:	4f 4f       	sbci	r20, 0xFF	; 255
    69f4:	5f 4f       	sbci	r21, 0xFF	; 255
    69f6:	e0 e8       	ldi	r30, 0x80	; 128
    69f8:	fe 2a       	or	r15, r30
    69fa:	ca 01       	movw	r24, r20
    69fc:	b9 01       	movw	r22, r18
    69fe:	a1 01       	movw	r20, r2
    6a00:	2a e0       	ldi	r18, 0x0A	; 10
    6a02:	30 e0       	ldi	r19, 0x00	; 0
    6a04:	0e 94 09 39 	call	0x7212	; 0x7212 <__ultoa_invert>
    6a08:	d8 2e       	mov	r13, r24
    6a0a:	d2 18       	sub	r13, r2
    6a0c:	40 c0       	rjmp	.+128    	; 0x6a8e <vfprintf+0x2b2>
    6a0e:	95 37       	cpi	r25, 0x75	; 117
    6a10:	29 f4       	brne	.+10     	; 0x6a1c <vfprintf+0x240>
    6a12:	1f 2d       	mov	r17, r15
    6a14:	1f 7e       	andi	r17, 0xEF	; 239
    6a16:	2a e0       	ldi	r18, 0x0A	; 10
    6a18:	30 e0       	ldi	r19, 0x00	; 0
    6a1a:	1d c0       	rjmp	.+58     	; 0x6a56 <vfprintf+0x27a>
    6a1c:	1f 2d       	mov	r17, r15
    6a1e:	19 7f       	andi	r17, 0xF9	; 249
    6a20:	9f 36       	cpi	r25, 0x6F	; 111
    6a22:	61 f0       	breq	.+24     	; 0x6a3c <vfprintf+0x260>
    6a24:	90 37       	cpi	r25, 0x70	; 112
    6a26:	20 f4       	brcc	.+8      	; 0x6a30 <vfprintf+0x254>
    6a28:	98 35       	cpi	r25, 0x58	; 88
    6a2a:	09 f0       	breq	.+2      	; 0x6a2e <vfprintf+0x252>
    6a2c:	ac c0       	rjmp	.+344    	; 0x6b86 <vfprintf+0x3aa>
    6a2e:	0f c0       	rjmp	.+30     	; 0x6a4e <vfprintf+0x272>
    6a30:	90 37       	cpi	r25, 0x70	; 112
    6a32:	39 f0       	breq	.+14     	; 0x6a42 <vfprintf+0x266>
    6a34:	98 37       	cpi	r25, 0x78	; 120
    6a36:	09 f0       	breq	.+2      	; 0x6a3a <vfprintf+0x25e>
    6a38:	a6 c0       	rjmp	.+332    	; 0x6b86 <vfprintf+0x3aa>
    6a3a:	04 c0       	rjmp	.+8      	; 0x6a44 <vfprintf+0x268>
    6a3c:	28 e0       	ldi	r18, 0x08	; 8
    6a3e:	30 e0       	ldi	r19, 0x00	; 0
    6a40:	0a c0       	rjmp	.+20     	; 0x6a56 <vfprintf+0x27a>
    6a42:	10 61       	ori	r17, 0x10	; 16
    6a44:	14 fd       	sbrc	r17, 4
    6a46:	14 60       	ori	r17, 0x04	; 4
    6a48:	20 e1       	ldi	r18, 0x10	; 16
    6a4a:	30 e0       	ldi	r19, 0x00	; 0
    6a4c:	04 c0       	rjmp	.+8      	; 0x6a56 <vfprintf+0x27a>
    6a4e:	14 fd       	sbrc	r17, 4
    6a50:	16 60       	ori	r17, 0x06	; 6
    6a52:	20 e1       	ldi	r18, 0x10	; 16
    6a54:	32 e0       	ldi	r19, 0x02	; 2
    6a56:	17 ff       	sbrs	r17, 7
    6a58:	08 c0       	rjmp	.+16     	; 0x6a6a <vfprintf+0x28e>
    6a5a:	f5 01       	movw	r30, r10
    6a5c:	60 81       	ld	r22, Z
    6a5e:	71 81       	ldd	r23, Z+1	; 0x01
    6a60:	82 81       	ldd	r24, Z+2	; 0x02
    6a62:	93 81       	ldd	r25, Z+3	; 0x03
    6a64:	44 e0       	ldi	r20, 0x04	; 4
    6a66:	50 e0       	ldi	r21, 0x00	; 0
    6a68:	08 c0       	rjmp	.+16     	; 0x6a7a <vfprintf+0x29e>
    6a6a:	f5 01       	movw	r30, r10
    6a6c:	80 81       	ld	r24, Z
    6a6e:	91 81       	ldd	r25, Z+1	; 0x01
    6a70:	bc 01       	movw	r22, r24
    6a72:	80 e0       	ldi	r24, 0x00	; 0
    6a74:	90 e0       	ldi	r25, 0x00	; 0
    6a76:	42 e0       	ldi	r20, 0x02	; 2
    6a78:	50 e0       	ldi	r21, 0x00	; 0
    6a7a:	a4 0e       	add	r10, r20
    6a7c:	b5 1e       	adc	r11, r21
    6a7e:	a1 01       	movw	r20, r2
    6a80:	0e 94 09 39 	call	0x7212	; 0x7212 <__ultoa_invert>
    6a84:	d8 2e       	mov	r13, r24
    6a86:	d2 18       	sub	r13, r2
    6a88:	8f e7       	ldi	r24, 0x7F	; 127
    6a8a:	f8 2e       	mov	r15, r24
    6a8c:	f1 22       	and	r15, r17
    6a8e:	f6 fe       	sbrs	r15, 6
    6a90:	0b c0       	rjmp	.+22     	; 0x6aa8 <vfprintf+0x2cc>
    6a92:	5e ef       	ldi	r21, 0xFE	; 254
    6a94:	f5 22       	and	r15, r21
    6a96:	d9 14       	cp	r13, r9
    6a98:	38 f4       	brcc	.+14     	; 0x6aa8 <vfprintf+0x2cc>
    6a9a:	f4 fe       	sbrs	r15, 4
    6a9c:	07 c0       	rjmp	.+14     	; 0x6aac <vfprintf+0x2d0>
    6a9e:	f2 fc       	sbrc	r15, 2
    6aa0:	05 c0       	rjmp	.+10     	; 0x6aac <vfprintf+0x2d0>
    6aa2:	8f ee       	ldi	r24, 0xEF	; 239
    6aa4:	f8 22       	and	r15, r24
    6aa6:	02 c0       	rjmp	.+4      	; 0x6aac <vfprintf+0x2d0>
    6aa8:	1d 2d       	mov	r17, r13
    6aaa:	01 c0       	rjmp	.+2      	; 0x6aae <vfprintf+0x2d2>
    6aac:	19 2d       	mov	r17, r9
    6aae:	f4 fe       	sbrs	r15, 4
    6ab0:	0d c0       	rjmp	.+26     	; 0x6acc <vfprintf+0x2f0>
    6ab2:	fe 01       	movw	r30, r28
    6ab4:	ed 0d       	add	r30, r13
    6ab6:	f1 1d       	adc	r31, r1
    6ab8:	80 81       	ld	r24, Z
    6aba:	80 33       	cpi	r24, 0x30	; 48
    6abc:	19 f4       	brne	.+6      	; 0x6ac4 <vfprintf+0x2e8>
    6abe:	99 ee       	ldi	r25, 0xE9	; 233
    6ac0:	f9 22       	and	r15, r25
    6ac2:	08 c0       	rjmp	.+16     	; 0x6ad4 <vfprintf+0x2f8>
    6ac4:	1f 5f       	subi	r17, 0xFF	; 255
    6ac6:	f2 fe       	sbrs	r15, 2
    6ac8:	05 c0       	rjmp	.+10     	; 0x6ad4 <vfprintf+0x2f8>
    6aca:	03 c0       	rjmp	.+6      	; 0x6ad2 <vfprintf+0x2f6>
    6acc:	8f 2d       	mov	r24, r15
    6ace:	86 78       	andi	r24, 0x86	; 134
    6ad0:	09 f0       	breq	.+2      	; 0x6ad4 <vfprintf+0x2f8>
    6ad2:	1f 5f       	subi	r17, 0xFF	; 255
    6ad4:	0f 2d       	mov	r16, r15
    6ad6:	f3 fc       	sbrc	r15, 3
    6ad8:	14 c0       	rjmp	.+40     	; 0x6b02 <vfprintf+0x326>
    6ada:	f0 fe       	sbrs	r15, 0
    6adc:	0f c0       	rjmp	.+30     	; 0x6afc <vfprintf+0x320>
    6ade:	1e 15       	cp	r17, r14
    6ae0:	10 f0       	brcs	.+4      	; 0x6ae6 <vfprintf+0x30a>
    6ae2:	9d 2c       	mov	r9, r13
    6ae4:	0b c0       	rjmp	.+22     	; 0x6afc <vfprintf+0x320>
    6ae6:	9d 2c       	mov	r9, r13
    6ae8:	9e 0c       	add	r9, r14
    6aea:	91 1a       	sub	r9, r17
    6aec:	1e 2d       	mov	r17, r14
    6aee:	06 c0       	rjmp	.+12     	; 0x6afc <vfprintf+0x320>
    6af0:	80 e2       	ldi	r24, 0x20	; 32
    6af2:	90 e0       	ldi	r25, 0x00	; 0
    6af4:	b3 01       	movw	r22, r6
    6af6:	0e 94 c3 38 	call	0x7186	; 0x7186 <fputc>
    6afa:	1f 5f       	subi	r17, 0xFF	; 255
    6afc:	1e 15       	cp	r17, r14
    6afe:	c0 f3       	brcs	.-16     	; 0x6af0 <vfprintf+0x314>
    6b00:	04 c0       	rjmp	.+8      	; 0x6b0a <vfprintf+0x32e>
    6b02:	1e 15       	cp	r17, r14
    6b04:	10 f4       	brcc	.+4      	; 0x6b0a <vfprintf+0x32e>
    6b06:	e1 1a       	sub	r14, r17
    6b08:	01 c0       	rjmp	.+2      	; 0x6b0c <vfprintf+0x330>
    6b0a:	ee 24       	eor	r14, r14
    6b0c:	04 ff       	sbrs	r16, 4
    6b0e:	0f c0       	rjmp	.+30     	; 0x6b2e <vfprintf+0x352>
    6b10:	80 e3       	ldi	r24, 0x30	; 48
    6b12:	90 e0       	ldi	r25, 0x00	; 0
    6b14:	b3 01       	movw	r22, r6
    6b16:	0e 94 c3 38 	call	0x7186	; 0x7186 <fputc>
    6b1a:	02 ff       	sbrs	r16, 2
    6b1c:	1d c0       	rjmp	.+58     	; 0x6b58 <vfprintf+0x37c>
    6b1e:	01 fd       	sbrc	r16, 1
    6b20:	03 c0       	rjmp	.+6      	; 0x6b28 <vfprintf+0x34c>
    6b22:	88 e7       	ldi	r24, 0x78	; 120
    6b24:	90 e0       	ldi	r25, 0x00	; 0
    6b26:	0e c0       	rjmp	.+28     	; 0x6b44 <vfprintf+0x368>
    6b28:	88 e5       	ldi	r24, 0x58	; 88
    6b2a:	90 e0       	ldi	r25, 0x00	; 0
    6b2c:	0b c0       	rjmp	.+22     	; 0x6b44 <vfprintf+0x368>
    6b2e:	80 2f       	mov	r24, r16
    6b30:	86 78       	andi	r24, 0x86	; 134
    6b32:	91 f0       	breq	.+36     	; 0x6b58 <vfprintf+0x37c>
    6b34:	01 ff       	sbrs	r16, 1
    6b36:	02 c0       	rjmp	.+4      	; 0x6b3c <vfprintf+0x360>
    6b38:	8b e2       	ldi	r24, 0x2B	; 43
    6b3a:	01 c0       	rjmp	.+2      	; 0x6b3e <vfprintf+0x362>
    6b3c:	80 e2       	ldi	r24, 0x20	; 32
    6b3e:	f7 fc       	sbrc	r15, 7
    6b40:	8d e2       	ldi	r24, 0x2D	; 45
    6b42:	90 e0       	ldi	r25, 0x00	; 0
    6b44:	b3 01       	movw	r22, r6
    6b46:	0e 94 c3 38 	call	0x7186	; 0x7186 <fputc>
    6b4a:	06 c0       	rjmp	.+12     	; 0x6b58 <vfprintf+0x37c>
    6b4c:	80 e3       	ldi	r24, 0x30	; 48
    6b4e:	90 e0       	ldi	r25, 0x00	; 0
    6b50:	b3 01       	movw	r22, r6
    6b52:	0e 94 c3 38 	call	0x7186	; 0x7186 <fputc>
    6b56:	9a 94       	dec	r9
    6b58:	d9 14       	cp	r13, r9
    6b5a:	c0 f3       	brcs	.-16     	; 0x6b4c <vfprintf+0x370>
    6b5c:	da 94       	dec	r13
    6b5e:	f1 01       	movw	r30, r2
    6b60:	ed 0d       	add	r30, r13
    6b62:	f1 1d       	adc	r31, r1
    6b64:	80 81       	ld	r24, Z
    6b66:	90 e0       	ldi	r25, 0x00	; 0
    6b68:	b3 01       	movw	r22, r6
    6b6a:	0e 94 c3 38 	call	0x7186	; 0x7186 <fputc>
    6b6e:	dd 20       	and	r13, r13
    6b70:	a9 f7       	brne	.-22     	; 0x6b5c <vfprintf+0x380>
    6b72:	06 c0       	rjmp	.+12     	; 0x6b80 <vfprintf+0x3a4>
    6b74:	80 e2       	ldi	r24, 0x20	; 32
    6b76:	90 e0       	ldi	r25, 0x00	; 0
    6b78:	b3 01       	movw	r22, r6
    6b7a:	0e 94 c3 38 	call	0x7186	; 0x7186 <fputc>
    6b7e:	ea 94       	dec	r14
    6b80:	ee 20       	and	r14, r14
    6b82:	c1 f7       	brne	.-16     	; 0x6b74 <vfprintf+0x398>
    6b84:	43 ce       	rjmp	.-890    	; 0x680c <vfprintf+0x30>
    6b86:	f3 01       	movw	r30, r6
    6b88:	66 81       	ldd	r22, Z+6	; 0x06
    6b8a:	77 81       	ldd	r23, Z+7	; 0x07
    6b8c:	cb 01       	movw	r24, r22
    6b8e:	2b 96       	adiw	r28, 0x0b	; 11
    6b90:	e2 e1       	ldi	r30, 0x12	; 18
    6b92:	0c 94 f2 3b 	jmp	0x77e4	; 0x77e4 <__epilogue_restores__>

00006b96 <putval>:
    6b96:	fc 01       	movw	r30, r24
    6b98:	20 fd       	sbrc	r18, 0
    6b9a:	08 c0       	rjmp	.+16     	; 0x6bac <putval+0x16>
    6b9c:	23 fd       	sbrc	r18, 3
    6b9e:	05 c0       	rjmp	.+10     	; 0x6baa <putval+0x14>
    6ba0:	22 ff       	sbrs	r18, 2
    6ba2:	02 c0       	rjmp	.+4      	; 0x6ba8 <putval+0x12>
    6ba4:	73 83       	std	Z+3, r23	; 0x03
    6ba6:	62 83       	std	Z+2, r22	; 0x02
    6ba8:	51 83       	std	Z+1, r21	; 0x01
    6baa:	40 83       	st	Z, r20
    6bac:	08 95       	ret

00006bae <mulacc>:
    6bae:	ef 92       	push	r14
    6bb0:	ff 92       	push	r15
    6bb2:	0f 93       	push	r16
    6bb4:	1f 93       	push	r17
    6bb6:	44 ff       	sbrs	r20, 4
    6bb8:	02 c0       	rjmp	.+4      	; 0x6bbe <mulacc+0x10>
    6bba:	33 e0       	ldi	r19, 0x03	; 3
    6bbc:	11 c0       	rjmp	.+34     	; 0x6be0 <mulacc+0x32>
    6bbe:	46 ff       	sbrs	r20, 6
    6bc0:	02 c0       	rjmp	.+4      	; 0x6bc6 <mulacc+0x18>
    6bc2:	34 e0       	ldi	r19, 0x04	; 4
    6bc4:	0d c0       	rjmp	.+26     	; 0x6be0 <mulacc+0x32>
    6bc6:	db 01       	movw	r26, r22
    6bc8:	fc 01       	movw	r30, r24
    6bca:	aa 0f       	add	r26, r26
    6bcc:	bb 1f       	adc	r27, r27
    6bce:	ee 1f       	adc	r30, r30
    6bd0:	ff 1f       	adc	r31, r31
    6bd2:	10 94       	com	r1
    6bd4:	d1 f7       	brne	.-12     	; 0x6bca <mulacc+0x1c>
    6bd6:	6a 0f       	add	r22, r26
    6bd8:	7b 1f       	adc	r23, r27
    6bda:	8e 1f       	adc	r24, r30
    6bdc:	9f 1f       	adc	r25, r31
    6bde:	31 e0       	ldi	r19, 0x01	; 1
    6be0:	66 0f       	add	r22, r22
    6be2:	77 1f       	adc	r23, r23
    6be4:	88 1f       	adc	r24, r24
    6be6:	99 1f       	adc	r25, r25
    6be8:	31 50       	subi	r19, 0x01	; 1
    6bea:	d1 f7       	brne	.-12     	; 0x6be0 <mulacc+0x32>
    6bec:	7b 01       	movw	r14, r22
    6bee:	8c 01       	movw	r16, r24
    6bf0:	e2 0e       	add	r14, r18
    6bf2:	f1 1c       	adc	r15, r1
    6bf4:	01 1d       	adc	r16, r1
    6bf6:	11 1d       	adc	r17, r1
    6bf8:	a8 01       	movw	r20, r16
    6bfa:	97 01       	movw	r18, r14
    6bfc:	b7 01       	movw	r22, r14
    6bfe:	ca 01       	movw	r24, r20
    6c00:	1f 91       	pop	r17
    6c02:	0f 91       	pop	r16
    6c04:	ff 90       	pop	r15
    6c06:	ef 90       	pop	r14
    6c08:	08 95       	ret

00006c0a <skip_spaces>:
    6c0a:	0f 93       	push	r16
    6c0c:	1f 93       	push	r17
    6c0e:	cf 93       	push	r28
    6c10:	df 93       	push	r29
    6c12:	8c 01       	movw	r16, r24
    6c14:	c8 01       	movw	r24, r16
    6c16:	0e 94 81 38 	call	0x7102	; 0x7102 <fgetc>
    6c1a:	ec 01       	movw	r28, r24
    6c1c:	97 fd       	sbrc	r25, 7
    6c1e:	08 c0       	rjmp	.+16     	; 0x6c30 <skip_spaces+0x26>
    6c20:	0e 94 cb 3b 	call	0x7796	; 0x7796 <isspace>
    6c24:	89 2b       	or	r24, r25
    6c26:	b1 f7       	brne	.-20     	; 0x6c14 <skip_spaces+0xa>
    6c28:	ce 01       	movw	r24, r28
    6c2a:	b8 01       	movw	r22, r16
    6c2c:	0e 94 ef 38 	call	0x71de	; 0x71de <ungetc>
    6c30:	ce 01       	movw	r24, r28
    6c32:	df 91       	pop	r29
    6c34:	cf 91       	pop	r28
    6c36:	1f 91       	pop	r17
    6c38:	0f 91       	pop	r16
    6c3a:	08 95       	ret

00006c3c <conv_int>:
    6c3c:	a0 e0       	ldi	r26, 0x00	; 0
    6c3e:	b0 e0       	ldi	r27, 0x00	; 0
    6c40:	e4 e2       	ldi	r30, 0x24	; 36
    6c42:	f6 e3       	ldi	r31, 0x36	; 54
    6c44:	0c 94 de 3b 	jmp	0x77bc	; 0x77bc <__prologue_saves__+0x10>
    6c48:	ec 01       	movw	r28, r24
    6c4a:	c6 2e       	mov	r12, r22
    6c4c:	5a 01       	movw	r10, r20
    6c4e:	12 2f       	mov	r17, r18
    6c50:	0e 94 81 38 	call	0x7102	; 0x7102 <fgetc>
    6c54:	ac 01       	movw	r20, r24
    6c56:	8b 32       	cpi	r24, 0x2B	; 43
    6c58:	19 f0       	breq	.+6      	; 0x6c60 <conv_int+0x24>
    6c5a:	8d 32       	cpi	r24, 0x2D	; 45
    6c5c:	51 f4       	brne	.+20     	; 0x6c72 <conv_int+0x36>
    6c5e:	10 68       	ori	r17, 0x80	; 128
    6c60:	ca 94       	dec	r12
    6c62:	09 f4       	brne	.+2      	; 0x6c66 <conv_int+0x2a>
    6c64:	6d c0       	rjmp	.+218    	; 0x6d40 <conv_int+0x104>
    6c66:	ce 01       	movw	r24, r28
    6c68:	0e 94 81 38 	call	0x7102	; 0x7102 <fgetc>
    6c6c:	ac 01       	movw	r20, r24
    6c6e:	97 fd       	sbrc	r25, 7
    6c70:	67 c0       	rjmp	.+206    	; 0x6d40 <conv_int+0x104>
    6c72:	6d ef       	ldi	r22, 0xFD	; 253
    6c74:	d6 2e       	mov	r13, r22
    6c76:	d1 22       	and	r13, r17
    6c78:	8d 2d       	mov	r24, r13
    6c7a:	80 73       	andi	r24, 0x30	; 48
    6c7c:	01 f5       	brne	.+64     	; 0x6cbe <conv_int+0x82>
    6c7e:	40 33       	cpi	r20, 0x30	; 48
    6c80:	f1 f4       	brne	.+60     	; 0x6cbe <conv_int+0x82>
    6c82:	ca 94       	dec	r12
    6c84:	09 f4       	brne	.+2      	; 0x6c88 <conv_int+0x4c>
    6c86:	47 c0       	rjmp	.+142    	; 0x6d16 <conv_int+0xda>
    6c88:	ce 01       	movw	r24, r28
    6c8a:	0e 94 81 38 	call	0x7102	; 0x7102 <fgetc>
    6c8e:	ac 01       	movw	r20, r24
    6c90:	97 fd       	sbrc	r25, 7
    6c92:	41 c0       	rjmp	.+130    	; 0x6d16 <conv_int+0xda>
    6c94:	82 e0       	ldi	r24, 0x02	; 2
    6c96:	d8 2a       	or	r13, r24
    6c98:	48 37       	cpi	r20, 0x78	; 120
    6c9a:	11 f0       	breq	.+4      	; 0x6ca0 <conv_int+0x64>
    6c9c:	48 35       	cpi	r20, 0x58	; 88
    6c9e:	59 f4       	brne	.+22     	; 0x6cb6 <conv_int+0x7a>
    6ca0:	80 e4       	ldi	r24, 0x40	; 64
    6ca2:	d8 2a       	or	r13, r24
    6ca4:	ca 94       	dec	r12
    6ca6:	b9 f1       	breq	.+110    	; 0x6d16 <conv_int+0xda>
    6ca8:	ce 01       	movw	r24, r28
    6caa:	0e 94 81 38 	call	0x7102	; 0x7102 <fgetc>
    6cae:	ac 01       	movw	r20, r24
    6cb0:	99 23       	and	r25, r25
    6cb2:	2c f4       	brge	.+10     	; 0x6cbe <conv_int+0x82>
    6cb4:	30 c0       	rjmp	.+96     	; 0x6d16 <conv_int+0xda>
    6cb6:	d6 fc       	sbrc	r13, 6
    6cb8:	02 c0       	rjmp	.+4      	; 0x6cbe <conv_int+0x82>
    6cba:	80 e1       	ldi	r24, 0x10	; 16
    6cbc:	d8 2a       	or	r13, r24
    6cbe:	ee 24       	eor	r14, r14
    6cc0:	ff 24       	eor	r15, r15
    6cc2:	87 01       	movw	r16, r14
    6cc4:	24 2f       	mov	r18, r20
    6cc6:	20 53       	subi	r18, 0x30	; 48
    6cc8:	28 30       	cpi	r18, 0x08	; 8
    6cca:	88 f0       	brcs	.+34     	; 0x6cee <conv_int+0xb2>
    6ccc:	d4 fc       	sbrc	r13, 4
    6cce:	09 c0       	rjmp	.+18     	; 0x6ce2 <conv_int+0xa6>
    6cd0:	2a 30       	cpi	r18, 0x0A	; 10
    6cd2:	68 f0       	brcs	.+26     	; 0x6cee <conv_int+0xb2>
    6cd4:	d6 fe       	sbrs	r13, 6
    6cd6:	05 c0       	rjmp	.+10     	; 0x6ce2 <conv_int+0xa6>
    6cd8:	2f 7d       	andi	r18, 0xDF	; 223
    6cda:	82 2f       	mov	r24, r18
    6cdc:	81 51       	subi	r24, 0x11	; 17
    6cde:	86 30       	cpi	r24, 0x06	; 6
    6ce0:	28 f0       	brcs	.+10     	; 0x6cec <conv_int+0xb0>
    6ce2:	ca 01       	movw	r24, r20
    6ce4:	be 01       	movw	r22, r28
    6ce6:	0e 94 ef 38 	call	0x71de	; 0x71de <ungetc>
    6cea:	12 c0       	rjmp	.+36     	; 0x6d10 <conv_int+0xd4>
    6cec:	27 50       	subi	r18, 0x07	; 7
    6cee:	c8 01       	movw	r24, r16
    6cf0:	b7 01       	movw	r22, r14
    6cf2:	4d 2d       	mov	r20, r13
    6cf4:	0e 94 d7 35 	call	0x6bae	; 0x6bae <mulacc>
    6cf8:	7b 01       	movw	r14, r22
    6cfa:	8c 01       	movw	r16, r24
    6cfc:	82 e0       	ldi	r24, 0x02	; 2
    6cfe:	d8 2a       	or	r13, r24
    6d00:	ca 94       	dec	r12
    6d02:	61 f0       	breq	.+24     	; 0x6d1c <conv_int+0xe0>
    6d04:	ce 01       	movw	r24, r28
    6d06:	0e 94 81 38 	call	0x7102	; 0x7102 <fgetc>
    6d0a:	ac 01       	movw	r20, r24
    6d0c:	97 ff       	sbrs	r25, 7
    6d0e:	da cf       	rjmp	.-76     	; 0x6cc4 <conv_int+0x88>
    6d10:	d1 fc       	sbrc	r13, 1
    6d12:	04 c0       	rjmp	.+8      	; 0x6d1c <conv_int+0xe0>
    6d14:	15 c0       	rjmp	.+42     	; 0x6d40 <conv_int+0x104>
    6d16:	ee 24       	eor	r14, r14
    6d18:	ff 24       	eor	r15, r15
    6d1a:	87 01       	movw	r16, r14
    6d1c:	d7 fe       	sbrs	r13, 7
    6d1e:	08 c0       	rjmp	.+16     	; 0x6d30 <conv_int+0xf4>
    6d20:	10 95       	com	r17
    6d22:	00 95       	com	r16
    6d24:	f0 94       	com	r15
    6d26:	e0 94       	com	r14
    6d28:	e1 1c       	adc	r14, r1
    6d2a:	f1 1c       	adc	r15, r1
    6d2c:	01 1d       	adc	r16, r1
    6d2e:	11 1d       	adc	r17, r1
    6d30:	c5 01       	movw	r24, r10
    6d32:	b8 01       	movw	r22, r16
    6d34:	a7 01       	movw	r20, r14
    6d36:	2d 2d       	mov	r18, r13
    6d38:	0e 94 cb 35 	call	0x6b96	; 0x6b96 <putval>
    6d3c:	81 e0       	ldi	r24, 0x01	; 1
    6d3e:	01 c0       	rjmp	.+2      	; 0x6d42 <conv_int+0x106>
    6d40:	80 e0       	ldi	r24, 0x00	; 0
    6d42:	cd b7       	in	r28, 0x3d	; 61
    6d44:	de b7       	in	r29, 0x3e	; 62
    6d46:	ea e0       	ldi	r30, 0x0A	; 10
    6d48:	0c 94 fa 3b 	jmp	0x77f4	; 0x77f4 <__epilogue_restores__+0x10>

00006d4c <conv_brk>:
    6d4c:	a0 e2       	ldi	r26, 0x20	; 32
    6d4e:	b0 e0       	ldi	r27, 0x00	; 0
    6d50:	ec ea       	ldi	r30, 0xAC	; 172
    6d52:	f6 e3       	ldi	r31, 0x36	; 54
    6d54:	0c 94 da 3b 	jmp	0x77b4	; 0x77b4 <__prologue_saves__+0x8>
    6d58:	6c 01       	movw	r12, r24
    6d5a:	a6 2e       	mov	r10, r22
    6d5c:	8a 01       	movw	r16, r20
    6d5e:	79 01       	movw	r14, r18
    6d60:	fe 01       	movw	r30, r28
    6d62:	31 96       	adiw	r30, 0x01	; 1
    6d64:	80 e2       	ldi	r24, 0x20	; 32
    6d66:	df 01       	movw	r26, r30
    6d68:	1d 92       	st	X+, r1
    6d6a:	8a 95       	dec	r24
    6d6c:	e9 f7       	brne	.-6      	; 0x6d68 <conv_brk+0x1c>
    6d6e:	70 e0       	ldi	r23, 0x00	; 0
    6d70:	30 e0       	ldi	r19, 0x00	; 0
    6d72:	60 e0       	ldi	r22, 0x00	; 0
    6d74:	40 e0       	ldi	r20, 0x00	; 0
    6d76:	50 e0       	ldi	r21, 0x00	; 0
    6d78:	4f 01       	movw	r8, r30
    6d7a:	a1 e0       	ldi	r26, 0x01	; 1
    6d7c:	b0 e0       	ldi	r27, 0x00	; 0
    6d7e:	f6 01       	movw	r30, r12
    6d80:	83 81       	ldd	r24, Z+3	; 0x03
    6d82:	f7 01       	movw	r30, r14
    6d84:	83 fd       	sbrc	r24, 3
    6d86:	25 91       	lpm	r18, Z+
    6d88:	83 ff       	sbrs	r24, 3
    6d8a:	21 91       	ld	r18, Z+
    6d8c:	7f 01       	movw	r14, r30
    6d8e:	22 23       	and	r18, r18
    6d90:	09 f4       	brne	.+2      	; 0x6d94 <conv_brk+0x48>
    6d92:	7e c0       	rjmp	.+252    	; 0x6e90 <conv_brk+0x144>
    6d94:	2e 35       	cpi	r18, 0x5E	; 94
    6d96:	19 f4       	brne	.+6      	; 0x6d9e <conv_brk+0x52>
    6d98:	41 15       	cp	r20, r1
    6d9a:	51 05       	cpc	r21, r1
    6d9c:	69 f1       	breq	.+90     	; 0x6df8 <conv_brk+0xac>
    6d9e:	87 2f       	mov	r24, r23
    6da0:	90 e0       	ldi	r25, 0x00	; 0
    6da2:	84 17       	cp	r24, r20
    6da4:	95 07       	cpc	r25, r21
    6da6:	44 f4       	brge	.+16     	; 0x6db8 <conv_brk+0x6c>
    6da8:	2d 35       	cpi	r18, 0x5D	; 93
    6daa:	51 f1       	breq	.+84     	; 0x6e00 <conv_brk+0xb4>
    6dac:	2d 32       	cpi	r18, 0x2D	; 45
    6dae:	21 f4       	brne	.+8      	; 0x6db8 <conv_brk+0x6c>
    6db0:	33 23       	and	r19, r19
    6db2:	29 f4       	brne	.+10     	; 0x6dbe <conv_brk+0x72>
    6db4:	31 e0       	ldi	r19, 0x01	; 1
    6db6:	21 c0       	rjmp	.+66     	; 0x6dfa <conv_brk+0xae>
    6db8:	33 23       	and	r19, r19
    6dba:	09 f4       	brne	.+2      	; 0x6dbe <conv_brk+0x72>
    6dbc:	62 2f       	mov	r22, r18
    6dbe:	32 2f       	mov	r19, r18
    6dc0:	83 2f       	mov	r24, r19
    6dc2:	86 95       	lsr	r24
    6dc4:	86 95       	lsr	r24
    6dc6:	86 95       	lsr	r24
    6dc8:	f4 01       	movw	r30, r8
    6dca:	e8 0f       	add	r30, r24
    6dcc:	f1 1d       	adc	r31, r1
    6dce:	83 2f       	mov	r24, r19
    6dd0:	87 70       	andi	r24, 0x07	; 7
    6dd2:	3d 01       	movw	r6, r26
    6dd4:	02 c0       	rjmp	.+4      	; 0x6dda <conv_brk+0x8e>
    6dd6:	66 0c       	add	r6, r6
    6dd8:	77 1c       	adc	r7, r7
    6dda:	8a 95       	dec	r24
    6ddc:	e2 f7       	brpl	.-8      	; 0x6dd6 <conv_brk+0x8a>
    6dde:	20 81       	ld	r18, Z
    6de0:	26 29       	or	r18, r6
    6de2:	20 83       	st	Z, r18
    6de4:	36 17       	cp	r19, r22
    6de6:	11 f4       	brne	.+4      	; 0x6dec <conv_brk+0xa0>
    6de8:	30 e0       	ldi	r19, 0x00	; 0
    6dea:	07 c0       	rjmp	.+14     	; 0x6dfa <conv_brk+0xae>
    6dec:	36 17       	cp	r19, r22
    6dee:	10 f4       	brcc	.+4      	; 0x6df4 <conv_brk+0xa8>
    6df0:	3f 5f       	subi	r19, 0xFF	; 255
    6df2:	e6 cf       	rjmp	.-52     	; 0x6dc0 <conv_brk+0x74>
    6df4:	31 50       	subi	r19, 0x01	; 1
    6df6:	e4 cf       	rjmp	.-56     	; 0x6dc0 <conv_brk+0x74>
    6df8:	71 e0       	ldi	r23, 0x01	; 1
    6dfa:	4f 5f       	subi	r20, 0xFF	; 255
    6dfc:	5f 4f       	sbci	r21, 0xFF	; 255
    6dfe:	bf cf       	rjmp	.-130    	; 0x6d7e <conv_brk+0x32>
    6e00:	33 23       	and	r19, r19
    6e02:	19 f0       	breq	.+6      	; 0x6e0a <conv_brk+0xbe>
    6e04:	8e 81       	ldd	r24, Y+6	; 0x06
    6e06:	80 62       	ori	r24, 0x20	; 32
    6e08:	8e 83       	std	Y+6, r24	; 0x06
    6e0a:	77 23       	and	r23, r23
    6e0c:	59 f0       	breq	.+22     	; 0x6e24 <conv_brk+0xd8>
    6e0e:	fe 01       	movw	r30, r28
    6e10:	31 96       	adiw	r30, 0x01	; 1
    6e12:	9e 01       	movw	r18, r28
    6e14:	2f 5d       	subi	r18, 0xDF	; 223
    6e16:	3f 4f       	sbci	r19, 0xFF	; 255
    6e18:	80 81       	ld	r24, Z
    6e1a:	80 95       	com	r24
    6e1c:	81 93       	st	Z+, r24
    6e1e:	e2 17       	cp	r30, r18
    6e20:	f3 07       	cpc	r31, r19
    6e22:	d1 f7       	brne	.-12     	; 0x6e18 <conv_brk+0xcc>
    6e24:	bb 24       	eor	r11, r11
    6e26:	b3 94       	inc	r11
    6e28:	4e 01       	movw	r8, r28
    6e2a:	08 94       	sec
    6e2c:	81 1c       	adc	r8, r1
    6e2e:	91 1c       	adc	r9, r1
    6e30:	c6 01       	movw	r24, r12
    6e32:	0e 94 81 38 	call	0x7102	; 0x7102 <fgetc>
    6e36:	ac 01       	movw	r20, r24
    6e38:	97 fd       	sbrc	r25, 7
    6e3a:	22 c0       	rjmp	.+68     	; 0x6e80 <conv_brk+0x134>
    6e3c:	86 95       	lsr	r24
    6e3e:	86 95       	lsr	r24
    6e40:	86 95       	lsr	r24
    6e42:	f4 01       	movw	r30, r8
    6e44:	e8 0f       	add	r30, r24
    6e46:	f1 1d       	adc	r31, r1
    6e48:	80 81       	ld	r24, Z
    6e4a:	90 e0       	ldi	r25, 0x00	; 0
    6e4c:	9a 01       	movw	r18, r20
    6e4e:	27 70       	andi	r18, 0x07	; 7
    6e50:	30 70       	andi	r19, 0x00	; 0
    6e52:	02 c0       	rjmp	.+4      	; 0x6e58 <conv_brk+0x10c>
    6e54:	95 95       	asr	r25
    6e56:	87 95       	ror	r24
    6e58:	2a 95       	dec	r18
    6e5a:	e2 f7       	brpl	.-8      	; 0x6e54 <conv_brk+0x108>
    6e5c:	80 fd       	sbrc	r24, 0
    6e5e:	05 c0       	rjmp	.+10     	; 0x6e6a <conv_brk+0x11e>
    6e60:	ca 01       	movw	r24, r20
    6e62:	b6 01       	movw	r22, r12
    6e64:	0e 94 ef 38 	call	0x71de	; 0x71de <ungetc>
    6e68:	0b c0       	rjmp	.+22     	; 0x6e80 <conv_brk+0x134>
    6e6a:	01 15       	cp	r16, r1
    6e6c:	11 05       	cpc	r17, r1
    6e6e:	19 f0       	breq	.+6      	; 0x6e76 <conv_brk+0x12a>
    6e70:	d8 01       	movw	r26, r16
    6e72:	4d 93       	st	X+, r20
    6e74:	8d 01       	movw	r16, r26
    6e76:	aa 94       	dec	r10
    6e78:	bb 24       	eor	r11, r11
    6e7a:	aa 20       	and	r10, r10
    6e7c:	c9 f6       	brne	.-78     	; 0x6e30 <conv_brk+0xe4>
    6e7e:	02 c0       	rjmp	.+4      	; 0x6e84 <conv_brk+0x138>
    6e80:	bb 20       	and	r11, r11
    6e82:	31 f4       	brne	.+12     	; 0x6e90 <conv_brk+0x144>
    6e84:	01 15       	cp	r16, r1
    6e86:	11 05       	cpc	r17, r1
    6e88:	29 f0       	breq	.+10     	; 0x6e94 <conv_brk+0x148>
    6e8a:	f8 01       	movw	r30, r16
    6e8c:	10 82       	st	Z, r1
    6e8e:	02 c0       	rjmp	.+4      	; 0x6e94 <conv_brk+0x148>
    6e90:	ee 24       	eor	r14, r14
    6e92:	ff 24       	eor	r15, r15
    6e94:	c7 01       	movw	r24, r14
    6e96:	a0 96       	adiw	r28, 0x20	; 32
    6e98:	ee e0       	ldi	r30, 0x0E	; 14
    6e9a:	0c 94 f6 3b 	jmp	0x77ec	; 0x77ec <__epilogue_restores__+0x8>

00006e9e <vfscanf>:
    6e9e:	a0 e0       	ldi	r26, 0x00	; 0
    6ea0:	b0 e0       	ldi	r27, 0x00	; 0
    6ea2:	e5 e5       	ldi	r30, 0x55	; 85
    6ea4:	f7 e3       	ldi	r31, 0x37	; 55
    6ea6:	0c 94 da 3b 	jmp	0x77b4	; 0x77b4 <__prologue_saves__+0x8>
    6eaa:	5c 01       	movw	r10, r24
    6eac:	6b 01       	movw	r12, r22
    6eae:	3a 01       	movw	r6, r20
    6eb0:	fc 01       	movw	r30, r24
    6eb2:	17 82       	std	Z+7, r1	; 0x07
    6eb4:	16 82       	std	Z+6, r1	; 0x06
    6eb6:	88 24       	eor	r8, r8
    6eb8:	ea c0       	rjmp	.+468    	; 0x708e <vfscanf+0x1f0>
    6eba:	81 2f       	mov	r24, r17
    6ebc:	90 e0       	ldi	r25, 0x00	; 0
    6ebe:	0e 94 cb 3b 	call	0x7796	; 0x7796 <isspace>
    6ec2:	89 2b       	or	r24, r25
    6ec4:	21 f0       	breq	.+8      	; 0x6ece <vfscanf+0x30>
    6ec6:	c5 01       	movw	r24, r10
    6ec8:	0e 94 05 36 	call	0x6c0a	; 0x6c0a <skip_spaces>
    6ecc:	e0 c0       	rjmp	.+448    	; 0x708e <vfscanf+0x1f0>
    6ece:	15 32       	cpi	r17, 0x25	; 37
    6ed0:	49 f4       	brne	.+18     	; 0x6ee4 <vfscanf+0x46>
    6ed2:	f6 01       	movw	r30, r12
    6ed4:	f3 fc       	sbrc	r15, 3
    6ed6:	65 91       	lpm	r22, Z+
    6ed8:	f3 fe       	sbrs	r15, 3
    6eda:	61 91       	ld	r22, Z+
    6edc:	6f 01       	movw	r12, r30
    6ede:	65 32       	cpi	r22, 0x25	; 37
    6ee0:	69 f4       	brne	.+26     	; 0x6efc <vfscanf+0x5e>
    6ee2:	15 e2       	ldi	r17, 0x25	; 37
    6ee4:	c5 01       	movw	r24, r10
    6ee6:	0e 94 81 38 	call	0x7102	; 0x7102 <fgetc>
    6eea:	97 fd       	sbrc	r25, 7
    6eec:	dc c0       	rjmp	.+440    	; 0x70a6 <vfscanf+0x208>
    6eee:	18 17       	cp	r17, r24
    6ef0:	09 f4       	brne	.+2      	; 0x6ef4 <vfscanf+0x56>
    6ef2:	cd c0       	rjmp	.+410    	; 0x708e <vfscanf+0x1f0>
    6ef4:	b5 01       	movw	r22, r10
    6ef6:	0e 94 ef 38 	call	0x71de	; 0x71de <ungetc>
    6efa:	da c0       	rjmp	.+436    	; 0x70b0 <vfscanf+0x212>
    6efc:	6a 32       	cpi	r22, 0x2A	; 42
    6efe:	19 f0       	breq	.+6      	; 0x6f06 <vfscanf+0x68>
    6f00:	16 2f       	mov	r17, r22
    6f02:	00 e0       	ldi	r16, 0x00	; 0
    6f04:	06 c0       	rjmp	.+12     	; 0x6f12 <vfscanf+0x74>
    6f06:	f3 fc       	sbrc	r15, 3
    6f08:	15 91       	lpm	r17, Z+
    6f0a:	f3 fe       	sbrs	r15, 3
    6f0c:	11 91       	ld	r17, Z+
    6f0e:	6f 01       	movw	r12, r30
    6f10:	01 e0       	ldi	r16, 0x01	; 1
    6f12:	99 24       	eor	r9, r9
    6f14:	0f c0       	rjmp	.+30     	; 0x6f34 <vfscanf+0x96>
    6f16:	02 60       	ori	r16, 0x02	; 2
    6f18:	69 2d       	mov	r22, r9
    6f1a:	70 e0       	ldi	r23, 0x00	; 0
    6f1c:	80 e0       	ldi	r24, 0x00	; 0
    6f1e:	90 e0       	ldi	r25, 0x00	; 0
    6f20:	40 e2       	ldi	r20, 0x20	; 32
    6f22:	0e 94 d7 35 	call	0x6bae	; 0x6bae <mulacc>
    6f26:	96 2e       	mov	r9, r22
    6f28:	f6 01       	movw	r30, r12
    6f2a:	f3 fc       	sbrc	r15, 3
    6f2c:	15 91       	lpm	r17, Z+
    6f2e:	f3 fe       	sbrs	r15, 3
    6f30:	11 91       	ld	r17, Z+
    6f32:	6f 01       	movw	r12, r30
    6f34:	21 2f       	mov	r18, r17
    6f36:	20 53       	subi	r18, 0x30	; 48
    6f38:	2a 30       	cpi	r18, 0x0A	; 10
    6f3a:	68 f3       	brcs	.-38     	; 0x6f16 <vfscanf+0x78>
    6f3c:	01 fd       	sbrc	r16, 1
    6f3e:	03 c0       	rjmp	.+6      	; 0x6f46 <vfscanf+0xa8>
    6f40:	99 24       	eor	r9, r9
    6f42:	9a 94       	dec	r9
    6f44:	03 c0       	rjmp	.+6      	; 0x6f4c <vfscanf+0xae>
    6f46:	99 20       	and	r9, r9
    6f48:	09 f4       	brne	.+2      	; 0x6f4c <vfscanf+0xae>
    6f4a:	b2 c0       	rjmp	.+356    	; 0x70b0 <vfscanf+0x212>
    6f4c:	18 36       	cpi	r17, 0x68	; 104
    6f4e:	21 f0       	breq	.+8      	; 0x6f58 <vfscanf+0xba>
    6f50:	1c 36       	cpi	r17, 0x6C	; 108
    6f52:	99 f4       	brne	.+38     	; 0x6f7a <vfscanf+0xdc>
    6f54:	f6 01       	movw	r30, r12
    6f56:	0b c0       	rjmp	.+22     	; 0x6f6e <vfscanf+0xd0>
    6f58:	f6 01       	movw	r30, r12
    6f5a:	f3 fc       	sbrc	r15, 3
    6f5c:	65 91       	lpm	r22, Z+
    6f5e:	f3 fe       	sbrs	r15, 3
    6f60:	61 91       	ld	r22, Z+
    6f62:	68 36       	cpi	r22, 0x68	; 104
    6f64:	19 f0       	breq	.+6      	; 0x6f6c <vfscanf+0xce>
    6f66:	6f 01       	movw	r12, r30
    6f68:	16 2f       	mov	r17, r22
    6f6a:	07 c0       	rjmp	.+14     	; 0x6f7a <vfscanf+0xdc>
    6f6c:	08 60       	ori	r16, 0x08	; 8
    6f6e:	04 60       	ori	r16, 0x04	; 4
    6f70:	f3 fc       	sbrc	r15, 3
    6f72:	15 91       	lpm	r17, Z+
    6f74:	f3 fe       	sbrs	r15, 3
    6f76:	11 91       	ld	r17, Z+
    6f78:	6f 01       	movw	r12, r30
    6f7a:	11 23       	and	r17, r17
    6f7c:	09 f4       	brne	.+2      	; 0x6f80 <vfscanf+0xe2>
    6f7e:	98 c0       	rjmp	.+304    	; 0x70b0 <vfscanf+0x212>
    6f80:	8b e1       	ldi	r24, 0x1B	; 27
    6f82:	9d e0       	ldi	r25, 0x0D	; 13
    6f84:	61 2f       	mov	r22, r17
    6f86:	70 e0       	ldi	r23, 0x00	; 0
    6f88:	0e 94 60 38 	call	0x70c0	; 0x70c0 <strchr_P>
    6f8c:	89 2b       	or	r24, r25
    6f8e:	09 f4       	brne	.+2      	; 0x6f92 <vfscanf+0xf4>
    6f90:	8f c0       	rjmp	.+286    	; 0x70b0 <vfscanf+0x212>
    6f92:	80 2f       	mov	r24, r16
    6f94:	00 ff       	sbrs	r16, 0
    6f96:	03 c0       	rjmp	.+6      	; 0x6f9e <vfscanf+0x100>
    6f98:	ee 24       	eor	r14, r14
    6f9a:	ff 24       	eor	r15, r15
    6f9c:	07 c0       	rjmp	.+14     	; 0x6fac <vfscanf+0x10e>
    6f9e:	f3 01       	movw	r30, r6
    6fa0:	e0 80       	ld	r14, Z
    6fa2:	f1 80       	ldd	r15, Z+1	; 0x01
    6fa4:	22 e0       	ldi	r18, 0x02	; 2
    6fa6:	30 e0       	ldi	r19, 0x00	; 0
    6fa8:	62 0e       	add	r6, r18
    6faa:	73 1e       	adc	r7, r19
    6fac:	1e 36       	cpi	r17, 0x6E	; 110
    6fae:	51 f4       	brne	.+20     	; 0x6fc4 <vfscanf+0x126>
    6fb0:	f5 01       	movw	r30, r10
    6fb2:	46 81       	ldd	r20, Z+6	; 0x06
    6fb4:	57 81       	ldd	r21, Z+7	; 0x07
    6fb6:	60 e0       	ldi	r22, 0x00	; 0
    6fb8:	70 e0       	ldi	r23, 0x00	; 0
    6fba:	c7 01       	movw	r24, r14
    6fbc:	20 2f       	mov	r18, r16
    6fbe:	0e 94 cb 35 	call	0x6b96	; 0x6b96 <putval>
    6fc2:	65 c0       	rjmp	.+202    	; 0x708e <vfscanf+0x1f0>
    6fc4:	13 36       	cpi	r17, 0x63	; 99
    6fc6:	91 f4       	brne	.+36     	; 0x6fec <vfscanf+0x14e>
    6fc8:	81 fd       	sbrc	r24, 1
    6fca:	02 c0       	rjmp	.+4      	; 0x6fd0 <vfscanf+0x132>
    6fcc:	99 24       	eor	r9, r9
    6fce:	93 94       	inc	r9
    6fd0:	c5 01       	movw	r24, r10
    6fd2:	0e 94 81 38 	call	0x7102	; 0x7102 <fgetc>
    6fd6:	97 fd       	sbrc	r25, 7
    6fd8:	66 c0       	rjmp	.+204    	; 0x70a6 <vfscanf+0x208>
    6fda:	e1 14       	cp	r14, r1
    6fdc:	f1 04       	cpc	r15, r1
    6fde:	19 f0       	breq	.+6      	; 0x6fe6 <vfscanf+0x148>
    6fe0:	f7 01       	movw	r30, r14
    6fe2:	81 93       	st	Z+, r24
    6fe4:	7f 01       	movw	r14, r30
    6fe6:	9a 94       	dec	r9
    6fe8:	99 f7       	brne	.-26     	; 0x6fd0 <vfscanf+0x132>
    6fea:	4f c0       	rjmp	.+158    	; 0x708a <vfscanf+0x1ec>
    6fec:	1b 35       	cpi	r17, 0x5B	; 91
    6fee:	59 f4       	brne	.+22     	; 0x7006 <vfscanf+0x168>
    6ff0:	c5 01       	movw	r24, r10
    6ff2:	69 2d       	mov	r22, r9
    6ff4:	a7 01       	movw	r20, r14
    6ff6:	96 01       	movw	r18, r12
    6ff8:	0e 94 a6 36 	call	0x6d4c	; 0x6d4c <conv_brk>
    6ffc:	6c 01       	movw	r12, r24
    6ffe:	00 97       	sbiw	r24, 0x00	; 0
    7000:	09 f0       	breq	.+2      	; 0x7004 <vfscanf+0x166>
    7002:	43 c0       	rjmp	.+134    	; 0x708a <vfscanf+0x1ec>
    7004:	3d c0       	rjmp	.+122    	; 0x7080 <vfscanf+0x1e2>
    7006:	c5 01       	movw	r24, r10
    7008:	0e 94 05 36 	call	0x6c0a	; 0x6c0a <skip_spaces>
    700c:	97 fd       	sbrc	r25, 7
    700e:	4b c0       	rjmp	.+150    	; 0x70a6 <vfscanf+0x208>
    7010:	1f 36       	cpi	r17, 0x6F	; 111
    7012:	59 f1       	breq	.+86     	; 0x706a <vfscanf+0x1cc>
    7014:	10 37       	cpi	r17, 0x70	; 112
    7016:	28 f4       	brcc	.+10     	; 0x7022 <vfscanf+0x184>
    7018:	14 36       	cpi	r17, 0x64	; 100
    701a:	29 f1       	breq	.+74     	; 0x7066 <vfscanf+0x1c8>
    701c:	19 36       	cpi	r17, 0x69	; 105
    701e:	39 f5       	brne	.+78     	; 0x706e <vfscanf+0x1d0>
    7020:	27 c0       	rjmp	.+78     	; 0x7070 <vfscanf+0x1d2>
    7022:	13 37       	cpi	r17, 0x73	; 115
    7024:	19 f0       	breq	.+6      	; 0x702c <vfscanf+0x18e>
    7026:	15 37       	cpi	r17, 0x75	; 117
    7028:	11 f5       	brne	.+68     	; 0x706e <vfscanf+0x1d0>
    702a:	1d c0       	rjmp	.+58     	; 0x7066 <vfscanf+0x1c8>
    702c:	c5 01       	movw	r24, r10
    702e:	0e 94 81 38 	call	0x7102	; 0x7102 <fgetc>
    7032:	ec 01       	movw	r28, r24
    7034:	97 fd       	sbrc	r25, 7
    7036:	11 c0       	rjmp	.+34     	; 0x705a <vfscanf+0x1bc>
    7038:	0e 94 cb 3b 	call	0x7796	; 0x7796 <isspace>
    703c:	89 2b       	or	r24, r25
    703e:	29 f0       	breq	.+10     	; 0x704a <vfscanf+0x1ac>
    7040:	ce 01       	movw	r24, r28
    7042:	b5 01       	movw	r22, r10
    7044:	0e 94 ef 38 	call	0x71de	; 0x71de <ungetc>
    7048:	08 c0       	rjmp	.+16     	; 0x705a <vfscanf+0x1bc>
    704a:	e1 14       	cp	r14, r1
    704c:	f1 04       	cpc	r15, r1
    704e:	19 f0       	breq	.+6      	; 0x7056 <vfscanf+0x1b8>
    7050:	f7 01       	movw	r30, r14
    7052:	c1 93       	st	Z+, r28
    7054:	7f 01       	movw	r14, r30
    7056:	9a 94       	dec	r9
    7058:	49 f7       	brne	.-46     	; 0x702c <vfscanf+0x18e>
    705a:	e1 14       	cp	r14, r1
    705c:	f1 04       	cpc	r15, r1
    705e:	a9 f0       	breq	.+42     	; 0x708a <vfscanf+0x1ec>
    7060:	f7 01       	movw	r30, r14
    7062:	10 82       	st	Z, r1
    7064:	12 c0       	rjmp	.+36     	; 0x708a <vfscanf+0x1ec>
    7066:	00 62       	ori	r16, 0x20	; 32
    7068:	03 c0       	rjmp	.+6      	; 0x7070 <vfscanf+0x1d2>
    706a:	00 61       	ori	r16, 0x10	; 16
    706c:	01 c0       	rjmp	.+2      	; 0x7070 <vfscanf+0x1d2>
    706e:	00 64       	ori	r16, 0x40	; 64
    7070:	c5 01       	movw	r24, r10
    7072:	69 2d       	mov	r22, r9
    7074:	a7 01       	movw	r20, r14
    7076:	20 2f       	mov	r18, r16
    7078:	0e 94 1e 36 	call	0x6c3c	; 0x6c3c <conv_int>
    707c:	88 23       	and	r24, r24
    707e:	29 f4       	brne	.+10     	; 0x708a <vfscanf+0x1ec>
    7080:	f5 01       	movw	r30, r10
    7082:	83 81       	ldd	r24, Z+3	; 0x03
    7084:	80 73       	andi	r24, 0x30	; 48
    7086:	79 f4       	brne	.+30     	; 0x70a6 <vfscanf+0x208>
    7088:	13 c0       	rjmp	.+38     	; 0x70b0 <vfscanf+0x212>
    708a:	00 ff       	sbrs	r16, 0
    708c:	83 94       	inc	r8
    708e:	f5 01       	movw	r30, r10
    7090:	f3 80       	ldd	r15, Z+3	; 0x03
    7092:	f6 01       	movw	r30, r12
    7094:	f3 fc       	sbrc	r15, 3
    7096:	15 91       	lpm	r17, Z+
    7098:	f3 fe       	sbrs	r15, 3
    709a:	11 91       	ld	r17, Z+
    709c:	6f 01       	movw	r12, r30
    709e:	11 23       	and	r17, r17
    70a0:	09 f0       	breq	.+2      	; 0x70a4 <vfscanf+0x206>
    70a2:	0b cf       	rjmp	.-490    	; 0x6eba <vfscanf+0x1c>
    70a4:	05 c0       	rjmp	.+10     	; 0x70b0 <vfscanf+0x212>
    70a6:	88 20       	and	r8, r8
    70a8:	19 f4       	brne	.+6      	; 0x70b0 <vfscanf+0x212>
    70aa:	2f ef       	ldi	r18, 0xFF	; 255
    70ac:	3f ef       	ldi	r19, 0xFF	; 255
    70ae:	02 c0       	rjmp	.+4      	; 0x70b4 <vfscanf+0x216>
    70b0:	28 2d       	mov	r18, r8
    70b2:	30 e0       	ldi	r19, 0x00	; 0
    70b4:	c9 01       	movw	r24, r18
    70b6:	cd b7       	in	r28, 0x3d	; 61
    70b8:	de b7       	in	r29, 0x3e	; 62
    70ba:	ee e0       	ldi	r30, 0x0E	; 14
    70bc:	0c 94 f6 3b 	jmp	0x77ec	; 0x77ec <__epilogue_restores__+0x8>

000070c0 <strchr_P>:
    70c0:	fc 01       	movw	r30, r24
    70c2:	05 90       	lpm	r0, Z+
    70c4:	06 16       	cp	r0, r22
    70c6:	21 f0       	breq	.+8      	; 0x70d0 <strchr_P+0x10>
    70c8:	00 20       	and	r0, r0
    70ca:	d9 f7       	brne	.-10     	; 0x70c2 <strchr_P+0x2>
    70cc:	c0 01       	movw	r24, r0
    70ce:	08 95       	ret
    70d0:	31 97       	sbiw	r30, 0x01	; 1
    70d2:	cf 01       	movw	r24, r30
    70d4:	08 95       	ret

000070d6 <strnlen_P>:
    70d6:	fc 01       	movw	r30, r24
    70d8:	05 90       	lpm	r0, Z+
    70da:	61 50       	subi	r22, 0x01	; 1
    70dc:	70 40       	sbci	r23, 0x00	; 0
    70de:	01 10       	cpse	r0, r1
    70e0:	d8 f7       	brcc	.-10     	; 0x70d8 <strnlen_P+0x2>
    70e2:	80 95       	com	r24
    70e4:	90 95       	com	r25
    70e6:	8e 0f       	add	r24, r30
    70e8:	9f 1f       	adc	r25, r31
    70ea:	08 95       	ret

000070ec <strnlen>:
    70ec:	fc 01       	movw	r30, r24
    70ee:	61 50       	subi	r22, 0x01	; 1
    70f0:	70 40       	sbci	r23, 0x00	; 0
    70f2:	01 90       	ld	r0, Z+
    70f4:	01 10       	cpse	r0, r1
    70f6:	d8 f7       	brcc	.-10     	; 0x70ee <strnlen+0x2>
    70f8:	80 95       	com	r24
    70fa:	90 95       	com	r25
    70fc:	8e 0f       	add	r24, r30
    70fe:	9f 1f       	adc	r25, r31
    7100:	08 95       	ret

00007102 <fgetc>:
    7102:	cf 93       	push	r28
    7104:	df 93       	push	r29
    7106:	ec 01       	movw	r28, r24
    7108:	4b 81       	ldd	r20, Y+3	; 0x03
    710a:	40 ff       	sbrs	r20, 0
    710c:	1a c0       	rjmp	.+52     	; 0x7142 <fgetc+0x40>
    710e:	46 ff       	sbrs	r20, 6
    7110:	0a c0       	rjmp	.+20     	; 0x7126 <fgetc+0x24>
    7112:	4f 7b       	andi	r20, 0xBF	; 191
    7114:	4b 83       	std	Y+3, r20	; 0x03
    7116:	8e 81       	ldd	r24, Y+6	; 0x06
    7118:	9f 81       	ldd	r25, Y+7	; 0x07
    711a:	01 96       	adiw	r24, 0x01	; 1
    711c:	9f 83       	std	Y+7, r25	; 0x07
    711e:	8e 83       	std	Y+6, r24	; 0x06
    7120:	8a 81       	ldd	r24, Y+2	; 0x02
    7122:	28 2f       	mov	r18, r24
    7124:	2b c0       	rjmp	.+86     	; 0x717c <fgetc+0x7a>
    7126:	42 ff       	sbrs	r20, 2
    7128:	13 c0       	rjmp	.+38     	; 0x7150 <fgetc+0x4e>
    712a:	e8 81       	ld	r30, Y
    712c:	f9 81       	ldd	r31, Y+1	; 0x01
    712e:	80 81       	ld	r24, Z
    7130:	28 2f       	mov	r18, r24
    7132:	33 27       	eor	r19, r19
    7134:	27 fd       	sbrc	r18, 7
    7136:	30 95       	com	r19
    7138:	21 15       	cp	r18, r1
    713a:	31 05       	cpc	r19, r1
    713c:	29 f4       	brne	.+10     	; 0x7148 <fgetc+0x46>
    713e:	40 62       	ori	r20, 0x20	; 32
    7140:	4b 83       	std	Y+3, r20	; 0x03
    7142:	2f ef       	ldi	r18, 0xFF	; 255
    7144:	3f ef       	ldi	r19, 0xFF	; 255
    7146:	1b c0       	rjmp	.+54     	; 0x717e <fgetc+0x7c>
    7148:	31 96       	adiw	r30, 0x01	; 1
    714a:	f9 83       	std	Y+1, r31	; 0x01
    714c:	e8 83       	st	Y, r30
    714e:	11 c0       	rjmp	.+34     	; 0x7172 <fgetc+0x70>
    7150:	ea 85       	ldd	r30, Y+10	; 0x0a
    7152:	fb 85       	ldd	r31, Y+11	; 0x0b
    7154:	ce 01       	movw	r24, r28
    7156:	09 95       	icall
    7158:	9c 01       	movw	r18, r24
    715a:	97 ff       	sbrs	r25, 7
    715c:	0a c0       	rjmp	.+20     	; 0x7172 <fgetc+0x70>
    715e:	9b 81       	ldd	r25, Y+3	; 0x03
    7160:	2f 5f       	subi	r18, 0xFF	; 255
    7162:	3f 4f       	sbci	r19, 0xFF	; 255
    7164:	11 f0       	breq	.+4      	; 0x716a <fgetc+0x68>
    7166:	80 e2       	ldi	r24, 0x20	; 32
    7168:	01 c0       	rjmp	.+2      	; 0x716c <fgetc+0x6a>
    716a:	80 e1       	ldi	r24, 0x10	; 16
    716c:	89 2b       	or	r24, r25
    716e:	8b 83       	std	Y+3, r24	; 0x03
    7170:	e8 cf       	rjmp	.-48     	; 0x7142 <fgetc+0x40>
    7172:	8e 81       	ldd	r24, Y+6	; 0x06
    7174:	9f 81       	ldd	r25, Y+7	; 0x07
    7176:	01 96       	adiw	r24, 0x01	; 1
    7178:	9f 83       	std	Y+7, r25	; 0x07
    717a:	8e 83       	std	Y+6, r24	; 0x06
    717c:	30 e0       	ldi	r19, 0x00	; 0
    717e:	c9 01       	movw	r24, r18
    7180:	df 91       	pop	r29
    7182:	cf 91       	pop	r28
    7184:	08 95       	ret

00007186 <fputc>:
    7186:	0f 93       	push	r16
    7188:	1f 93       	push	r17
    718a:	cf 93       	push	r28
    718c:	df 93       	push	r29
    718e:	8c 01       	movw	r16, r24
    7190:	eb 01       	movw	r28, r22
    7192:	8b 81       	ldd	r24, Y+3	; 0x03
    7194:	81 ff       	sbrs	r24, 1
    7196:	1b c0       	rjmp	.+54     	; 0x71ce <fputc+0x48>
    7198:	82 ff       	sbrs	r24, 2
    719a:	0d c0       	rjmp	.+26     	; 0x71b6 <fputc+0x30>
    719c:	2e 81       	ldd	r18, Y+6	; 0x06
    719e:	3f 81       	ldd	r19, Y+7	; 0x07
    71a0:	8c 81       	ldd	r24, Y+4	; 0x04
    71a2:	9d 81       	ldd	r25, Y+5	; 0x05
    71a4:	28 17       	cp	r18, r24
    71a6:	39 07       	cpc	r19, r25
    71a8:	64 f4       	brge	.+24     	; 0x71c2 <fputc+0x3c>
    71aa:	e8 81       	ld	r30, Y
    71ac:	f9 81       	ldd	r31, Y+1	; 0x01
    71ae:	01 93       	st	Z+, r16
    71b0:	f9 83       	std	Y+1, r31	; 0x01
    71b2:	e8 83       	st	Y, r30
    71b4:	06 c0       	rjmp	.+12     	; 0x71c2 <fputc+0x3c>
    71b6:	e8 85       	ldd	r30, Y+8	; 0x08
    71b8:	f9 85       	ldd	r31, Y+9	; 0x09
    71ba:	80 2f       	mov	r24, r16
    71bc:	09 95       	icall
    71be:	89 2b       	or	r24, r25
    71c0:	31 f4       	brne	.+12     	; 0x71ce <fputc+0x48>
    71c2:	8e 81       	ldd	r24, Y+6	; 0x06
    71c4:	9f 81       	ldd	r25, Y+7	; 0x07
    71c6:	01 96       	adiw	r24, 0x01	; 1
    71c8:	9f 83       	std	Y+7, r25	; 0x07
    71ca:	8e 83       	std	Y+6, r24	; 0x06
    71cc:	02 c0       	rjmp	.+4      	; 0x71d2 <fputc+0x4c>
    71ce:	0f ef       	ldi	r16, 0xFF	; 255
    71d0:	1f ef       	ldi	r17, 0xFF	; 255
    71d2:	c8 01       	movw	r24, r16
    71d4:	df 91       	pop	r29
    71d6:	cf 91       	pop	r28
    71d8:	1f 91       	pop	r17
    71da:	0f 91       	pop	r16
    71dc:	08 95       	ret

000071de <ungetc>:
    71de:	9c 01       	movw	r18, r24
    71e0:	fb 01       	movw	r30, r22
    71e2:	83 81       	ldd	r24, Z+3	; 0x03
    71e4:	80 ff       	sbrs	r24, 0
    71e6:	11 c0       	rjmp	.+34     	; 0x720a <ungetc+0x2c>
    71e8:	86 fd       	sbrc	r24, 6
    71ea:	0f c0       	rjmp	.+30     	; 0x720a <ungetc+0x2c>
    71ec:	9f ef       	ldi	r25, 0xFF	; 255
    71ee:	2f 3f       	cpi	r18, 0xFF	; 255
    71f0:	39 07       	cpc	r19, r25
    71f2:	59 f0       	breq	.+22     	; 0x720a <ungetc+0x2c>
    71f4:	22 83       	std	Z+2, r18	; 0x02
    71f6:	80 64       	ori	r24, 0x40	; 64
    71f8:	8f 7d       	andi	r24, 0xDF	; 223
    71fa:	83 83       	std	Z+3, r24	; 0x03
    71fc:	86 81       	ldd	r24, Z+6	; 0x06
    71fe:	97 81       	ldd	r25, Z+7	; 0x07
    7200:	01 97       	sbiw	r24, 0x01	; 1
    7202:	97 83       	std	Z+7, r25	; 0x07
    7204:	86 83       	std	Z+6, r24	; 0x06
    7206:	30 e0       	ldi	r19, 0x00	; 0
    7208:	02 c0       	rjmp	.+4      	; 0x720e <ungetc+0x30>
    720a:	2f ef       	ldi	r18, 0xFF	; 255
    720c:	3f ef       	ldi	r19, 0xFF	; 255
    720e:	c9 01       	movw	r24, r18
    7210:	08 95       	ret

00007212 <__ultoa_invert>:
    7212:	fa 01       	movw	r30, r20
    7214:	aa 27       	eor	r26, r26
    7216:	28 30       	cpi	r18, 0x08	; 8
    7218:	51 f1       	breq	.+84     	; 0x726e <__ultoa_invert+0x5c>
    721a:	20 31       	cpi	r18, 0x10	; 16
    721c:	81 f1       	breq	.+96     	; 0x727e <__ultoa_invert+0x6c>
    721e:	e8 94       	clt
    7220:	6f 93       	push	r22
    7222:	6e 7f       	andi	r22, 0xFE	; 254
    7224:	6e 5f       	subi	r22, 0xFE	; 254
    7226:	7f 4f       	sbci	r23, 0xFF	; 255
    7228:	8f 4f       	sbci	r24, 0xFF	; 255
    722a:	9f 4f       	sbci	r25, 0xFF	; 255
    722c:	af 4f       	sbci	r26, 0xFF	; 255
    722e:	b1 e0       	ldi	r27, 0x01	; 1
    7230:	3e d0       	rcall	.+124    	; 0x72ae <__ultoa_invert+0x9c>
    7232:	b4 e0       	ldi	r27, 0x04	; 4
    7234:	3c d0       	rcall	.+120    	; 0x72ae <__ultoa_invert+0x9c>
    7236:	67 0f       	add	r22, r23
    7238:	78 1f       	adc	r23, r24
    723a:	89 1f       	adc	r24, r25
    723c:	9a 1f       	adc	r25, r26
    723e:	a1 1d       	adc	r26, r1
    7240:	68 0f       	add	r22, r24
    7242:	79 1f       	adc	r23, r25
    7244:	8a 1f       	adc	r24, r26
    7246:	91 1d       	adc	r25, r1
    7248:	a1 1d       	adc	r26, r1
    724a:	6a 0f       	add	r22, r26
    724c:	71 1d       	adc	r23, r1
    724e:	81 1d       	adc	r24, r1
    7250:	91 1d       	adc	r25, r1
    7252:	a1 1d       	adc	r26, r1
    7254:	20 d0       	rcall	.+64     	; 0x7296 <__ultoa_invert+0x84>
    7256:	09 f4       	brne	.+2      	; 0x725a <__ultoa_invert+0x48>
    7258:	68 94       	set
    725a:	3f 91       	pop	r19
    725c:	2a e0       	ldi	r18, 0x0A	; 10
    725e:	26 9f       	mul	r18, r22
    7260:	11 24       	eor	r1, r1
    7262:	30 19       	sub	r19, r0
    7264:	30 5d       	subi	r19, 0xD0	; 208
    7266:	31 93       	st	Z+, r19
    7268:	de f6       	brtc	.-74     	; 0x7220 <__ultoa_invert+0xe>
    726a:	cf 01       	movw	r24, r30
    726c:	08 95       	ret
    726e:	46 2f       	mov	r20, r22
    7270:	47 70       	andi	r20, 0x07	; 7
    7272:	40 5d       	subi	r20, 0xD0	; 208
    7274:	41 93       	st	Z+, r20
    7276:	b3 e0       	ldi	r27, 0x03	; 3
    7278:	0f d0       	rcall	.+30     	; 0x7298 <__ultoa_invert+0x86>
    727a:	c9 f7       	brne	.-14     	; 0x726e <__ultoa_invert+0x5c>
    727c:	f6 cf       	rjmp	.-20     	; 0x726a <__ultoa_invert+0x58>
    727e:	46 2f       	mov	r20, r22
    7280:	4f 70       	andi	r20, 0x0F	; 15
    7282:	40 5d       	subi	r20, 0xD0	; 208
    7284:	4a 33       	cpi	r20, 0x3A	; 58
    7286:	18 f0       	brcs	.+6      	; 0x728e <__ultoa_invert+0x7c>
    7288:	49 5d       	subi	r20, 0xD9	; 217
    728a:	31 fd       	sbrc	r19, 1
    728c:	40 52       	subi	r20, 0x20	; 32
    728e:	41 93       	st	Z+, r20
    7290:	02 d0       	rcall	.+4      	; 0x7296 <__ultoa_invert+0x84>
    7292:	a9 f7       	brne	.-22     	; 0x727e <__ultoa_invert+0x6c>
    7294:	ea cf       	rjmp	.-44     	; 0x726a <__ultoa_invert+0x58>
    7296:	b4 e0       	ldi	r27, 0x04	; 4
    7298:	a6 95       	lsr	r26
    729a:	97 95       	ror	r25
    729c:	87 95       	ror	r24
    729e:	77 95       	ror	r23
    72a0:	67 95       	ror	r22
    72a2:	ba 95       	dec	r27
    72a4:	c9 f7       	brne	.-14     	; 0x7298 <__ultoa_invert+0x86>
    72a6:	00 97       	sbiw	r24, 0x00	; 0
    72a8:	61 05       	cpc	r22, r1
    72aa:	71 05       	cpc	r23, r1
    72ac:	08 95       	ret
    72ae:	9b 01       	movw	r18, r22
    72b0:	ac 01       	movw	r20, r24
    72b2:	0a 2e       	mov	r0, r26
    72b4:	06 94       	lsr	r0
    72b6:	57 95       	ror	r21
    72b8:	47 95       	ror	r20
    72ba:	37 95       	ror	r19
    72bc:	27 95       	ror	r18
    72be:	ba 95       	dec	r27
    72c0:	c9 f7       	brne	.-14     	; 0x72b4 <__ultoa_invert+0xa2>
    72c2:	62 0f       	add	r22, r18
    72c4:	73 1f       	adc	r23, r19
    72c6:	84 1f       	adc	r24, r20
    72c8:	95 1f       	adc	r25, r21
    72ca:	a0 1d       	adc	r26, r0
    72cc:	08 95       	ret

000072ce <__subsf3>:
    72ce:	50 58       	subi	r21, 0x80	; 128

000072d0 <__addsf3>:
    72d0:	bb 27       	eor	r27, r27
    72d2:	aa 27       	eor	r26, r26
    72d4:	0e d0       	rcall	.+28     	; 0x72f2 <__addsf3x>
    72d6:	75 c1       	rjmp	.+746    	; 0x75c2 <__fp_round>
    72d8:	66 d1       	rcall	.+716    	; 0x75a6 <__fp_pscA>
    72da:	30 f0       	brcs	.+12     	; 0x72e8 <__addsf3+0x18>
    72dc:	6b d1       	rcall	.+726    	; 0x75b4 <__fp_pscB>
    72de:	20 f0       	brcs	.+8      	; 0x72e8 <__addsf3+0x18>
    72e0:	31 f4       	brne	.+12     	; 0x72ee <__addsf3+0x1e>
    72e2:	9f 3f       	cpi	r25, 0xFF	; 255
    72e4:	11 f4       	brne	.+4      	; 0x72ea <__addsf3+0x1a>
    72e6:	1e f4       	brtc	.+6      	; 0x72ee <__addsf3+0x1e>
    72e8:	5b c1       	rjmp	.+694    	; 0x75a0 <__fp_nan>
    72ea:	0e f4       	brtc	.+2      	; 0x72ee <__addsf3+0x1e>
    72ec:	e0 95       	com	r30
    72ee:	e7 fb       	bst	r30, 7
    72f0:	51 c1       	rjmp	.+674    	; 0x7594 <__fp_inf>

000072f2 <__addsf3x>:
    72f2:	e9 2f       	mov	r30, r25
    72f4:	77 d1       	rcall	.+750    	; 0x75e4 <__fp_split3>
    72f6:	80 f3       	brcs	.-32     	; 0x72d8 <__addsf3+0x8>
    72f8:	ba 17       	cp	r27, r26
    72fa:	62 07       	cpc	r22, r18
    72fc:	73 07       	cpc	r23, r19
    72fe:	84 07       	cpc	r24, r20
    7300:	95 07       	cpc	r25, r21
    7302:	18 f0       	brcs	.+6      	; 0x730a <__addsf3x+0x18>
    7304:	71 f4       	brne	.+28     	; 0x7322 <__addsf3x+0x30>
    7306:	9e f5       	brtc	.+102    	; 0x736e <__addsf3x+0x7c>
    7308:	8f c1       	rjmp	.+798    	; 0x7628 <__fp_zero>
    730a:	0e f4       	brtc	.+2      	; 0x730e <__addsf3x+0x1c>
    730c:	e0 95       	com	r30
    730e:	0b 2e       	mov	r0, r27
    7310:	ba 2f       	mov	r27, r26
    7312:	a0 2d       	mov	r26, r0
    7314:	0b 01       	movw	r0, r22
    7316:	b9 01       	movw	r22, r18
    7318:	90 01       	movw	r18, r0
    731a:	0c 01       	movw	r0, r24
    731c:	ca 01       	movw	r24, r20
    731e:	a0 01       	movw	r20, r0
    7320:	11 24       	eor	r1, r1
    7322:	ff 27       	eor	r31, r31
    7324:	59 1b       	sub	r21, r25
    7326:	99 f0       	breq	.+38     	; 0x734e <__addsf3x+0x5c>
    7328:	59 3f       	cpi	r21, 0xF9	; 249
    732a:	50 f4       	brcc	.+20     	; 0x7340 <__addsf3x+0x4e>
    732c:	50 3e       	cpi	r21, 0xE0	; 224
    732e:	68 f1       	brcs	.+90     	; 0x738a <__addsf3x+0x98>
    7330:	1a 16       	cp	r1, r26
    7332:	f0 40       	sbci	r31, 0x00	; 0
    7334:	a2 2f       	mov	r26, r18
    7336:	23 2f       	mov	r18, r19
    7338:	34 2f       	mov	r19, r20
    733a:	44 27       	eor	r20, r20
    733c:	58 5f       	subi	r21, 0xF8	; 248
    733e:	f3 cf       	rjmp	.-26     	; 0x7326 <__addsf3x+0x34>
    7340:	46 95       	lsr	r20
    7342:	37 95       	ror	r19
    7344:	27 95       	ror	r18
    7346:	a7 95       	ror	r26
    7348:	f0 40       	sbci	r31, 0x00	; 0
    734a:	53 95       	inc	r21
    734c:	c9 f7       	brne	.-14     	; 0x7340 <__addsf3x+0x4e>
    734e:	7e f4       	brtc	.+30     	; 0x736e <__addsf3x+0x7c>
    7350:	1f 16       	cp	r1, r31
    7352:	ba 0b       	sbc	r27, r26
    7354:	62 0b       	sbc	r22, r18
    7356:	73 0b       	sbc	r23, r19
    7358:	84 0b       	sbc	r24, r20
    735a:	ba f0       	brmi	.+46     	; 0x738a <__addsf3x+0x98>
    735c:	91 50       	subi	r25, 0x01	; 1
    735e:	a1 f0       	breq	.+40     	; 0x7388 <__addsf3x+0x96>
    7360:	ff 0f       	add	r31, r31
    7362:	bb 1f       	adc	r27, r27
    7364:	66 1f       	adc	r22, r22
    7366:	77 1f       	adc	r23, r23
    7368:	88 1f       	adc	r24, r24
    736a:	c2 f7       	brpl	.-16     	; 0x735c <__addsf3x+0x6a>
    736c:	0e c0       	rjmp	.+28     	; 0x738a <__addsf3x+0x98>
    736e:	ba 0f       	add	r27, r26
    7370:	62 1f       	adc	r22, r18
    7372:	73 1f       	adc	r23, r19
    7374:	84 1f       	adc	r24, r20
    7376:	48 f4       	brcc	.+18     	; 0x738a <__addsf3x+0x98>
    7378:	87 95       	ror	r24
    737a:	77 95       	ror	r23
    737c:	67 95       	ror	r22
    737e:	b7 95       	ror	r27
    7380:	f7 95       	ror	r31
    7382:	9e 3f       	cpi	r25, 0xFE	; 254
    7384:	08 f0       	brcs	.+2      	; 0x7388 <__addsf3x+0x96>
    7386:	b3 cf       	rjmp	.-154    	; 0x72ee <__addsf3+0x1e>
    7388:	93 95       	inc	r25
    738a:	88 0f       	add	r24, r24
    738c:	08 f0       	brcs	.+2      	; 0x7390 <__addsf3x+0x9e>
    738e:	99 27       	eor	r25, r25
    7390:	ee 0f       	add	r30, r30
    7392:	97 95       	ror	r25
    7394:	87 95       	ror	r24
    7396:	08 95       	ret

00007398 <__cmpsf2>:
    7398:	d9 d0       	rcall	.+434    	; 0x754c <__fp_cmp>
    739a:	08 f4       	brcc	.+2      	; 0x739e <__cmpsf2+0x6>
    739c:	81 e0       	ldi	r24, 0x01	; 1
    739e:	08 95       	ret

000073a0 <__divsf3>:
    73a0:	0c d0       	rcall	.+24     	; 0x73ba <__divsf3x>
    73a2:	0f c1       	rjmp	.+542    	; 0x75c2 <__fp_round>
    73a4:	07 d1       	rcall	.+526    	; 0x75b4 <__fp_pscB>
    73a6:	40 f0       	brcs	.+16     	; 0x73b8 <__divsf3+0x18>
    73a8:	fe d0       	rcall	.+508    	; 0x75a6 <__fp_pscA>
    73aa:	30 f0       	brcs	.+12     	; 0x73b8 <__divsf3+0x18>
    73ac:	21 f4       	brne	.+8      	; 0x73b6 <__divsf3+0x16>
    73ae:	5f 3f       	cpi	r21, 0xFF	; 255
    73b0:	19 f0       	breq	.+6      	; 0x73b8 <__divsf3+0x18>
    73b2:	f0 c0       	rjmp	.+480    	; 0x7594 <__fp_inf>
    73b4:	51 11       	cpse	r21, r1
    73b6:	39 c1       	rjmp	.+626    	; 0x762a <__fp_szero>
    73b8:	f3 c0       	rjmp	.+486    	; 0x75a0 <__fp_nan>

000073ba <__divsf3x>:
    73ba:	14 d1       	rcall	.+552    	; 0x75e4 <__fp_split3>
    73bc:	98 f3       	brcs	.-26     	; 0x73a4 <__divsf3+0x4>

000073be <__divsf3_pse>:
    73be:	99 23       	and	r25, r25
    73c0:	c9 f3       	breq	.-14     	; 0x73b4 <__divsf3+0x14>
    73c2:	55 23       	and	r21, r21
    73c4:	b1 f3       	breq	.-20     	; 0x73b2 <__divsf3+0x12>
    73c6:	95 1b       	sub	r25, r21
    73c8:	55 0b       	sbc	r21, r21
    73ca:	bb 27       	eor	r27, r27
    73cc:	aa 27       	eor	r26, r26
    73ce:	62 17       	cp	r22, r18
    73d0:	73 07       	cpc	r23, r19
    73d2:	84 07       	cpc	r24, r20
    73d4:	38 f0       	brcs	.+14     	; 0x73e4 <__divsf3_pse+0x26>
    73d6:	9f 5f       	subi	r25, 0xFF	; 255
    73d8:	5f 4f       	sbci	r21, 0xFF	; 255
    73da:	22 0f       	add	r18, r18
    73dc:	33 1f       	adc	r19, r19
    73de:	44 1f       	adc	r20, r20
    73e0:	aa 1f       	adc	r26, r26
    73e2:	a9 f3       	breq	.-22     	; 0x73ce <__divsf3_pse+0x10>
    73e4:	33 d0       	rcall	.+102    	; 0x744c <__divsf3_pse+0x8e>
    73e6:	0e 2e       	mov	r0, r30
    73e8:	3a f0       	brmi	.+14     	; 0x73f8 <__divsf3_pse+0x3a>
    73ea:	e0 e8       	ldi	r30, 0x80	; 128
    73ec:	30 d0       	rcall	.+96     	; 0x744e <__divsf3_pse+0x90>
    73ee:	91 50       	subi	r25, 0x01	; 1
    73f0:	50 40       	sbci	r21, 0x00	; 0
    73f2:	e6 95       	lsr	r30
    73f4:	00 1c       	adc	r0, r0
    73f6:	ca f7       	brpl	.-14     	; 0x73ea <__divsf3_pse+0x2c>
    73f8:	29 d0       	rcall	.+82     	; 0x744c <__divsf3_pse+0x8e>
    73fa:	fe 2f       	mov	r31, r30
    73fc:	27 d0       	rcall	.+78     	; 0x744c <__divsf3_pse+0x8e>
    73fe:	66 0f       	add	r22, r22
    7400:	77 1f       	adc	r23, r23
    7402:	88 1f       	adc	r24, r24
    7404:	bb 1f       	adc	r27, r27
    7406:	26 17       	cp	r18, r22
    7408:	37 07       	cpc	r19, r23
    740a:	48 07       	cpc	r20, r24
    740c:	ab 07       	cpc	r26, r27
    740e:	b0 e8       	ldi	r27, 0x80	; 128
    7410:	09 f0       	breq	.+2      	; 0x7414 <__divsf3_pse+0x56>
    7412:	bb 0b       	sbc	r27, r27
    7414:	80 2d       	mov	r24, r0
    7416:	bf 01       	movw	r22, r30
    7418:	ff 27       	eor	r31, r31
    741a:	93 58       	subi	r25, 0x83	; 131
    741c:	5f 4f       	sbci	r21, 0xFF	; 255
    741e:	2a f0       	brmi	.+10     	; 0x742a <__divsf3_pse+0x6c>
    7420:	9e 3f       	cpi	r25, 0xFE	; 254
    7422:	51 05       	cpc	r21, r1
    7424:	68 f0       	brcs	.+26     	; 0x7440 <__divsf3_pse+0x82>
    7426:	b6 c0       	rjmp	.+364    	; 0x7594 <__fp_inf>
    7428:	00 c1       	rjmp	.+512    	; 0x762a <__fp_szero>
    742a:	5f 3f       	cpi	r21, 0xFF	; 255
    742c:	ec f3       	brlt	.-6      	; 0x7428 <__divsf3_pse+0x6a>
    742e:	98 3e       	cpi	r25, 0xE8	; 232
    7430:	dc f3       	brlt	.-10     	; 0x7428 <__divsf3_pse+0x6a>
    7432:	86 95       	lsr	r24
    7434:	77 95       	ror	r23
    7436:	67 95       	ror	r22
    7438:	b7 95       	ror	r27
    743a:	f7 95       	ror	r31
    743c:	9f 5f       	subi	r25, 0xFF	; 255
    743e:	c9 f7       	brne	.-14     	; 0x7432 <__divsf3_pse+0x74>
    7440:	88 0f       	add	r24, r24
    7442:	91 1d       	adc	r25, r1
    7444:	96 95       	lsr	r25
    7446:	87 95       	ror	r24
    7448:	97 f9       	bld	r25, 7
    744a:	08 95       	ret
    744c:	e1 e0       	ldi	r30, 0x01	; 1
    744e:	66 0f       	add	r22, r22
    7450:	77 1f       	adc	r23, r23
    7452:	88 1f       	adc	r24, r24
    7454:	bb 1f       	adc	r27, r27
    7456:	62 17       	cp	r22, r18
    7458:	73 07       	cpc	r23, r19
    745a:	84 07       	cpc	r24, r20
    745c:	ba 07       	cpc	r27, r26
    745e:	20 f0       	brcs	.+8      	; 0x7468 <__divsf3_pse+0xaa>
    7460:	62 1b       	sub	r22, r18
    7462:	73 0b       	sbc	r23, r19
    7464:	84 0b       	sbc	r24, r20
    7466:	ba 0b       	sbc	r27, r26
    7468:	ee 1f       	adc	r30, r30
    746a:	88 f7       	brcc	.-30     	; 0x744e <__divsf3_pse+0x90>
    746c:	e0 95       	com	r30
    746e:	08 95       	ret

00007470 <__fixsfsi>:
    7470:	04 d0       	rcall	.+8      	; 0x747a <__fixunssfsi>
    7472:	68 94       	set
    7474:	b1 11       	cpse	r27, r1
    7476:	d9 c0       	rjmp	.+434    	; 0x762a <__fp_szero>
    7478:	08 95       	ret

0000747a <__fixunssfsi>:
    747a:	bc d0       	rcall	.+376    	; 0x75f4 <__fp_splitA>
    747c:	88 f0       	brcs	.+34     	; 0x74a0 <__fixunssfsi+0x26>
    747e:	9f 57       	subi	r25, 0x7F	; 127
    7480:	90 f0       	brcs	.+36     	; 0x74a6 <__fixunssfsi+0x2c>
    7482:	b9 2f       	mov	r27, r25
    7484:	99 27       	eor	r25, r25
    7486:	b7 51       	subi	r27, 0x17	; 23
    7488:	a0 f0       	brcs	.+40     	; 0x74b2 <__fixunssfsi+0x38>
    748a:	d1 f0       	breq	.+52     	; 0x74c0 <__fixunssfsi+0x46>
    748c:	66 0f       	add	r22, r22
    748e:	77 1f       	adc	r23, r23
    7490:	88 1f       	adc	r24, r24
    7492:	99 1f       	adc	r25, r25
    7494:	1a f0       	brmi	.+6      	; 0x749c <__fixunssfsi+0x22>
    7496:	ba 95       	dec	r27
    7498:	c9 f7       	brne	.-14     	; 0x748c <__fixunssfsi+0x12>
    749a:	12 c0       	rjmp	.+36     	; 0x74c0 <__fixunssfsi+0x46>
    749c:	b1 30       	cpi	r27, 0x01	; 1
    749e:	81 f0       	breq	.+32     	; 0x74c0 <__fixunssfsi+0x46>
    74a0:	c3 d0       	rcall	.+390    	; 0x7628 <__fp_zero>
    74a2:	b1 e0       	ldi	r27, 0x01	; 1
    74a4:	08 95       	ret
    74a6:	c0 c0       	rjmp	.+384    	; 0x7628 <__fp_zero>
    74a8:	67 2f       	mov	r22, r23
    74aa:	78 2f       	mov	r23, r24
    74ac:	88 27       	eor	r24, r24
    74ae:	b8 5f       	subi	r27, 0xF8	; 248
    74b0:	39 f0       	breq	.+14     	; 0x74c0 <__fixunssfsi+0x46>
    74b2:	b9 3f       	cpi	r27, 0xF9	; 249
    74b4:	cc f3       	brlt	.-14     	; 0x74a8 <__fixunssfsi+0x2e>
    74b6:	86 95       	lsr	r24
    74b8:	77 95       	ror	r23
    74ba:	67 95       	ror	r22
    74bc:	b3 95       	inc	r27
    74be:	d9 f7       	brne	.-10     	; 0x74b6 <__fixunssfsi+0x3c>
    74c0:	3e f4       	brtc	.+14     	; 0x74d0 <__fixunssfsi+0x56>
    74c2:	90 95       	com	r25
    74c4:	80 95       	com	r24
    74c6:	70 95       	com	r23
    74c8:	61 95       	neg	r22
    74ca:	7f 4f       	sbci	r23, 0xFF	; 255
    74cc:	8f 4f       	sbci	r24, 0xFF	; 255
    74ce:	9f 4f       	sbci	r25, 0xFF	; 255
    74d0:	08 95       	ret

000074d2 <__floatunsisf>:
    74d2:	e8 94       	clt
    74d4:	09 c0       	rjmp	.+18     	; 0x74e8 <__floatsisf+0x12>

000074d6 <__floatsisf>:
    74d6:	97 fb       	bst	r25, 7
    74d8:	3e f4       	brtc	.+14     	; 0x74e8 <__floatsisf+0x12>
    74da:	90 95       	com	r25
    74dc:	80 95       	com	r24
    74de:	70 95       	com	r23
    74e0:	61 95       	neg	r22
    74e2:	7f 4f       	sbci	r23, 0xFF	; 255
    74e4:	8f 4f       	sbci	r24, 0xFF	; 255
    74e6:	9f 4f       	sbci	r25, 0xFF	; 255
    74e8:	99 23       	and	r25, r25
    74ea:	a9 f0       	breq	.+42     	; 0x7516 <__floatsisf+0x40>
    74ec:	f9 2f       	mov	r31, r25
    74ee:	96 e9       	ldi	r25, 0x96	; 150
    74f0:	bb 27       	eor	r27, r27
    74f2:	93 95       	inc	r25
    74f4:	f6 95       	lsr	r31
    74f6:	87 95       	ror	r24
    74f8:	77 95       	ror	r23
    74fa:	67 95       	ror	r22
    74fc:	b7 95       	ror	r27
    74fe:	f1 11       	cpse	r31, r1
    7500:	f8 cf       	rjmp	.-16     	; 0x74f2 <__floatsisf+0x1c>
    7502:	fa f4       	brpl	.+62     	; 0x7542 <__floatsisf+0x6c>
    7504:	bb 0f       	add	r27, r27
    7506:	11 f4       	brne	.+4      	; 0x750c <__floatsisf+0x36>
    7508:	60 ff       	sbrs	r22, 0
    750a:	1b c0       	rjmp	.+54     	; 0x7542 <__floatsisf+0x6c>
    750c:	6f 5f       	subi	r22, 0xFF	; 255
    750e:	7f 4f       	sbci	r23, 0xFF	; 255
    7510:	8f 4f       	sbci	r24, 0xFF	; 255
    7512:	9f 4f       	sbci	r25, 0xFF	; 255
    7514:	16 c0       	rjmp	.+44     	; 0x7542 <__floatsisf+0x6c>
    7516:	88 23       	and	r24, r24
    7518:	11 f0       	breq	.+4      	; 0x751e <__floatsisf+0x48>
    751a:	96 e9       	ldi	r25, 0x96	; 150
    751c:	11 c0       	rjmp	.+34     	; 0x7540 <__floatsisf+0x6a>
    751e:	77 23       	and	r23, r23
    7520:	21 f0       	breq	.+8      	; 0x752a <__floatsisf+0x54>
    7522:	9e e8       	ldi	r25, 0x8E	; 142
    7524:	87 2f       	mov	r24, r23
    7526:	76 2f       	mov	r23, r22
    7528:	05 c0       	rjmp	.+10     	; 0x7534 <__floatsisf+0x5e>
    752a:	66 23       	and	r22, r22
    752c:	71 f0       	breq	.+28     	; 0x754a <__floatsisf+0x74>
    752e:	96 e8       	ldi	r25, 0x86	; 134
    7530:	86 2f       	mov	r24, r22
    7532:	70 e0       	ldi	r23, 0x00	; 0
    7534:	60 e0       	ldi	r22, 0x00	; 0
    7536:	2a f0       	brmi	.+10     	; 0x7542 <__floatsisf+0x6c>
    7538:	9a 95       	dec	r25
    753a:	66 0f       	add	r22, r22
    753c:	77 1f       	adc	r23, r23
    753e:	88 1f       	adc	r24, r24
    7540:	da f7       	brpl	.-10     	; 0x7538 <__floatsisf+0x62>
    7542:	88 0f       	add	r24, r24
    7544:	96 95       	lsr	r25
    7546:	87 95       	ror	r24
    7548:	97 f9       	bld	r25, 7
    754a:	08 95       	ret

0000754c <__fp_cmp>:
    754c:	99 0f       	add	r25, r25
    754e:	00 08       	sbc	r0, r0
    7550:	55 0f       	add	r21, r21
    7552:	aa 0b       	sbc	r26, r26
    7554:	e0 e8       	ldi	r30, 0x80	; 128
    7556:	fe ef       	ldi	r31, 0xFE	; 254
    7558:	16 16       	cp	r1, r22
    755a:	17 06       	cpc	r1, r23
    755c:	e8 07       	cpc	r30, r24
    755e:	f9 07       	cpc	r31, r25
    7560:	c0 f0       	brcs	.+48     	; 0x7592 <__fp_cmp+0x46>
    7562:	12 16       	cp	r1, r18
    7564:	13 06       	cpc	r1, r19
    7566:	e4 07       	cpc	r30, r20
    7568:	f5 07       	cpc	r31, r21
    756a:	98 f0       	brcs	.+38     	; 0x7592 <__fp_cmp+0x46>
    756c:	62 1b       	sub	r22, r18
    756e:	73 0b       	sbc	r23, r19
    7570:	84 0b       	sbc	r24, r20
    7572:	95 0b       	sbc	r25, r21
    7574:	39 f4       	brne	.+14     	; 0x7584 <__fp_cmp+0x38>
    7576:	0a 26       	eor	r0, r26
    7578:	61 f0       	breq	.+24     	; 0x7592 <__fp_cmp+0x46>
    757a:	23 2b       	or	r18, r19
    757c:	24 2b       	or	r18, r20
    757e:	25 2b       	or	r18, r21
    7580:	21 f4       	brne	.+8      	; 0x758a <__fp_cmp+0x3e>
    7582:	08 95       	ret
    7584:	0a 26       	eor	r0, r26
    7586:	09 f4       	brne	.+2      	; 0x758a <__fp_cmp+0x3e>
    7588:	a1 40       	sbci	r26, 0x01	; 1
    758a:	a6 95       	lsr	r26
    758c:	8f ef       	ldi	r24, 0xFF	; 255
    758e:	81 1d       	adc	r24, r1
    7590:	81 1d       	adc	r24, r1
    7592:	08 95       	ret

00007594 <__fp_inf>:
    7594:	97 f9       	bld	r25, 7
    7596:	9f 67       	ori	r25, 0x7F	; 127
    7598:	80 e8       	ldi	r24, 0x80	; 128
    759a:	70 e0       	ldi	r23, 0x00	; 0
    759c:	60 e0       	ldi	r22, 0x00	; 0
    759e:	08 95       	ret

000075a0 <__fp_nan>:
    75a0:	9f ef       	ldi	r25, 0xFF	; 255
    75a2:	80 ec       	ldi	r24, 0xC0	; 192
    75a4:	08 95       	ret

000075a6 <__fp_pscA>:
    75a6:	00 24       	eor	r0, r0
    75a8:	0a 94       	dec	r0
    75aa:	16 16       	cp	r1, r22
    75ac:	17 06       	cpc	r1, r23
    75ae:	18 06       	cpc	r1, r24
    75b0:	09 06       	cpc	r0, r25
    75b2:	08 95       	ret

000075b4 <__fp_pscB>:
    75b4:	00 24       	eor	r0, r0
    75b6:	0a 94       	dec	r0
    75b8:	12 16       	cp	r1, r18
    75ba:	13 06       	cpc	r1, r19
    75bc:	14 06       	cpc	r1, r20
    75be:	05 06       	cpc	r0, r21
    75c0:	08 95       	ret

000075c2 <__fp_round>:
    75c2:	09 2e       	mov	r0, r25
    75c4:	03 94       	inc	r0
    75c6:	00 0c       	add	r0, r0
    75c8:	11 f4       	brne	.+4      	; 0x75ce <__fp_round+0xc>
    75ca:	88 23       	and	r24, r24
    75cc:	52 f0       	brmi	.+20     	; 0x75e2 <__fp_round+0x20>
    75ce:	bb 0f       	add	r27, r27
    75d0:	40 f4       	brcc	.+16     	; 0x75e2 <__fp_round+0x20>
    75d2:	bf 2b       	or	r27, r31
    75d4:	11 f4       	brne	.+4      	; 0x75da <__fp_round+0x18>
    75d6:	60 ff       	sbrs	r22, 0
    75d8:	04 c0       	rjmp	.+8      	; 0x75e2 <__fp_round+0x20>
    75da:	6f 5f       	subi	r22, 0xFF	; 255
    75dc:	7f 4f       	sbci	r23, 0xFF	; 255
    75de:	8f 4f       	sbci	r24, 0xFF	; 255
    75e0:	9f 4f       	sbci	r25, 0xFF	; 255
    75e2:	08 95       	ret

000075e4 <__fp_split3>:
    75e4:	57 fd       	sbrc	r21, 7
    75e6:	90 58       	subi	r25, 0x80	; 128
    75e8:	44 0f       	add	r20, r20
    75ea:	55 1f       	adc	r21, r21
    75ec:	59 f0       	breq	.+22     	; 0x7604 <__fp_splitA+0x10>
    75ee:	5f 3f       	cpi	r21, 0xFF	; 255
    75f0:	71 f0       	breq	.+28     	; 0x760e <__fp_splitA+0x1a>
    75f2:	47 95       	ror	r20

000075f4 <__fp_splitA>:
    75f4:	88 0f       	add	r24, r24
    75f6:	97 fb       	bst	r25, 7
    75f8:	99 1f       	adc	r25, r25
    75fa:	61 f0       	breq	.+24     	; 0x7614 <__fp_splitA+0x20>
    75fc:	9f 3f       	cpi	r25, 0xFF	; 255
    75fe:	79 f0       	breq	.+30     	; 0x761e <__fp_splitA+0x2a>
    7600:	87 95       	ror	r24
    7602:	08 95       	ret
    7604:	12 16       	cp	r1, r18
    7606:	13 06       	cpc	r1, r19
    7608:	14 06       	cpc	r1, r20
    760a:	55 1f       	adc	r21, r21
    760c:	f2 cf       	rjmp	.-28     	; 0x75f2 <__fp_split3+0xe>
    760e:	46 95       	lsr	r20
    7610:	f1 df       	rcall	.-30     	; 0x75f4 <__fp_splitA>
    7612:	08 c0       	rjmp	.+16     	; 0x7624 <__fp_splitA+0x30>
    7614:	16 16       	cp	r1, r22
    7616:	17 06       	cpc	r1, r23
    7618:	18 06       	cpc	r1, r24
    761a:	99 1f       	adc	r25, r25
    761c:	f1 cf       	rjmp	.-30     	; 0x7600 <__fp_splitA+0xc>
    761e:	86 95       	lsr	r24
    7620:	71 05       	cpc	r23, r1
    7622:	61 05       	cpc	r22, r1
    7624:	08 94       	sec
    7626:	08 95       	ret

00007628 <__fp_zero>:
    7628:	e8 94       	clt

0000762a <__fp_szero>:
    762a:	bb 27       	eor	r27, r27
    762c:	66 27       	eor	r22, r22
    762e:	77 27       	eor	r23, r23
    7630:	cb 01       	movw	r24, r22
    7632:	97 f9       	bld	r25, 7
    7634:	08 95       	ret

00007636 <__gesf2>:
    7636:	8a df       	rcall	.-236    	; 0x754c <__fp_cmp>
    7638:	08 f4       	brcc	.+2      	; 0x763c <__gesf2+0x6>
    763a:	8f ef       	ldi	r24, 0xFF	; 255
    763c:	08 95       	ret

0000763e <__mulsf3>:
    763e:	0b d0       	rcall	.+22     	; 0x7656 <__mulsf3x>
    7640:	c0 cf       	rjmp	.-128    	; 0x75c2 <__fp_round>
    7642:	b1 df       	rcall	.-158    	; 0x75a6 <__fp_pscA>
    7644:	28 f0       	brcs	.+10     	; 0x7650 <__mulsf3+0x12>
    7646:	b6 df       	rcall	.-148    	; 0x75b4 <__fp_pscB>
    7648:	18 f0       	brcs	.+6      	; 0x7650 <__mulsf3+0x12>
    764a:	95 23       	and	r25, r21
    764c:	09 f0       	breq	.+2      	; 0x7650 <__mulsf3+0x12>
    764e:	a2 cf       	rjmp	.-188    	; 0x7594 <__fp_inf>
    7650:	a7 cf       	rjmp	.-178    	; 0x75a0 <__fp_nan>
    7652:	11 24       	eor	r1, r1
    7654:	ea cf       	rjmp	.-44     	; 0x762a <__fp_szero>

00007656 <__mulsf3x>:
    7656:	c6 df       	rcall	.-116    	; 0x75e4 <__fp_split3>
    7658:	a0 f3       	brcs	.-24     	; 0x7642 <__mulsf3+0x4>

0000765a <__mulsf3_pse>:
    765a:	95 9f       	mul	r25, r21
    765c:	d1 f3       	breq	.-12     	; 0x7652 <__mulsf3+0x14>
    765e:	95 0f       	add	r25, r21
    7660:	50 e0       	ldi	r21, 0x00	; 0
    7662:	55 1f       	adc	r21, r21
    7664:	62 9f       	mul	r22, r18
    7666:	f0 01       	movw	r30, r0
    7668:	72 9f       	mul	r23, r18
    766a:	bb 27       	eor	r27, r27
    766c:	f0 0d       	add	r31, r0
    766e:	b1 1d       	adc	r27, r1
    7670:	63 9f       	mul	r22, r19
    7672:	aa 27       	eor	r26, r26
    7674:	f0 0d       	add	r31, r0
    7676:	b1 1d       	adc	r27, r1
    7678:	aa 1f       	adc	r26, r26
    767a:	64 9f       	mul	r22, r20
    767c:	66 27       	eor	r22, r22
    767e:	b0 0d       	add	r27, r0
    7680:	a1 1d       	adc	r26, r1
    7682:	66 1f       	adc	r22, r22
    7684:	82 9f       	mul	r24, r18
    7686:	22 27       	eor	r18, r18
    7688:	b0 0d       	add	r27, r0
    768a:	a1 1d       	adc	r26, r1
    768c:	62 1f       	adc	r22, r18
    768e:	73 9f       	mul	r23, r19
    7690:	b0 0d       	add	r27, r0
    7692:	a1 1d       	adc	r26, r1
    7694:	62 1f       	adc	r22, r18
    7696:	83 9f       	mul	r24, r19
    7698:	a0 0d       	add	r26, r0
    769a:	61 1d       	adc	r22, r1
    769c:	22 1f       	adc	r18, r18
    769e:	74 9f       	mul	r23, r20
    76a0:	33 27       	eor	r19, r19
    76a2:	a0 0d       	add	r26, r0
    76a4:	61 1d       	adc	r22, r1
    76a6:	23 1f       	adc	r18, r19
    76a8:	84 9f       	mul	r24, r20
    76aa:	60 0d       	add	r22, r0
    76ac:	21 1d       	adc	r18, r1
    76ae:	82 2f       	mov	r24, r18
    76b0:	76 2f       	mov	r23, r22
    76b2:	6a 2f       	mov	r22, r26
    76b4:	11 24       	eor	r1, r1
    76b6:	9f 57       	subi	r25, 0x7F	; 127
    76b8:	50 40       	sbci	r21, 0x00	; 0
    76ba:	8a f0       	brmi	.+34     	; 0x76de <__mulsf3_pse+0x84>
    76bc:	e1 f0       	breq	.+56     	; 0x76f6 <__mulsf3_pse+0x9c>
    76be:	88 23       	and	r24, r24
    76c0:	4a f0       	brmi	.+18     	; 0x76d4 <__mulsf3_pse+0x7a>
    76c2:	ee 0f       	add	r30, r30
    76c4:	ff 1f       	adc	r31, r31
    76c6:	bb 1f       	adc	r27, r27
    76c8:	66 1f       	adc	r22, r22
    76ca:	77 1f       	adc	r23, r23
    76cc:	88 1f       	adc	r24, r24
    76ce:	91 50       	subi	r25, 0x01	; 1
    76d0:	50 40       	sbci	r21, 0x00	; 0
    76d2:	a9 f7       	brne	.-22     	; 0x76be <__mulsf3_pse+0x64>
    76d4:	9e 3f       	cpi	r25, 0xFE	; 254
    76d6:	51 05       	cpc	r21, r1
    76d8:	70 f0       	brcs	.+28     	; 0x76f6 <__mulsf3_pse+0x9c>
    76da:	5c cf       	rjmp	.-328    	; 0x7594 <__fp_inf>
    76dc:	a6 cf       	rjmp	.-180    	; 0x762a <__fp_szero>
    76de:	5f 3f       	cpi	r21, 0xFF	; 255
    76e0:	ec f3       	brlt	.-6      	; 0x76dc <__mulsf3_pse+0x82>
    76e2:	98 3e       	cpi	r25, 0xE8	; 232
    76e4:	dc f3       	brlt	.-10     	; 0x76dc <__mulsf3_pse+0x82>
    76e6:	86 95       	lsr	r24
    76e8:	77 95       	ror	r23
    76ea:	67 95       	ror	r22
    76ec:	b7 95       	ror	r27
    76ee:	f7 95       	ror	r31
    76f0:	e7 95       	ror	r30
    76f2:	9f 5f       	subi	r25, 0xFF	; 255
    76f4:	c1 f7       	brne	.-16     	; 0x76e6 <__mulsf3_pse+0x8c>
    76f6:	fe 2b       	or	r31, r30
    76f8:	88 0f       	add	r24, r24
    76fa:	91 1d       	adc	r25, r1
    76fc:	96 95       	lsr	r25
    76fe:	87 95       	ror	r24
    7700:	97 f9       	bld	r25, 7
    7702:	08 95       	ret

00007704 <__udivmodhi4>:
    7704:	aa 1b       	sub	r26, r26
    7706:	bb 1b       	sub	r27, r27
    7708:	51 e1       	ldi	r21, 0x11	; 17
    770a:	07 c0       	rjmp	.+14     	; 0x771a <__udivmodhi4_ep>

0000770c <__udivmodhi4_loop>:
    770c:	aa 1f       	adc	r26, r26
    770e:	bb 1f       	adc	r27, r27
    7710:	a6 17       	cp	r26, r22
    7712:	b7 07       	cpc	r27, r23
    7714:	10 f0       	brcs	.+4      	; 0x771a <__udivmodhi4_ep>
    7716:	a6 1b       	sub	r26, r22
    7718:	b7 0b       	sbc	r27, r23

0000771a <__udivmodhi4_ep>:
    771a:	88 1f       	adc	r24, r24
    771c:	99 1f       	adc	r25, r25
    771e:	5a 95       	dec	r21
    7720:	a9 f7       	brne	.-22     	; 0x770c <__udivmodhi4_loop>
    7722:	80 95       	com	r24
    7724:	90 95       	com	r25
    7726:	bc 01       	movw	r22, r24
    7728:	cd 01       	movw	r24, r26
    772a:	08 95       	ret

0000772c <__divmodhi4>:
    772c:	97 fb       	bst	r25, 7
    772e:	09 2e       	mov	r0, r25
    7730:	07 26       	eor	r0, r23
    7732:	0a d0       	rcall	.+20     	; 0x7748 <__divmodhi4_neg1>
    7734:	77 fd       	sbrc	r23, 7
    7736:	04 d0       	rcall	.+8      	; 0x7740 <__divmodhi4_neg2>
    7738:	e5 df       	rcall	.-54     	; 0x7704 <__udivmodhi4>
    773a:	06 d0       	rcall	.+12     	; 0x7748 <__divmodhi4_neg1>
    773c:	00 20       	and	r0, r0
    773e:	1a f4       	brpl	.+6      	; 0x7746 <__divmodhi4_exit>

00007740 <__divmodhi4_neg2>:
    7740:	70 95       	com	r23
    7742:	61 95       	neg	r22
    7744:	7f 4f       	sbci	r23, 0xFF	; 255

00007746 <__divmodhi4_exit>:
    7746:	08 95       	ret

00007748 <__divmodhi4_neg1>:
    7748:	f6 f7       	brtc	.-4      	; 0x7746 <__divmodhi4_exit>
    774a:	90 95       	com	r25
    774c:	81 95       	neg	r24
    774e:	9f 4f       	sbci	r25, 0xFF	; 255
    7750:	08 95       	ret

00007752 <__udivmodsi4>:
    7752:	a1 e2       	ldi	r26, 0x21	; 33
    7754:	1a 2e       	mov	r1, r26
    7756:	aa 1b       	sub	r26, r26
    7758:	bb 1b       	sub	r27, r27
    775a:	fd 01       	movw	r30, r26
    775c:	0d c0       	rjmp	.+26     	; 0x7778 <__udivmodsi4_ep>

0000775e <__udivmodsi4_loop>:
    775e:	aa 1f       	adc	r26, r26
    7760:	bb 1f       	adc	r27, r27
    7762:	ee 1f       	adc	r30, r30
    7764:	ff 1f       	adc	r31, r31
    7766:	a2 17       	cp	r26, r18
    7768:	b3 07       	cpc	r27, r19
    776a:	e4 07       	cpc	r30, r20
    776c:	f5 07       	cpc	r31, r21
    776e:	20 f0       	brcs	.+8      	; 0x7778 <__udivmodsi4_ep>
    7770:	a2 1b       	sub	r26, r18
    7772:	b3 0b       	sbc	r27, r19
    7774:	e4 0b       	sbc	r30, r20
    7776:	f5 0b       	sbc	r31, r21

00007778 <__udivmodsi4_ep>:
    7778:	66 1f       	adc	r22, r22
    777a:	77 1f       	adc	r23, r23
    777c:	88 1f       	adc	r24, r24
    777e:	99 1f       	adc	r25, r25
    7780:	1a 94       	dec	r1
    7782:	69 f7       	brne	.-38     	; 0x775e <__udivmodsi4_loop>
    7784:	60 95       	com	r22
    7786:	70 95       	com	r23
    7788:	80 95       	com	r24
    778a:	90 95       	com	r25
    778c:	9b 01       	movw	r18, r22
    778e:	ac 01       	movw	r20, r24
    7790:	bd 01       	movw	r22, r26
    7792:	cf 01       	movw	r24, r30
    7794:	08 95       	ret

00007796 <isspace>:
    7796:	91 11       	cpse	r25, r1
    7798:	06 c0       	rjmp	.+12     	; 0x77a6 <__ctype_isfalse>
    779a:	80 32       	cpi	r24, 0x20	; 32
    779c:	19 f0       	breq	.+6      	; 0x77a4 <isspace+0xe>
    779e:	89 50       	subi	r24, 0x09	; 9
    77a0:	85 50       	subi	r24, 0x05	; 5
    77a2:	d0 f7       	brcc	.-12     	; 0x7798 <isspace+0x2>
    77a4:	08 95       	ret

000077a6 <__ctype_isfalse>:
    77a6:	99 27       	eor	r25, r25
    77a8:	88 27       	eor	r24, r24

000077aa <__ctype_istrue>:
    77aa:	08 95       	ret

000077ac <__prologue_saves__>:
    77ac:	2f 92       	push	r2
    77ae:	3f 92       	push	r3
    77b0:	4f 92       	push	r4
    77b2:	5f 92       	push	r5
    77b4:	6f 92       	push	r6
    77b6:	7f 92       	push	r7
    77b8:	8f 92       	push	r8
    77ba:	9f 92       	push	r9
    77bc:	af 92       	push	r10
    77be:	bf 92       	push	r11
    77c0:	cf 92       	push	r12
    77c2:	df 92       	push	r13
    77c4:	ef 92       	push	r14
    77c6:	ff 92       	push	r15
    77c8:	0f 93       	push	r16
    77ca:	1f 93       	push	r17
    77cc:	cf 93       	push	r28
    77ce:	df 93       	push	r29
    77d0:	cd b7       	in	r28, 0x3d	; 61
    77d2:	de b7       	in	r29, 0x3e	; 62
    77d4:	ca 1b       	sub	r28, r26
    77d6:	db 0b       	sbc	r29, r27
    77d8:	0f b6       	in	r0, 0x3f	; 63
    77da:	f8 94       	cli
    77dc:	de bf       	out	0x3e, r29	; 62
    77de:	0f be       	out	0x3f, r0	; 63
    77e0:	cd bf       	out	0x3d, r28	; 61
    77e2:	09 94       	ijmp

000077e4 <__epilogue_restores__>:
    77e4:	2a 88       	ldd	r2, Y+18	; 0x12
    77e6:	39 88       	ldd	r3, Y+17	; 0x11
    77e8:	48 88       	ldd	r4, Y+16	; 0x10
    77ea:	5f 84       	ldd	r5, Y+15	; 0x0f
    77ec:	6e 84       	ldd	r6, Y+14	; 0x0e
    77ee:	7d 84       	ldd	r7, Y+13	; 0x0d
    77f0:	8c 84       	ldd	r8, Y+12	; 0x0c
    77f2:	9b 84       	ldd	r9, Y+11	; 0x0b
    77f4:	aa 84       	ldd	r10, Y+10	; 0x0a
    77f6:	b9 84       	ldd	r11, Y+9	; 0x09
    77f8:	c8 84       	ldd	r12, Y+8	; 0x08
    77fa:	df 80       	ldd	r13, Y+7	; 0x07
    77fc:	ee 80       	ldd	r14, Y+6	; 0x06
    77fe:	fd 80       	ldd	r15, Y+5	; 0x05
    7800:	0c 81       	ldd	r16, Y+4	; 0x04
    7802:	1b 81       	ldd	r17, Y+3	; 0x03
    7804:	aa 81       	ldd	r26, Y+2	; 0x02
    7806:	b9 81       	ldd	r27, Y+1	; 0x01
    7808:	ce 0f       	add	r28, r30
    780a:	d1 1d       	adc	r29, r1
    780c:	0f b6       	in	r0, 0x3f	; 63
    780e:	f8 94       	cli
    7810:	de bf       	out	0x3e, r29	; 62
    7812:	0f be       	out	0x3f, r0	; 63
    7814:	cd bf       	out	0x3d, r28	; 61
    7816:	ed 01       	movw	r28, r26
    7818:	08 95       	ret

0000781a <_exit>:
    781a:	f8 94       	cli

0000781c <__stop_program>:
    781c:	ff cf       	rjmp	.-2      	; 0x781c <__stop_program>
