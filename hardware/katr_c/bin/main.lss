
main.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000fe4  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000034  00800060  00000fe4  00001078  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          000000fc  00800094  00800094  000010ac  2**0
                  ALLOC
  3 .stab         00000378  00000000  00000000  000010ac  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      00000071  00000000  00000000  00001424  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_aranges 000000c0  00000000  00000000  00001495  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_pubnames 00000555  00000000  00000000  00001555  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_info   000010d1  00000000  00000000  00001aaa  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 000006ca  00000000  00000000  00002b7b  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   00000e3b  00000000  00000000  00003245  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_frame  00000280  00000000  00000000  00004080  2**2
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_str    000004e7  00000000  00000000  00004300  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_loc    000004d3  00000000  00000000  000047e7  2**0
                  CONTENTS, READONLY, DEBUGGING
Disassembly of section .text:

00000000 <__vectors>:
   0:	12 c0       	rjmp	.+36     	; 0x26 <__ctors_end>
   2:	2c c0       	rjmp	.+88     	; 0x5c <__bad_interrupt>
   4:	2b c0       	rjmp	.+86     	; 0x5c <__bad_interrupt>
   6:	2a c0       	rjmp	.+84     	; 0x5c <__bad_interrupt>
   8:	29 c0       	rjmp	.+82     	; 0x5c <__bad_interrupt>
   a:	28 c0       	rjmp	.+80     	; 0x5c <__bad_interrupt>
   c:	63 c0       	rjmp	.+198    	; 0xd4 <__vector_6>
   e:	26 c0       	rjmp	.+76     	; 0x5c <__bad_interrupt>
  10:	25 c0       	rjmp	.+74     	; 0x5c <__bad_interrupt>
  12:	24 c0       	rjmp	.+72     	; 0x5c <__bad_interrupt>
  14:	23 c0       	rjmp	.+70     	; 0x5c <__bad_interrupt>
  16:	1b c3       	rjmp	.+1590   	; 0x64e <__vector_11>
  18:	a8 c2       	rjmp	.+1360   	; 0x56a <__vector_12>
  1a:	20 c0       	rjmp	.+64     	; 0x5c <__bad_interrupt>
  1c:	1f c0       	rjmp	.+62     	; 0x5c <__bad_interrupt>
  1e:	1e c0       	rjmp	.+60     	; 0x5c <__bad_interrupt>
  20:	1d c0       	rjmp	.+58     	; 0x5c <__bad_interrupt>
  22:	1c c0       	rjmp	.+56     	; 0x5c <__bad_interrupt>
  24:	1b c0       	rjmp	.+54     	; 0x5c <__bad_interrupt>

00000026 <__ctors_end>:
  26:	11 24       	eor	r1, r1
  28:	1f be       	out	0x3f, r1	; 63
  2a:	cf e5       	ldi	r28, 0x5F	; 95
  2c:	d4 e0       	ldi	r29, 0x04	; 4
  2e:	de bf       	out	0x3e, r29	; 62
  30:	cd bf       	out	0x3d, r28	; 61

00000032 <__do_copy_data>:
  32:	10 e0       	ldi	r17, 0x00	; 0
  34:	a0 e6       	ldi	r26, 0x60	; 96
  36:	b0 e0       	ldi	r27, 0x00	; 0
  38:	e4 ee       	ldi	r30, 0xE4	; 228
  3a:	ff e0       	ldi	r31, 0x0F	; 15
  3c:	02 c0       	rjmp	.+4      	; 0x42 <.do_copy_data_start>

0000003e <.do_copy_data_loop>:
  3e:	05 90       	lpm	r0, Z+
  40:	0d 92       	st	X+, r0

00000042 <.do_copy_data_start>:
  42:	a4 39       	cpi	r26, 0x94	; 148
  44:	b1 07       	cpc	r27, r17
  46:	d9 f7       	brne	.-10     	; 0x3e <.do_copy_data_loop>

00000048 <__do_clear_bss>:
  48:	11 e0       	ldi	r17, 0x01	; 1
  4a:	a4 e9       	ldi	r26, 0x94	; 148
  4c:	b0 e0       	ldi	r27, 0x00	; 0
  4e:	01 c0       	rjmp	.+2      	; 0x52 <.do_clear_bss_start>

00000050 <.do_clear_bss_loop>:
  50:	1d 92       	st	X+, r1

00000052 <.do_clear_bss_start>:
  52:	a0 39       	cpi	r26, 0x90	; 144
  54:	b1 07       	cpc	r27, r17
  56:	e1 f7       	brne	.-8      	; 0x50 <.do_clear_bss_loop>
  58:	21 d0       	rcall	.+66     	; 0x9c <main>
  5a:	c3 c7       	rjmp	.+3974   	; 0xfe2 <_exit>

0000005c <__bad_interrupt>:
  5c:	d1 cf       	rjmp	.-94     	; 0x0 <__vectors>

0000005e <ioinit>:



// Inicializace èítaèe pro volání inkrementálního èidla
void ioinit (void) {
  5e:	89 e0       	ldi	r24, 0x09	; 9
  60:	8e bd       	out	0x2e, r24	; 46
  int pocet_cyklu = 400;

  // citac bude citat v každém cyklu, režim - Clear Timer on Compare (CTC)
  TCCR1B = (1 << CS10) | (1 << WGM12);
  // nastaveni pøerušení pøi porovnání
  TIMSK = (1 << OCIE1A);
  62:	80 e1       	ldi	r24, 0x10	; 16
  64:	89 bf       	out	0x39, r24	; 57

  // Nastavení jak èasto se bude volat 
  OCR1AH = (unsigned char)(pocet_cyklu >> 8);
  66:	81 e0       	ldi	r24, 0x01	; 1
  68:	8b bd       	out	0x2b, r24	; 43
  OCR1AL = (unsigned char) pocet_cyklu;
  6a:	80 e9       	ldi	r24, 0x90	; 144
  6c:	8a bd       	out	0x2a, r24	; 42
  6e:	08 95       	ret

00000070 <test_shutdown>:
  70:	80 b3       	in	r24, 0x10	; 16
  72:	86 95       	lsr	r24
  74:	86 95       	lsr	r24
  76:	80 fd       	sbrc	r24, 0
  78:	10 c0       	rjmp	.+32     	; 0x9a <test_shutdown+0x2a>
  7a:	c3 d5       	rcall	.+2950   	; 0xc02 <eeprom_save>
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
  7c:	80 e2       	ldi	r24, 0x20	; 32
  7e:	9e e4       	ldi	r25, 0x4E	; 78
  80:	01 97       	sbiw	r24, 0x01	; 1
  82:	f1 f7       	brne	.-4      	; 0x80 <test_shutdown+0x10>
  84:	e0 e2       	ldi	r30, 0x20	; 32
  86:	fe e4       	ldi	r31, 0x4E	; 78
  88:	03 c0       	rjmp	.+6      	; 0x90 <test_shutdown+0x20>
  8a:	cf 01       	movw	r24, r30
  8c:	01 97       	sbiw	r24, 0x01	; 1
  8e:	f1 f7       	brne	.-4      	; 0x8c <test_shutdown+0x1c>
  90:	80 b3       	in	r24, 0x10	; 16
  92:	86 95       	lsr	r24
  94:	86 95       	lsr	r24
  96:	80 ff       	sbrs	r24, 0
  98:	f8 cf       	rjmp	.-16     	; 0x8a <test_shutdown+0x1a>
  9a:	08 95       	ret

0000009c <main>:
}



int main(void){
  9c:	20 e0       	ldi	r18, 0x00	; 0
  9e:	30 e0       	ldi	r19, 0x00	; 0
  a0:	e0 ed       	ldi	r30, 0xD0	; 208
  a2:	f7 e0       	ldi	r31, 0x07	; 7
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
  a4:	cf 01       	movw	r24, r30
  a6:	01 97       	sbiw	r24, 0x01	; 1
  a8:	f1 f7       	brne	.-4      	; 0xa6 <main+0xa>
  int i=0;

  //eeprom_w32((void *)0,10);
  //eeprom_w16((void *)4,20);
  //eeprom_w32((void *)6,30);
  
  //poèkáme 100 ms
  for(i=0; i < 100;i++){
  aa:	2f 5f       	subi	r18, 0xFF	; 255
  ac:	3f 4f       	sbci	r19, 0xFF	; 255
  ae:	24 36       	cpi	r18, 0x64	; 100
  b0:	31 05       	cpc	r19, r1
  b2:	c1 f7       	brne	.-16     	; 0xa4 <main+0x8>
  
  _delay_ms(1);
  
  }
  ioinit ();
  b4:	d4 df       	rcall	.-88     	; 0x5e <ioinit>
  data_msg[0] = '\x40';
  b6:	80 e4       	ldi	r24, 0x40	; 64
  b8:	80 93 a2 00 	sts	0x00A2, r24
  irc_init();
  bc:	69 d3       	rcall	.+1746   	; 0x790 <irc_init>
  width_watch_init();
  be:	2d d0       	rcall	.+90     	; 0x11a <width_watch_init>
  USART_Init(51);
  c0:	83 e3       	ldi	r24, 0x33	; 51
  c2:	90 e0       	ldi	r25, 0x00	; 0
  c4:	4f d1       	rcall	.+670    	; 0x364 <USART_Init>
  eeprom_load();
  c6:	a9 d5       	rcall	.+2898   	; 0xc1a <eeprom_load>
  sei();
  c8:	78 94       	sei
  irc_send_msg(1); //odelše informaci o poloze válce
  ca:	81 e0       	ldi	r24, 0x01	; 1
  cc:	bd d3       	rcall	.+1914   	; 0x848 <irc_send_msg>

  while(1){
    width_watch();
  ce:	d4 d0       	rcall	.+424    	; 0x278 <width_watch>
        
    test_shutdown();
  d0:	cf df       	rcall	.-98     	; 0x70 <test_shutdown>
  d2:	fd cf       	rjmp	.-6      	; 0xce <main+0x32>

000000d4 <__vector_6>:
  d4:	1f 92       	push	r1
  d6:	0f 92       	push	r0
  d8:	0f b6       	in	r0, 0x3f	; 63
  da:	0f 92       	push	r0
  dc:	11 24       	eor	r1, r1
  de:	2f 93       	push	r18
  e0:	3f 93       	push	r19
  e2:	4f 93       	push	r20
  e4:	5f 93       	push	r21
  e6:	6f 93       	push	r22
  e8:	7f 93       	push	r23
  ea:	8f 93       	push	r24
  ec:	9f 93       	push	r25
  ee:	af 93       	push	r26
  f0:	bf 93       	push	r27
  f2:	ef 93       	push	r30
  f4:	ff 93       	push	r31
  f6:	fb d3       	rcall	.+2038   	; 0x8ee <irc_watch>
  f8:	ff 91       	pop	r31
  fa:	ef 91       	pop	r30
  fc:	bf 91       	pop	r27
  fe:	af 91       	pop	r26
 100:	9f 91       	pop	r25
 102:	8f 91       	pop	r24
 104:	7f 91       	pop	r23
 106:	6f 91       	pop	r22
 108:	5f 91       	pop	r21
 10a:	4f 91       	pop	r20
 10c:	3f 91       	pop	r19
 10e:	2f 91       	pop	r18
 110:	0f 90       	pop	r0
 112:	0f be       	out	0x3f, r0	; 63
 114:	0f 90       	pop	r0
 116:	1f 90       	pop	r1
 118:	18 95       	reti

0000011a <width_watch_init>:


// Inicializace mereni sirky
// Vyuluje se zde pole pro nascitavani zmerenych hodnot.
void width_watch_init(void) {
 11a:	ed ea       	ldi	r30, 0xAD	; 173
 11c:	f0 e0       	ldi	r31, 0x00	; 0
  int i = 0;
  for (i = 0; i < LenOfWidIntegrArr ; i++){
    width_integrate_array[i] = 0;
 11e:	11 92       	st	Z+, r1
 120:	11 92       	st	Z+, r1
 122:	81 e0       	ldi	r24, 0x01	; 1
 124:	ed 34       	cpi	r30, 0x4D	; 77
 126:	f8 07       	cpc	r31, r24
 128:	d1 f7       	brne	.-12     	; 0x11e <width_watch_init+0x4>
  }
  // vypis adresu multiplexu na prvni tri bity portu C
  DDRC |= 0x07; 
 12a:	84 b3       	in	r24, 0x14	; 20
 12c:	87 60       	ori	r24, 0x07	; 7
 12e:	84 bb       	out	0x14, r24	; 20
  PORTC = ((PORTC & 0xf8) | (width_multiplex_adress & 0x07));
 130:	95 b3       	in	r25, 0x15	; 21
 132:	98 7f       	andi	r25, 0xF8	; 248
 134:	80 91 94 00 	lds	r24, 0x0094
 138:	87 70       	andi	r24, 0x07	; 7
 13a:	98 2b       	or	r25, r24
 13c:	95 bb       	out	0x15, r25	; 21
  PORTB = 0xff;
 13e:	8f ef       	ldi	r24, 0xFF	; 255
 140:	88 bb       	out	0x18, r24	; 24
  PORTD |= (1 << 6)|(1 << 7);
 142:	82 b3       	in	r24, 0x12	; 18
 144:	80 6c       	ori	r24, 0xC0	; 192
 146:	82 bb       	out	0x12, r24	; 18
 148:	08 95       	ret

0000014a <get_d_h>:
}


/* Funkce je volána v tìle funkce width_watch
 * Je zde implementováno erodování osamìlých jednièek a nastavení nul obklopených jednièkami na jedna
 */
void width_computation(void){
  int i = 0;
  char pocet = 0;
  char ppppredchozi = 0;
  char pppredchozi = 0;
  char ppredchozi = 0; //predpredchozi
  char predchozi = 0;
  char nula2jedna = 0;
  
  for (i = 0; i < LenOfWidIntegrArr; i++){
    //if (width_integrate_array[i] > widthIterLimit){ // zda se mi že je tam chyba 
    if (width_integrate_array[i] > widthIterComparator){
      pocet++;
      
      // tady se pocita pocet prechodu z nuly na jednicku
      if (predchozi == 0){
        nula2jedna++;
      }
      // vyraz na slivani
      // pokud je nula mezi jednièkama, hodí to nulu na jednièku
      if ((predchozi == 0)&(ppredchozi == 1)){
        nula2jedna--;
        pocet++;
        predchozi = 1;
      }
      ppppredchozi = pppredchozi;
      pppredchozi = ppredchozi;
      ppredchozi = predchozi;
      //konec slivani

      predchozi = 1;
      
    }
    else{
      //slivani
      // jesli je za jednou jednickou a pred jendickou 
      // (to plyne z toho, že to neopravil jednièkovej slívací výraz) dve nuly,
      // z jednièky udìlej nulu
      /*
      if ((predchozi == 0)&(ppredchozi == 1)&(pppredchozi == 0)){
        ppredchozi = 0;
        pocet--;
      }*/
      ppppredchozi = pppredchozi;
      pppredchozi = ppredchozi;
      ppredchozi = predchozi;
      //konec slivani
      predchozi = 0;
    }

    width_integrate_array[i] = 0;

    
  }
  
  if (nula2jedna < 2){
    width_value = pocet;
    width_valid = 1;
    width_send_msg();

  }
  else {
    width_value = 0;
    width_valid = 0;
    // chyba mereni sirky - vice ploch
    //new_msg("\003width");
    //
    //lazeni
    width_value = pocet;
    width_send_msg();

  }
}


uint16_t get_d_h(void){
 14a:	cf 92       	push	r12
 14c:	df 92       	push	r13
 14e:	ef 92       	push	r14
 150:	ff 92       	push	r15
 152:	0f 93       	push	r16
 154:	1f 93       	push	r17
 156:	cf 93       	push	r28
 158:	df 93       	push	r29
  float r1;
  uint16_t w;

  w = width_value * 10; // v mm
 15a:	80 91 99 00 	lds	r24, 0x0099
 15e:	9a e0       	ldi	r25, 0x0A	; 10
 160:	89 9f       	mul	r24, r25
 162:	e0 01       	movw	r28, r0
 164:	11 24       	eor	r1, r1

  if (width_prepocet != 0){
 166:	80 91 62 00 	lds	r24, 0x0062
 16a:	88 23       	and	r24, r24
 16c:	a1 f1       	breq	.+104    	; 0x1d6 <get_d_h+0x8c>
    r1 = (irc_get_d()) / 2.0; //dva jsou aby to bylp polomìèr a né prùmìr
 16e:	30 d3       	rcall	.+1632   	; 0x7d0 <irc_get_d>
 170:	8c 01       	movw	r16, r24

    w = (uint16_t)((w / ((float) vzdalSvetlaOdSnimacu)) * ((float)vzdalSvetlaOdSnimacu - r1 - vzdalSnimacuOdStromu));
 172:	be 01       	movw	r22, r28
 174:	88 27       	eor	r24, r24
 176:	77 fd       	sbrc	r23, 7
 178:	80 95       	com	r24
 17a:	98 2f       	mov	r25, r24
 17c:	21 d6       	rcall	.+3138   	; 0xdc0 <__floatsisf>
 17e:	20 e0       	ldi	r18, 0x00	; 0
 180:	30 e0       	ldi	r19, 0x00	; 0
 182:	4a ef       	ldi	r20, 0xFA	; 250
 184:	54 e4       	ldi	r21, 0x44	; 68
 186:	b9 d5       	rcall	.+2930   	; 0xcfa <__divsf3>
 188:	6b 01       	movw	r12, r22
 18a:	7c 01       	movw	r14, r24
 18c:	b8 01       	movw	r22, r16
 18e:	88 27       	eor	r24, r24
 190:	77 fd       	sbrc	r23, 7
 192:	80 95       	com	r24
 194:	98 2f       	mov	r25, r24
 196:	14 d6       	rcall	.+3112   	; 0xdc0 <__floatsisf>
 198:	17 ff       	sbrs	r17, 7
 19a:	05 c0       	rjmp	.+10     	; 0x1a6 <get_d_h+0x5c>
 19c:	20 e0       	ldi	r18, 0x00	; 0
 19e:	30 e0       	ldi	r19, 0x00	; 0
 1a0:	40 e8       	ldi	r20, 0x80	; 128
 1a2:	57 e4       	ldi	r21, 0x47	; 71
 1a4:	68 d5       	rcall	.+2768   	; 0xc76 <__addsf3>
 1a6:	20 e0       	ldi	r18, 0x00	; 0
 1a8:	30 e0       	ldi	r19, 0x00	; 0
 1aa:	40 e0       	ldi	r20, 0x00	; 0
 1ac:	5f e3       	ldi	r21, 0x3F	; 63
 1ae:	82 d6       	rcall	.+3332   	; 0xeb4 <__mulsf3>
 1b0:	9b 01       	movw	r18, r22
 1b2:	ac 01       	movw	r20, r24
 1b4:	60 e0       	ldi	r22, 0x00	; 0
 1b6:	70 e0       	ldi	r23, 0x00	; 0
 1b8:	8a ef       	ldi	r24, 0xFA	; 250
 1ba:	94 e4       	ldi	r25, 0x44	; 68
 1bc:	5b d5       	rcall	.+2742   	; 0xc74 <__subsf3>
 1be:	20 e0       	ldi	r18, 0x00	; 0
 1c0:	30 e0       	ldi	r19, 0x00	; 0
 1c2:	48 e4       	ldi	r20, 0x48	; 72
 1c4:	52 e4       	ldi	r21, 0x42	; 66
 1c6:	56 d5       	rcall	.+2732   	; 0xc74 <__subsf3>
 1c8:	9b 01       	movw	r18, r22
 1ca:	ac 01       	movw	r20, r24
 1cc:	c7 01       	movw	r24, r14
 1ce:	b6 01       	movw	r22, r12
 1d0:	71 d6       	rcall	.+3298   	; 0xeb4 <__mulsf3>
 1d2:	d9 d5       	rcall	.+2994   	; 0xd86 <__fixsfsi>
 1d4:	eb 01       	movw	r28, r22
  } 
  return w;
}
 1d6:	ce 01       	movw	r24, r28
 1d8:	df 91       	pop	r29
 1da:	cf 91       	pop	r28
 1dc:	1f 91       	pop	r17
 1de:	0f 91       	pop	r16
 1e0:	ff 90       	pop	r15
 1e2:	ef 90       	pop	r14
 1e4:	df 90       	pop	r13
 1e6:	cf 90       	pop	r12
 1e8:	08 95       	ret

000001ea <width_send_msg>:

void width_send_msg(void){
 1ea:	af df       	rcall	.-162    	; 0x14a <get_d_h>
 1ec:	9c 01       	movw	r18, r24
  uint16_t w;
  char ch1,ch2;


  //if (width_value >=0){
    //w = width_value * 10; // v mm
  /*}
  else{
    w = 0;
  }*/

  w = get_d_h();
    
  ch1 = w % 256;
  ch2 = w / 256;
 1ee:	43 2f       	mov	r20, r19
 1f0:	55 27       	eor	r21, r21
    // odeslima pouze pokud doslo ke zmene
  if ((data_msg[3] != ch1) || (data_msg[4] != ch2)){ 
 1f2:	80 91 a5 00 	lds	r24, 0x00A5
 1f6:	82 17       	cp	r24, r18
 1f8:	21 f4       	brne	.+8      	; 0x202 <width_send_msg+0x18>
 1fa:	80 91 a6 00 	lds	r24, 0x00A6
 1fe:	84 17       	cp	r24, r20
 200:	39 f0       	breq	.+14     	; 0x210 <width_send_msg+0x26>
    data_msg[3] = ch1;
 202:	20 93 a5 00 	sts	0x00A5, r18
    data_msg[4] = ch2;
 206:	40 93 a6 00 	sts	0x00A6, r20
    new_msg(data_msg);
 20a:	82 ea       	ldi	r24, 0xA2	; 162
 20c:	90 e0       	ldi	r25, 0x00	; 0
 20e:	1f d1       	rcall	.+574    	; 0x44e <new_msg>
 210:	08 95       	ret

00000212 <width_computation>:
 212:	40 e0       	ldi	r20, 0x00	; 0
 214:	50 e0       	ldi	r21, 0x00	; 0
 216:	20 e0       	ldi	r18, 0x00	; 0
 218:	30 e0       	ldi	r19, 0x00	; 0
 21a:	ed ea       	ldi	r30, 0xAD	; 173
 21c:	f0 e0       	ldi	r31, 0x00	; 0
 21e:	80 81       	ld	r24, Z
 220:	91 81       	ldd	r25, Z+1	; 0x01
 222:	c3 97       	sbiw	r24, 0x33	; 51
 224:	1c f4       	brge	.+6      	; 0x22c <width_computation+0x1a>
 226:	52 2f       	mov	r21, r18
 228:	20 e0       	ldi	r18, 0x00	; 0
 22a:	0d c0       	rjmp	.+26     	; 0x246 <width_computation+0x34>
 22c:	4f 5f       	subi	r20, 0xFF	; 255
 22e:	22 23       	and	r18, r18
 230:	11 f0       	breq	.+4      	; 0x236 <width_computation+0x24>
 232:	52 2f       	mov	r21, r18
 234:	07 c0       	rjmp	.+14     	; 0x244 <width_computation+0x32>
 236:	3f 5f       	subi	r19, 0xFF	; 255
 238:	51 30       	cpi	r21, 0x01	; 1
 23a:	11 f0       	breq	.+4      	; 0x240 <width_computation+0x2e>
 23c:	50 e0       	ldi	r21, 0x00	; 0
 23e:	02 c0       	rjmp	.+4      	; 0x244 <width_computation+0x32>
 240:	31 50       	subi	r19, 0x01	; 1
 242:	4f 5f       	subi	r20, 0xFF	; 255
 244:	21 e0       	ldi	r18, 0x01	; 1
 246:	11 92       	st	Z+, r1
 248:	11 92       	st	Z+, r1
 24a:	81 e0       	ldi	r24, 0x01	; 1
 24c:	ed 34       	cpi	r30, 0x4D	; 77
 24e:	f8 07       	cpc	r31, r24
 250:	31 f7       	brne	.-52     	; 0x21e <width_computation+0xc>
 252:	32 30       	cpi	r19, 0x02	; 2
 254:	48 f4       	brcc	.+18     	; 0x268 <width_computation+0x56>
 256:	40 93 99 00 	sts	0x0099, r20
 25a:	81 e0       	ldi	r24, 0x01	; 1
 25c:	90 e0       	ldi	r25, 0x00	; 0
 25e:	90 93 98 00 	sts	0x0098, r25
 262:	80 93 97 00 	sts	0x0097, r24
 266:	06 c0       	rjmp	.+12     	; 0x274 <width_computation+0x62>
 268:	10 92 98 00 	sts	0x0098, r1
 26c:	10 92 97 00 	sts	0x0097, r1
 270:	40 93 99 00 	sts	0x0099, r20
 274:	ba df       	rcall	.-140    	; 0x1ea <width_send_msg>
 276:	08 95       	ret

00000278 <width_watch>:
 278:	cf 93       	push	r28
 27a:	df 93       	push	r29
 27c:	80 91 60 00 	lds	r24, 0x0060
 280:	90 91 61 00 	lds	r25, 0x0061
 284:	00 97       	sbiw	r24, 0x00	; 0
 286:	09 f0       	breq	.+2      	; 0x28a <width_watch+0x12>
 288:	65 c0       	rjmp	.+202    	; 0x354 <width_watch+0xdc>
 28a:	86 b3       	in	r24, 0x16	; 22
 28c:	a0 b3       	in	r26, 0x10	; 16
 28e:	a2 95       	swap	r26
 290:	a6 95       	lsr	r26
 292:	a6 95       	lsr	r26
 294:	a3 70       	andi	r26, 0x03	; 3
 296:	b0 91 94 00 	lds	r27, 0x0094
 29a:	4b 2f       	mov	r20, r27
 29c:	55 27       	eor	r21, r21
 29e:	fa 01       	movw	r30, r20
 2a0:	ee 0f       	add	r30, r30
 2a2:	ff 1f       	adc	r31, r31
 2a4:	e3 55       	subi	r30, 0x53	; 83
 2a6:	ff 4f       	sbci	r31, 0xFF	; 255
 2a8:	60 e0       	ldi	r22, 0x00	; 0
 2aa:	70 e0       	ldi	r23, 0x00	; 0
 2ac:	c8 2f       	mov	r28, r24
 2ae:	dd 27       	eor	r29, r29
 2b0:	9e 01       	movw	r18, r28
 2b2:	06 2e       	mov	r0, r22
 2b4:	02 c0       	rjmp	.+4      	; 0x2ba <width_watch+0x42>
 2b6:	35 95       	asr	r19
 2b8:	27 95       	ror	r18
 2ba:	0a 94       	dec	r0
 2bc:	e2 f7       	brpl	.-8      	; 0x2b6 <width_watch+0x3e>
 2be:	21 70       	andi	r18, 0x01	; 1
 2c0:	30 70       	andi	r19, 0x00	; 0
 2c2:	80 81       	ld	r24, Z
 2c4:	91 81       	ldd	r25, Z+1	; 0x01
 2c6:	82 0f       	add	r24, r18
 2c8:	93 1f       	adc	r25, r19
 2ca:	91 83       	std	Z+1, r25	; 0x01
 2cc:	80 83       	st	Z, r24
 2ce:	6f 5f       	subi	r22, 0xFF	; 255
 2d0:	7f 4f       	sbci	r23, 0xFF	; 255
 2d2:	70 96       	adiw	r30, 0x10	; 16
 2d4:	68 30       	cpi	r22, 0x08	; 8
 2d6:	71 05       	cpc	r23, r1
 2d8:	59 f7       	brne	.-42     	; 0x2b0 <width_watch+0x38>
 2da:	44 0f       	add	r20, r20
 2dc:	55 1f       	adc	r21, r21
 2de:	fa 01       	movw	r30, r20
 2e0:	e3 5d       	subi	r30, 0xD3	; 211
 2e2:	fe 4f       	sbci	r31, 0xFE	; 254
 2e4:	2a 2f       	mov	r18, r26
 2e6:	33 27       	eor	r19, r19
 2e8:	21 70       	andi	r18, 0x01	; 1
 2ea:	30 70       	andi	r19, 0x00	; 0
 2ec:	80 81       	ld	r24, Z
 2ee:	91 81       	ldd	r25, Z+1	; 0x01
 2f0:	82 0f       	add	r24, r18
 2f2:	93 1f       	adc	r25, r19
 2f4:	91 83       	std	Z+1, r25	; 0x01
 2f6:	80 83       	st	Z, r24
 2f8:	fa 01       	movw	r30, r20
 2fa:	e3 5c       	subi	r30, 0xC3	; 195
 2fc:	fe 4f       	sbci	r31, 0xFE	; 254
 2fe:	a6 95       	lsr	r26
 300:	80 81       	ld	r24, Z
 302:	91 81       	ldd	r25, Z+1	; 0x01
 304:	8a 0f       	add	r24, r26
 306:	91 1d       	adc	r25, r1
 308:	91 83       	std	Z+1, r25	; 0x01
 30a:	80 83       	st	Z, r24
 30c:	b7 30       	cpi	r27, 0x07	; 7
 30e:	20 f4       	brcc	.+8      	; 0x318 <width_watch+0xa0>
 310:	bf 5f       	subi	r27, 0xFF	; 255
 312:	b0 93 94 00 	sts	0x0094, r27
 316:	14 c0       	rjmp	.+40     	; 0x340 <width_watch+0xc8>
 318:	10 92 94 00 	sts	0x0094, r1
 31c:	80 91 95 00 	lds	r24, 0x0095
 320:	90 91 96 00 	lds	r25, 0x0096
 324:	84 36       	cpi	r24, 0x64	; 100
 326:	91 05       	cpc	r25, r1
 328:	34 f4       	brge	.+12     	; 0x336 <width_watch+0xbe>
 32a:	01 96       	adiw	r24, 0x01	; 1
 32c:	90 93 96 00 	sts	0x0096, r25
 330:	80 93 95 00 	sts	0x0095, r24
 334:	05 c0       	rjmp	.+10     	; 0x340 <width_watch+0xc8>
 336:	10 92 96 00 	sts	0x0096, r1
 33a:	10 92 95 00 	sts	0x0095, r1
 33e:	69 df       	rcall	.-302    	; 0x212 <width_computation>
 340:	85 b3       	in	r24, 0x15	; 21
 342:	88 7f       	andi	r24, 0xF8	; 248
 344:	90 91 94 00 	lds	r25, 0x0094
 348:	97 70       	andi	r25, 0x07	; 7
 34a:	89 2b       	or	r24, r25
 34c:	85 bb       	out	0x15, r24	; 21
 34e:	85 e0       	ldi	r24, 0x05	; 5
 350:	90 e0       	ldi	r25, 0x00	; 0
 352:	01 c0       	rjmp	.+2      	; 0x356 <width_watch+0xde>
 354:	01 97       	sbiw	r24, 0x01	; 1
 356:	90 93 61 00 	sts	0x0061, r25
 35a:	80 93 60 00 	sts	0x0060, r24
 35e:	df 91       	pop	r29
 360:	cf 91       	pop	r28
 362:	08 95       	ret

00000364 <USART_Init>:

/**
 * Inicializace usartu
 */
void USART_Init( unsigned int baud ){
 364:	8b 9a       	sbi	0x11, 3	; 17
  int i = 0;

  DDRD = set_bit(DDRD,3); // nastaveni vystupniho pinu pro rizeni  

  /* Set baud rate */
  UBRRH = (unsigned char)(baud>>8);
 366:	29 2f       	mov	r18, r25
 368:	33 27       	eor	r19, r19
 36a:	20 bd       	out	0x20, r18	; 32
  UBRRL = (unsigned char)baud;
 36c:	89 b9       	out	0x09, r24	; 9
  /* Enable Receiver and Transmitter */
  /* Data,RX interrupt enable*/
  UCSRB = (1<<RXEN)|(1<<TXEN)|(1<<RXCIE); // |(1<<UDRIE)
 36e:	88 e9       	ldi	r24, 0x98	; 152
 370:	8a b9       	out	0x0a, r24	; 10
  /* Set frame format: 8data, 2stop bit */
  UCSRC = (1<<URSEL)|(1<<USBS)|(3<<UCSZ0);
 372:	8e e8       	ldi	r24, 0x8E	; 142
 374:	80 bd       	out	0x20, r24	; 32
 376:	e4 e7       	ldi	r30, 0x74	; 116
 378:	f1 e0       	ldi	r31, 0x01	; 1

  // Clear usart recive buffer
  for (i = 0; i < LenOfRecvBuff; i++){
    usart_recv_buff[i] = 0;
 37a:	11 92       	st	Z+, r1
 37c:	81 e0       	ldi	r24, 0x01	; 1
 37e:	e6 38       	cpi	r30, 0x86	; 134
 380:	f8 07       	cpc	r31, r24
 382:	d9 f7       	brne	.-10     	; 0x37a <USART_Init+0x16>
 384:	ed e4       	ldi	r30, 0x4D	; 77
 386:	f1 e0       	ldi	r31, 0x01	; 1
  }

  // Clear usart transmitt buffer
  for (i = 0; i < LenOfTransBuff; i++){
    usart_trans_buff[i] = 0;
 388:	11 92       	st	Z+, r1
 38a:	81 e0       	ldi	r24, 0x01	; 1
 38c:	ef 35       	cpi	r30, 0x5F	; 95
 38e:	f8 07       	cpc	r31, r24
 390:	d9 f7       	brne	.-10     	; 0x388 <USART_Init+0x24>
 392:	08 95       	ret

00000394 <to_transmitt_buffer>:
  }
  
  // Clear usart transmitt buffer level 2
  /*
  for (i = 0; i < LenOfTransBuff; i++){
    usart_trans_buff_2[i] = 0;
  }
  */

//  UDR = 0;
}

// Tahle cast se spousti vzdy kdyz prijmeme nejaky byte po seriovym kanale
SIGNAL(SIG_UART_RECV){
  char prijmuty;

  prijmuty = UDR;
  
  if (usart_recv_count == -1){
    if (prijmuty == 255){
      usart_recv_buff[0] = 255;
      usart_recv_count = 1;
    }
    else{
      // error 
      // chyba prenosu - zahajeno nespravnym znakem
      new_msg("\002rse2");
    }
  }
  else{
    usart_recv_buff[usart_recv_count] = prijmuty;
    usart_recv_count++;

    //kdyz jsou prijaty vsechny byty...
    if (usart_recv_count == LenOfRecvBuff){
      // test validity zpravy
      if (test_message(usart_recv_buff) == 1){
        // zpracovani prijate zpravy
        
        process_recived_msg();
      }
      else {
        // chyba prenosu - neshoda v kontrolnim souctu
        new_msg("\001rse1");
      }
      usart_recv_count = -1;
    }
    
  }
  
  
  //zarad_tri_zpravy();
}


// Tohle se spousti kdyz je prazdnej odesilaci buffer
// Kdyz chce nekdo neco vysilat, staci, kdyz nastavi usart_trans_count = 0;
// odeslíá to po bytech vìci z usart_trans_bufferu az do konce
// na konci je malé odmlèení, kvùli lepší synchronizaci
SIGNAL(SIG_UART_DATA){
  // Pokud neni co odesilat, tak se mrnkni jestli neco nema send_msg
  if (usart_trans_count == -1){
    send_msg();
    
  }
  // pokud je neco v bufferu, tak makej
  if (usart_trans_count != -1){
    PORTD = set_bit(PORTD, 3); // pøipojení odesílací linky

    if (usart_trans_count != LenOfTransBuff){
      UDR = usart_trans_buff[usart_trans_count];
    
      usart_trans_count++;
    }
    
    // tak takhle to fungovalo
    /*
    if (usart_trans_count == LenOfTransBuff){
      usart_trans_count = -1;
    }
    */
    //az sem
    
    // teï se po každým odeslání udìlá pauza
    // dela se to tak, že se vždycky sníží counter a když je nula, tak se vše
    // nastaví a ukonèí
    //*
    if (usart_trans_count == LenOfTransBuff){
      if (after_trans_delay_counter != 0){
        after_trans_delay_counter--;
      

      }
      else{
        after_trans_delay_counter = Delay;
        usart_trans_count = -1;
      }
    }
  }
  else{
      PORTD = clear_bit(PORTD,3); // odpojení odesílacího kanálu od linky
    UCSRB = UCSRB & (~(1 << UDRIE));
  }

} 
                     


// Odesilani zprav pracuje tak, ze funkce new_msg vytvari a udrzuje seznam
// zprav a funkce send_msg tyto zpravy rozesila. Pouzivji se zde pocitadla.
// msg_buffer_counter ukazuje na zpravu, kterou je treba odeslat. Je-li -1, pak
// neni zadne zprava k odeslani.

// Tato funkce obaluje zpravu kodem pouzivanym pro prenos po seriovem kanale.
void to_transmitt_buffer(char *msg){
 394:	cf 93       	push	r28
 396:	df 93       	push	r29
 398:	dc 01       	movw	r26, r24
  int i = 0;
  
  usart_trans_buff[0] = 255;
 39a:	8f ef       	ldi	r24, 0xFF	; 255
 39c:	80 93 4d 01 	sts	0x014D, r24
 3a0:	ed 01       	movw	r28, r26
 3a2:	ee e4       	ldi	r30, 0x4E	; 78
 3a4:	f1 e0       	ldi	r31, 0x01	; 1
  
  for (i = 0; i < LenOfMsg; i++){
    usart_trans_buff[i + 1] = msg[i];
 3a6:	89 91       	ld	r24, Y+
 3a8:	81 93       	st	Z+, r24
 3aa:	81 e0       	ldi	r24, 0x01	; 1
 3ac:	e9 35       	cpi	r30, 0x59	; 89
 3ae:	f8 07       	cpc	r31, r24
 3b0:	d1 f7       	brne	.-12     	; 0x3a6 <to_transmitt_buffer+0x12>
  }

  usart_trans_buff[LenOfMsg + 1] = usart_trans_buff[0] ^ msg[0];  
 3b2:	80 91 4d 01 	lds	r24, 0x014D
 3b6:	9c 91       	ld	r25, X
 3b8:	89 27       	eor	r24, r25
 3ba:	80 93 59 01 	sts	0x0159, r24
 3be:	ed 01       	movw	r28, r26
 3c0:	20 e0       	ldi	r18, 0x00	; 0
 3c2:	30 e0       	ldi	r19, 0x00	; 0

  for(i=0; i < DATASIZE; i = i + 2){
      usart_trans_buff[DATASIZE + 3 + (i/2)] = msg[i+1]^msg[i+2];
 3c4:	c9 01       	movw	r24, r18
 3c6:	62 e0       	ldi	r22, 0x02	; 2
 3c8:	70 e0       	ldi	r23, 0x00	; 0
 3ca:	d0 d5       	rcall	.+2976   	; 0xf6c <__divmodhi4>
 3cc:	fb 01       	movw	r30, r22
 3ce:	e3 5b       	subi	r30, 0xB3	; 179
 3d0:	fe 4f       	sbci	r31, 0xFE	; 254
 3d2:	89 81       	ldd	r24, Y+1	; 0x01
 3d4:	9a 81       	ldd	r25, Y+2	; 0x02
 3d6:	89 27       	eor	r24, r25
 3d8:	85 87       	std	Z+13, r24	; 0x0d
 3da:	2e 5f       	subi	r18, 0xFE	; 254
 3dc:	3f 4f       	sbci	r19, 0xFF	; 255
 3de:	22 96       	adiw	r28, 0x02	; 2
 3e0:	2a 30       	cpi	r18, 0x0A	; 10
 3e2:	31 05       	cpc	r19, r1
 3e4:	79 f7       	brne	.-34     	; 0x3c4 <to_transmitt_buffer+0x30>
 3e6:	df 91       	pop	r29
 3e8:	cf 91       	pop	r28
 3ea:	08 95       	ret

000003ec <test_message>:
  }


//  usart_trans_buff[LenOfMsg + 1 + 1] = msg[1] ^ msg[2];
//  usart_trans_buff[LenOfMsg + 1 + 2] = msg[3] ^ msg[4];
}

// Funkce tesuje spravnost zpravy
// Pokud je zprava v poradku, vrati 1
// pokud je ve zprave chyba, vrati funkce 0
int test_message(char *msg){
 3ec:	ef 92       	push	r14
 3ee:	ff 92       	push	r15
 3f0:	0f 93       	push	r16
 3f2:	1f 93       	push	r17
 3f4:	cf 93       	push	r28
 3f6:	df 93       	push	r29
 3f8:	8c 01       	movw	r16, r24
  int i=0;

  if (msg[0] != 255){
 3fa:	fc 01       	movw	r30, r24
 3fc:	80 81       	ld	r24, Z
 3fe:	8f 3f       	cpi	r24, 0xFF	; 255
 400:	e9 f4       	brne	.+58     	; 0x43c <test_message+0x50>
 402:	e8 01       	movw	r28, r16
 404:	ee 24       	eor	r14, r14
 406:	ff 24       	eor	r15, r15
    return 0;
  }
//  printf("zacatek ok!\n");
  for(i=0;i < DATASIZE;i=i+2){
    unsigned char a,b,c,d;
    a = msg[i+2];
    b = msg[i+3];
    c = 2 + DATASIZE + 1 + (i/2);
    d = msg[c];
    //printf("%i ^ %i = %i, compare with buffer[%i] = %i\n",a,b,a^b,c,d);
    if ((a^b) != d){
 408:	2a 81       	ldd	r18, Y+2	; 0x02
 40a:	8b 81       	ldd	r24, Y+3	; 0x03
 40c:	28 27       	eor	r18, r24
 40e:	c7 01       	movw	r24, r14
 410:	62 e0       	ldi	r22, 0x02	; 2
 412:	70 e0       	ldi	r23, 0x00	; 0
 414:	ab d5       	rcall	.+2902   	; 0xf6c <__divmodhi4>
 416:	63 5f       	subi	r22, 0xF3	; 243
 418:	f8 01       	movw	r30, r16
 41a:	e6 0f       	add	r30, r22
 41c:	f1 1d       	adc	r31, r1
 41e:	80 81       	ld	r24, Z
 420:	28 17       	cp	r18, r24
 422:	61 f4       	brne	.+24     	; 0x43c <test_message+0x50>
 424:	82 e0       	ldi	r24, 0x02	; 2
 426:	90 e0       	ldi	r25, 0x00	; 0
 428:	e8 0e       	add	r14, r24
 42a:	f9 1e       	adc	r15, r25
 42c:	22 96       	adiw	r28, 0x02	; 2
 42e:	9a e0       	ldi	r25, 0x0A	; 10
 430:	e9 16       	cp	r14, r25
 432:	f1 04       	cpc	r15, r1
 434:	49 f7       	brne	.-46     	; 0x408 <test_message+0x1c>
 436:	81 e0       	ldi	r24, 0x01	; 1
 438:	90 e0       	ldi	r25, 0x00	; 0
 43a:	02 c0       	rjmp	.+4      	; 0x440 <test_message+0x54>
 43c:	80 e0       	ldi	r24, 0x00	; 0
 43e:	90 e0       	ldi	r25, 0x00	; 0
 440:	df 91       	pop	r29
 442:	cf 91       	pop	r28
 444:	1f 91       	pop	r17
 446:	0f 91       	pop	r16
 448:	ff 90       	pop	r15
 44a:	ef 90       	pop	r14
 44c:	08 95       	ret

0000044e <new_msg>:
	//printf("fuckoff");
      return 0;
    }
  }
  return 1;
}



// vstupem do teto funkce je ukazatel na zpravu
// pokud se ukazatel uz v seznamu nenachazi, tak je zarazen na konec seznamu.
void new_msg (char *msg){
 44e:	cf 93       	push	r28
 450:	df 93       	push	r29
 452:	ac 01       	movw	r20, r24
  if (vysilame > 0){
 454:	80 91 7d 00 	lds	r24, 0x007D
 458:	88 23       	and	r24, r24
 45a:	09 f4       	brne	.+2      	; 0x45e <new_msg+0x10>
 45c:	45 c0       	rjmp	.+138    	; 0x4e8 <__stack+0x89>

    // pokud zadna zprava v seznamu neni, tak ji strc na nulty misto a nastartuj
    // citac a zapni preruseni od datovaho bufferu.
    if (msg_buffer_counter == -1){
 45e:	a0 91 79 00 	lds	r26, 0x0079
 462:	b0 91 7a 00 	lds	r27, 0x007A
 466:	8f ef       	ldi	r24, 0xFF	; 255
 468:	af 3f       	cpi	r26, 0xFF	; 255
 46a:	b8 07       	cpc	r27, r24
 46c:	51 f4       	brne	.+20     	; 0x482 <__stack+0x23>
      msg_buffer_counter = 0;
 46e:	10 92 7a 00 	sts	0x007A, r1
 472:	10 92 79 00 	sts	0x0079, r1
      msg_buffer[msg_buffer_counter] = msg;
 476:	50 93 60 01 	sts	0x0160, r21
 47a:	40 93 5f 01 	sts	0x015F, r20
      UCSRB = UCSRB | (1 << UDRIE);
 47e:	55 9a       	sbi	0x0a, 5	; 10
 480:	33 c0       	rjmp	.+102    	; 0x4e8 <__stack+0x89>
 482:	cf e5       	ldi	r28, 0x5F	; 95
 484:	d1 e0       	ldi	r29, 0x01	; 1
 486:	fa 01       	movw	r30, r20
 488:	90 81       	ld	r25, Z
    
    }
    // pokud jsou v seznamu zpravy, strc ji na konec.
    else{
      int i = 0;

      // testujeme, zda uz zprava neni v seznamu
      for (i = 0; i < LenOfMsgBuffer; i++){
        if (msg_buffer[i][0] == msg[0]){
 48a:	e8 81       	ld	r30, Y
 48c:	f9 81       	ldd	r31, Y+1	; 0x01
 48e:	80 81       	ld	r24, Z
 490:	89 17       	cp	r24, r25
 492:	51 f1       	breq	.+84     	; 0x4e8 <__stack+0x89>
          return;
 494:	22 96       	adiw	r28, 0x02	; 2
 496:	f1 e0       	ldi	r31, 0x01	; 1
 498:	c9 36       	cpi	r28, 0x69	; 105
 49a:	df 07       	cpc	r29, r31
 49c:	b1 f7       	brne	.-20     	; 0x48a <__stack+0x2b>
        }
        
      }
    
      // nastavime pocitadlo na prvek za aktualnim prvkem
      if (msg_buffer_counter != (LenOfMsgBuffer - 1))
 49e:	a4 30       	cpi	r26, 0x04	; 4
 4a0:	b1 05       	cpc	r27, r1
 4a2:	71 f0       	breq	.+28     	; 0x4c0 <__stack+0x61>
        i = msg_buffer_counter + 1;
 4a4:	9d 01       	movw	r18, r26
 4a6:	0f c0       	rjmp	.+30     	; 0x4c6 <__stack+0x67>
      else
        i = 0;
    
      while(i != msg_buffer_counter){
        // kdyz najdeme ukazatel NULL, tak vyskocime z cyklu
        if (msg_buffer[i] == NULL)
 4a8:	f9 01       	movw	r30, r18
 4aa:	ee 0f       	add	r30, r30
 4ac:	ff 1f       	adc	r31, r31
 4ae:	e1 5a       	subi	r30, 0xA1	; 161
 4b0:	fe 4f       	sbci	r31, 0xFE	; 254
 4b2:	80 81       	ld	r24, Z
 4b4:	91 81       	ldd	r25, Z+1	; 0x01
 4b6:	89 2b       	or	r24, r25
 4b8:	61 f0       	breq	.+24     	; 0x4d2 <__stack+0x73>
          break;

        // jesli nejsme na konci, inkrementujem, jinak na nulu.
        if (i != (LenOfMsgBuffer - 1)) 
 4ba:	24 30       	cpi	r18, 0x04	; 4
 4bc:	31 05       	cpc	r19, r1
 4be:	19 f4       	brne	.+6      	; 0x4c6 <__stack+0x67>
 4c0:	20 e0       	ldi	r18, 0x00	; 0
 4c2:	30 e0       	ldi	r19, 0x00	; 0
 4c4:	02 c0       	rjmp	.+4      	; 0x4ca <__stack+0x6b>
          i++;
 4c6:	2f 5f       	subi	r18, 0xFF	; 255
 4c8:	3f 4f       	sbci	r19, 0xFF	; 255
 4ca:	2a 17       	cp	r18, r26
 4cc:	3b 07       	cpc	r19, r27
 4ce:	61 f7       	brne	.-40     	; 0x4a8 <__stack+0x49>
 4d0:	03 c0       	rjmp	.+6      	; 0x4d8 <__stack+0x79>
        else 
          i = 0;
      }
    
      if (i != msg_buffer_counter){
        msg_buffer[i] = msg;
 4d2:	51 83       	std	Z+1, r21	; 0x01
 4d4:	40 83       	st	Z, r20
 4d6:	08 c0       	rjmp	.+16     	; 0x4e8 <__stack+0x89>
      }
      else{
        msg_buffer[i] = "\007msgf";
 4d8:	aa 0f       	add	r26, r26
 4da:	bb 1f       	adc	r27, r27
 4dc:	a1 5a       	subi	r26, 0xA1	; 161
 4de:	be 4f       	sbci	r27, 0xFE	; 254
 4e0:	83 e6       	ldi	r24, 0x63	; 99
 4e2:	90 e0       	ldi	r25, 0x00	; 0
 4e4:	8d 93       	st	X+, r24
 4e6:	9c 93       	st	X, r25
 4e8:	df 91       	pop	r29
 4ea:	cf 91       	pop	r28
 4ec:	08 95       	ret

000004ee <send_msg>:
        //psat error preplneni zasobniku zprav
      }
    
    }
  }
  
}

// Funkce po svem zavolani projde seznam zprav. Jestli je nejaka zprava k
// odeslani, zkopiruje ji do odesilaciho bufferu a nastavi usart_trans_count=0;
// Tim se zahaji odesilani.
void send_msg (void){
 4ee:	e0 91 79 00 	lds	r30, 0x0079
 4f2:	f0 91 7a 00 	lds	r31, 0x007A
 4f6:	8f ef       	ldi	r24, 0xFF	; 255
 4f8:	ef 3f       	cpi	r30, 0xFF	; 255
 4fa:	f8 07       	cpc	r31, r24
 4fc:	a9 f1       	breq	.+106    	; 0x568 <send_msg+0x7a>
  if (msg_buffer_counter != -1){
    char *poiter_to_msg;

    // zkopirujeme obsah do bufferu
    poiter_to_msg = msg_buffer[msg_buffer_counter];

    to_transmitt_buffer(poiter_to_msg);
 4fe:	ee 0f       	add	r30, r30
 500:	ff 1f       	adc	r31, r31
 502:	e1 5a       	subi	r30, 0xA1	; 161
 504:	fe 4f       	sbci	r31, 0xFE	; 254
 506:	80 81       	ld	r24, Z
 508:	91 81       	ldd	r25, Z+1	; 0x01
 50a:	44 df       	rcall	.-376    	; 0x394 <to_transmitt_buffer>

    /*
    for (i = 0; i < LenOfTransBuff; i++){
      usart_trans_buff[i] = poiter_to_msg[i];
    }
    */
    // 
    msg_buffer[msg_buffer_counter] = NULL;
 50c:	80 91 79 00 	lds	r24, 0x0079
 510:	90 91 7a 00 	lds	r25, 0x007A
 514:	fc 01       	movw	r30, r24
 516:	ee 0f       	add	r30, r30
 518:	ff 1f       	adc	r31, r31
 51a:	e1 5a       	subi	r30, 0xA1	; 161
 51c:	fe 4f       	sbci	r31, 0xFE	; 254
 51e:	11 82       	std	Z+1, r1	; 0x01
 520:	10 82       	st	Z, r1

    // zahajime odesilani
    usart_trans_count = 0;
 522:	10 92 78 00 	sts	0x0078, r1
 526:	10 92 77 00 	sts	0x0077, r1

    // Pokusime se nalezt dalsi zpravu
    if (msg_buffer_counter == (LenOfMsgBuffer - 1)){
 52a:	84 30       	cpi	r24, 0x04	; 4
 52c:	91 05       	cpc	r25, r1
 52e:	29 f4       	brne	.+10     	; 0x53a <send_msg+0x4c>
      msg_buffer_counter = 0;
 530:	10 92 7a 00 	sts	0x007A, r1
 534:	10 92 79 00 	sts	0x0079, r1
 538:	05 c0       	rjmp	.+10     	; 0x544 <send_msg+0x56>
    }
    else{
      msg_buffer_counter++;
 53a:	01 96       	adiw	r24, 0x01	; 1
 53c:	90 93 7a 00 	sts	0x007A, r25
 540:	80 93 79 00 	sts	0x0079, r24
    }

    // Pokud zprava neexistuje, nastavime pocitadlo na -1;
    if (msg_buffer[msg_buffer_counter] == NULL){
 544:	e0 91 79 00 	lds	r30, 0x0079
 548:	f0 91 7a 00 	lds	r31, 0x007A
 54c:	ee 0f       	add	r30, r30
 54e:	ff 1f       	adc	r31, r31
 550:	e1 5a       	subi	r30, 0xA1	; 161
 552:	fe 4f       	sbci	r31, 0xFE	; 254
 554:	80 81       	ld	r24, Z
 556:	91 81       	ldd	r25, Z+1	; 0x01
 558:	89 2b       	or	r24, r25
 55a:	31 f4       	brne	.+12     	; 0x568 <send_msg+0x7a>
      msg_buffer_counter = -1; 
 55c:	8f ef       	ldi	r24, 0xFF	; 255
 55e:	9f ef       	ldi	r25, 0xFF	; 255
 560:	90 93 7a 00 	sts	0x007A, r25
 564:	80 93 79 00 	sts	0x0079, r24
 568:	08 95       	ret

0000056a <__vector_12>:
 56a:	1f 92       	push	r1
 56c:	0f 92       	push	r0
 56e:	0f b6       	in	r0, 0x3f	; 63
 570:	0f 92       	push	r0
 572:	11 24       	eor	r1, r1
 574:	2f 93       	push	r18
 576:	3f 93       	push	r19
 578:	4f 93       	push	r20
 57a:	5f 93       	push	r21
 57c:	6f 93       	push	r22
 57e:	7f 93       	push	r23
 580:	8f 93       	push	r24
 582:	9f 93       	push	r25
 584:	af 93       	push	r26
 586:	bf 93       	push	r27
 588:	ef 93       	push	r30
 58a:	ff 93       	push	r31
 58c:	20 91 77 00 	lds	r18, 0x0077
 590:	30 91 78 00 	lds	r19, 0x0078
 594:	8f ef       	ldi	r24, 0xFF	; 255
 596:	2f 3f       	cpi	r18, 0xFF	; 255
 598:	38 07       	cpc	r19, r24
 59a:	49 f4       	brne	.+18     	; 0x5ae <__vector_12+0x44>
 59c:	a8 df       	rcall	.-176    	; 0x4ee <send_msg>
 59e:	20 91 77 00 	lds	r18, 0x0077
 5a2:	30 91 78 00 	lds	r19, 0x0078
 5a6:	8f ef       	ldi	r24, 0xFF	; 255
 5a8:	2f 3f       	cpi	r18, 0xFF	; 255
 5aa:	38 07       	cpc	r19, r24
 5ac:	51 f1       	breq	.+84     	; 0x602 <__vector_12+0x98>
 5ae:	93 9a       	sbi	0x12, 3	; 18
 5b0:	22 31       	cpi	r18, 0x12	; 18
 5b2:	31 05       	cpc	r19, r1
 5b4:	69 f0       	breq	.+26     	; 0x5d0 <__vector_12+0x66>
 5b6:	f9 01       	movw	r30, r18
 5b8:	e3 5b       	subi	r30, 0xB3	; 179
 5ba:	fe 4f       	sbci	r31, 0xFE	; 254
 5bc:	80 81       	ld	r24, Z
 5be:	8c b9       	out	0x0c, r24	; 12
 5c0:	c9 01       	movw	r24, r18
 5c2:	01 96       	adiw	r24, 0x01	; 1
 5c4:	90 93 78 00 	sts	0x0078, r25
 5c8:	80 93 77 00 	sts	0x0077, r24
 5cc:	42 97       	sbiw	r24, 0x12	; 18
 5ce:	e9 f4       	brne	.+58     	; 0x60a <__vector_12+0xa0>
 5d0:	80 91 7b 00 	lds	r24, 0x007B
 5d4:	90 91 7c 00 	lds	r25, 0x007C
 5d8:	00 97       	sbiw	r24, 0x00	; 0
 5da:	31 f0       	breq	.+12     	; 0x5e8 <__vector_12+0x7e>
 5dc:	01 97       	sbiw	r24, 0x01	; 1
 5de:	90 93 7c 00 	sts	0x007C, r25
 5e2:	80 93 7b 00 	sts	0x007B, r24
 5e6:	11 c0       	rjmp	.+34     	; 0x60a <__vector_12+0xa0>
 5e8:	84 ef       	ldi	r24, 0xF4	; 244
 5ea:	91 e0       	ldi	r25, 0x01	; 1
 5ec:	90 93 7c 00 	sts	0x007C, r25
 5f0:	80 93 7b 00 	sts	0x007B, r24
 5f4:	8f ef       	ldi	r24, 0xFF	; 255
 5f6:	9f ef       	ldi	r25, 0xFF	; 255
 5f8:	90 93 78 00 	sts	0x0078, r25
 5fc:	80 93 77 00 	sts	0x0077, r24
 600:	04 c0       	rjmp	.+8      	; 0x60a <__vector_12+0xa0>
 602:	82 b3       	in	r24, 0x12	; 18
 604:	80 7f       	andi	r24, 0xF0	; 240
 606:	82 bb       	out	0x12, r24	; 18
 608:	55 98       	cbi	0x0a, 5	; 10
 60a:	ff 91       	pop	r31
 60c:	ef 91       	pop	r30
 60e:	bf 91       	pop	r27
 610:	af 91       	pop	r26
 612:	9f 91       	pop	r25
 614:	8f 91       	pop	r24
 616:	7f 91       	pop	r23
 618:	6f 91       	pop	r22
 61a:	5f 91       	pop	r21
 61c:	4f 91       	pop	r20
 61e:	3f 91       	pop	r19
 620:	2f 91       	pop	r18
 622:	0f 90       	pop	r0
 624:	0f be       	out	0x3f, r0	; 63
 626:	0f 90       	pop	r0
 628:	1f 90       	pop	r1
 62a:	18 95       	reti

0000062c <odesilame>:
      // jestli uz je vsechno odeslany zakazeme preruseni od prazdneho datoveho
      // bufferu. Stejne tam ted nic neprijde.  Az budeme preruseni potrebovat,
      // funkce new_msg ho zase zapne.
      // nejak to nefunguje
      /*
      if (usart_trans_count == -1){
        UCSRB = UCSRB & (~(1 << UDRIE));
      }
      */
    }
  }
  
}

// V tele teto funkce je reseno zpracovani prijate zpravy.
void process_recived_msg(){
  int i = 0;
  
  //zkopirovani zpravy a tim uvoneni prijimaciho bufferu
  for (i = 0; i < LenOfMsg; i++){
    recived_msg[i] = usart_recv_buff[i + 1];
  }
  recv_msg(recived_msg);
}

void odesilame(char c){
 62c:	80 93 7d 00 	sts	0x007D, r24
 630:	08 95       	ret

00000632 <process_recived_msg>:
 632:	e5 e7       	ldi	r30, 0x75	; 117
 634:	f1 e0       	ldi	r31, 0x01	; 1
 636:	a9 e6       	ldi	r26, 0x69	; 105
 638:	b1 e0       	ldi	r27, 0x01	; 1
 63a:	81 91       	ld	r24, Z+
 63c:	8d 93       	st	X+, r24
 63e:	81 e0       	ldi	r24, 0x01	; 1
 640:	e0 38       	cpi	r30, 0x80	; 128
 642:	f8 07       	cpc	r31, r24
 644:	d1 f7       	brne	.-12     	; 0x63a <process_recived_msg+0x8>
 646:	89 e6       	ldi	r24, 0x69	; 105
 648:	91 e0       	ldi	r25, 0x01	; 1
 64a:	52 d0       	rcall	.+164    	; 0x6f0 <recv_msg>
 64c:	08 95       	ret

0000064e <__vector_11>:
 64e:	1f 92       	push	r1
 650:	0f 92       	push	r0
 652:	0f b6       	in	r0, 0x3f	; 63
 654:	0f 92       	push	r0
 656:	11 24       	eor	r1, r1
 658:	2f 93       	push	r18
 65a:	3f 93       	push	r19
 65c:	4f 93       	push	r20
 65e:	5f 93       	push	r21
 660:	6f 93       	push	r22
 662:	7f 93       	push	r23
 664:	8f 93       	push	r24
 666:	9f 93       	push	r25
 668:	af 93       	push	r26
 66a:	bf 93       	push	r27
 66c:	ef 93       	push	r30
 66e:	ff 93       	push	r31
 670:	2c b1       	in	r18, 0x0c	; 12
 672:	80 91 75 00 	lds	r24, 0x0075
 676:	90 91 76 00 	lds	r25, 0x0076
 67a:	3f ef       	ldi	r19, 0xFF	; 255
 67c:	8f 3f       	cpi	r24, 0xFF	; 255
 67e:	93 07       	cpc	r25, r19
 680:	59 f4       	brne	.+22     	; 0x698 <__vector_11+0x4a>
 682:	2f 3f       	cpi	r18, 0xFF	; 255
 684:	29 f4       	brne	.+10     	; 0x690 <__vector_11+0x42>
 686:	20 93 74 01 	sts	0x0174, r18
 68a:	81 e0       	ldi	r24, 0x01	; 1
 68c:	90 e0       	ldi	r25, 0x00	; 0
 68e:	1b c0       	rjmp	.+54     	; 0x6c6 <__vector_11+0x78>
 690:	89 e6       	ldi	r24, 0x69	; 105
 692:	90 e0       	ldi	r25, 0x00	; 0
 694:	dc de       	rcall	.-584    	; 0x44e <new_msg>
 696:	1b c0       	rjmp	.+54     	; 0x6ce <__vector_11+0x80>
 698:	fc 01       	movw	r30, r24
 69a:	ec 58       	subi	r30, 0x8C	; 140
 69c:	fe 4f       	sbci	r31, 0xFE	; 254
 69e:	20 83       	st	Z, r18
 6a0:	01 96       	adiw	r24, 0x01	; 1
 6a2:	90 93 76 00 	sts	0x0076, r25
 6a6:	80 93 75 00 	sts	0x0075, r24
 6aa:	42 97       	sbiw	r24, 0x12	; 18
 6ac:	81 f4       	brne	.+32     	; 0x6ce <__vector_11+0x80>
 6ae:	84 e7       	ldi	r24, 0x74	; 116
 6b0:	91 e0       	ldi	r25, 0x01	; 1
 6b2:	9c de       	rcall	.-712    	; 0x3ec <test_message>
 6b4:	01 97       	sbiw	r24, 0x01	; 1
 6b6:	11 f4       	brne	.+4      	; 0x6bc <__vector_11+0x6e>
 6b8:	bc df       	rcall	.-136    	; 0x632 <process_recived_msg>
 6ba:	03 c0       	rjmp	.+6      	; 0x6c2 <__vector_11+0x74>
 6bc:	8f e6       	ldi	r24, 0x6F	; 111
 6be:	90 e0       	ldi	r25, 0x00	; 0
 6c0:	c6 de       	rcall	.-628    	; 0x44e <new_msg>
 6c2:	8f ef       	ldi	r24, 0xFF	; 255
 6c4:	9f ef       	ldi	r25, 0xFF	; 255
 6c6:	90 93 76 00 	sts	0x0076, r25
 6ca:	80 93 75 00 	sts	0x0075, r24
 6ce:	ff 91       	pop	r31
 6d0:	ef 91       	pop	r30
 6d2:	bf 91       	pop	r27
 6d4:	af 91       	pop	r26
 6d6:	9f 91       	pop	r25
 6d8:	8f 91       	pop	r24
 6da:	7f 91       	pop	r23
 6dc:	6f 91       	pop	r22
 6de:	5f 91       	pop	r21
 6e0:	4f 91       	pop	r20
 6e2:	3f 91       	pop	r19
 6e4:	2f 91       	pop	r18
 6e6:	0f 90       	pop	r0
 6e8:	0f be       	out	0x3f, r0	; 63
 6ea:	0f 90       	pop	r0
 6ec:	1f 90       	pop	r1
 6ee:	18 95       	reti

000006f0 <recv_msg>:
#include "eeprom.h"
#include "irc.h"
#include "width.h"

void recv_msg(char * recived_msg){
 6f0:	cf 93       	push	r28
 6f2:	df 93       	push	r29
 6f4:	ec 01       	movw	r28, r24

  switch (recived_msg[0]){
 6f6:	88 81       	ld	r24, Y
 6f8:	80 31       	cpi	r24, 0x10	; 16
 6fa:	09 f1       	breq	.+66     	; 0x73e <recv_msg+0x4e>
 6fc:	81 31       	cpi	r24, 0x11	; 17
 6fe:	30 f4       	brcc	.+12     	; 0x70c <recv_msg+0x1c>
 700:	89 30       	cpi	r24, 0x09	; 9
 702:	69 f0       	breq	.+26     	; 0x71e <recv_msg+0x2e>
 704:	8a 30       	cpi	r24, 0x0A	; 10
 706:	09 f0       	breq	.+2      	; 0x70a <recv_msg+0x1a>
 708:	40 c0       	rjmp	.+128    	; 0x78a <recv_msg+0x9a>
 70a:	07 c0       	rjmp	.+14     	; 0x71a <recv_msg+0x2a>
 70c:	83 31       	cpi	r24, 0x13	; 19
 70e:	b9 f1       	breq	.+110    	; 0x77e <recv_msg+0x8e>
 710:	86 31       	cpi	r24, 0x16	; 22
 712:	c9 f1       	breq	.+114    	; 0x786 <recv_msg+0x96>
 714:	81 31       	cpi	r24, 0x11	; 17
 716:	c9 f5       	brne	.+114    	; 0x78a <recv_msg+0x9a>
 718:	23 c0       	rjmp	.+70     	; 0x760 <recv_msg+0x70>
   
  case 0:
    break;
  case '\x0A':
    eeprom_save();
 71a:	73 d2       	rcall	.+1254   	; 0xc02 <eeprom_save>
 71c:	1d c0       	rjmp	.+58     	; 0x758 <recv_msg+0x68>
    new_msg("\x14ok  ");
    break;
    
  case '\x09':
    if (recived_msg[1] > 0){
 71e:	89 81       	ldd	r24, Y+1	; 0x01
 720:	88 23       	and	r24, r24
 722:	29 f0       	breq	.+10     	; 0x72e <recv_msg+0x3e>
      odesilame (recived_msg[1]);
 724:	83 df       	rcall	.-250    	; 0x62c <odesilame>
      new_msg("\x14ok  ");
 726:	8e e7       	ldi	r24, 0x7E	; 126
 728:	90 e0       	ldi	r25, 0x00	; 0
 72a:	91 de       	rcall	.-734    	; 0x44e <new_msg>
 72c:	2c c0       	rjmp	.+88     	; 0x786 <recv_msg+0x96>
      irc_send_msg(1);
      
    }
    else{
      odesilame (1); // musi to byt, aby i v pripade ze to mlci umelo odpovedet
 72e:	81 e0       	ldi	r24, 0x01	; 1
 730:	7d df       	rcall	.-262    	; 0x62c <odesilame>
      new_msg("\x14ok  ");
 732:	8e e7       	ldi	r24, 0x7E	; 126
 734:	90 e0       	ldi	r25, 0x00	; 0
 736:	8b de       	rcall	.-746    	; 0x44e <new_msg>
      odesilame (recived_msg[1]);
 738:	89 81       	ldd	r24, Y+1	; 0x01
 73a:	78 df       	rcall	.-272    	; 0x62c <odesilame>
 73c:	26 c0       	rjmp	.+76     	; 0x78a <recv_msg+0x9a>
   
      
    }
    break;
  case '\x10':
    //nastavení pøenásobovací konstanty
    set_irc_k((uint16_t)((uint16_t)(recived_msg[1] * 256) + recived_msg[2]));
 73e:	89 81       	ldd	r24, Y+1	; 0x01
 740:	99 27       	eor	r25, r25
 742:	98 2f       	mov	r25, r24
 744:	88 27       	eor	r24, r24
 746:	2a 81       	ldd	r18, Y+2	; 0x02
 748:	82 0f       	add	r24, r18
 74a:	91 1d       	adc	r25, r1
 74c:	2a d0       	rcall	.+84     	; 0x7a2 <set_irc_k>
    
    //uložení do eeprom
    eeprom_w16((void *)ee_irc_k, (uint16_t)irc_get_k());
 74e:	3b d0       	rcall	.+118    	; 0x7c6 <irc_get_k>
 750:	bc 01       	movw	r22, r24
 752:	84 e0       	ldi	r24, 0x04	; 4
 754:	90 e0       	ldi	r25, 0x00	; 0
 756:	0b d2       	rcall	.+1046   	; 0xb6e <eeprom_w16>
    new_msg("\x14ok  ");
 758:	8e e7       	ldi	r24, 0x7E	; 126
 75a:	90 e0       	ldi	r25, 0x00	; 0
 75c:	78 de       	rcall	.-784    	; 0x44e <new_msg>
 75e:	15 c0       	rjmp	.+42     	; 0x78a <recv_msg+0x9a>
    break;
    
  case '\x11':
    set_irc_set_on_value((uint32_t)((uint32_t)(recived_msg[1] * 256) + recived_msg[2]));
 760:	69 81       	ldd	r22, Y+1	; 0x01
 762:	77 27       	eor	r23, r23
 764:	76 2f       	mov	r23, r22
 766:	66 27       	eor	r22, r22
 768:	88 27       	eor	r24, r24
 76a:	77 fd       	sbrc	r23, 7
 76c:	80 95       	com	r24
 76e:	98 2f       	mov	r25, r24
 770:	2a 81       	ldd	r18, Y+2	; 0x02
 772:	62 0f       	add	r22, r18
 774:	71 1d       	adc	r23, r1
 776:	81 1d       	adc	r24, r1
 778:	91 1d       	adc	r25, r1
 77a:	b3 d1       	rcall	.+870    	; 0xae2 <set_irc_set_on_value>
 77c:	ed cf       	rjmp	.-38     	; 0x758 <recv_msg+0x68>
    new_msg("\x14ok  ");
    break;
    
  case '\x13': // vypíná pøepoèítávání prùmìru na skuteèný
    width_prepocet = recived_msg[1];
 77e:	89 81       	ldd	r24, Y+1	; 0x01
 780:	80 93 62 00 	sts	0x0062, r24
 784:	e9 cf       	rjmp	.-46     	; 0x758 <recv_msg+0x68>
    new_msg("\x14ok  ");
    break;
/*    case 8:  //vrací honoru irc_counteru 
      {
      char *s = "\x07    ";
      char *c = (char *)&irc_counter;
      
      s[1] = c[0];
      s[2] = c[1];
      s[3] = c[2];
      s[4] = c[3];
      
      new_msg(s);
      }
      break; */
  case '\x16':
    // TODO odeslání datové zprávy
    irc_send_msg(1);
 786:	81 e0       	ldi	r24, 0x01	; 1
 788:	5f d0       	rcall	.+190    	; 0x848 <irc_send_msg>
 78a:	df 91       	pop	r29
 78c:	cf 91       	pop	r28
 78e:	08 95       	ret

00000790 <irc_init>:
/* void irc_send_msg(void); */
/* void set_irc_k(uint16_t i); */
/* void set_irc_set_on_value(int32_t q); */

void irc_init(void){
 790:	ab 9a       	sbi	0x15, 3	; 21
  PORTC |= (1 << 3);
  // aby nedocházelo k vytváøení erroru pøi prvním volání irc_watch()
  prev_state = ((PINC) >> 3) & 0x07; 
 792:	83 b3       	in	r24, 0x13	; 19
 794:	86 95       	lsr	r24
 796:	86 95       	lsr	r24
 798:	86 95       	lsr	r24
 79a:	87 70       	andi	r24, 0x07	; 7
 79c:	80 93 9a 00 	sts	0x009A, r24
 7a0:	08 95       	ret

000007a2 <set_irc_k>:
}

/**
 * Funkce nastaví irc_k tak, aby pøi otoèení o jednu otáèku byla namìøená vzdálenost 
 * právì 'i'. Jinými slovy: vstupem funkce je vzdálenost v mm, kterou popojede válec 
 * pøi otoèení IRC o jednu otáèku.
 * 
 */
void set_irc_k (uint16_t i) {
 7a2:	2d e7       	ldi	r18, 0x7D	; 125
 7a4:	30 e0       	ldi	r19, 0x00	; 0
 7a6:	ac 01       	movw	r20, r24
 7a8:	42 9f       	mul	r20, r18
 7aa:	c0 01       	movw	r24, r0
 7ac:	43 9f       	mul	r20, r19
 7ae:	90 0d       	add	r25, r0
 7b0:	52 9f       	mul	r21, r18
 7b2:	90 0d       	add	r25, r0
 7b4:	11 24       	eor	r1, r1
 7b6:	66 e0       	ldi	r22, 0x06	; 6
 7b8:	70 e0       	ldi	r23, 0x00	; 0
 7ba:	c4 d3       	rcall	.+1928   	; 0xf44 <__udivmodhi4>
 7bc:	70 93 a1 00 	sts	0x00A1, r23
 7c0:	60 93 a0 00 	sts	0x00A0, r22
 7c4:	08 95       	ret

000007c6 <irc_get_k>:
  irc_k = (i * 125) / (6); //10000/480 = 125/6, 120 pulzù * 4 hrany  = 480
  
}

uint16_t irc_get_k(void){
 7c6:	80 91 a0 00 	lds	r24, 0x00A0
 7ca:	90 91 a1 00 	lds	r25, 0x00A1
 7ce:	08 95       	ret

000007d0 <irc_get_d>:
  return irc_k;
}

/// Nastavení hodnoty offsetu irc, pøi projetí kolem referenèního bodu.
///
/// param q
/// Vstupem je vzdálenost nastavovacíhoo bodu od poèátku v centimetrech vynásobená deseti,
/// tj 65 cm je 650.
void set_irc_set_on_value(int32_t q){
  // je tu jen 1000 místo 10000. Je to protože ta vstupní hodnota je pøenásobená deseti, tak je
  // tøeba jí vydìlit
  irc_set_on_value = (int32_t)(q * (10000.0 /(irc_k)));
  eeprom_w32((void *)ee_irc_set_on_value, irc_set_on_value);
}

/// V teto funkci je reseno sledovani vstupu irc a jeho nastaveni. Vzdy kdyz je
/// funkce zavolana, je zkontrolovano, zda nedoslo okd minuleho zavolani ke
/// zmene na vstupech irc. Pokud ano, jsou provedeny prislusne korky - zvyseni
/// nebo snizeni citace irc a pripadne odeslani namerene hodnoty. Namerena
/// hodnota je dana jako hodnota irc cidla krat konstanta (obvykle mensi nez
/// jedna). 
void irc_watch(void){
  unsigned char stav;
  unsigned char zmena_stavu;
  unsigned char ruzne;

  // vstupy jsou invertovany
  //stav = ((~PINC) >> 3) & 0x07;
  stav = ((PINC) >> 3) & 0x07;
  zmena_stavu = stav ^ prev_state;
  ruzne = (((stav >> 2) ^ (stav >> 1)) & 0x01);

  // zde se resi pricitani a odecitani pri zmenach vstupu A a B Jestlize dojde
  // ke zmene nektereho vstupu, pak se porovna zda jsou oba bity stejne, ci ne
  // a podle toho se citac bud inkrementuje nebo dekrementuje.
  // Rovnez je zde resen erroru pri soucasne zmene obou vstupu.
  switch ((zmena_stavu >> 1) & 0x03){
    case 1 : 
      // zmenaA
      if (ruzne == 0){
        irc_counter++;
        last_oper_with_irc_counter = 1;
        irc_send_msg(0);
      }
      else{
        irc_counter--;
        last_oper_with_irc_counter = 0;
        irc_send_msg(0);
      }
      break;
    case 2 :
      // zmenaB
      if (ruzne == 0){
        irc_counter--;
        last_oper_with_irc_counter = 0;
        irc_send_msg(0);
      }
      else{
        irc_counter++;
        last_oper_with_irc_counter = 1;
        irc_send_msg(0);
      }
      break;
    case 3 :
      // oba
      // error
      new_msg("\004ircb     ");
      break;
    default : 
      break;

  }

  // zde je reseno nastavovani irc citace
  // pokud se objevi jednicka na pinc.6 a pohybujeme se nahoru (nula je tam
  // pri obraceni vstupu)
  //
  if ((((zmena_stavu ) & 0x01 ) == 1) && (last_oper_with_irc_counter == 1) && (((stav & 0x01) == 1))){
    int dif = 0;

    dif = irc_set_on_value - irc_counter;
    if (dif < 0)
      dif = -1 * dif;

    dif = dif * 0.0001 * irc_k;

    irc_dif_msg[0] = 5;
    irc_dif_msg[1] = dif / 256;
    irc_dif_msg[2] = dif % 256;
    irc_dif_msg[3] = 0;
    irc_dif_msg[4] = 0;

    irc_counter = irc_set_on_value;


    irc_send_msg(1);

    if ((dif * 0.0001 * irc_k) > 10){
      new_msg(irc_dif_msg);
    }
    
  }
  

    
  prev_state = stav;
  
}

/**
 * Tato funkce je volána pøi každé zmìnì èítaèe irc. Zde je realizován pøed
 * odesláním je zde zrealizován pøepoèet mezi nasèítanými kroky z irc a
 * skuteèou hodnotou. Pokud již byla odeslána zpráva se stejnými daty (a
 * paramer sure je <= nule) nic se neodesílá.
 * @param sure Je-li hodnota vìtší než nula, je zpráva odeslána bez ohledu na to,
 * zda již nebyla odeslána stejná zpráva se stejnými daty.
 */
void irc_send_msg(char sure){
  unsigned int count;
  char ch1 = 0;
  char ch2 = 0;
  char ch3, ch4;
  uint16_t w;

  //ch = irc_counter * (0.1) * irc_k;
  count = irc_get_d();
  w = get_d_h();

  //rozložím si integer na dva chary a ty pak odešlu
  // výstup je v setinách milimetru. Je tøeba jej vydìlit 1000 aby byl v cm
  ch1 = (char) count;
  ch2 = (char) (count / 256);
 
  ch3 = (char) (w % 256);
  ch4 = (char) (w / 256);

  // odesilame jen pokud doslo ke zmene v vertikalnim nebo horizontalnim
  if ((ch1 != data_msg[1])|(ch2 != data_msg[2])|(ch3 != data_msg[3])|(ch4 != data_msg[4])|(sure > 0)){
    //data_msg[1] = ch;
    //

    data_msg[1] = ch1;
    data_msg[2] = ch2;
    
    data_msg[3] = ch3;
    data_msg[4] = ch4;
    data_msg[5] = 0;
    data_msg[6] = 0;

    //new_msg("jojoj");
    new_msg(data_msg);
  }
  
}

uint16_t irc_get_d(void){
 7d0:	cf 92       	push	r12
 7d2:	df 92       	push	r13
 7d4:	ef 92       	push	r14
 7d6:	ff 92       	push	r15
 7d8:	0f 93       	push	r16
 7da:	1f 93       	push	r17
 7dc:	60 91 9b 00 	lds	r22, 0x009B
 7e0:	70 91 9c 00 	lds	r23, 0x009C
 7e4:	80 91 9d 00 	lds	r24, 0x009D
 7e8:	90 91 9e 00 	lds	r25, 0x009E
 7ec:	97 ff       	sbrs	r25, 7
 7ee:	04 c0       	rjmp	.+8      	; 0x7f8 <irc_get_d+0x28>
 7f0:	60 e0       	ldi	r22, 0x00	; 0
 7f2:	70 e0       	ldi	r23, 0x00	; 0
 7f4:	80 e0       	ldi	r24, 0x00	; 0
 7f6:	90 e0       	ldi	r25, 0x00	; 0
 7f8:	e3 d2       	rcall	.+1478   	; 0xdc0 <__floatsisf>
 7fa:	27 e1       	ldi	r18, 0x17	; 23
 7fc:	37 eb       	ldi	r19, 0xB7	; 183
 7fe:	41 ed       	ldi	r20, 0xD1	; 209
 800:	58 e3       	ldi	r21, 0x38	; 56
 802:	58 d3       	rcall	.+1712   	; 0xeb4 <__mulsf3>
 804:	6b 01       	movw	r12, r22
 806:	7c 01       	movw	r14, r24
 808:	00 91 a0 00 	lds	r16, 0x00A0
 80c:	10 91 a1 00 	lds	r17, 0x00A1
 810:	b8 01       	movw	r22, r16
 812:	88 27       	eor	r24, r24
 814:	77 fd       	sbrc	r23, 7
 816:	80 95       	com	r24
 818:	98 2f       	mov	r25, r24
 81a:	d2 d2       	rcall	.+1444   	; 0xdc0 <__floatsisf>
 81c:	17 ff       	sbrs	r17, 7
 81e:	05 c0       	rjmp	.+10     	; 0x82a <irc_get_d+0x5a>
 820:	20 e0       	ldi	r18, 0x00	; 0
 822:	30 e0       	ldi	r19, 0x00	; 0
 824:	40 e8       	ldi	r20, 0x80	; 128
 826:	57 e4       	ldi	r21, 0x47	; 71
 828:	26 d2       	rcall	.+1100   	; 0xc76 <__addsf3>
 82a:	9b 01       	movw	r18, r22
 82c:	ac 01       	movw	r20, r24
 82e:	c7 01       	movw	r24, r14
 830:	b6 01       	movw	r22, r12
 832:	40 d3       	rcall	.+1664   	; 0xeb4 <__mulsf3>
 834:	a8 d2       	rcall	.+1360   	; 0xd86 <__fixsfsi>
 836:	dc 01       	movw	r26, r24
 838:	cb 01       	movw	r24, r22
 83a:	1f 91       	pop	r17
 83c:	0f 91       	pop	r16
 83e:	ff 90       	pop	r15
 840:	ef 90       	pop	r14
 842:	df 90       	pop	r13
 844:	cf 90       	pop	r12
 846:	08 95       	ret

00000848 <irc_send_msg>:
 848:	ef 92       	push	r14
 84a:	ff 92       	push	r15
 84c:	0f 93       	push	r16
 84e:	1f 93       	push	r17
 850:	cf 93       	push	r28
 852:	df 93       	push	r29
 854:	e8 2e       	mov	r14, r24
 856:	bc df       	rcall	.-136    	; 0x7d0 <irc_get_d>
 858:	ec 01       	movw	r28, r24
 85a:	77 dc       	rcall	.-1810   	; 0x14a <get_d_h>
 85c:	bc 01       	movw	r22, r24
 85e:	2c 2f       	mov	r18, r28
 860:	0d 2f       	mov	r16, r29
 862:	11 27       	eor	r17, r17
 864:	30 2f       	mov	r19, r16
 866:	f6 2e       	mov	r15, r22
 868:	a7 2f       	mov	r26, r23
 86a:	bb 27       	eor	r27, r27
 86c:	e0 e0       	ldi	r30, 0x00	; 0
 86e:	f0 e0       	ldi	r31, 0x00	; 0
 870:	80 91 a6 00 	lds	r24, 0x00A6
 874:	8a 17       	cp	r24, r26
 876:	11 f0       	breq	.+4      	; 0x87c <irc_send_msg+0x34>
 878:	e1 e0       	ldi	r30, 0x01	; 1
 87a:	f0 e0       	ldi	r31, 0x00	; 0
 87c:	90 e0       	ldi	r25, 0x00	; 0
 87e:	80 91 a3 00 	lds	r24, 0x00A3
 882:	28 13       	cpse	r18, r24
 884:	91 e0       	ldi	r25, 0x01	; 1
 886:	20 e0       	ldi	r18, 0x00	; 0
 888:	80 91 a4 00 	lds	r24, 0x00A4
 88c:	38 13       	cpse	r19, r24
 88e:	21 e0       	ldi	r18, 0x01	; 1
 890:	92 2b       	or	r25, r18
 892:	29 2f       	mov	r18, r25
 894:	33 27       	eor	r19, r19
 896:	40 e0       	ldi	r20, 0x00	; 0
 898:	50 e0       	ldi	r21, 0x00	; 0
 89a:	80 91 a5 00 	lds	r24, 0x00A5
 89e:	f8 16       	cp	r15, r24
 8a0:	11 f0       	breq	.+4      	; 0x8a6 <irc_send_msg+0x5e>
 8a2:	41 e0       	ldi	r20, 0x01	; 1
 8a4:	50 e0       	ldi	r21, 0x00	; 0
 8a6:	24 2b       	or	r18, r20
 8a8:	35 2b       	or	r19, r21
 8aa:	40 e0       	ldi	r20, 0x00	; 0
 8ac:	50 e0       	ldi	r21, 0x00	; 0
 8ae:	ee 20       	and	r14, r14
 8b0:	11 f0       	breq	.+4      	; 0x8b6 <irc_send_msg+0x6e>
 8b2:	41 e0       	ldi	r20, 0x01	; 1
 8b4:	50 e0       	ldi	r21, 0x00	; 0
 8b6:	24 2b       	or	r18, r20
 8b8:	35 2b       	or	r19, r21
 8ba:	e2 2b       	or	r30, r18
 8bc:	f3 2b       	or	r31, r19
 8be:	ef 2b       	or	r30, r31
 8c0:	79 f0       	breq	.+30     	; 0x8e0 <irc_send_msg+0x98>
 8c2:	c0 93 a3 00 	sts	0x00A3, r28
 8c6:	00 93 a4 00 	sts	0x00A4, r16
 8ca:	60 93 a5 00 	sts	0x00A5, r22
 8ce:	a0 93 a6 00 	sts	0x00A6, r26
 8d2:	10 92 a7 00 	sts	0x00A7, r1
 8d6:	10 92 a8 00 	sts	0x00A8, r1
 8da:	82 ea       	ldi	r24, 0xA2	; 162
 8dc:	90 e0       	ldi	r25, 0x00	; 0
 8de:	b7 dd       	rcall	.-1170   	; 0x44e <new_msg>
 8e0:	df 91       	pop	r29
 8e2:	cf 91       	pop	r28
 8e4:	1f 91       	pop	r17
 8e6:	0f 91       	pop	r16
 8e8:	ff 90       	pop	r15
 8ea:	ef 90       	pop	r14
 8ec:	08 95       	ret

000008ee <irc_watch>:
 8ee:	7f 92       	push	r7
 8f0:	8f 92       	push	r8
 8f2:	9f 92       	push	r9
 8f4:	af 92       	push	r10
 8f6:	bf 92       	push	r11
 8f8:	cf 92       	push	r12
 8fa:	df 92       	push	r13
 8fc:	ef 92       	push	r14
 8fe:	ff 92       	push	r15
 900:	0f 93       	push	r16
 902:	1f 93       	push	r17
 904:	73 b2       	in	r7, 0x13	; 19
 906:	76 94       	lsr	r7
 908:	76 94       	lsr	r7
 90a:	76 94       	lsr	r7
 90c:	87 e0       	ldi	r24, 0x07	; 7
 90e:	78 22       	and	r7, r24
 910:	00 91 9a 00 	lds	r16, 0x009A
 914:	07 25       	eor	r16, r7
 916:	27 2d       	mov	r18, r7
 918:	26 95       	lsr	r18
 91a:	26 95       	lsr	r18
 91c:	87 2d       	mov	r24, r7
 91e:	86 95       	lsr	r24
 920:	28 27       	eor	r18, r24
 922:	21 70       	andi	r18, 0x01	; 1
 924:	80 2f       	mov	r24, r16
 926:	86 95       	lsr	r24
 928:	99 27       	eor	r25, r25
 92a:	83 70       	andi	r24, 0x03	; 3
 92c:	90 70       	andi	r25, 0x00	; 0
 92e:	82 30       	cpi	r24, 0x02	; 2
 930:	91 05       	cpc	r25, r1
 932:	f9 f0       	breq	.+62     	; 0x972 <irc_watch+0x84>
 934:	83 30       	cpi	r24, 0x03	; 3
 936:	91 05       	cpc	r25, r1
 938:	a9 f1       	breq	.+106    	; 0x9a4 <irc_watch+0xb6>
 93a:	01 97       	sbiw	r24, 0x01	; 1
 93c:	b1 f5       	brne	.+108    	; 0x9aa <irc_watch+0xbc>
 93e:	80 91 9b 00 	lds	r24, 0x009B
 942:	90 91 9c 00 	lds	r25, 0x009C
 946:	a0 91 9d 00 	lds	r26, 0x009D
 94a:	b0 91 9e 00 	lds	r27, 0x009E
 94e:	22 23       	and	r18, r18
 950:	d1 f0       	breq	.+52     	; 0x986 <irc_watch+0x98>
 952:	01 97       	sbiw	r24, 0x01	; 1
 954:	a1 09       	sbc	r26, r1
 956:	b1 09       	sbc	r27, r1
 958:	80 93 9b 00 	sts	0x009B, r24
 95c:	90 93 9c 00 	sts	0x009C, r25
 960:	a0 93 9d 00 	sts	0x009D, r26
 964:	b0 93 9e 00 	sts	0x009E, r27
 968:	10 92 9f 00 	sts	0x009F, r1
 96c:	80 e0       	ldi	r24, 0x00	; 0
 96e:	6c df       	rcall	.-296    	; 0x848 <irc_send_msg>
 970:	1c c0       	rjmp	.+56     	; 0x9aa <irc_watch+0xbc>
 972:	80 91 9b 00 	lds	r24, 0x009B
 976:	90 91 9c 00 	lds	r25, 0x009C
 97a:	a0 91 9d 00 	lds	r26, 0x009D
 97e:	b0 91 9e 00 	lds	r27, 0x009E
 982:	22 23       	and	r18, r18
 984:	31 f3       	breq	.-52     	; 0x952 <irc_watch+0x64>
 986:	01 96       	adiw	r24, 0x01	; 1
 988:	a1 1d       	adc	r26, r1
 98a:	b1 1d       	adc	r27, r1
 98c:	80 93 9b 00 	sts	0x009B, r24
 990:	90 93 9c 00 	sts	0x009C, r25
 994:	a0 93 9d 00 	sts	0x009D, r26
 998:	b0 93 9e 00 	sts	0x009E, r27
 99c:	81 e0       	ldi	r24, 0x01	; 1
 99e:	80 93 9f 00 	sts	0x009F, r24
 9a2:	e4 cf       	rjmp	.-56     	; 0x96c <irc_watch+0x7e>
 9a4:	84 e8       	ldi	r24, 0x84	; 132
 9a6:	90 e0       	ldi	r25, 0x00	; 0
 9a8:	52 dd       	rcall	.-1372   	; 0x44e <new_msg>
 9aa:	00 ff       	sbrs	r16, 0
 9ac:	8c c0       	rjmp	.+280    	; 0xac6 <irc_watch+0x1d8>
 9ae:	80 91 9f 00 	lds	r24, 0x009F
 9b2:	81 30       	cpi	r24, 0x01	; 1
 9b4:	09 f0       	breq	.+2      	; 0x9b8 <irc_watch+0xca>
 9b6:	87 c0       	rjmp	.+270    	; 0xac6 <irc_watch+0x1d8>
 9b8:	70 fe       	sbrs	r7, 0
 9ba:	85 c0       	rjmp	.+266    	; 0xac6 <irc_watch+0x1d8>
 9bc:	80 90 8f 00 	lds	r8, 0x008F
 9c0:	90 90 90 00 	lds	r9, 0x0090
 9c4:	a0 90 91 00 	lds	r10, 0x0091
 9c8:	b0 90 92 00 	lds	r11, 0x0092
 9cc:	80 91 9b 00 	lds	r24, 0x009B
 9d0:	90 91 9c 00 	lds	r25, 0x009C
 9d4:	b4 01       	movw	r22, r8
 9d6:	68 1b       	sub	r22, r24
 9d8:	79 0b       	sbc	r23, r25
 9da:	77 ff       	sbrs	r23, 7
 9dc:	03 c0       	rjmp	.+6      	; 0x9e4 <irc_watch+0xf6>
 9de:	70 95       	com	r23
 9e0:	61 95       	neg	r22
 9e2:	7f 4f       	sbci	r23, 0xFF	; 255
 9e4:	88 27       	eor	r24, r24
 9e6:	77 fd       	sbrc	r23, 7
 9e8:	80 95       	com	r24
 9ea:	98 2f       	mov	r25, r24
 9ec:	e9 d1       	rcall	.+978    	; 0xdc0 <__floatsisf>
 9ee:	27 e1       	ldi	r18, 0x17	; 23
 9f0:	37 eb       	ldi	r19, 0xB7	; 183
 9f2:	41 ed       	ldi	r20, 0xD1	; 209
 9f4:	58 e3       	ldi	r21, 0x38	; 56
 9f6:	5e d2       	rcall	.+1212   	; 0xeb4 <__mulsf3>
 9f8:	6b 01       	movw	r12, r22
 9fa:	7c 01       	movw	r14, r24
 9fc:	00 91 a0 00 	lds	r16, 0x00A0
 a00:	10 91 a1 00 	lds	r17, 0x00A1
 a04:	b8 01       	movw	r22, r16
 a06:	88 27       	eor	r24, r24
 a08:	77 fd       	sbrc	r23, 7
 a0a:	80 95       	com	r24
 a0c:	98 2f       	mov	r25, r24
 a0e:	d8 d1       	rcall	.+944    	; 0xdc0 <__floatsisf>
 a10:	17 ff       	sbrs	r17, 7
 a12:	05 c0       	rjmp	.+10     	; 0xa1e <irc_watch+0x130>
 a14:	20 e0       	ldi	r18, 0x00	; 0
 a16:	30 e0       	ldi	r19, 0x00	; 0
 a18:	40 e8       	ldi	r20, 0x80	; 128
 a1a:	57 e4       	ldi	r21, 0x47	; 71
 a1c:	2c d1       	rcall	.+600    	; 0xc76 <__addsf3>
 a1e:	9b 01       	movw	r18, r22
 a20:	ac 01       	movw	r20, r24
 a22:	c7 01       	movw	r24, r14
 a24:	b6 01       	movw	r22, r12
 a26:	46 d2       	rcall	.+1164   	; 0xeb4 <__mulsf3>
 a28:	ae d1       	rcall	.+860    	; 0xd86 <__fixsfsi>
 a2a:	8b 01       	movw	r16, r22
 a2c:	9c 01       	movw	r18, r24
 a2e:	6b 01       	movw	r12, r22
 a30:	85 e0       	ldi	r24, 0x05	; 5
 a32:	80 93 86 01 	sts	0x0186, r24
 a36:	c8 01       	movw	r24, r16
 a38:	60 e0       	ldi	r22, 0x00	; 0
 a3a:	71 e0       	ldi	r23, 0x01	; 1
 a3c:	97 d2       	rcall	.+1326   	; 0xf6c <__divmodhi4>
 a3e:	60 93 87 01 	sts	0x0187, r22
 a42:	c8 01       	movw	r24, r16
 a44:	60 e0       	ldi	r22, 0x00	; 0
 a46:	71 e0       	ldi	r23, 0x01	; 1
 a48:	91 d2       	rcall	.+1314   	; 0xf6c <__divmodhi4>
 a4a:	80 93 88 01 	sts	0x0188, r24
 a4e:	10 92 89 01 	sts	0x0189, r1
 a52:	10 92 8a 01 	sts	0x018A, r1
 a56:	80 92 9b 00 	sts	0x009B, r8
 a5a:	90 92 9c 00 	sts	0x009C, r9
 a5e:	a0 92 9d 00 	sts	0x009D, r10
 a62:	b0 92 9e 00 	sts	0x009E, r11
 a66:	81 e0       	ldi	r24, 0x01	; 1
 a68:	ef de       	rcall	.-546    	; 0x848 <irc_send_msg>
 a6a:	ee 24       	eor	r14, r14
 a6c:	d7 fc       	sbrc	r13, 7
 a6e:	e0 94       	com	r14
 a70:	fe 2c       	mov	r15, r14
 a72:	c7 01       	movw	r24, r14
 a74:	b6 01       	movw	r22, r12
 a76:	a4 d1       	rcall	.+840    	; 0xdc0 <__floatsisf>
 a78:	27 e1       	ldi	r18, 0x17	; 23
 a7a:	37 eb       	ldi	r19, 0xB7	; 183
 a7c:	41 ed       	ldi	r20, 0xD1	; 209
 a7e:	58 e3       	ldi	r21, 0x38	; 56
 a80:	19 d2       	rcall	.+1074   	; 0xeb4 <__mulsf3>
 a82:	6b 01       	movw	r12, r22
 a84:	7c 01       	movw	r14, r24
 a86:	00 91 a0 00 	lds	r16, 0x00A0
 a8a:	10 91 a1 00 	lds	r17, 0x00A1
 a8e:	b8 01       	movw	r22, r16
 a90:	88 27       	eor	r24, r24
 a92:	77 fd       	sbrc	r23, 7
 a94:	80 95       	com	r24
 a96:	98 2f       	mov	r25, r24
 a98:	93 d1       	rcall	.+806    	; 0xdc0 <__floatsisf>
 a9a:	17 ff       	sbrs	r17, 7
 a9c:	05 c0       	rjmp	.+10     	; 0xaa8 <irc_watch+0x1ba>
 a9e:	20 e0       	ldi	r18, 0x00	; 0
 aa0:	30 e0       	ldi	r19, 0x00	; 0
 aa2:	40 e8       	ldi	r20, 0x80	; 128
 aa4:	57 e4       	ldi	r21, 0x47	; 71
 aa6:	e7 d0       	rcall	.+462    	; 0xc76 <__addsf3>
 aa8:	9b 01       	movw	r18, r22
 aaa:	ac 01       	movw	r20, r24
 aac:	c7 01       	movw	r24, r14
 aae:	b6 01       	movw	r22, r12
 ab0:	01 d2       	rcall	.+1026   	; 0xeb4 <__mulsf3>
 ab2:	20 e0       	ldi	r18, 0x00	; 0
 ab4:	30 e0       	ldi	r19, 0x00	; 0
 ab6:	40 e2       	ldi	r20, 0x20	; 32
 ab8:	51 e4       	ldi	r21, 0x41	; 65
 aba:	8f d1       	rcall	.+798    	; 0xdda <__gesf2>
 abc:	18 16       	cp	r1, r24
 abe:	1c f4       	brge	.+6      	; 0xac6 <irc_watch+0x1d8>
 ac0:	86 e8       	ldi	r24, 0x86	; 134
 ac2:	91 e0       	ldi	r25, 0x01	; 1
 ac4:	c4 dc       	rcall	.-1656   	; 0x44e <new_msg>
 ac6:	70 92 9a 00 	sts	0x009A, r7
 aca:	1f 91       	pop	r17
 acc:	0f 91       	pop	r16
 ace:	ff 90       	pop	r15
 ad0:	ef 90       	pop	r14
 ad2:	df 90       	pop	r13
 ad4:	cf 90       	pop	r12
 ad6:	bf 90       	pop	r11
 ad8:	af 90       	pop	r10
 ada:	9f 90       	pop	r9
 adc:	8f 90       	pop	r8
 ade:	7f 90       	pop	r7
 ae0:	08 95       	ret

00000ae2 <set_irc_set_on_value>:
 ae2:	cf 92       	push	r12
 ae4:	df 92       	push	r13
 ae6:	ef 92       	push	r14
 ae8:	ff 92       	push	r15
 aea:	0f 93       	push	r16
 aec:	1f 93       	push	r17
 aee:	68 d1       	rcall	.+720    	; 0xdc0 <__floatsisf>
 af0:	6b 01       	movw	r12, r22
 af2:	7c 01       	movw	r14, r24
 af4:	00 91 a0 00 	lds	r16, 0x00A0
 af8:	10 91 a1 00 	lds	r17, 0x00A1
 afc:	b8 01       	movw	r22, r16
 afe:	88 27       	eor	r24, r24
 b00:	77 fd       	sbrc	r23, 7
 b02:	80 95       	com	r24
 b04:	98 2f       	mov	r25, r24
 b06:	5c d1       	rcall	.+696    	; 0xdc0 <__floatsisf>
 b08:	17 ff       	sbrs	r17, 7
 b0a:	05 c0       	rjmp	.+10     	; 0xb16 <set_irc_set_on_value+0x34>
 b0c:	20 e0       	ldi	r18, 0x00	; 0
 b0e:	30 e0       	ldi	r19, 0x00	; 0
 b10:	40 e8       	ldi	r20, 0x80	; 128
 b12:	57 e4       	ldi	r21, 0x47	; 71
 b14:	b0 d0       	rcall	.+352    	; 0xc76 <__addsf3>
 b16:	9b 01       	movw	r18, r22
 b18:	ac 01       	movw	r20, r24
 b1a:	60 e0       	ldi	r22, 0x00	; 0
 b1c:	70 e4       	ldi	r23, 0x40	; 64
 b1e:	8c e1       	ldi	r24, 0x1C	; 28
 b20:	96 e4       	ldi	r25, 0x46	; 70
 b22:	eb d0       	rcall	.+470    	; 0xcfa <__divsf3>
 b24:	9b 01       	movw	r18, r22
 b26:	ac 01       	movw	r20, r24
 b28:	c7 01       	movw	r24, r14
 b2a:	b6 01       	movw	r22, r12
 b2c:	c3 d1       	rcall	.+902    	; 0xeb4 <__mulsf3>
 b2e:	2b d1       	rcall	.+598    	; 0xd86 <__fixsfsi>
 b30:	ab 01       	movw	r20, r22
 b32:	bc 01       	movw	r22, r24
 b34:	40 93 8f 00 	sts	0x008F, r20
 b38:	50 93 90 00 	sts	0x0090, r21
 b3c:	60 93 91 00 	sts	0x0091, r22
 b40:	70 93 92 00 	sts	0x0092, r23
 b44:	86 e0       	ldi	r24, 0x06	; 6
 b46:	90 e0       	ldi	r25, 0x00	; 0
 b48:	3d d0       	rcall	.+122    	; 0xbc4 <eeprom_w32>
 b4a:	1f 91       	pop	r17
 b4c:	0f 91       	pop	r16
 b4e:	ff 90       	pop	r15
 b50:	ef 90       	pop	r14
 b52:	df 90       	pop	r13
 b54:	cf 90       	pop	r12
 b56:	08 95       	ret

00000b58 <eeprom_w8>:
  eeprom_w32((void *)ee_irc_counter, irc_counter);
}

//8 bit
void eeprom_w8(void *uiAddress, uint8_t c){
 b58:	dc 01       	movw	r26, r24
  //cekame dokud neni volno
  eeprom_busy_wait();
 b5a:	e1 99       	sbic	0x1c, 1	; 28
 b5c:	fe cf       	rjmp	.-4      	; 0xb5a <eeprom_w8+0x2>

void 
eeprom_write_byte (uint8_t *addr,uint8_t value)
{
  __asm__ __volatile__ (
 b5e:	06 2e       	mov	r0, r22
 b60:	2a d2       	rcall	.+1108   	; 0xfb6 <__eeprom_write_byte_1C1D1E>
 b62:	08 95       	ret

00000b64 <eeprom_r8>:
  eeprom_write_byte(uiAddress, c);
  
}

char eeprom_r8(void *uiAddress){
 b64:	dc 01       	movw	r26, r24
 b66:	15 d2       	rcall	.+1066   	; 0xf92 <__eeprom_read_byte_1C1D1E>
 b68:	80 2d       	mov	r24, r0
  return eeprom_read_byte(uiAddress);
}
 b6a:	99 27       	eor	r25, r25
 b6c:	08 95       	ret

00000b6e <eeprom_w16>:


//16bit
void eeprom_w16(void *uiAddress, uint16_t word){
 b6e:	dc 01       	movw	r26, r24
  //cekame dokud neni volno
  eeprom_busy_wait();
 b70:	e1 99       	sbic	0x1c, 1	; 28
 b72:	fe cf       	rjmp	.-4      	; 0xb70 <eeprom_w16+0x2>

void 
eeprom_write_word (uint16_t *addr,uint16_t value)
{
  __asm__ __volatile__ (
 b74:	0b 01       	movw	r0, r22
 b76:	2b d2       	rcall	.+1110   	; 0xfce <__eeprom_write_word_1C1D1E>
 b78:	08 95       	ret

00000b7a <eeprom_r16>:
  eeprom_write_word(uiAddress, word);
  
}

uint16_t eeprom_r16(void *uiAddress){
 b7a:	dc 01       	movw	r26, r24
 b7c:	17 d2       	rcall	.+1070   	; 0xfac <__eeprom_read_word_1C1D1E>
 b7e:	cf 01       	movw	r24, r30
 b80:	08 95       	ret

00000b82 <eeprom_r32>:
  return eeprom_read_word(uiAddress);
}

//32bit
void eeprom_w32(void *uiAddress, uint32_t data){
  //cekame dokud neni volno
  eeprom_busy_wait();
  eeprom_write_block( (void *)&data, uiAddress, 4);
}

uint32_t eeprom_r32(void *uiAddress){
 b82:	cf 93       	push	r28
 b84:	df 93       	push	r29
 b86:	cd b7       	in	r28, 0x3d	; 61
 b88:	de b7       	in	r29, 0x3e	; 62
 b8a:	24 97       	sbiw	r28, 0x04	; 4
 b8c:	0f b6       	in	r0, 0x3f	; 63
 b8e:	f8 94       	cli
 b90:	de bf       	out	0x3e, r29	; 62
 b92:	0f be       	out	0x3f, r0	; 63
 b94:	cd bf       	out	0x3d, r28	; 61
  uint32_t out = 0;
 b96:	19 82       	std	Y+1, r1	; 0x01
 b98:	1a 82       	std	Y+2, r1	; 0x02
 b9a:	1b 82       	std	Y+3, r1	; 0x03
 b9c:	1c 82       	std	Y+4, r1	; 0x04
              /* Needed in order to truncate to 8 bit.  */
              uint8_t len;
              len = (uint8_t) n; 

              __asm__ __volatile__ (
 b9e:	24 e0       	ldi	r18, 0x04	; 4
 ba0:	fe 01       	movw	r30, r28
 ba2:	31 96       	adiw	r30, 0x01	; 1
 ba4:	dc 01       	movw	r26, r24
 ba6:	12 2e       	mov	r1, r18
 ba8:	fc d1       	rcall	.+1016   	; 0xfa2 <__eeprom_read_block_1C1D1E>
 baa:	69 81       	ldd	r22, Y+1	; 0x01
 bac:	7a 81       	ldd	r23, Y+2	; 0x02
 bae:	8b 81       	ldd	r24, Y+3	; 0x03
 bb0:	9c 81       	ldd	r25, Y+4	; 0x04
 bb2:	24 96       	adiw	r28, 0x04	; 4
 bb4:	0f b6       	in	r0, 0x3f	; 63
 bb6:	f8 94       	cli
 bb8:	de bf       	out	0x3e, r29	; 62
 bba:	0f be       	out	0x3f, r0	; 63
 bbc:	cd bf       	out	0x3d, r28	; 61
 bbe:	df 91       	pop	r29
 bc0:	cf 91       	pop	r28
 bc2:	08 95       	ret

00000bc4 <eeprom_w32>:
 bc4:	cf 93       	push	r28
 bc6:	df 93       	push	r29
 bc8:	cd b7       	in	r28, 0x3d	; 61
 bca:	de b7       	in	r29, 0x3e	; 62
 bcc:	24 97       	sbiw	r28, 0x04	; 4
 bce:	0f b6       	in	r0, 0x3f	; 63
 bd0:	f8 94       	cli
 bd2:	de bf       	out	0x3e, r29	; 62
 bd4:	0f be       	out	0x3f, r0	; 63
 bd6:	cd bf       	out	0x3d, r28	; 61
 bd8:	dc 01       	movw	r26, r24
 bda:	49 83       	std	Y+1, r20	; 0x01
 bdc:	5a 83       	std	Y+2, r21	; 0x02
 bde:	6b 83       	std	Y+3, r22	; 0x03
 be0:	7c 83       	std	Y+4, r23	; 0x04
 be2:	e1 99       	sbic	0x1c, 1	; 28
 be4:	fe cf       	rjmp	.-4      	; 0xbe2 <eeprom_w32+0x1e>
            {
              uint8_t len;
              len = (uint8_t) n;

              __asm__ __volatile__ (
 be6:	84 e0       	ldi	r24, 0x04	; 4
 be8:	fe 01       	movw	r30, r28
 bea:	31 96       	adiw	r30, 0x01	; 1
 bec:	18 2e       	mov	r1, r24
 bee:	f4 d1       	rcall	.+1000   	; 0xfd8 <__eeprom_write_block_1C1D1E>
 bf0:	24 96       	adiw	r28, 0x04	; 4
 bf2:	0f b6       	in	r0, 0x3f	; 63
 bf4:	f8 94       	cli
 bf6:	de bf       	out	0x3e, r29	; 62
 bf8:	0f be       	out	0x3f, r0	; 63
 bfa:	cd bf       	out	0x3d, r28	; 61
 bfc:	df 91       	pop	r29
 bfe:	cf 91       	pop	r28
 c00:	08 95       	ret

00000c02 <eeprom_save>:
 c02:	40 91 9b 00 	lds	r20, 0x009B
 c06:	50 91 9c 00 	lds	r21, 0x009C
 c0a:	60 91 9d 00 	lds	r22, 0x009D
 c0e:	70 91 9e 00 	lds	r23, 0x009E
 c12:	80 e0       	ldi	r24, 0x00	; 0
 c14:	90 e0       	ldi	r25, 0x00	; 0
 c16:	d6 df       	rcall	.-84     	; 0xbc4 <eeprom_w32>
 c18:	08 95       	ret

00000c1a <eeprom_load>:
 c1a:	80 e0       	ldi	r24, 0x00	; 0
 c1c:	90 e0       	ldi	r25, 0x00	; 0
 c1e:	b1 df       	rcall	.-158    	; 0xb82 <eeprom_r32>
 c20:	60 93 9b 00 	sts	0x009B, r22
 c24:	70 93 9c 00 	sts	0x009C, r23
 c28:	80 93 9d 00 	sts	0x009D, r24
 c2c:	90 93 9e 00 	sts	0x009E, r25
eeprom_read_word (const uint16_t *addr)
{
  uint16_t result;

  __asm__ __volatile__ (
 c30:	a4 e0       	ldi	r26, 0x04	; 4
 c32:	b0 e0       	ldi	r27, 0x00	; 0
 c34:	bb d1       	rcall	.+886    	; 0xfac <__eeprom_read_word_1C1D1E>
 c36:	f0 93 a1 00 	sts	0x00A1, r31
 c3a:	e0 93 a0 00 	sts	0x00A0, r30
 c3e:	86 e0       	ldi	r24, 0x06	; 6
 c40:	90 e0       	ldi	r25, 0x00	; 0
 c42:	9f df       	rcall	.-194    	; 0xb82 <eeprom_r32>
 c44:	60 93 8f 00 	sts	0x008F, r22
 c48:	70 93 90 00 	sts	0x0090, r23
 c4c:	80 93 91 00 	sts	0x0091, r24
 c50:	90 93 92 00 	sts	0x0092, r25
 c54:	80 91 a0 00 	lds	r24, 0x00A0
 c58:	90 91 a1 00 	lds	r25, 0x00A1
 c5c:	81 51       	subi	r24, 0x11	; 17
 c5e:	97 42       	sbci	r25, 0x27	; 39
 c60:	40 f0       	brcs	.+16     	; 0xc72 <eeprom_load+0x58>
 c62:	89 ea       	ldi	r24, 0xA9	; 169
 c64:	91 e0       	ldi	r25, 0x01	; 1
 c66:	9d dd       	rcall	.-1222   	; 0x7a2 <set_irc_k>
 c68:	62 ec       	ldi	r22, 0xC2	; 194
 c6a:	71 e0       	ldi	r23, 0x01	; 1
 c6c:	80 e0       	ldi	r24, 0x00	; 0
 c6e:	90 e0       	ldi	r25, 0x00	; 0
 c70:	38 df       	rcall	.-400    	; 0xae2 <set_irc_set_on_value>
 c72:	08 95       	ret

00000c74 <__subsf3>:
 c74:	50 58       	subi	r21, 0x80	; 128

00000c76 <__addsf3>:
 c76:	19 2e       	mov	r1, r25
 c78:	ef d0       	rcall	.+478    	; 0xe58 <__fp_split3>
 c7a:	01 d0       	rcall	.+2      	; 0xc7e <__addsf3x>
 c7c:	d2 c0       	rjmp	.+420    	; 0xe22 <__fp_merge>

00000c7e <__addsf3x>:
 c7e:	ba 17       	cp	r27, r26
 c80:	62 07       	cpc	r22, r18
 c82:	73 07       	cpc	r23, r19
 c84:	84 07       	cpc	r24, r20
 c86:	95 07       	cpc	r25, r21
 c88:	b1 f1       	breq	.+108    	; 0xcf6 <__addsf3x+0x78>
 c8a:	88 f4       	brcc	.+34     	; 0xcae <__addsf3x+0x30>
 c8c:	0e f4       	brtc	.+2      	; 0xc90 <__addsf3x+0x12>
 c8e:	10 94       	com	r1
 c90:	0b 2e       	mov	r0, r27
 c92:	ba 2f       	mov	r27, r26
 c94:	a0 2d       	mov	r26, r0
 c96:	06 2e       	mov	r0, r22
 c98:	62 2f       	mov	r22, r18
 c9a:	20 2d       	mov	r18, r0
 c9c:	07 2e       	mov	r0, r23
 c9e:	73 2f       	mov	r23, r19
 ca0:	30 2d       	mov	r19, r0
 ca2:	08 2e       	mov	r0, r24
 ca4:	84 2f       	mov	r24, r20
 ca6:	40 2d       	mov	r20, r0
 ca8:	09 2e       	mov	r0, r25
 caa:	95 2f       	mov	r25, r21
 cac:	50 2d       	mov	r21, r0
 cae:	ff 27       	eor	r31, r31
 cb0:	55 23       	and	r21, r21
 cb2:	b9 f0       	breq	.+46     	; 0xce2 <__addsf3x+0x64>
 cb4:	59 1b       	sub	r21, r25
 cb6:	49 f0       	breq	.+18     	; 0xcca <__addsf3x+0x4c>
 cb8:	57 3e       	cpi	r21, 0xE7	; 231
 cba:	98 f0       	brcs	.+38     	; 0xce2 <__addsf3x+0x64>
 cbc:	46 95       	lsr	r20
 cbe:	37 95       	ror	r19
 cc0:	27 95       	ror	r18
 cc2:	a7 95       	ror	r26
 cc4:	f0 40       	sbci	r31, 0x00	; 0
 cc6:	53 95       	inc	r21
 cc8:	c9 f7       	brne	.-14     	; 0xcbc <__addsf3x+0x3e>
 cca:	76 f0       	brts	.+28     	; 0xce8 <__addsf3x+0x6a>
 ccc:	ba 0f       	add	r27, r26
 cce:	62 1f       	adc	r22, r18
 cd0:	73 1f       	adc	r23, r19
 cd2:	84 1f       	adc	r24, r20
 cd4:	30 f4       	brcc	.+12     	; 0xce2 <__addsf3x+0x64>
 cd6:	87 95       	ror	r24
 cd8:	77 95       	ror	r23
 cda:	67 95       	ror	r22
 cdc:	b7 95       	ror	r27
 cde:	f0 40       	sbci	r31, 0x00	; 0
 ce0:	93 95       	inc	r25
 ce2:	17 fa       	bst	r1, 7
 ce4:	0f 2e       	mov	r0, r31
 ce6:	08 95       	ret
 ce8:	bf 1b       	sub	r27, r31
 cea:	bb 27       	eor	r27, r27
 cec:	ba 0b       	sbc	r27, r26
 cee:	62 0b       	sbc	r22, r18
 cf0:	73 0b       	sbc	r23, r19
 cf2:	84 0b       	sbc	r24, r20
 cf4:	f6 cf       	rjmp	.-20     	; 0xce2 <__addsf3x+0x64>
 cf6:	de f6       	brtc	.-74     	; 0xcae <__addsf3x+0x30>
 cf8:	db c0       	rjmp	.+438    	; 0xeb0 <__fp_zerox>

00000cfa <__divsf3>:
 cfa:	ae d0       	rcall	.+348    	; 0xe58 <__fp_split3>
 cfc:	01 d0       	rcall	.+2      	; 0xd00 <__divsf3x>
 cfe:	91 c0       	rjmp	.+290    	; 0xe22 <__fp_merge>

00000d00 <__divsf3x>:
 d00:	55 23       	and	r21, r21
 d02:	59 f0       	breq	.+22     	; 0xd1a <__divsf3x+0x1a>
 d04:	99 23       	and	r25, r25
 d06:	69 f0       	breq	.+26     	; 0xd22 <__divsf3x+0x22>
 d08:	9f 57       	subi	r25, 0x7F	; 127
 d0a:	5f 57       	subi	r21, 0x7F	; 127
 d0c:	95 1b       	sub	r25, r21
 d0e:	33 f4       	brvc	.+12     	; 0xd1c <__divsf3x+0x1c>
 d10:	42 f4       	brpl	.+16     	; 0xd22 <__divsf3x+0x22>
 d12:	90 38       	cpi	r25, 0x80	; 128
 d14:	11 f4       	brne	.+4      	; 0xd1a <__divsf3x+0x1a>
 d16:	91 58       	subi	r25, 0x81	; 129
 d18:	05 c0       	rjmp	.+10     	; 0xd24 <__divsf3x+0x24>
 d1a:	9b c0       	rjmp	.+310    	; 0xe52 <__fp_nan>
 d1c:	91 58       	subi	r25, 0x81	; 129
 d1e:	9f 3f       	cpi	r25, 0xFF	; 255
 d20:	09 f4       	brne	.+2      	; 0xd24 <__divsf3x+0x24>
 d22:	c6 c0       	rjmp	.+396    	; 0xeb0 <__fp_zerox>
 d24:	bb 27       	eor	r27, r27
 d26:	11 24       	eor	r1, r1
 d28:	62 17       	cp	r22, r18
 d2a:	73 07       	cpc	r23, r19
 d2c:	84 07       	cpc	r24, r20
 d2e:	30 f4       	brcc	.+12     	; 0xd3c <__divsf3x+0x3c>
 d30:	66 0f       	add	r22, r22
 d32:	77 1f       	adc	r23, r23
 d34:	88 1f       	adc	r24, r24
 d36:	bb 1f       	adc	r27, r27
 d38:	91 50       	subi	r25, 0x01	; 1
 d3a:	98 f3       	brcs	.-26     	; 0xd22 <__divsf3x+0x22>
 d3c:	11 d0       	rcall	.+34     	; 0xd60 <__divsf3x+0x60>
 d3e:	0f 92       	push	r0
 d40:	0f d0       	rcall	.+30     	; 0xd60 <__divsf3x+0x60>
 d42:	0f 92       	push	r0
 d44:	0d d0       	rcall	.+26     	; 0xd60 <__divsf3x+0x60>
 d46:	a0 e8       	ldi	r26, 0x80	; 128
 d48:	26 17       	cp	r18, r22
 d4a:	37 07       	cpc	r19, r23
 d4c:	48 07       	cpc	r20, r24
 d4e:	1b 06       	cpc	r1, r27
 d50:	09 f0       	breq	.+2      	; 0xd54 <__divsf3x+0x54>
 d52:	a0 48       	sbci	r26, 0x80	; 128
 d54:	ba 2f       	mov	r27, r26
 d56:	60 2d       	mov	r22, r0
 d58:	7f 91       	pop	r23
 d5a:	8f 91       	pop	r24
 d5c:	00 24       	eor	r0, r0
 d5e:	08 95       	ret
 d60:	a0 e8       	ldi	r26, 0x80	; 128
 d62:	00 24       	eor	r0, r0
 d64:	62 17       	cp	r22, r18
 d66:	73 07       	cpc	r23, r19
 d68:	84 07       	cpc	r24, r20
 d6a:	b1 05       	cpc	r27, r1
 d6c:	28 f0       	brcs	.+10     	; 0xd78 <__divsf3x+0x78>
 d6e:	62 1b       	sub	r22, r18
 d70:	73 0b       	sbc	r23, r19
 d72:	84 0b       	sbc	r24, r20
 d74:	b1 09       	sbc	r27, r1
 d76:	0a 2a       	or	r0, r26
 d78:	66 0f       	add	r22, r22
 d7a:	77 1f       	adc	r23, r23
 d7c:	88 1f       	adc	r24, r24
 d7e:	bb 1f       	adc	r27, r27
 d80:	a6 95       	lsr	r26
 d82:	81 f7       	brne	.-32     	; 0xd64 <__divsf3x+0x64>
 d84:	08 95       	ret

00000d86 <__fixsfsi>:
 d86:	97 fb       	bst	r25, 7
 d88:	73 d0       	rcall	.+230    	; 0xe70 <__fp_split1>
 d8a:	9f 37       	cpi	r25, 0x7F	; 127
 d8c:	38 f0       	brcs	.+14     	; 0xd9c <__fixsfsi+0x16>
 d8e:	fe e9       	ldi	r31, 0x9E	; 158
 d90:	f9 1b       	sub	r31, r25
 d92:	98 2f       	mov	r25, r24
 d94:	87 2f       	mov	r24, r23
 d96:	76 2f       	mov	r23, r22
 d98:	6b 2f       	mov	r22, r27
 d9a:	05 c0       	rjmp	.+10     	; 0xda6 <__fixsfsi+0x20>
 d9c:	86 c0       	rjmp	.+268    	; 0xeaa <__fp_zero>
 d9e:	96 95       	lsr	r25
 da0:	87 95       	ror	r24
 da2:	77 95       	ror	r23
 da4:	67 95       	ror	r22
 da6:	f1 50       	subi	r31, 0x01	; 1
 da8:	d0 f7       	brcc	.-12     	; 0xd9e <__fixsfsi+0x18>
 daa:	3e f4       	brtc	.+14     	; 0xdba <__fp_lneg+0xe>

00000dac <__fp_lneg>:
 dac:	90 95       	com	r25
 dae:	80 95       	com	r24
 db0:	70 95       	com	r23
 db2:	61 95       	neg	r22
 db4:	7f 4f       	sbci	r23, 0xFF	; 255
 db6:	8f 4f       	sbci	r24, 0xFF	; 255
 db8:	9f 4f       	sbci	r25, 0xFF	; 255
 dba:	08 95       	ret

00000dbc <__floatunssisf>:
 dbc:	e8 94       	clt
 dbe:	03 c0       	rjmp	.+6      	; 0xdc6 <__floatsisf+0x6>

00000dc0 <__floatsisf>:
 dc0:	97 fb       	bst	r25, 7
 dc2:	0e f4       	brtc	.+2      	; 0xdc6 <__floatsisf+0x6>
 dc4:	f3 df       	rcall	.-26     	; 0xdac <__fp_lneg>
 dc6:	b6 2f       	mov	r27, r22
 dc8:	67 2f       	mov	r22, r23
 dca:	78 2f       	mov	r23, r24
 dcc:	89 2f       	mov	r24, r25
 dce:	9e e9       	ldi	r25, 0x9E	; 158
 dd0:	00 24       	eor	r0, r0
 dd2:	27 c0       	rjmp	.+78     	; 0xe22 <__fp_merge>

00000dd4 <__eqsf2>:
 dd4:	0e d0       	rcall	.+28     	; 0xdf2 <.fp_cmp>
 dd6:	5e f0       	brts	.+22     	; 0xdee <__cmpsf2+0xe>
 dd8:	04 c0       	rjmp	.+8      	; 0xde2 <__cmpsf2+0x2>

00000dda <__gesf2>:
 dda:	0b d0       	rcall	.+22     	; 0xdf2 <.fp_cmp>
 ddc:	26 f0       	brts	.+8      	; 0xde6 <__cmpsf2+0x6>
 dde:	01 c0       	rjmp	.+2      	; 0xde2 <__cmpsf2+0x2>

00000de0 <__cmpsf2>:
 de0:	08 d0       	rcall	.+16     	; 0xdf2 <.fp_cmp>
 de2:	19 f0       	breq	.+6      	; 0xdea <__cmpsf2+0xa>
 de4:	20 f4       	brcc	.+8      	; 0xdee <__cmpsf2+0xe>
 de6:	8f ef       	ldi	r24, 0xFF	; 255
 de8:	08 95       	ret
 dea:	80 e0       	ldi	r24, 0x00	; 0
 dec:	08 95       	ret
 dee:	81 e0       	ldi	r24, 0x01	; 1
 df0:	08 95       	ret

00000df2 <.fp_cmp>:
 df2:	97 fb       	bst	r25, 7
 df4:	09 2e       	mov	r0, r25
 df6:	05 26       	eor	r0, r21
 df8:	00 f8       	bld	r0, 0
 dfa:	68 94       	set
 dfc:	30 d0       	rcall	.+96     	; 0xe5e <__fp_split2>
 dfe:	e8 94       	clt
 e00:	07 fc       	sbrc	r0, 7
 e02:	07 c0       	rjmp	.+14     	; 0xe12 <.fp_cmp+0x20>
 e04:	62 17       	cp	r22, r18
 e06:	73 07       	cpc	r23, r19
 e08:	84 07       	cpc	r24, r20
 e0a:	95 07       	cpc	r25, r21
 e0c:	21 f0       	breq	.+8      	; 0xe16 <.fp_cmp+0x24>
 e0e:	08 f4       	brcc	.+2      	; 0xe12 <.fp_cmp+0x20>
 e10:	00 94       	com	r0
 e12:	07 94       	ror	r0
 e14:	98 94       	clz
 e16:	08 95       	ret
 e18:	9a 95       	dec	r25
 e1a:	bb 0f       	add	r27, r27
 e1c:	66 1f       	adc	r22, r22
 e1e:	77 1f       	adc	r23, r23
 e20:	88 1f       	adc	r24, r24

00000e22 <__fp_merge>:
 e22:	11 24       	eor	r1, r1
 e24:	99 23       	and	r25, r25
 e26:	a1 f0       	breq	.+40     	; 0xe50 <__fp_merge+0x2e>
 e28:	88 23       	and	r24, r24
 e2a:	b2 f7       	brpl	.-20     	; 0xe18 <.fp_cmp+0x26>
 e2c:	9f 3f       	cpi	r25, 0xFF	; 255
 e2e:	59 f0       	breq	.+22     	; 0xe46 <__fp_merge+0x24>
 e30:	bb 0f       	add	r27, r27
 e32:	48 f4       	brcc	.+18     	; 0xe46 <__fp_merge+0x24>
 e34:	21 f4       	brne	.+8      	; 0xe3e <__fp_merge+0x1c>
 e36:	00 20       	and	r0, r0
 e38:	11 f4       	brne	.+4      	; 0xe3e <__fp_merge+0x1c>
 e3a:	60 ff       	sbrs	r22, 0
 e3c:	04 c0       	rjmp	.+8      	; 0xe46 <__fp_merge+0x24>
 e3e:	6f 5f       	subi	r22, 0xFF	; 255
 e40:	7f 4f       	sbci	r23, 0xFF	; 255
 e42:	8f 4f       	sbci	r24, 0xFF	; 255
 e44:	9f 4f       	sbci	r25, 0xFF	; 255
 e46:	88 1f       	adc	r24, r24
 e48:	97 95       	ror	r25
 e4a:	87 95       	ror	r24
 e4c:	97 f9       	bld	r25, 7
 e4e:	08 95       	ret
 e50:	2c c0       	rjmp	.+88     	; 0xeaa <__fp_zero>

00000e52 <__fp_nan>:
 e52:	9f ef       	ldi	r25, 0xFF	; 255
 e54:	80 ec       	ldi	r24, 0xC0	; 192
 e56:	08 95       	ret

00000e58 <__fp_split3>:
 e58:	05 2e       	mov	r0, r21
 e5a:	09 26       	eor	r0, r25
 e5c:	07 fa       	bst	r0, 7

00000e5e <__fp_split2>:
 e5e:	44 0f       	add	r20, r20
 e60:	55 1f       	adc	r21, r21
 e62:	5f 3f       	cpi	r21, 0xFF	; 255
 e64:	79 f0       	breq	.+30     	; 0xe84 <__fp_split1+0x14>
 e66:	aa 27       	eor	r26, r26
 e68:	a5 17       	cp	r26, r21
 e6a:	08 f0       	brcs	.+2      	; 0xe6e <__fp_split2+0x10>
 e6c:	51 e0       	ldi	r21, 0x01	; 1
 e6e:	47 95       	ror	r20

00000e70 <__fp_split1>:
 e70:	88 0f       	add	r24, r24
 e72:	99 1f       	adc	r25, r25
 e74:	9f 3f       	cpi	r25, 0xFF	; 255
 e76:	31 f0       	breq	.+12     	; 0xe84 <__fp_split1+0x14>
 e78:	bb 27       	eor	r27, r27
 e7a:	b9 17       	cp	r27, r25
 e7c:	08 f0       	brcs	.+2      	; 0xe80 <__fp_split1+0x10>
 e7e:	91 e0       	ldi	r25, 0x01	; 1
 e80:	87 95       	ror	r24
 e82:	08 95       	ret
 e84:	9f 91       	pop	r25
 e86:	9f 91       	pop	r25
 e88:	11 24       	eor	r1, r1
 e8a:	e3 cf       	rjmp	.-58     	; 0xe52 <__fp_nan>

00000e8c <__fp_split_a>:
 e8c:	97 fb       	bst	r25, 7
 e8e:	88 0f       	add	r24, r24
 e90:	99 1f       	adc	r25, r25
 e92:	9f 3f       	cpi	r25, 0xFF	; 255
 e94:	31 f0       	breq	.+12     	; 0xea2 <__fp_split_a+0x16>
 e96:	bb 27       	eor	r27, r27
 e98:	b9 17       	cp	r27, r25
 e9a:	08 f0       	brcs	.+2      	; 0xe9e <__fp_split_a+0x12>
 e9c:	91 e0       	ldi	r25, 0x01	; 1
 e9e:	87 95       	ror	r24
 ea0:	08 95       	ret
 ea2:	9f 91       	pop	r25
 ea4:	9f 91       	pop	r25
 ea6:	11 24       	eor	r1, r1
 ea8:	d4 cf       	rjmp	.-88     	; 0xe52 <__fp_nan>

00000eaa <__fp_zero>:
 eaa:	66 27       	eor	r22, r22
 eac:	77 27       	eor	r23, r23
 eae:	88 27       	eor	r24, r24

00000eb0 <__fp_zerox>:
 eb0:	99 27       	eor	r25, r25
 eb2:	08 95       	ret

00000eb4 <__mulsf3>:
 eb4:	d1 df       	rcall	.-94     	; 0xe58 <__fp_split3>
 eb6:	01 d0       	rcall	.+2      	; 0xeba <__mulsf3x>
 eb8:	b4 cf       	rjmp	.-152    	; 0xe22 <__fp_merge>

00000eba <__mulsf3x>:
 eba:	99 23       	and	r25, r25
 ebc:	39 f0       	breq	.+14     	; 0xecc <__mulsf3x+0x12>
 ebe:	55 23       	and	r21, r21
 ec0:	29 f0       	breq	.+10     	; 0xecc <__mulsf3x+0x12>
 ec2:	9f 57       	subi	r25, 0x7F	; 127
 ec4:	5f 57       	subi	r21, 0x7F	; 127
 ec6:	95 0f       	add	r25, r21
 ec8:	13 f4       	brvc	.+4      	; 0xece <__mulsf3x+0x14>
 eca:	9a f1       	brmi	.+102    	; 0xf32 <__mulsf3x+0x78>
 ecc:	f1 cf       	rjmp	.-30     	; 0xeb0 <__fp_zerox>
 ece:	91 58       	subi	r25, 0x81	; 129
 ed0:	9f 3f       	cpi	r25, 0xFF	; 255
 ed2:	e1 f3       	breq	.-8      	; 0xecc <__mulsf3x+0x12>
 ed4:	62 9f       	mul	r22, r18
 ed6:	a1 2d       	mov	r26, r1
 ed8:	0f 92       	push	r0
 eda:	bb 27       	eor	r27, r27
 edc:	63 9f       	mul	r22, r19
 ede:	a0 0d       	add	r26, r0
 ee0:	b1 1d       	adc	r27, r1
 ee2:	ee 27       	eor	r30, r30
 ee4:	72 9f       	mul	r23, r18
 ee6:	a0 0d       	add	r26, r0
 ee8:	b1 1d       	adc	r27, r1
 eea:	ee 1f       	adc	r30, r30
 eec:	af 93       	push	r26
 eee:	aa 27       	eor	r26, r26
 ef0:	64 9f       	mul	r22, r20
 ef2:	b0 0d       	add	r27, r0
 ef4:	e1 1d       	adc	r30, r1
 ef6:	73 9f       	mul	r23, r19
 ef8:	b0 0d       	add	r27, r0
 efa:	e1 1d       	adc	r30, r1
 efc:	aa 1f       	adc	r26, r26
 efe:	66 27       	eor	r22, r22
 f00:	82 9f       	mul	r24, r18
 f02:	b0 0d       	add	r27, r0
 f04:	e1 1d       	adc	r30, r1
 f06:	a6 1f       	adc	r26, r22
 f08:	55 27       	eor	r21, r21
 f0a:	74 9f       	mul	r23, r20
 f0c:	e0 0d       	add	r30, r0
 f0e:	a1 1d       	adc	r26, r1
 f10:	55 1f       	adc	r21, r21
 f12:	83 9f       	mul	r24, r19
 f14:	e0 0d       	add	r30, r0
 f16:	a1 1d       	adc	r26, r1
 f18:	56 1f       	adc	r21, r22
 f1a:	84 9f       	mul	r24, r20
 f1c:	a0 0d       	add	r26, r0
 f1e:	51 1d       	adc	r21, r1
 f20:	85 2f       	mov	r24, r21
 f22:	7a 2f       	mov	r23, r26
 f24:	6e 2f       	mov	r22, r30
 f26:	1f 90       	pop	r1
 f28:	0f 90       	pop	r0
 f2a:	88 23       	and	r24, r24
 f2c:	1a f4       	brpl	.+6      	; 0xf34 <__mulsf3x+0x7a>
 f2e:	93 95       	inc	r25
 f30:	39 f4       	brne	.+14     	; 0xf40 <__mulsf3x+0x86>
 f32:	8f cf       	rjmp	.-226    	; 0xe52 <__fp_nan>
 f34:	00 0c       	add	r0, r0
 f36:	11 1c       	adc	r1, r1
 f38:	bb 1f       	adc	r27, r27
 f3a:	66 1f       	adc	r22, r22
 f3c:	77 1f       	adc	r23, r23
 f3e:	88 1f       	adc	r24, r24
 f40:	01 28       	or	r0, r1
 f42:	08 95       	ret

00000f44 <__udivmodhi4>:
 f44:	aa 1b       	sub	r26, r26
 f46:	bb 1b       	sub	r27, r27
 f48:	51 e1       	ldi	r21, 0x11	; 17
 f4a:	07 c0       	rjmp	.+14     	; 0xf5a <__udivmodhi4_ep>

00000f4c <__udivmodhi4_loop>:
 f4c:	aa 1f       	adc	r26, r26
 f4e:	bb 1f       	adc	r27, r27
 f50:	a6 17       	cp	r26, r22
 f52:	b7 07       	cpc	r27, r23
 f54:	10 f0       	brcs	.+4      	; 0xf5a <__udivmodhi4_ep>
 f56:	a6 1b       	sub	r26, r22
 f58:	b7 0b       	sbc	r27, r23

00000f5a <__udivmodhi4_ep>:
 f5a:	88 1f       	adc	r24, r24
 f5c:	99 1f       	adc	r25, r25
 f5e:	5a 95       	dec	r21
 f60:	a9 f7       	brne	.-22     	; 0xf4c <__udivmodhi4_loop>
 f62:	80 95       	com	r24
 f64:	90 95       	com	r25
 f66:	bc 01       	movw	r22, r24
 f68:	cd 01       	movw	r24, r26
 f6a:	08 95       	ret

00000f6c <__divmodhi4>:
 f6c:	97 fb       	bst	r25, 7
 f6e:	09 2e       	mov	r0, r25
 f70:	07 26       	eor	r0, r23
 f72:	0a d0       	rcall	.+20     	; 0xf88 <__divmodhi4_neg1>
 f74:	77 fd       	sbrc	r23, 7
 f76:	04 d0       	rcall	.+8      	; 0xf80 <__divmodhi4_neg2>
 f78:	e5 df       	rcall	.-54     	; 0xf44 <__udivmodhi4>
 f7a:	06 d0       	rcall	.+12     	; 0xf88 <__divmodhi4_neg1>
 f7c:	00 20       	and	r0, r0
 f7e:	1a f4       	brpl	.+6      	; 0xf86 <__divmodhi4_exit>

00000f80 <__divmodhi4_neg2>:
 f80:	70 95       	com	r23
 f82:	61 95       	neg	r22
 f84:	7f 4f       	sbci	r23, 0xFF	; 255

00000f86 <__divmodhi4_exit>:
 f86:	08 95       	ret

00000f88 <__divmodhi4_neg1>:
 f88:	f6 f7       	brtc	.-4      	; 0xf86 <__divmodhi4_exit>
 f8a:	90 95       	com	r25
 f8c:	81 95       	neg	r24
 f8e:	9f 4f       	sbci	r25, 0xFF	; 255
 f90:	08 95       	ret

00000f92 <__eeprom_read_byte_1C1D1E>:
 f92:	e1 99       	sbic	0x1c, 1	; 28
 f94:	fe cf       	rjmp	.-4      	; 0xf92 <__eeprom_read_byte_1C1D1E>
 f96:	bf bb       	out	0x1f, r27	; 31
 f98:	ae bb       	out	0x1e, r26	; 30
 f9a:	e0 9a       	sbi	0x1c, 0	; 28
 f9c:	11 96       	adiw	r26, 0x01	; 1
 f9e:	0d b2       	in	r0, 0x1d	; 29
 fa0:	08 95       	ret

00000fa2 <__eeprom_read_block_1C1D1E>:
 fa2:	f7 df       	rcall	.-18     	; 0xf92 <__eeprom_read_byte_1C1D1E>
 fa4:	01 92       	st	Z+, r0
 fa6:	1a 94       	dec	r1
 fa8:	e1 f7       	brne	.-8      	; 0xfa2 <__eeprom_read_block_1C1D1E>
 faa:	08 95       	ret

00000fac <__eeprom_read_word_1C1D1E>:
 fac:	f2 df       	rcall	.-28     	; 0xf92 <__eeprom_read_byte_1C1D1E>
 fae:	e0 2d       	mov	r30, r0
 fb0:	f0 df       	rcall	.-32     	; 0xf92 <__eeprom_read_byte_1C1D1E>
 fb2:	f0 2d       	mov	r31, r0
 fb4:	08 95       	ret

00000fb6 <__eeprom_write_byte_1C1D1E>:
 fb6:	e1 99       	sbic	0x1c, 1	; 28
 fb8:	fe cf       	rjmp	.-4      	; 0xfb6 <__eeprom_write_byte_1C1D1E>
 fba:	bf bb       	out	0x1f, r27	; 31
 fbc:	ae bb       	out	0x1e, r26	; 30
 fbe:	0d ba       	out	0x1d, r0	; 29
 fc0:	11 96       	adiw	r26, 0x01	; 1
 fc2:	0f b6       	in	r0, 0x3f	; 63
 fc4:	f8 94       	cli
 fc6:	e2 9a       	sbi	0x1c, 2	; 28
 fc8:	e1 9a       	sbi	0x1c, 1	; 28
 fca:	0f be       	out	0x3f, r0	; 63
 fcc:	08 95       	ret

00000fce <__eeprom_write_word_1C1D1E>:
 fce:	f3 df       	rcall	.-26     	; 0xfb6 <__eeprom_write_byte_1C1D1E>
 fd0:	01 2c       	mov	r0, r1
 fd2:	f1 df       	rcall	.-30     	; 0xfb6 <__eeprom_write_byte_1C1D1E>
 fd4:	11 24       	eor	r1, r1
 fd6:	08 95       	ret

00000fd8 <__eeprom_write_block_1C1D1E>:
 fd8:	01 90       	ld	r0, Z+
 fda:	ed df       	rcall	.-38     	; 0xfb6 <__eeprom_write_byte_1C1D1E>
 fdc:	1a 94       	dec	r1
 fde:	e1 f7       	brne	.-8      	; 0xfd8 <__eeprom_write_block_1C1D1E>
 fe0:	08 95       	ret

00000fe2 <_exit>:
 fe2:	ff cf       	rjmp	.-2      	; 0xfe2 <_exit>
